918dba4c72eb87d30288f028e3695332
"use strict";
'use client';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.reset = reset;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var React = _interopRequireWildcard(require("react"));
var ReactDOM = _interopRequireWildcard(require("react-dom"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _utils = require("@mui/utils");
var _system = require("@mui/system");
var _base = require("@mui/base");
var _Drawer = _interopRequireWildcard(require("../Drawer/Drawer"));
var _useForkRef = _interopRequireDefault(require("../utils/useForkRef"));
var _ownerDocument = _interopRequireDefault(require("../utils/ownerDocument"));
var _ownerWindow = _interopRequireDefault(require("../utils/ownerWindow"));
var _useEventCallback = _interopRequireDefault(require("../utils/useEventCallback"));
var _useEnhancedEffect = _interopRequireDefault(require("../utils/useEnhancedEffect"));
var _useTheme = _interopRequireDefault(require("../styles/useTheme"));
var _utils2 = require("../transitions/utils");
var _SwipeArea = _interopRequireDefault(require("./SwipeArea"));
var _jsxRuntime = require("react/jsx-runtime");
const _excluded = ["BackdropProps"],
  _excluded2 = ["anchor", "disableBackdropTransition", "disableDiscovery", "disableSwipeToOpen", "hideBackdrop", "hysteresis", "allowSwipeInChildren", "minFlingVelocity", "ModalProps", "onClose", "onOpen", "open", "PaperProps", "SwipeAreaProps", "swipeAreaWidth", "transitionDuration", "variant"]; // This value is closed to what browsers are using internally to
// trigger a native scroll.
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
const UNCERTAINTY_THRESHOLD = 3; // px

// This is the part of the drawer displayed on touch start.
const DRAG_STARTED_SIGNAL = 20; // px

// We can only have one instance at the time claiming ownership for handling the swipe.
// Otherwise, the UX would be confusing.
// That's why we use a singleton here.
let claimedSwipeInstance = null;

// Exported for test purposes.
function reset() {
  claimedSwipeInstance = null;
}
function calculateCurrentX(anchor, touches, doc) {
  return anchor === 'right' ? doc.body.offsetWidth - touches[0].pageX : touches[0].pageX;
}
function calculateCurrentY(anchor, touches, containerWindow) {
  return anchor === 'bottom' ? containerWindow.innerHeight - touches[0].clientY : touches[0].clientY;
}
function getMaxTranslate(horizontalSwipe, paperInstance) {
  return horizontalSwipe ? paperInstance.clientWidth : paperInstance.clientHeight;
}
function getTranslate(currentTranslate, startLocation, open, maxTranslate) {
  return Math.min(Math.max(open ? startLocation - currentTranslate : maxTranslate + startLocation - currentTranslate, 0), maxTranslate);
}

/**
 * @param {Element | null} element
 * @param {Element} rootNode
 */
function getDomTreeShapes(element, rootNode) {
  // Adapted from https://github.com/oliviertassinari/react-swipeable-views/blob/7666de1dba253b896911adf2790ce51467670856/packages/react-swipeable-views/src/SwipeableViews.js#L129
  const domTreeShapes = [];
  while (element && element !== rootNode.parentElement) {
    const style = (0, _ownerWindow.default)(rootNode).getComputedStyle(element);
    if (
    // Ignore the scroll children if the element is absolute positioned.
    style.getPropertyValue('position') === 'absolute' ||
    // Ignore the scroll children if the element has an overflowX hidden
    style.getPropertyValue('overflow-x') === 'hidden') {
      // noop
    } else if (element.clientWidth > 0 && element.scrollWidth > element.clientWidth || element.clientHeight > 0 && element.scrollHeight > element.clientHeight) {
      // Ignore the nodes that have no width.
      // Keep elements with a scroll
      domTreeShapes.push(element);
    }
    element = element.parentElement;
  }
  return domTreeShapes;
}

/**
 * @param {object} param0
 * @param {ReturnType<getDomTreeShapes>} param0.domTreeShapes
 */
function computeHasNativeHandler({
  domTreeShapes,
  start,
  current,
  anchor
}) {
  // Adapted from https://github.com/oliviertassinari/react-swipeable-views/blob/7666de1dba253b896911adf2790ce51467670856/packages/react-swipeable-views/src/SwipeableViews.js#L175
  const axisProperties = {
    scrollPosition: {
      x: 'scrollLeft',
      y: 'scrollTop'
    },
    scrollLength: {
      x: 'scrollWidth',
      y: 'scrollHeight'
    },
    clientLength: {
      x: 'clientWidth',
      y: 'clientHeight'
    }
  };
  return domTreeShapes.some(shape => {
    // Determine if we are going backward or forward.
    let goingForward = current >= start;
    if (anchor === 'top' || anchor === 'left') {
      goingForward = !goingForward;
    }
    const axis = anchor === 'left' || anchor === 'right' ? 'x' : 'y';
    const scrollPosition = Math.round(shape[axisProperties.scrollPosition[axis]]);
    const areNotAtStart = scrollPosition > 0;
    const areNotAtEnd = scrollPosition + shape[axisProperties.clientLength[axis]] < shape[axisProperties.scrollLength[axis]];
    if (goingForward && areNotAtEnd || !goingForward && areNotAtStart) {
      return true;
    }
    return false;
  });
}
const iOS = typeof navigator !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent);
const SwipeableDrawer = /*#__PURE__*/React.forwardRef(function SwipeableDrawer(inProps, ref) {
  const props = (0, _system.useThemeProps)({
    name: 'MuiSwipeableDrawer',
    props: inProps
  });
  const theme = (0, _useTheme.default)();
  const transitionDurationDefault = {
    enter: theme.transitions.duration.enteringScreen,
    exit: theme.transitions.duration.leavingScreen
  };
  const {
      anchor = 'left',
      disableBackdropTransition = false,
      disableDiscovery = false,
      disableSwipeToOpen = iOS,
      hideBackdrop,
      hysteresis = 0.52,
      allowSwipeInChildren = false,
      minFlingVelocity = 450,
      ModalProps: {
        BackdropProps
      } = {},
      onClose,
      onOpen,
      open = false,
      PaperProps = {},
      SwipeAreaProps,
      swipeAreaWidth = 20,
      transitionDuration = transitionDurationDefault,
      variant = 'temporary' // Mobile first.
    } = props,
    ModalPropsProp = (0, _objectWithoutPropertiesLoose2.default)(props.ModalProps, _excluded),
    other = (0, _objectWithoutPropertiesLoose2.default)(props, _excluded2);
  const [maybeSwiping, setMaybeSwiping] = React.useState(false);
  const swipeInstance = React.useRef({
    isSwiping: null
  });
  const swipeAreaRef = React.useRef();
  const backdropRef = React.useRef();
  const paperRef = React.useRef();
  const handleRef = (0, _useForkRef.default)(PaperProps.ref, paperRef);
  const touchDetected = React.useRef(false);

  // Ref for transition duration based on / to match swipe speed
  const calculatedDurationRef = React.useRef();

  // Use a ref so the open value used is always up to date inside useCallback.
  (0, _useEnhancedEffect.default)(() => {
    calculatedDurationRef.current = null;
  }, [open]);
  const setPosition = React.useCallback((translate, options = {}) => {
    const {
      mode = null,
      changeTransition = true
    } = options;
    const anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);
    const rtlTranslateMultiplier = ['right', 'bottom'].indexOf(anchorRtl) !== -1 ? 1 : -1;
    const horizontalSwipe = (0, _Drawer.isHorizontal)(anchor);
    const transform = horizontalSwipe ? `translate(${rtlTranslateMultiplier * translate}px, 0)` : `translate(0, ${rtlTranslateMultiplier * translate}px)`;
    const drawerStyle = paperRef.current.style;
    drawerStyle.webkitTransform = transform;
    drawerStyle.transform = transform;
    let transition = '';
    if (mode) {
      transition = theme.transitions.create('all', (0, _utils2.getTransitionProps)({
        easing: undefined,
        style: undefined,
        timeout: transitionDuration
      }, {
        mode
      }));
    }
    if (changeTransition) {
      drawerStyle.webkitTransition = transition;
      drawerStyle.transition = transition;
    }
    if (!disableBackdropTransition && !hideBackdrop) {
      const backdropStyle = backdropRef.current.style;
      backdropStyle.opacity = 1 - translate / getMaxTranslate(horizontalSwipe, paperRef.current);
      if (changeTransition) {
        backdropStyle.webkitTransition = transition;
        backdropStyle.transition = transition;
      }
    }
  }, [anchor, disableBackdropTransition, hideBackdrop, theme, transitionDuration]);
  const handleBodyTouchEnd = (0, _useEventCallback.default)(nativeEvent => {
    if (!touchDetected.current) {
      return;
    }
    claimedSwipeInstance = null;
    touchDetected.current = false;
    ReactDOM.flushSync(() => {
      setMaybeSwiping(false);
    });

    // The swipe wasn't started.
    if (!swipeInstance.current.isSwiping) {
      swipeInstance.current.isSwiping = null;
      return;
    }
    swipeInstance.current.isSwiping = null;
    const anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);
    const horizontal = (0, _Drawer.isHorizontal)(anchor);
    let current;
    if (horizontal) {
      current = calculateCurrentX(anchorRtl, nativeEvent.changedTouches, (0, _ownerDocument.default)(nativeEvent.currentTarget));
    } else {
      current = calculateCurrentY(anchorRtl, nativeEvent.changedTouches, (0, _ownerWindow.default)(nativeEvent.currentTarget));
    }
    const startLocation = horizontal ? swipeInstance.current.startX : swipeInstance.current.startY;
    const maxTranslate = getMaxTranslate(horizontal, paperRef.current);
    const currentTranslate = getTranslate(current, startLocation, open, maxTranslate);
    const translateRatio = currentTranslate / maxTranslate;
    if (Math.abs(swipeInstance.current.velocity) > minFlingVelocity) {
      // Calculate transition duration to match swipe speed
      calculatedDurationRef.current = Math.abs((maxTranslate - currentTranslate) / swipeInstance.current.velocity) * 1000;
    }
    if (open) {
      if (swipeInstance.current.velocity > minFlingVelocity || translateRatio > hysteresis) {
        onClose();
      } else {
        // Reset the position, the swipe was aborted.
        setPosition(0, {
          mode: 'exit'
        });
      }
      return;
    }
    if (swipeInstance.current.velocity < -minFlingVelocity || 1 - translateRatio > hysteresis) {
      onOpen();
    } else {
      // Reset the position, the swipe was aborted.
      setPosition(getMaxTranslate(horizontal, paperRef.current), {
        mode: 'enter'
      });
    }
  });
  const startMaybeSwiping = (force = false) => {
    if (!maybeSwiping) {
      // on Safari Mobile, if you want to be able to have the 'click' event fired on child elements, nothing in the DOM can be changed.
      // this is because Safari Mobile will not fire any mouse events (still fires touch though) if the DOM changes during mousemove.
      // so do this change on first touchmove instead of touchstart
      if (force || !(disableDiscovery && allowSwipeInChildren)) {
        ReactDOM.flushSync(() => {
          setMaybeSwiping(true);
        });
      }
      const horizontalSwipe = (0, _Drawer.isHorizontal)(anchor);
      if (!open && paperRef.current) {
        // The ref may be null when a parent component updates while swiping.
        setPosition(getMaxTranslate(horizontalSwipe, paperRef.current) + (disableDiscovery ? 15 : -DRAG_STARTED_SIGNAL), {
          changeTransition: false
        });
      }
      swipeInstance.current.velocity = 0;
      swipeInstance.current.lastTime = null;
      swipeInstance.current.lastTranslate = null;
      swipeInstance.current.paperHit = false;
      touchDetected.current = true;
    }
  };
  const handleBodyTouchMove = (0, _useEventCallback.default)(nativeEvent => {
    // the ref may be null when a parent component updates while swiping
    if (!paperRef.current || !touchDetected.current) {
      return;
    }

    // We are not supposed to handle this touch move because the swipe was started in a scrollable container in the drawer
    if (claimedSwipeInstance !== null && claimedSwipeInstance !== swipeInstance.current) {
      return;
    }
    startMaybeSwiping(true);
    const anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);
    const horizontalSwipe = (0, _Drawer.isHorizontal)(anchor);
    const currentX = calculateCurrentX(anchorRtl, nativeEvent.touches, (0, _ownerDocument.default)(nativeEvent.currentTarget));
    const currentY = calculateCurrentY(anchorRtl, nativeEvent.touches, (0, _ownerWindow.default)(nativeEvent.currentTarget));
    if (open && paperRef.current.contains(nativeEvent.target) && claimedSwipeInstance === null) {
      const domTreeShapes = getDomTreeShapes(nativeEvent.target, paperRef.current);
      const hasNativeHandler = computeHasNativeHandler({
        domTreeShapes,
        start: horizontalSwipe ? swipeInstance.current.startX : swipeInstance.current.startY,
        current: horizontalSwipe ? currentX : currentY,
        anchor
      });
      if (hasNativeHandler) {
        claimedSwipeInstance = true;
        return;
      }
      claimedSwipeInstance = swipeInstance.current;
    }

    // We don't know yet.
    if (swipeInstance.current.isSwiping == null) {
      const dx = Math.abs(currentX - swipeInstance.current.startX);
      const dy = Math.abs(currentY - swipeInstance.current.startY);
      const definitelySwiping = horizontalSwipe ? dx > dy && dx > UNCERTAINTY_THRESHOLD : dy > dx && dy > UNCERTAINTY_THRESHOLD;
      if (definitelySwiping && nativeEvent.cancelable) {
        nativeEvent.preventDefault();
      }
      if (definitelySwiping === true || (horizontalSwipe ? dy > UNCERTAINTY_THRESHOLD : dx > UNCERTAINTY_THRESHOLD)) {
        swipeInstance.current.isSwiping = definitelySwiping;
        if (!definitelySwiping) {
          handleBodyTouchEnd(nativeEvent);
          return;
        }

        // Shift the starting point.
        swipeInstance.current.startX = currentX;
        swipeInstance.current.startY = currentY;

        // Compensate for the part of the drawer displayed on touch start.
        if (!disableDiscovery && !open) {
          if (horizontalSwipe) {
            swipeInstance.current.startX -= DRAG_STARTED_SIGNAL;
          } else {
            swipeInstance.current.startY -= DRAG_STARTED_SIGNAL;
          }
        }
      }
    }
    if (!swipeInstance.current.isSwiping) {
      return;
    }
    const maxTranslate = getMaxTranslate(horizontalSwipe, paperRef.current);
    let startLocation = horizontalSwipe ? swipeInstance.current.startX : swipeInstance.current.startY;
    if (open && !swipeInstance.current.paperHit) {
      startLocation = Math.min(startLocation, maxTranslate);
    }
    const translate = getTranslate(horizontalSwipe ? currentX : currentY, startLocation, open, maxTranslate);
    if (open) {
      if (!swipeInstance.current.paperHit) {
        const paperHit = horizontalSwipe ? currentX < maxTranslate : currentY < maxTranslate;
        if (paperHit) {
          swipeInstance.current.paperHit = true;
          swipeInstance.current.startX = currentX;
          swipeInstance.current.startY = currentY;
        } else {
          return;
        }
      } else if (translate === 0) {
        swipeInstance.current.startX = currentX;
        swipeInstance.current.startY = currentY;
      }
    }
    if (swipeInstance.current.lastTranslate === null) {
      swipeInstance.current.lastTranslate = translate;
      swipeInstance.current.lastTime = performance.now() + 1;
    }
    const velocity = (translate - swipeInstance.current.lastTranslate) / (performance.now() - swipeInstance.current.lastTime) * 1e3;

    // Low Pass filter.
    swipeInstance.current.velocity = swipeInstance.current.velocity * 0.4 + velocity * 0.6;
    swipeInstance.current.lastTranslate = translate;
    swipeInstance.current.lastTime = performance.now();

    // We are swiping, let's prevent the scroll event on iOS.
    if (nativeEvent.cancelable) {
      nativeEvent.preventDefault();
    }
    setPosition(translate);
  });
  const handleBodyTouchStart = (0, _useEventCallback.default)(nativeEvent => {
    // We are not supposed to handle this touch move.
    // Example of use case: ignore the event if there is a Slider.
    if (nativeEvent.defaultPrevented) {
      return;
    }

    // We can only have one node at the time claiming ownership for handling the swipe.
    if (nativeEvent.defaultMuiPrevented) {
      return;
    }

    // At least one element clogs the drawer interaction zone.
    if (open && (hideBackdrop || !backdropRef.current.contains(nativeEvent.target)) && !paperRef.current.contains(nativeEvent.target)) {
      return;
    }
    const anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);
    const horizontalSwipe = (0, _Drawer.isHorizontal)(anchor);
    const currentX = calculateCurrentX(anchorRtl, nativeEvent.touches, (0, _ownerDocument.default)(nativeEvent.currentTarget));
    const currentY = calculateCurrentY(anchorRtl, nativeEvent.touches, (0, _ownerWindow.default)(nativeEvent.currentTarget));
    if (!open) {
      var _paperRef$current;
      // logic for if swipe should be ignored:
      // if disableSwipeToOpen
      // if target != swipeArea, and target is not a child of paper ref
      // if is a child of paper ref, and `allowSwipeInChildren` does not allow it
      if (disableSwipeToOpen || !(nativeEvent.target === swipeAreaRef.current || (_paperRef$current = paperRef.current) != null && _paperRef$current.contains(nativeEvent.target) && (typeof allowSwipeInChildren === 'function' ? allowSwipeInChildren(nativeEvent, swipeAreaRef.current, paperRef.current) : allowSwipeInChildren))) {
        return;
      }
      if (horizontalSwipe) {
        if (currentX > swipeAreaWidth) {
          return;
        }
      } else if (currentY > swipeAreaWidth) {
        return;
      }
    }
    nativeEvent.defaultMuiPrevented = true;
    claimedSwipeInstance = null;
    swipeInstance.current.startX = currentX;
    swipeInstance.current.startY = currentY;
    startMaybeSwiping();
  });
  React.useEffect(() => {
    if (variant === 'temporary') {
      const doc = (0, _ownerDocument.default)(paperRef.current);
      doc.addEventListener('touchstart', handleBodyTouchStart);
      // A blocking listener prevents Firefox's navbar to auto-hide on scroll.
      // It only needs to prevent scrolling on the drawer's content when open.
      // When closed, the overlay prevents scrolling.
      doc.addEventListener('touchmove', handleBodyTouchMove, {
        passive: !open
      });
      doc.addEventListener('touchend', handleBodyTouchEnd);
      return () => {
        doc.removeEventListener('touchstart', handleBodyTouchStart);
        doc.removeEventListener('touchmove', handleBodyTouchMove, {
          passive: !open
        });
        doc.removeEventListener('touchend', handleBodyTouchEnd);
      };
    }
    return undefined;
  }, [variant, open, handleBodyTouchStart, handleBodyTouchMove, handleBodyTouchEnd]);
  React.useEffect(() => () => {
    // We need to release the lock.
    if (claimedSwipeInstance === swipeInstance.current) {
      claimedSwipeInstance = null;
    }
  }, []);
  React.useEffect(() => {
    if (!open) {
      setMaybeSwiping(false);
    }
  }, [open]);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(React.Fragment, {
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_Drawer.default, (0, _extends2.default)({
      open: variant === 'temporary' && maybeSwiping ? true : open,
      variant: variant,
      ModalProps: (0, _extends2.default)({
        BackdropProps: (0, _extends2.default)({}, BackdropProps, {
          ref: backdropRef
        })
      }, variant === 'temporary' && {
        keepMounted: true
      }, ModalPropsProp),
      hideBackdrop: hideBackdrop,
      PaperProps: (0, _extends2.default)({}, PaperProps, {
        style: (0, _extends2.default)({
          pointerEvents: variant === 'temporary' && !open && !allowSwipeInChildren ? 'none' : ''
        }, PaperProps.style),
        ref: handleRef
      }),
      anchor: anchor,
      transitionDuration: calculatedDurationRef.current || transitionDuration,
      onClose: onClose,
      ref: ref
    }, other)), !disableSwipeToOpen && variant === 'temporary' && /*#__PURE__*/(0, _jsxRuntime.jsx)(_base.NoSsr, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_SwipeArea.default, (0, _extends2.default)({
        anchor: anchor,
        ref: swipeAreaRef,
        width: swipeAreaWidth
      }, SwipeAreaProps))
    })]
  });
});
process.env.NODE_ENV !== "production" ? SwipeableDrawer.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * If set to true, the swipe event will open the drawer even if the user begins the swipe on one of the drawer's children.
   * This can be useful in scenarios where the drawer is partially visible.
   * You can customize it further with a callback that determines which children the user can drag over to open the drawer
   * (for example, to ignore other elements that handle touch move events, like sliders).
   *
   * @param {TouchEvent} event The 'touchstart' event
   * @param {HTMLDivElement} swipeArea The swipe area element
   * @param {HTMLDivElement} paper The drawer's paper element
   *
   * @default false
   */
  allowSwipeInChildren: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.func]),
  /**
   * @ignore
   */
  anchor: _propTypes.default.oneOf(['bottom', 'left', 'right', 'top']),
  /**
   * The content of the component.
   */
  children: _propTypes.default.node,
  /**
   * Disable the backdrop transition.
   * This can improve the FPS on low-end devices.
   * @default false
   */
  disableBackdropTransition: _propTypes.default.bool,
  /**
   * If `true`, touching the screen near the edge of the drawer will not slide in the drawer a bit
   * to promote accidental discovery of the swipe gesture.
   * @default false
   */
  disableDiscovery: _propTypes.default.bool,
  /**
   * If `true`, swipe to open is disabled. This is useful in browsers where swiping triggers
   * navigation actions. Swipe to open is disabled on iOS browsers by default.
   * @default typeof navigator !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent)
   */
  disableSwipeToOpen: _propTypes.default.bool,
  /**
   * @ignore
   */
  hideBackdrop: _propTypes.default.bool,
  /**
   * Affects how far the drawer must be opened/closed to change its state.
   * Specified as percent (0-1) of the width of the drawer
   * @default 0.52
   */
  hysteresis: _propTypes.default.number,
  /**
   * Defines, from which (average) velocity on, the swipe is
   * defined as complete although hysteresis isn't reached.
   * Good threshold is between 250 - 1000 px/s
   * @default 450
   */
  minFlingVelocity: _propTypes.default.number,
  /**
   * @ignore
   */
  ModalProps: _propTypes.default /* @typescript-to-proptypes-ignore */.shape({
    BackdropProps: _propTypes.default.shape({
      component: _utils.elementTypeAcceptingRef
    })
  }),
  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {object} event The event source of the callback.
   */
  onClose: _propTypes.default.func.isRequired,
  /**
   * Callback fired when the component requests to be opened.
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: _propTypes.default.func.isRequired,
  /**
   * If `true`, the component is shown.
   * @default false
   */
  open: _propTypes.default.bool.isRequired,
  /**
   * @ignore
   */
  PaperProps: _propTypes.default /* @typescript-to-proptypes-ignore */.shape({
    component: _utils.elementTypeAcceptingRef,
    style: _propTypes.default.object
  }),
  /**
   * The element is used to intercept the touch events on the edge.
   */
  SwipeAreaProps: _propTypes.default.object,
  /**
   * The width of the left most (or right most) area in `px` that
   * the drawer can be swiped open from.
   * @default 20
   */
  swipeAreaWidth: _propTypes.default.number,
  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   * @default {
   *   enter: theme.transitions.duration.enteringScreen,
   *   exit: theme.transitions.duration.leavingScreen,
   * }
   */
  transitionDuration: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.shape({
    appear: _propTypes.default.number,
    enter: _propTypes.default.number,
    exit: _propTypes.default.number
  })]),
  /**
   * @ignore
   */
  variant: _propTypes.default.oneOf(['permanent', 'persistent', 'temporary'])
} : void 0;
var _default = SwipeableDrawer;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsInJlc2V0IiwiX2V4dGVuZHMyIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UyIiwiUmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsIlJlYWN0RE9NIiwiX3Byb3BUeXBlcyIsIl91dGlscyIsIl9zeXN0ZW0iLCJfYmFzZSIsIl9EcmF3ZXIiLCJfdXNlRm9ya1JlZiIsIl9vd25lckRvY3VtZW50IiwiX293bmVyV2luZG93IiwiX3VzZUV2ZW50Q2FsbGJhY2siLCJfdXNlRW5oYW5jZWRFZmZlY3QiLCJfdXNlVGhlbWUiLCJfdXRpbHMyIiwiX1N3aXBlQXJlYSIsIl9qc3hSdW50aW1lIiwiX2V4Y2x1ZGVkIiwiX2V4Y2x1ZGVkMiIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsIm5vZGVJbnRlcm9wIiwiV2Vha01hcCIsImNhY2hlQmFiZWxJbnRlcm9wIiwiY2FjaGVOb2RlSW50ZXJvcCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJjYWNoZSIsImhhcyIsImdldCIsIm5ld09iaiIsImhhc1Byb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImRlc2MiLCJzZXQiLCJVTkNFUlRBSU5UWV9USFJFU0hPTEQiLCJEUkFHX1NUQVJURURfU0lHTkFMIiwiY2xhaW1lZFN3aXBlSW5zdGFuY2UiLCJjYWxjdWxhdGVDdXJyZW50WCIsImFuY2hvciIsInRvdWNoZXMiLCJkb2MiLCJib2R5Iiwib2Zmc2V0V2lkdGgiLCJwYWdlWCIsImNhbGN1bGF0ZUN1cnJlbnRZIiwiY29udGFpbmVyV2luZG93IiwiaW5uZXJIZWlnaHQiLCJjbGllbnRZIiwiZ2V0TWF4VHJhbnNsYXRlIiwiaG9yaXpvbnRhbFN3aXBlIiwicGFwZXJJbnN0YW5jZSIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiZ2V0VHJhbnNsYXRlIiwiY3VycmVudFRyYW5zbGF0ZSIsInN0YXJ0TG9jYXRpb24iLCJvcGVuIiwibWF4VHJhbnNsYXRlIiwiTWF0aCIsIm1pbiIsIm1heCIsImdldERvbVRyZWVTaGFwZXMiLCJlbGVtZW50Iiwicm9vdE5vZGUiLCJkb21UcmVlU2hhcGVzIiwicGFyZW50RWxlbWVudCIsInN0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsInB1c2giLCJjb21wdXRlSGFzTmF0aXZlSGFuZGxlciIsInN0YXJ0IiwiY3VycmVudCIsImF4aXNQcm9wZXJ0aWVzIiwic2Nyb2xsUG9zaXRpb24iLCJ4IiwieSIsInNjcm9sbExlbmd0aCIsImNsaWVudExlbmd0aCIsInNvbWUiLCJzaGFwZSIsImdvaW5nRm9yd2FyZCIsImF4aXMiLCJyb3VuZCIsImFyZU5vdEF0U3RhcnQiLCJhcmVOb3RBdEVuZCIsImlPUyIsIm5hdmlnYXRvciIsInRlc3QiLCJ1c2VyQWdlbnQiLCJTd2lwZWFibGVEcmF3ZXIiLCJmb3J3YXJkUmVmIiwiaW5Qcm9wcyIsInJlZiIsInByb3BzIiwidXNlVGhlbWVQcm9wcyIsIm5hbWUiLCJ0aGVtZSIsInRyYW5zaXRpb25EdXJhdGlvbkRlZmF1bHQiLCJlbnRlciIsInRyYW5zaXRpb25zIiwiZHVyYXRpb24iLCJlbnRlcmluZ1NjcmVlbiIsImV4aXQiLCJsZWF2aW5nU2NyZWVuIiwiZGlzYWJsZUJhY2tkcm9wVHJhbnNpdGlvbiIsImRpc2FibGVEaXNjb3ZlcnkiLCJkaXNhYmxlU3dpcGVUb09wZW4iLCJoaWRlQmFja2Ryb3AiLCJoeXN0ZXJlc2lzIiwiYWxsb3dTd2lwZUluQ2hpbGRyZW4iLCJtaW5GbGluZ1ZlbG9jaXR5IiwiTW9kYWxQcm9wcyIsIkJhY2tkcm9wUHJvcHMiLCJvbkNsb3NlIiwib25PcGVuIiwiUGFwZXJQcm9wcyIsIlN3aXBlQXJlYVByb3BzIiwic3dpcGVBcmVhV2lkdGgiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJ2YXJpYW50IiwiTW9kYWxQcm9wc1Byb3AiLCJvdGhlciIsIm1heWJlU3dpcGluZyIsInNldE1heWJlU3dpcGluZyIsInVzZVN0YXRlIiwic3dpcGVJbnN0YW5jZSIsInVzZVJlZiIsImlzU3dpcGluZyIsInN3aXBlQXJlYVJlZiIsImJhY2tkcm9wUmVmIiwicGFwZXJSZWYiLCJoYW5kbGVSZWYiLCJ0b3VjaERldGVjdGVkIiwiY2FsY3VsYXRlZER1cmF0aW9uUmVmIiwic2V0UG9zaXRpb24iLCJ1c2VDYWxsYmFjayIsInRyYW5zbGF0ZSIsIm9wdGlvbnMiLCJtb2RlIiwiY2hhbmdlVHJhbnNpdGlvbiIsImFuY2hvclJ0bCIsImdldEFuY2hvciIsInJ0bFRyYW5zbGF0ZU11bHRpcGxpZXIiLCJpbmRleE9mIiwiaXNIb3Jpem9udGFsIiwidHJhbnNmb3JtIiwiZHJhd2VyU3R5bGUiLCJ3ZWJraXRUcmFuc2Zvcm0iLCJ0cmFuc2l0aW9uIiwiY3JlYXRlIiwiZ2V0VHJhbnNpdGlvblByb3BzIiwiZWFzaW5nIiwidW5kZWZpbmVkIiwidGltZW91dCIsIndlYmtpdFRyYW5zaXRpb24iLCJiYWNrZHJvcFN0eWxlIiwib3BhY2l0eSIsImhhbmRsZUJvZHlUb3VjaEVuZCIsIm5hdGl2ZUV2ZW50IiwiZmx1c2hTeW5jIiwiaG9yaXpvbnRhbCIsImNoYW5nZWRUb3VjaGVzIiwiY3VycmVudFRhcmdldCIsInN0YXJ0WCIsInN0YXJ0WSIsInRyYW5zbGF0ZVJhdGlvIiwiYWJzIiwidmVsb2NpdHkiLCJzdGFydE1heWJlU3dpcGluZyIsImZvcmNlIiwibGFzdFRpbWUiLCJsYXN0VHJhbnNsYXRlIiwicGFwZXJIaXQiLCJoYW5kbGVCb2R5VG91Y2hNb3ZlIiwiY3VycmVudFgiLCJjdXJyZW50WSIsImNvbnRhaW5zIiwidGFyZ2V0IiwiaGFzTmF0aXZlSGFuZGxlciIsImR4IiwiZHkiLCJkZWZpbml0ZWx5U3dpcGluZyIsImNhbmNlbGFibGUiLCJwcmV2ZW50RGVmYXVsdCIsInBlcmZvcm1hbmNlIiwibm93IiwiaGFuZGxlQm9keVRvdWNoU3RhcnQiLCJkZWZhdWx0UHJldmVudGVkIiwiZGVmYXVsdE11aVByZXZlbnRlZCIsIl9wYXBlclJlZiRjdXJyZW50IiwidXNlRWZmZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwianN4cyIsIkZyYWdtZW50IiwiY2hpbGRyZW4iLCJqc3giLCJrZWVwTW91bnRlZCIsInBvaW50ZXJFdmVudHMiLCJOb1NzciIsIndpZHRoIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwicHJvcFR5cGVzIiwib25lT2ZUeXBlIiwiYm9vbCIsImZ1bmMiLCJvbmVPZiIsIm5vZGUiLCJudW1iZXIiLCJjb21wb25lbnQiLCJlbGVtZW50VHlwZUFjY2VwdGluZ1JlZiIsImlzUmVxdWlyZWQiLCJvYmplY3QiLCJhcHBlYXIiLCJfZGVmYXVsdCJdLCJzb3VyY2VzIjpbIlN3aXBlYWJsZURyYXdlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbid1c2UgY2xpZW50JztcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuZXhwb3J0cy5yZXNldCA9IHJlc2V0O1xudmFyIF9leHRlbmRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kc1wiKSk7XG52YXIgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCIpKTtcbnZhciBSZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgUmVhY3RET00gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcbnZhciBfcHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG52YXIgX3V0aWxzID0gcmVxdWlyZShcIkBtdWkvdXRpbHNcIik7XG52YXIgX3N5c3RlbSA9IHJlcXVpcmUoXCJAbXVpL3N5c3RlbVwiKTtcbnZhciBfYmFzZSA9IHJlcXVpcmUoXCJAbXVpL2Jhc2VcIik7XG52YXIgX0RyYXdlciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuLi9EcmF3ZXIvRHJhd2VyXCIpKTtcbnZhciBfdXNlRm9ya1JlZiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3V0aWxzL3VzZUZvcmtSZWZcIikpO1xudmFyIF9vd25lckRvY3VtZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHMvb3duZXJEb2N1bWVudFwiKSk7XG52YXIgX293bmVyV2luZG93ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHMvb3duZXJXaW5kb3dcIikpO1xudmFyIF91c2VFdmVudENhbGxiYWNrID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHMvdXNlRXZlbnRDYWxsYmFja1wiKSk7XG52YXIgX3VzZUVuaGFuY2VkRWZmZWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHMvdXNlRW5oYW5jZWRFZmZlY3RcIikpO1xudmFyIF91c2VUaGVtZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3N0eWxlcy91c2VUaGVtZVwiKSk7XG52YXIgX3V0aWxzMiA9IHJlcXVpcmUoXCIuLi90cmFuc2l0aW9ucy91dGlsc1wiKTtcbnZhciBfU3dpcGVBcmVhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9Td2lwZUFyZWFcIikpO1xudmFyIF9qc3hSdW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgX2V4Y2x1ZGVkID0gW1wiQmFja2Ryb3BQcm9wc1wiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcImFuY2hvclwiLCBcImRpc2FibGVCYWNrZHJvcFRyYW5zaXRpb25cIiwgXCJkaXNhYmxlRGlzY292ZXJ5XCIsIFwiZGlzYWJsZVN3aXBlVG9PcGVuXCIsIFwiaGlkZUJhY2tkcm9wXCIsIFwiaHlzdGVyZXNpc1wiLCBcImFsbG93U3dpcGVJbkNoaWxkcmVuXCIsIFwibWluRmxpbmdWZWxvY2l0eVwiLCBcIk1vZGFsUHJvcHNcIiwgXCJvbkNsb3NlXCIsIFwib25PcGVuXCIsIFwib3BlblwiLCBcIlBhcGVyUHJvcHNcIiwgXCJTd2lwZUFyZWFQcm9wc1wiLCBcInN3aXBlQXJlYVdpZHRoXCIsIFwidHJhbnNpdGlvbkR1cmF0aW9uXCIsIFwidmFyaWFudFwiXTsgLy8gVGhpcyB2YWx1ZSBpcyBjbG9zZWQgdG8gd2hhdCBicm93c2VycyBhcmUgdXNpbmcgaW50ZXJuYWxseSB0b1xuLy8gdHJpZ2dlciBhIG5hdGl2ZSBzY3JvbGwuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cbmNvbnN0IFVOQ0VSVEFJTlRZX1RIUkVTSE9MRCA9IDM7IC8vIHB4XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgb2YgdGhlIGRyYXdlciBkaXNwbGF5ZWQgb24gdG91Y2ggc3RhcnQuXG5jb25zdCBEUkFHX1NUQVJURURfU0lHTkFMID0gMjA7IC8vIHB4XG5cbi8vIFdlIGNhbiBvbmx5IGhhdmUgb25lIGluc3RhbmNlIGF0IHRoZSB0aW1lIGNsYWltaW5nIG93bmVyc2hpcCBmb3IgaGFuZGxpbmcgdGhlIHN3aXBlLlxuLy8gT3RoZXJ3aXNlLCB0aGUgVVggd291bGQgYmUgY29uZnVzaW5nLlxuLy8gVGhhdCdzIHdoeSB3ZSB1c2UgYSBzaW5nbGV0b24gaGVyZS5cbmxldCBjbGFpbWVkU3dpcGVJbnN0YW5jZSA9IG51bGw7XG5cbi8vIEV4cG9ydGVkIGZvciB0ZXN0IHB1cnBvc2VzLlxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gIGNsYWltZWRTd2lwZUluc3RhbmNlID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUN1cnJlbnRYKGFuY2hvciwgdG91Y2hlcywgZG9jKSB7XG4gIHJldHVybiBhbmNob3IgPT09ICdyaWdodCcgPyBkb2MuYm9keS5vZmZzZXRXaWR0aCAtIHRvdWNoZXNbMF0ucGFnZVggOiB0b3VjaGVzWzBdLnBhZ2VYO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ3VycmVudFkoYW5jaG9yLCB0b3VjaGVzLCBjb250YWluZXJXaW5kb3cpIHtcbiAgcmV0dXJuIGFuY2hvciA9PT0gJ2JvdHRvbScgPyBjb250YWluZXJXaW5kb3cuaW5uZXJIZWlnaHQgLSB0b3VjaGVzWzBdLmNsaWVudFkgOiB0b3VjaGVzWzBdLmNsaWVudFk7XG59XG5mdW5jdGlvbiBnZXRNYXhUcmFuc2xhdGUoaG9yaXpvbnRhbFN3aXBlLCBwYXBlckluc3RhbmNlKSB7XG4gIHJldHVybiBob3Jpem9udGFsU3dpcGUgPyBwYXBlckluc3RhbmNlLmNsaWVudFdpZHRoIDogcGFwZXJJbnN0YW5jZS5jbGllbnRIZWlnaHQ7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2xhdGUoY3VycmVudFRyYW5zbGF0ZSwgc3RhcnRMb2NhdGlvbiwgb3BlbiwgbWF4VHJhbnNsYXRlKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChvcGVuID8gc3RhcnRMb2NhdGlvbiAtIGN1cnJlbnRUcmFuc2xhdGUgOiBtYXhUcmFuc2xhdGUgKyBzdGFydExvY2F0aW9uIC0gY3VycmVudFRyYW5zbGF0ZSwgMCksIG1heFRyYW5zbGF0ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50IHwgbnVsbH0gZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSByb290Tm9kZVxuICovXG5mdW5jdGlvbiBnZXREb21UcmVlU2hhcGVzKGVsZW1lbnQsIHJvb3ROb2RlKSB7XG4gIC8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vb2xpdmllcnRhc3NpbmFyaS9yZWFjdC1zd2lwZWFibGUtdmlld3MvYmxvYi83NjY2ZGUxZGJhMjUzYjg5NjkxMWFkZjI3OTBjZTUxNDY3NjcwODU2L3BhY2thZ2VzL3JlYWN0LXN3aXBlYWJsZS12aWV3cy9zcmMvU3dpcGVhYmxlVmlld3MuanMjTDEyOVxuICBjb25zdCBkb21UcmVlU2hhcGVzID0gW107XG4gIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQgIT09IHJvb3ROb2RlLnBhcmVudEVsZW1lbnQpIHtcbiAgICBjb25zdCBzdHlsZSA9ICgwLCBfb3duZXJXaW5kb3cuZGVmYXVsdCkocm9vdE5vZGUpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgaWYgKFxuICAgIC8vIElnbm9yZSB0aGUgc2Nyb2xsIGNoaWxkcmVuIGlmIHRoZSBlbGVtZW50IGlzIGFic29sdXRlIHBvc2l0aW9uZWQuXG4gICAgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKSA9PT0gJ2Fic29sdXRlJyB8fFxuICAgIC8vIElnbm9yZSB0aGUgc2Nyb2xsIGNoaWxkcmVuIGlmIHRoZSBlbGVtZW50IGhhcyBhbiBvdmVyZmxvd1ggaGlkZGVuXG4gICAgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cteCcpID09PSAnaGlkZGVuJykge1xuICAgICAgLy8gbm9vcFxuICAgIH0gZWxzZSBpZiAoZWxlbWVudC5jbGllbnRXaWR0aCA+IDAgJiYgZWxlbWVudC5zY3JvbGxXaWR0aCA+IGVsZW1lbnQuY2xpZW50V2lkdGggfHwgZWxlbWVudC5jbGllbnRIZWlnaHQgPiAwICYmIGVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZWxlbWVudC5jbGllbnRIZWlnaHQpIHtcbiAgICAgIC8vIElnbm9yZSB0aGUgbm9kZXMgdGhhdCBoYXZlIG5vIHdpZHRoLlxuICAgICAgLy8gS2VlcCBlbGVtZW50cyB3aXRoIGEgc2Nyb2xsXG4gICAgICBkb21UcmVlU2hhcGVzLnB1c2goZWxlbWVudCk7XG4gICAgfVxuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGRvbVRyZWVTaGFwZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMFxuICogQHBhcmFtIHtSZXR1cm5UeXBlPGdldERvbVRyZWVTaGFwZXM+fSBwYXJhbTAuZG9tVHJlZVNoYXBlc1xuICovXG5mdW5jdGlvbiBjb21wdXRlSGFzTmF0aXZlSGFuZGxlcih7XG4gIGRvbVRyZWVTaGFwZXMsXG4gIHN0YXJ0LFxuICBjdXJyZW50LFxuICBhbmNob3Jcbn0pIHtcbiAgLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9vbGl2aWVydGFzc2luYXJpL3JlYWN0LXN3aXBlYWJsZS12aWV3cy9ibG9iLzc2NjZkZTFkYmEyNTNiODk2OTExYWRmMjc5MGNlNTE0Njc2NzA4NTYvcGFja2FnZXMvcmVhY3Qtc3dpcGVhYmxlLXZpZXdzL3NyYy9Td2lwZWFibGVWaWV3cy5qcyNMMTc1XG4gIGNvbnN0IGF4aXNQcm9wZXJ0aWVzID0ge1xuICAgIHNjcm9sbFBvc2l0aW9uOiB7XG4gICAgICB4OiAnc2Nyb2xsTGVmdCcsXG4gICAgICB5OiAnc2Nyb2xsVG9wJ1xuICAgIH0sXG4gICAgc2Nyb2xsTGVuZ3RoOiB7XG4gICAgICB4OiAnc2Nyb2xsV2lkdGgnLFxuICAgICAgeTogJ3Njcm9sbEhlaWdodCdcbiAgICB9LFxuICAgIGNsaWVudExlbmd0aDoge1xuICAgICAgeDogJ2NsaWVudFdpZHRoJyxcbiAgICAgIHk6ICdjbGllbnRIZWlnaHQnXG4gICAgfVxuICB9O1xuICByZXR1cm4gZG9tVHJlZVNoYXBlcy5zb21lKHNoYXBlID0+IHtcbiAgICAvLyBEZXRlcm1pbmUgaWYgd2UgYXJlIGdvaW5nIGJhY2t3YXJkIG9yIGZvcndhcmQuXG4gICAgbGV0IGdvaW5nRm9yd2FyZCA9IGN1cnJlbnQgPj0gc3RhcnQ7XG4gICAgaWYgKGFuY2hvciA9PT0gJ3RvcCcgfHwgYW5jaG9yID09PSAnbGVmdCcpIHtcbiAgICAgIGdvaW5nRm9yd2FyZCA9ICFnb2luZ0ZvcndhcmQ7XG4gICAgfVxuICAgIGNvbnN0IGF4aXMgPSBhbmNob3IgPT09ICdsZWZ0JyB8fCBhbmNob3IgPT09ICdyaWdodCcgPyAneCcgOiAneSc7XG4gICAgY29uc3Qgc2Nyb2xsUG9zaXRpb24gPSBNYXRoLnJvdW5kKHNoYXBlW2F4aXNQcm9wZXJ0aWVzLnNjcm9sbFBvc2l0aW9uW2F4aXNdXSk7XG4gICAgY29uc3QgYXJlTm90QXRTdGFydCA9IHNjcm9sbFBvc2l0aW9uID4gMDtcbiAgICBjb25zdCBhcmVOb3RBdEVuZCA9IHNjcm9sbFBvc2l0aW9uICsgc2hhcGVbYXhpc1Byb3BlcnRpZXMuY2xpZW50TGVuZ3RoW2F4aXNdXSA8IHNoYXBlW2F4aXNQcm9wZXJ0aWVzLnNjcm9sbExlbmd0aFtheGlzXV07XG4gICAgaWYgKGdvaW5nRm9yd2FyZCAmJiBhcmVOb3RBdEVuZCB8fCAhZ29pbmdGb3J3YXJkICYmIGFyZU5vdEF0U3RhcnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufVxuY29uc3QgaU9TID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBTd2lwZWFibGVEcmF3ZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBTd2lwZWFibGVEcmF3ZXIoaW5Qcm9wcywgcmVmKSB7XG4gIGNvbnN0IHByb3BzID0gKDAsIF9zeXN0ZW0udXNlVGhlbWVQcm9wcykoe1xuICAgIG5hbWU6ICdNdWlTd2lwZWFibGVEcmF3ZXInLFxuICAgIHByb3BzOiBpblByb3BzXG4gIH0pO1xuICBjb25zdCB0aGVtZSA9ICgwLCBfdXNlVGhlbWUuZGVmYXVsdCkoKTtcbiAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uRGVmYXVsdCA9IHtcbiAgICBlbnRlcjogdGhlbWUudHJhbnNpdGlvbnMuZHVyYXRpb24uZW50ZXJpbmdTY3JlZW4sXG4gICAgZXhpdDogdGhlbWUudHJhbnNpdGlvbnMuZHVyYXRpb24ubGVhdmluZ1NjcmVlblxuICB9O1xuICBjb25zdCB7XG4gICAgICBhbmNob3IgPSAnbGVmdCcsXG4gICAgICBkaXNhYmxlQmFja2Ryb3BUcmFuc2l0aW9uID0gZmFsc2UsXG4gICAgICBkaXNhYmxlRGlzY292ZXJ5ID0gZmFsc2UsXG4gICAgICBkaXNhYmxlU3dpcGVUb09wZW4gPSBpT1MsXG4gICAgICBoaWRlQmFja2Ryb3AsXG4gICAgICBoeXN0ZXJlc2lzID0gMC41MixcbiAgICAgIGFsbG93U3dpcGVJbkNoaWxkcmVuID0gZmFsc2UsXG4gICAgICBtaW5GbGluZ1ZlbG9jaXR5ID0gNDUwLFxuICAgICAgTW9kYWxQcm9wczoge1xuICAgICAgICBCYWNrZHJvcFByb3BzXG4gICAgICB9ID0ge30sXG4gICAgICBvbkNsb3NlLFxuICAgICAgb25PcGVuLFxuICAgICAgb3BlbiA9IGZhbHNlLFxuICAgICAgUGFwZXJQcm9wcyA9IHt9LFxuICAgICAgU3dpcGVBcmVhUHJvcHMsXG4gICAgICBzd2lwZUFyZWFXaWR0aCA9IDIwLFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gdHJhbnNpdGlvbkR1cmF0aW9uRGVmYXVsdCxcbiAgICAgIHZhcmlhbnQgPSAndGVtcG9yYXJ5JyAvLyBNb2JpbGUgZmlyc3QuXG4gICAgfSA9IHByb3BzLFxuICAgIE1vZGFsUHJvcHNQcm9wID0gKDAsIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlMi5kZWZhdWx0KShwcm9wcy5Nb2RhbFByb3BzLCBfZXhjbHVkZWQpLFxuICAgIG90aGVyID0gKDAsIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlMi5kZWZhdWx0KShwcm9wcywgX2V4Y2x1ZGVkMik7XG4gIGNvbnN0IFttYXliZVN3aXBpbmcsIHNldE1heWJlU3dpcGluZ10gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHN3aXBlSW5zdGFuY2UgPSBSZWFjdC51c2VSZWYoe1xuICAgIGlzU3dpcGluZzogbnVsbFxuICB9KTtcbiAgY29uc3Qgc3dpcGVBcmVhUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IGJhY2tkcm9wUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IHBhcGVyUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IGhhbmRsZVJlZiA9ICgwLCBfdXNlRm9ya1JlZi5kZWZhdWx0KShQYXBlclByb3BzLnJlZiwgcGFwZXJSZWYpO1xuICBjb25zdCB0b3VjaERldGVjdGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcblxuICAvLyBSZWYgZm9yIHRyYW5zaXRpb24gZHVyYXRpb24gYmFzZWQgb24gLyB0byBtYXRjaCBzd2lwZSBzcGVlZFxuICBjb25zdCBjYWxjdWxhdGVkRHVyYXRpb25SZWYgPSBSZWFjdC51c2VSZWYoKTtcblxuICAvLyBVc2UgYSByZWYgc28gdGhlIG9wZW4gdmFsdWUgdXNlZCBpcyBhbHdheXMgdXAgdG8gZGF0ZSBpbnNpZGUgdXNlQ2FsbGJhY2suXG4gICgwLCBfdXNlRW5oYW5jZWRFZmZlY3QuZGVmYXVsdCkoKCkgPT4ge1xuICAgIGNhbGN1bGF0ZWREdXJhdGlvblJlZi5jdXJyZW50ID0gbnVsbDtcbiAgfSwgW29wZW5dKTtcbiAgY29uc3Qgc2V0UG9zaXRpb24gPSBSZWFjdC51c2VDYWxsYmFjaygodHJhbnNsYXRlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBtb2RlID0gbnVsbCxcbiAgICAgIGNoYW5nZVRyYW5zaXRpb24gPSB0cnVlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYW5jaG9yUnRsID0gKDAsIF9EcmF3ZXIuZ2V0QW5jaG9yKSh0aGVtZSwgYW5jaG9yKTtcbiAgICBjb25zdCBydGxUcmFuc2xhdGVNdWx0aXBsaWVyID0gWydyaWdodCcsICdib3R0b20nXS5pbmRleE9mKGFuY2hvclJ0bCkgIT09IC0xID8gMSA6IC0xO1xuICAgIGNvbnN0IGhvcml6b250YWxTd2lwZSA9ICgwLCBfRHJhd2VyLmlzSG9yaXpvbnRhbCkoYW5jaG9yKTtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBob3Jpem9udGFsU3dpcGUgPyBgdHJhbnNsYXRlKCR7cnRsVHJhbnNsYXRlTXVsdGlwbGllciAqIHRyYW5zbGF0ZX1weCwgMClgIDogYHRyYW5zbGF0ZSgwLCAke3J0bFRyYW5zbGF0ZU11bHRpcGxpZXIgKiB0cmFuc2xhdGV9cHgpYDtcbiAgICBjb25zdCBkcmF3ZXJTdHlsZSA9IHBhcGVyUmVmLmN1cnJlbnQuc3R5bGU7XG4gICAgZHJhd2VyU3R5bGUud2Via2l0VHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGRyYXdlclN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBsZXQgdHJhbnNpdGlvbiA9ICcnO1xuICAgIGlmIChtb2RlKSB7XG4gICAgICB0cmFuc2l0aW9uID0gdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKCdhbGwnLCAoMCwgX3V0aWxzMi5nZXRUcmFuc2l0aW9uUHJvcHMpKHtcbiAgICAgICAgZWFzaW5nOiB1bmRlZmluZWQsXG4gICAgICAgIHN0eWxlOiB1bmRlZmluZWQsXG4gICAgICAgIHRpbWVvdXQ6IHRyYW5zaXRpb25EdXJhdGlvblxuICAgICAgfSwge1xuICAgICAgICBtb2RlXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChjaGFuZ2VUcmFuc2l0aW9uKSB7XG4gICAgICBkcmF3ZXJTdHlsZS53ZWJraXRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICAgIGRyYXdlclN0eWxlLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgIH1cbiAgICBpZiAoIWRpc2FibGVCYWNrZHJvcFRyYW5zaXRpb24gJiYgIWhpZGVCYWNrZHJvcCkge1xuICAgICAgY29uc3QgYmFja2Ryb3BTdHlsZSA9IGJhY2tkcm9wUmVmLmN1cnJlbnQuc3R5bGU7XG4gICAgICBiYWNrZHJvcFN0eWxlLm9wYWNpdHkgPSAxIC0gdHJhbnNsYXRlIC8gZ2V0TWF4VHJhbnNsYXRlKGhvcml6b250YWxTd2lwZSwgcGFwZXJSZWYuY3VycmVudCk7XG4gICAgICBpZiAoY2hhbmdlVHJhbnNpdGlvbikge1xuICAgICAgICBiYWNrZHJvcFN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgICAgICBiYWNrZHJvcFN0eWxlLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2FuY2hvciwgZGlzYWJsZUJhY2tkcm9wVHJhbnNpdGlvbiwgaGlkZUJhY2tkcm9wLCB0aGVtZSwgdHJhbnNpdGlvbkR1cmF0aW9uXSk7XG4gIGNvbnN0IGhhbmRsZUJvZHlUb3VjaEVuZCA9ICgwLCBfdXNlRXZlbnRDYWxsYmFjay5kZWZhdWx0KShuYXRpdmVFdmVudCA9PiB7XG4gICAgaWYgKCF0b3VjaERldGVjdGVkLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xhaW1lZFN3aXBlSW5zdGFuY2UgPSBudWxsO1xuICAgIHRvdWNoRGV0ZWN0ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgIFJlYWN0RE9NLmZsdXNoU3luYygoKSA9PiB7XG4gICAgICBzZXRNYXliZVN3aXBpbmcoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgLy8gVGhlIHN3aXBlIHdhc24ndCBzdGFydGVkLlxuICAgIGlmICghc3dpcGVJbnN0YW5jZS5jdXJyZW50LmlzU3dpcGluZykge1xuICAgICAgc3dpcGVJbnN0YW5jZS5jdXJyZW50LmlzU3dpcGluZyA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXBlSW5zdGFuY2UuY3VycmVudC5pc1N3aXBpbmcgPSBudWxsO1xuICAgIGNvbnN0IGFuY2hvclJ0bCA9ICgwLCBfRHJhd2VyLmdldEFuY2hvcikodGhlbWUsIGFuY2hvcik7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9ICgwLCBfRHJhd2VyLmlzSG9yaXpvbnRhbCkoYW5jaG9yKTtcbiAgICBsZXQgY3VycmVudDtcbiAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgY3VycmVudCA9IGNhbGN1bGF0ZUN1cnJlbnRYKGFuY2hvclJ0bCwgbmF0aXZlRXZlbnQuY2hhbmdlZFRvdWNoZXMsICgwLCBfb3duZXJEb2N1bWVudC5kZWZhdWx0KShuYXRpdmVFdmVudC5jdXJyZW50VGFyZ2V0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQgPSBjYWxjdWxhdGVDdXJyZW50WShhbmNob3JSdGwsIG5hdGl2ZUV2ZW50LmNoYW5nZWRUb3VjaGVzLCAoMCwgX293bmVyV2luZG93LmRlZmF1bHQpKG5hdGl2ZUV2ZW50LmN1cnJlbnRUYXJnZXQpKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRMb2NhdGlvbiA9IGhvcml6b250YWwgPyBzd2lwZUluc3RhbmNlLmN1cnJlbnQuc3RhcnRYIDogc3dpcGVJbnN0YW5jZS5jdXJyZW50LnN0YXJ0WTtcbiAgICBjb25zdCBtYXhUcmFuc2xhdGUgPSBnZXRNYXhUcmFuc2xhdGUoaG9yaXpvbnRhbCwgcGFwZXJSZWYuY3VycmVudCk7XG4gICAgY29uc3QgY3VycmVudFRyYW5zbGF0ZSA9IGdldFRyYW5zbGF0ZShjdXJyZW50LCBzdGFydExvY2F0aW9uLCBvcGVuLCBtYXhUcmFuc2xhdGUpO1xuICAgIGNvbnN0IHRyYW5zbGF0ZVJhdGlvID0gY3VycmVudFRyYW5zbGF0ZSAvIG1heFRyYW5zbGF0ZTtcbiAgICBpZiAoTWF0aC5hYnMoc3dpcGVJbnN0YW5jZS5jdXJyZW50LnZlbG9jaXR5KSA+IG1pbkZsaW5nVmVsb2NpdHkpIHtcbiAgICAgIC8vIENhbGN1bGF0ZSB0cmFuc2l0aW9uIGR1cmF0aW9uIHRvIG1hdGNoIHN3aXBlIHNwZWVkXG4gICAgICBjYWxjdWxhdGVkRHVyYXRpb25SZWYuY3VycmVudCA9IE1hdGguYWJzKChtYXhUcmFuc2xhdGUgLSBjdXJyZW50VHJhbnNsYXRlKSAvIHN3aXBlSW5zdGFuY2UuY3VycmVudC52ZWxvY2l0eSkgKiAxMDAwO1xuICAgIH1cbiAgICBpZiAob3Blbikge1xuICAgICAgaWYgKHN3aXBlSW5zdGFuY2UuY3VycmVudC52ZWxvY2l0eSA+IG1pbkZsaW5nVmVsb2NpdHkgfHwgdHJhbnNsYXRlUmF0aW8gPiBoeXN0ZXJlc2lzKSB7XG4gICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlc2V0IHRoZSBwb3NpdGlvbiwgdGhlIHN3aXBlIHdhcyBhYm9ydGVkLlxuICAgICAgICBzZXRQb3NpdGlvbigwLCB7XG4gICAgICAgICAgbW9kZTogJ2V4aXQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3dpcGVJbnN0YW5jZS5jdXJyZW50LnZlbG9jaXR5IDwgLW1pbkZsaW5nVmVsb2NpdHkgfHwgMSAtIHRyYW5zbGF0ZVJhdGlvID4gaHlzdGVyZXNpcykge1xuICAgICAgb25PcGVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBwb3NpdGlvbiwgdGhlIHN3aXBlIHdhcyBhYm9ydGVkLlxuICAgICAgc2V0UG9zaXRpb24oZ2V0TWF4VHJhbnNsYXRlKGhvcml6b250YWwsIHBhcGVyUmVmLmN1cnJlbnQpLCB7XG4gICAgICAgIG1vZGU6ICdlbnRlcidcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHN0YXJ0TWF5YmVTd2lwaW5nID0gKGZvcmNlID0gZmFsc2UpID0+IHtcbiAgICBpZiAoIW1heWJlU3dpcGluZykge1xuICAgICAgLy8gb24gU2FmYXJpIE1vYmlsZSwgaWYgeW91IHdhbnQgdG8gYmUgYWJsZSB0byBoYXZlIHRoZSAnY2xpY2snIGV2ZW50IGZpcmVkIG9uIGNoaWxkIGVsZW1lbnRzLCBub3RoaW5nIGluIHRoZSBET00gY2FuIGJlIGNoYW5nZWQuXG4gICAgICAvLyB0aGlzIGlzIGJlY2F1c2UgU2FmYXJpIE1vYmlsZSB3aWxsIG5vdCBmaXJlIGFueSBtb3VzZSBldmVudHMgKHN0aWxsIGZpcmVzIHRvdWNoIHRob3VnaCkgaWYgdGhlIERPTSBjaGFuZ2VzIGR1cmluZyBtb3VzZW1vdmUuXG4gICAgICAvLyBzbyBkbyB0aGlzIGNoYW5nZSBvbiBmaXJzdCB0b3VjaG1vdmUgaW5zdGVhZCBvZiB0b3VjaHN0YXJ0XG4gICAgICBpZiAoZm9yY2UgfHwgIShkaXNhYmxlRGlzY292ZXJ5ICYmIGFsbG93U3dpcGVJbkNoaWxkcmVuKSkge1xuICAgICAgICBSZWFjdERPTS5mbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgIHNldE1heWJlU3dpcGluZyh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBob3Jpem9udGFsU3dpcGUgPSAoMCwgX0RyYXdlci5pc0hvcml6b250YWwpKGFuY2hvcik7XG4gICAgICBpZiAoIW9wZW4gJiYgcGFwZXJSZWYuY3VycmVudCkge1xuICAgICAgICAvLyBUaGUgcmVmIG1heSBiZSBudWxsIHdoZW4gYSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZXMgd2hpbGUgc3dpcGluZy5cbiAgICAgICAgc2V0UG9zaXRpb24oZ2V0TWF4VHJhbnNsYXRlKGhvcml6b250YWxTd2lwZSwgcGFwZXJSZWYuY3VycmVudCkgKyAoZGlzYWJsZURpc2NvdmVyeSA/IDE1IDogLURSQUdfU1RBUlRFRF9TSUdOQUwpLCB7XG4gICAgICAgICAgY2hhbmdlVHJhbnNpdGlvbjogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzd2lwZUluc3RhbmNlLmN1cnJlbnQudmVsb2NpdHkgPSAwO1xuICAgICAgc3dpcGVJbnN0YW5jZS5jdXJyZW50Lmxhc3RUaW1lID0gbnVsbDtcbiAgICAgIHN3aXBlSW5zdGFuY2UuY3VycmVudC5sYXN0VHJhbnNsYXRlID0gbnVsbDtcbiAgICAgIHN3aXBlSW5zdGFuY2UuY3VycmVudC5wYXBlckhpdCA9IGZhbHNlO1xuICAgICAgdG91Y2hEZXRlY3RlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhhbmRsZUJvZHlUb3VjaE1vdmUgPSAoMCwgX3VzZUV2ZW50Q2FsbGJhY2suZGVmYXVsdCkobmF0aXZlRXZlbnQgPT4ge1xuICAgIC8vIHRoZSByZWYgbWF5IGJlIG51bGwgd2hlbiBhIHBhcmVudCBjb21wb25lbnQgdXBkYXRlcyB3aGlsZSBzd2lwaW5nXG4gICAgaWYgKCFwYXBlclJlZi5jdXJyZW50IHx8ICF0b3VjaERldGVjdGVkLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXZSBhcmUgbm90IHN1cHBvc2VkIHRvIGhhbmRsZSB0aGlzIHRvdWNoIG1vdmUgYmVjYXVzZSB0aGUgc3dpcGUgd2FzIHN0YXJ0ZWQgaW4gYSBzY3JvbGxhYmxlIGNvbnRhaW5lciBpbiB0aGUgZHJhd2VyXG4gICAgaWYgKGNsYWltZWRTd2lwZUluc3RhbmNlICE9PSBudWxsICYmIGNsYWltZWRTd2lwZUluc3RhbmNlICE9PSBzd2lwZUluc3RhbmNlLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RhcnRNYXliZVN3aXBpbmcodHJ1ZSk7XG4gICAgY29uc3QgYW5jaG9yUnRsID0gKDAsIF9EcmF3ZXIuZ2V0QW5jaG9yKSh0aGVtZSwgYW5jaG9yKTtcbiAgICBjb25zdCBob3Jpem9udGFsU3dpcGUgPSAoMCwgX0RyYXdlci5pc0hvcml6b250YWwpKGFuY2hvcik7XG4gICAgY29uc3QgY3VycmVudFggPSBjYWxjdWxhdGVDdXJyZW50WChhbmNob3JSdGwsIG5hdGl2ZUV2ZW50LnRvdWNoZXMsICgwLCBfb3duZXJEb2N1bWVudC5kZWZhdWx0KShuYXRpdmVFdmVudC5jdXJyZW50VGFyZ2V0KSk7XG4gICAgY29uc3QgY3VycmVudFkgPSBjYWxjdWxhdGVDdXJyZW50WShhbmNob3JSdGwsIG5hdGl2ZUV2ZW50LnRvdWNoZXMsICgwLCBfb3duZXJXaW5kb3cuZGVmYXVsdCkobmF0aXZlRXZlbnQuY3VycmVudFRhcmdldCkpO1xuICAgIGlmIChvcGVuICYmIHBhcGVyUmVmLmN1cnJlbnQuY29udGFpbnMobmF0aXZlRXZlbnQudGFyZ2V0KSAmJiBjbGFpbWVkU3dpcGVJbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgZG9tVHJlZVNoYXBlcyA9IGdldERvbVRyZWVTaGFwZXMobmF0aXZlRXZlbnQudGFyZ2V0LCBwYXBlclJlZi5jdXJyZW50KTtcbiAgICAgIGNvbnN0IGhhc05hdGl2ZUhhbmRsZXIgPSBjb21wdXRlSGFzTmF0aXZlSGFuZGxlcih7XG4gICAgICAgIGRvbVRyZWVTaGFwZXMsXG4gICAgICAgIHN0YXJ0OiBob3Jpem9udGFsU3dpcGUgPyBzd2lwZUluc3RhbmNlLmN1cnJlbnQuc3RhcnRYIDogc3dpcGVJbnN0YW5jZS5jdXJyZW50LnN0YXJ0WSxcbiAgICAgICAgY3VycmVudDogaG9yaXpvbnRhbFN3aXBlID8gY3VycmVudFggOiBjdXJyZW50WSxcbiAgICAgICAgYW5jaG9yXG4gICAgICB9KTtcbiAgICAgIGlmIChoYXNOYXRpdmVIYW5kbGVyKSB7XG4gICAgICAgIGNsYWltZWRTd2lwZUluc3RhbmNlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2xhaW1lZFN3aXBlSW5zdGFuY2UgPSBzd2lwZUluc3RhbmNlLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgLy8gV2UgZG9uJ3Qga25vdyB5ZXQuXG4gICAgaWYgKHN3aXBlSW5zdGFuY2UuY3VycmVudC5pc1N3aXBpbmcgPT0gbnVsbCkge1xuICAgICAgY29uc3QgZHggPSBNYXRoLmFicyhjdXJyZW50WCAtIHN3aXBlSW5zdGFuY2UuY3VycmVudC5zdGFydFgpO1xuICAgICAgY29uc3QgZHkgPSBNYXRoLmFicyhjdXJyZW50WSAtIHN3aXBlSW5zdGFuY2UuY3VycmVudC5zdGFydFkpO1xuICAgICAgY29uc3QgZGVmaW5pdGVseVN3aXBpbmcgPSBob3Jpem9udGFsU3dpcGUgPyBkeCA+IGR5ICYmIGR4ID4gVU5DRVJUQUlOVFlfVEhSRVNIT0xEIDogZHkgPiBkeCAmJiBkeSA+IFVOQ0VSVEFJTlRZX1RIUkVTSE9MRDtcbiAgICAgIGlmIChkZWZpbml0ZWx5U3dpcGluZyAmJiBuYXRpdmVFdmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICAgIG5hdGl2ZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5pdGVseVN3aXBpbmcgPT09IHRydWUgfHwgKGhvcml6b250YWxTd2lwZSA/IGR5ID4gVU5DRVJUQUlOVFlfVEhSRVNIT0xEIDogZHggPiBVTkNFUlRBSU5UWV9USFJFU0hPTEQpKSB7XG4gICAgICAgIHN3aXBlSW5zdGFuY2UuY3VycmVudC5pc1N3aXBpbmcgPSBkZWZpbml0ZWx5U3dpcGluZztcbiAgICAgICAgaWYgKCFkZWZpbml0ZWx5U3dpcGluZykge1xuICAgICAgICAgIGhhbmRsZUJvZHlUb3VjaEVuZChuYXRpdmVFdmVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hpZnQgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICAgICAgICBzd2lwZUluc3RhbmNlLmN1cnJlbnQuc3RhcnRYID0gY3VycmVudFg7XG4gICAgICAgIHN3aXBlSW5zdGFuY2UuY3VycmVudC5zdGFydFkgPSBjdXJyZW50WTtcblxuICAgICAgICAvLyBDb21wZW5zYXRlIGZvciB0aGUgcGFydCBvZiB0aGUgZHJhd2VyIGRpc3BsYXllZCBvbiB0b3VjaCBzdGFydC5cbiAgICAgICAgaWYgKCFkaXNhYmxlRGlzY292ZXJ5ICYmICFvcGVuKSB7XG4gICAgICAgICAgaWYgKGhvcml6b250YWxTd2lwZSkge1xuICAgICAgICAgICAgc3dpcGVJbnN0YW5jZS5jdXJyZW50LnN0YXJ0WCAtPSBEUkFHX1NUQVJURURfU0lHTkFMO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzd2lwZUluc3RhbmNlLmN1cnJlbnQuc3RhcnRZIC09IERSQUdfU1RBUlRFRF9TSUdOQUw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc3dpcGVJbnN0YW5jZS5jdXJyZW50LmlzU3dpcGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtYXhUcmFuc2xhdGUgPSBnZXRNYXhUcmFuc2xhdGUoaG9yaXpvbnRhbFN3aXBlLCBwYXBlclJlZi5jdXJyZW50KTtcbiAgICBsZXQgc3RhcnRMb2NhdGlvbiA9IGhvcml6b250YWxTd2lwZSA/IHN3aXBlSW5zdGFuY2UuY3VycmVudC5zdGFydFggOiBzd2lwZUluc3RhbmNlLmN1cnJlbnQuc3RhcnRZO1xuICAgIGlmIChvcGVuICYmICFzd2lwZUluc3RhbmNlLmN1cnJlbnQucGFwZXJIaXQpIHtcbiAgICAgIHN0YXJ0TG9jYXRpb24gPSBNYXRoLm1pbihzdGFydExvY2F0aW9uLCBtYXhUcmFuc2xhdGUpO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2xhdGUgPSBnZXRUcmFuc2xhdGUoaG9yaXpvbnRhbFN3aXBlID8gY3VycmVudFggOiBjdXJyZW50WSwgc3RhcnRMb2NhdGlvbiwgb3BlbiwgbWF4VHJhbnNsYXRlKTtcbiAgICBpZiAob3Blbikge1xuICAgICAgaWYgKCFzd2lwZUluc3RhbmNlLmN1cnJlbnQucGFwZXJIaXQpIHtcbiAgICAgICAgY29uc3QgcGFwZXJIaXQgPSBob3Jpem9udGFsU3dpcGUgPyBjdXJyZW50WCA8IG1heFRyYW5zbGF0ZSA6IGN1cnJlbnRZIDwgbWF4VHJhbnNsYXRlO1xuICAgICAgICBpZiAocGFwZXJIaXQpIHtcbiAgICAgICAgICBzd2lwZUluc3RhbmNlLmN1cnJlbnQucGFwZXJIaXQgPSB0cnVlO1xuICAgICAgICAgIHN3aXBlSW5zdGFuY2UuY3VycmVudC5zdGFydFggPSBjdXJyZW50WDtcbiAgICAgICAgICBzd2lwZUluc3RhbmNlLmN1cnJlbnQuc3RhcnRZID0gY3VycmVudFk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRyYW5zbGF0ZSA9PT0gMCkge1xuICAgICAgICBzd2lwZUluc3RhbmNlLmN1cnJlbnQuc3RhcnRYID0gY3VycmVudFg7XG4gICAgICAgIHN3aXBlSW5zdGFuY2UuY3VycmVudC5zdGFydFkgPSBjdXJyZW50WTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN3aXBlSW5zdGFuY2UuY3VycmVudC5sYXN0VHJhbnNsYXRlID09PSBudWxsKSB7XG4gICAgICBzd2lwZUluc3RhbmNlLmN1cnJlbnQubGFzdFRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbiAgICAgIHN3aXBlSW5zdGFuY2UuY3VycmVudC5sYXN0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpICsgMTtcbiAgICB9XG4gICAgY29uc3QgdmVsb2NpdHkgPSAodHJhbnNsYXRlIC0gc3dpcGVJbnN0YW5jZS5jdXJyZW50Lmxhc3RUcmFuc2xhdGUpIC8gKHBlcmZvcm1hbmNlLm5vdygpIC0gc3dpcGVJbnN0YW5jZS5jdXJyZW50Lmxhc3RUaW1lKSAqIDFlMztcblxuICAgIC8vIExvdyBQYXNzIGZpbHRlci5cbiAgICBzd2lwZUluc3RhbmNlLmN1cnJlbnQudmVsb2NpdHkgPSBzd2lwZUluc3RhbmNlLmN1cnJlbnQudmVsb2NpdHkgKiAwLjQgKyB2ZWxvY2l0eSAqIDAuNjtcbiAgICBzd2lwZUluc3RhbmNlLmN1cnJlbnQubGFzdFRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbiAgICBzd2lwZUluc3RhbmNlLmN1cnJlbnQubGFzdFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgIC8vIFdlIGFyZSBzd2lwaW5nLCBsZXQncyBwcmV2ZW50IHRoZSBzY3JvbGwgZXZlbnQgb24gaU9TLlxuICAgIGlmIChuYXRpdmVFdmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICBuYXRpdmVFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBzZXRQb3NpdGlvbih0cmFuc2xhdGUpO1xuICB9KTtcbiAgY29uc3QgaGFuZGxlQm9keVRvdWNoU3RhcnQgPSAoMCwgX3VzZUV2ZW50Q2FsbGJhY2suZGVmYXVsdCkobmF0aXZlRXZlbnQgPT4ge1xuICAgIC8vIFdlIGFyZSBub3Qgc3VwcG9zZWQgdG8gaGFuZGxlIHRoaXMgdG91Y2ggbW92ZS5cbiAgICAvLyBFeGFtcGxlIG9mIHVzZSBjYXNlOiBpZ25vcmUgdGhlIGV2ZW50IGlmIHRoZXJlIGlzIGEgU2xpZGVyLlxuICAgIGlmIChuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuIG9ubHkgaGF2ZSBvbmUgbm9kZSBhdCB0aGUgdGltZSBjbGFpbWluZyBvd25lcnNoaXAgZm9yIGhhbmRsaW5nIHRoZSBzd2lwZS5cbiAgICBpZiAobmF0aXZlRXZlbnQuZGVmYXVsdE11aVByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEF0IGxlYXN0IG9uZSBlbGVtZW50IGNsb2dzIHRoZSBkcmF3ZXIgaW50ZXJhY3Rpb24gem9uZS5cbiAgICBpZiAob3BlbiAmJiAoaGlkZUJhY2tkcm9wIHx8ICFiYWNrZHJvcFJlZi5jdXJyZW50LmNvbnRhaW5zKG5hdGl2ZUV2ZW50LnRhcmdldCkpICYmICFwYXBlclJlZi5jdXJyZW50LmNvbnRhaW5zKG5hdGl2ZUV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yUnRsID0gKDAsIF9EcmF3ZXIuZ2V0QW5jaG9yKSh0aGVtZSwgYW5jaG9yKTtcbiAgICBjb25zdCBob3Jpem9udGFsU3dpcGUgPSAoMCwgX0RyYXdlci5pc0hvcml6b250YWwpKGFuY2hvcik7XG4gICAgY29uc3QgY3VycmVudFggPSBjYWxjdWxhdGVDdXJyZW50WChhbmNob3JSdGwsIG5hdGl2ZUV2ZW50LnRvdWNoZXMsICgwLCBfb3duZXJEb2N1bWVudC5kZWZhdWx0KShuYXRpdmVFdmVudC5jdXJyZW50VGFyZ2V0KSk7XG4gICAgY29uc3QgY3VycmVudFkgPSBjYWxjdWxhdGVDdXJyZW50WShhbmNob3JSdGwsIG5hdGl2ZUV2ZW50LnRvdWNoZXMsICgwLCBfb3duZXJXaW5kb3cuZGVmYXVsdCkobmF0aXZlRXZlbnQuY3VycmVudFRhcmdldCkpO1xuICAgIGlmICghb3Blbikge1xuICAgICAgdmFyIF9wYXBlclJlZiRjdXJyZW50O1xuICAgICAgLy8gbG9naWMgZm9yIGlmIHN3aXBlIHNob3VsZCBiZSBpZ25vcmVkOlxuICAgICAgLy8gaWYgZGlzYWJsZVN3aXBlVG9PcGVuXG4gICAgICAvLyBpZiB0YXJnZXQgIT0gc3dpcGVBcmVhLCBhbmQgdGFyZ2V0IGlzIG5vdCBhIGNoaWxkIG9mIHBhcGVyIHJlZlxuICAgICAgLy8gaWYgaXMgYSBjaGlsZCBvZiBwYXBlciByZWYsIGFuZCBgYWxsb3dTd2lwZUluQ2hpbGRyZW5gIGRvZXMgbm90IGFsbG93IGl0XG4gICAgICBpZiAoZGlzYWJsZVN3aXBlVG9PcGVuIHx8ICEobmF0aXZlRXZlbnQudGFyZ2V0ID09PSBzd2lwZUFyZWFSZWYuY3VycmVudCB8fCAoX3BhcGVyUmVmJGN1cnJlbnQgPSBwYXBlclJlZi5jdXJyZW50KSAhPSBudWxsICYmIF9wYXBlclJlZiRjdXJyZW50LmNvbnRhaW5zKG5hdGl2ZUV2ZW50LnRhcmdldCkgJiYgKHR5cGVvZiBhbGxvd1N3aXBlSW5DaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJyA/IGFsbG93U3dpcGVJbkNoaWxkcmVuKG5hdGl2ZUV2ZW50LCBzd2lwZUFyZWFSZWYuY3VycmVudCwgcGFwZXJSZWYuY3VycmVudCkgOiBhbGxvd1N3aXBlSW5DaGlsZHJlbikpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChob3Jpem9udGFsU3dpcGUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRYID4gc3dpcGVBcmVhV2lkdGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudFkgPiBzd2lwZUFyZWFXaWR0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIG5hdGl2ZUV2ZW50LmRlZmF1bHRNdWlQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIGNsYWltZWRTd2lwZUluc3RhbmNlID0gbnVsbDtcbiAgICBzd2lwZUluc3RhbmNlLmN1cnJlbnQuc3RhcnRYID0gY3VycmVudFg7XG4gICAgc3dpcGVJbnN0YW5jZS5jdXJyZW50LnN0YXJ0WSA9IGN1cnJlbnRZO1xuICAgIHN0YXJ0TWF5YmVTd2lwaW5nKCk7XG4gIH0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh2YXJpYW50ID09PSAndGVtcG9yYXJ5Jykge1xuICAgICAgY29uc3QgZG9jID0gKDAsIF9vd25lckRvY3VtZW50LmRlZmF1bHQpKHBhcGVyUmVmLmN1cnJlbnQpO1xuICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBoYW5kbGVCb2R5VG91Y2hTdGFydCk7XG4gICAgICAvLyBBIGJsb2NraW5nIGxpc3RlbmVyIHByZXZlbnRzIEZpcmVmb3gncyBuYXZiYXIgdG8gYXV0by1oaWRlIG9uIHNjcm9sbC5cbiAgICAgIC8vIEl0IG9ubHkgbmVlZHMgdG8gcHJldmVudCBzY3JvbGxpbmcgb24gdGhlIGRyYXdlcidzIGNvbnRlbnQgd2hlbiBvcGVuLlxuICAgICAgLy8gV2hlbiBjbG9zZWQsIHRoZSBvdmVybGF5IHByZXZlbnRzIHNjcm9sbGluZy5cbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBoYW5kbGVCb2R5VG91Y2hNb3ZlLCB7XG4gICAgICAgIHBhc3NpdmU6ICFvcGVuXG4gICAgICB9KTtcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGhhbmRsZUJvZHlUb3VjaEVuZCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGhhbmRsZUJvZHlUb3VjaFN0YXJ0KTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGhhbmRsZUJvZHlUb3VjaE1vdmUsIHtcbiAgICAgICAgICBwYXNzaXZlOiAhb3BlblxuICAgICAgICB9KTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaGFuZGxlQm9keVRvdWNoRW5kKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sIFt2YXJpYW50LCBvcGVuLCBoYW5kbGVCb2R5VG91Y2hTdGFydCwgaGFuZGxlQm9keVRvdWNoTW92ZSwgaGFuZGxlQm9keVRvdWNoRW5kXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiAoKSA9PiB7XG4gICAgLy8gV2UgbmVlZCB0byByZWxlYXNlIHRoZSBsb2NrLlxuICAgIGlmIChjbGFpbWVkU3dpcGVJbnN0YW5jZSA9PT0gc3dpcGVJbnN0YW5jZS5jdXJyZW50KSB7XG4gICAgICBjbGFpbWVkU3dpcGVJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICB9LCBbXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBzZXRNYXliZVN3aXBpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW29wZW5dKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi8oMCwgX2pzeFJ1bnRpbWUuanN4cykoUmVhY3QuRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogWy8qI19fUFVSRV9fKi8oMCwgX2pzeFJ1bnRpbWUuanN4KShfRHJhd2VyLmRlZmF1bHQsICgwLCBfZXh0ZW5kczIuZGVmYXVsdCkoe1xuICAgICAgb3BlbjogdmFyaWFudCA9PT0gJ3RlbXBvcmFyeScgJiYgbWF5YmVTd2lwaW5nID8gdHJ1ZSA6IG9wZW4sXG4gICAgICB2YXJpYW50OiB2YXJpYW50LFxuICAgICAgTW9kYWxQcm9wczogKDAsIF9leHRlbmRzMi5kZWZhdWx0KSh7XG4gICAgICAgIEJhY2tkcm9wUHJvcHM6ICgwLCBfZXh0ZW5kczIuZGVmYXVsdCkoe30sIEJhY2tkcm9wUHJvcHMsIHtcbiAgICAgICAgICByZWY6IGJhY2tkcm9wUmVmXG4gICAgICAgIH0pXG4gICAgICB9LCB2YXJpYW50ID09PSAndGVtcG9yYXJ5JyAmJiB7XG4gICAgICAgIGtlZXBNb3VudGVkOiB0cnVlXG4gICAgICB9LCBNb2RhbFByb3BzUHJvcCksXG4gICAgICBoaWRlQmFja2Ryb3A6IGhpZGVCYWNrZHJvcCxcbiAgICAgIFBhcGVyUHJvcHM6ICgwLCBfZXh0ZW5kczIuZGVmYXVsdCkoe30sIFBhcGVyUHJvcHMsIHtcbiAgICAgICAgc3R5bGU6ICgwLCBfZXh0ZW5kczIuZGVmYXVsdCkoe1xuICAgICAgICAgIHBvaW50ZXJFdmVudHM6IHZhcmlhbnQgPT09ICd0ZW1wb3JhcnknICYmICFvcGVuICYmICFhbGxvd1N3aXBlSW5DaGlsZHJlbiA/ICdub25lJyA6ICcnXG4gICAgICAgIH0sIFBhcGVyUHJvcHMuc3R5bGUpLFxuICAgICAgICByZWY6IGhhbmRsZVJlZlxuICAgICAgfSksXG4gICAgICBhbmNob3I6IGFuY2hvcixcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogY2FsY3VsYXRlZER1cmF0aW9uUmVmLmN1cnJlbnQgfHwgdHJhbnNpdGlvbkR1cmF0aW9uLFxuICAgICAgb25DbG9zZTogb25DbG9zZSxcbiAgICAgIHJlZjogcmVmXG4gICAgfSwgb3RoZXIpKSwgIWRpc2FibGVTd2lwZVRvT3BlbiAmJiB2YXJpYW50ID09PSAndGVtcG9yYXJ5JyAmJiAvKiNfX1BVUkVfXyovKDAsIF9qc3hSdW50aW1lLmpzeCkoX2Jhc2UuTm9Tc3IsIHtcbiAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovKDAsIF9qc3hSdW50aW1lLmpzeCkoX1N3aXBlQXJlYS5kZWZhdWx0LCAoMCwgX2V4dGVuZHMyLmRlZmF1bHQpKHtcbiAgICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICAgIHJlZjogc3dpcGVBcmVhUmVmLFxuICAgICAgICB3aWR0aDogc3dpcGVBcmVhV2lkdGhcbiAgICAgIH0sIFN3aXBlQXJlYVByb3BzKSlcbiAgICB9KV1cbiAgfSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFN3aXBlYWJsZURyYXdlci5wcm9wVHlwZXMgLyogcmVtb3ZlLXByb3B0eXBlcyAqLyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHN3aXBlIGV2ZW50IHdpbGwgb3BlbiB0aGUgZHJhd2VyIGV2ZW4gaWYgdGhlIHVzZXIgYmVnaW5zIHRoZSBzd2lwZSBvbiBvbmUgb2YgdGhlIGRyYXdlcidzIGNoaWxkcmVuLlxuICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgaW4gc2NlbmFyaW9zIHdoZXJlIHRoZSBkcmF3ZXIgaXMgcGFydGlhbGx5IHZpc2libGUuXG4gICAqIFlvdSBjYW4gY3VzdG9taXplIGl0IGZ1cnRoZXIgd2l0aCBhIGNhbGxiYWNrIHRoYXQgZGV0ZXJtaW5lcyB3aGljaCBjaGlsZHJlbiB0aGUgdXNlciBjYW4gZHJhZyBvdmVyIHRvIG9wZW4gdGhlIGRyYXdlclxuICAgKiAoZm9yIGV4YW1wbGUsIHRvIGlnbm9yZSBvdGhlciBlbGVtZW50cyB0aGF0IGhhbmRsZSB0b3VjaCBtb3ZlIGV2ZW50cywgbGlrZSBzbGlkZXJzKS5cbiAgICpcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBldmVudCBUaGUgJ3RvdWNoc3RhcnQnIGV2ZW50XG4gICAqIEBwYXJhbSB7SFRNTERpdkVsZW1lbnR9IHN3aXBlQXJlYSBUaGUgc3dpcGUgYXJlYSBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTERpdkVsZW1lbnR9IHBhcGVyIFRoZSBkcmF3ZXIncyBwYXBlciBlbGVtZW50XG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBhbGxvd1N3aXBlSW5DaGlsZHJlbjogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsIF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jXSksXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBhbmNob3I6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCddKSxcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IG9mIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogX3Byb3BUeXBlcy5kZWZhdWx0Lm5vZGUsXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoZSBiYWNrZHJvcCB0cmFuc2l0aW9uLlxuICAgKiBUaGlzIGNhbiBpbXByb3ZlIHRoZSBGUFMgb24gbG93LWVuZCBkZXZpY2VzLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZUJhY2tkcm9wVHJhbnNpdGlvbjogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRvdWNoaW5nIHRoZSBzY3JlZW4gbmVhciB0aGUgZWRnZSBvZiB0aGUgZHJhd2VyIHdpbGwgbm90IHNsaWRlIGluIHRoZSBkcmF3ZXIgYSBiaXRcbiAgICogdG8gcHJvbW90ZSBhY2NpZGVudGFsIGRpc2NvdmVyeSBvZiB0aGUgc3dpcGUgZ2VzdHVyZS5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRpc2FibGVEaXNjb3Zlcnk6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvKipcbiAgICogSWYgYHRydWVgLCBzd2lwZSB0byBvcGVuIGlzIGRpc2FibGVkLiBUaGlzIGlzIHVzZWZ1bCBpbiBicm93c2VycyB3aGVyZSBzd2lwaW5nIHRyaWdnZXJzXG4gICAqIG5hdmlnYXRpb24gYWN0aW9ucy4gU3dpcGUgdG8gb3BlbiBpcyBkaXNhYmxlZCBvbiBpT1MgYnJvd3NlcnMgYnkgZGVmYXVsdC5cbiAgICogQGRlZmF1bHQgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICovXG4gIGRpc2FibGVTd2lwZVRvT3BlbjogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBoaWRlQmFja2Ryb3A6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvKipcbiAgICogQWZmZWN0cyBob3cgZmFyIHRoZSBkcmF3ZXIgbXVzdCBiZSBvcGVuZWQvY2xvc2VkIHRvIGNoYW5nZSBpdHMgc3RhdGUuXG4gICAqIFNwZWNpZmllZCBhcyBwZXJjZW50ICgwLTEpIG9mIHRoZSB3aWR0aCBvZiB0aGUgZHJhd2VyXG4gICAqIEBkZWZhdWx0IDAuNTJcbiAgICovXG4gIGh5c3RlcmVzaXM6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gIC8qKlxuICAgKiBEZWZpbmVzLCBmcm9tIHdoaWNoIChhdmVyYWdlKSB2ZWxvY2l0eSBvbiwgdGhlIHN3aXBlIGlzXG4gICAqIGRlZmluZWQgYXMgY29tcGxldGUgYWx0aG91Z2ggaHlzdGVyZXNpcyBpc24ndCByZWFjaGVkLlxuICAgKiBHb29kIHRocmVzaG9sZCBpcyBiZXR3ZWVuIDI1MCAtIDEwMDAgcHgvc1xuICAgKiBAZGVmYXVsdCA0NTBcbiAgICovXG4gIG1pbkZsaW5nVmVsb2NpdHk6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBNb2RhbFByb3BzOiBfcHJvcFR5cGVzLmRlZmF1bHQgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqLy5zaGFwZSh7XG4gICAgQmFja2Ryb3BQcm9wczogX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICAgIGNvbXBvbmVudDogX3V0aWxzLmVsZW1lbnRUeXBlQWNjZXB0aW5nUmVmXG4gICAgfSlcbiAgfSksXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIHRoZSBjb21wb25lbnQgcmVxdWVzdHMgdG8gYmUgY2xvc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBvZiB0aGUgY2FsbGJhY2suXG4gICAqL1xuICBvbkNsb3NlOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYy5pc1JlcXVpcmVkLFxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hlbiB0aGUgY29tcG9uZW50IHJlcXVlc3RzIHRvIGJlIG9wZW5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLlxuICAgKi9cbiAgb25PcGVuOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYy5pc1JlcXVpcmVkLFxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgY29tcG9uZW50IGlzIHNob3duLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgb3BlbjogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wuaXNSZXF1aXJlZCxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIFBhcGVyUHJvcHM6IF9wcm9wVHlwZXMuZGVmYXVsdCAvKiBAdHlwZXNjcmlwdC10by1wcm9wdHlwZXMtaWdub3JlICovLnNoYXBlKHtcbiAgICBjb21wb25lbnQ6IF91dGlscy5lbGVtZW50VHlwZUFjY2VwdGluZ1JlZixcbiAgICBzdHlsZTogX3Byb3BUeXBlcy5kZWZhdWx0Lm9iamVjdFxuICB9KSxcbiAgLyoqXG4gICAqIFRoZSBlbGVtZW50IGlzIHVzZWQgdG8gaW50ZXJjZXB0IHRoZSB0b3VjaCBldmVudHMgb24gdGhlIGVkZ2UuXG4gICAqL1xuICBTd2lwZUFyZWFQcm9wczogX3Byb3BUeXBlcy5kZWZhdWx0Lm9iamVjdCxcbiAgLyoqXG4gICAqIFRoZSB3aWR0aCBvZiB0aGUgbGVmdCBtb3N0IChvciByaWdodCBtb3N0KSBhcmVhIGluIGBweGAgdGhhdFxuICAgKiB0aGUgZHJhd2VyIGNhbiBiZSBzd2lwZWQgb3BlbiBmcm9tLlxuICAgKiBAZGVmYXVsdCAyMFxuICAgKi9cbiAgc3dpcGVBcmVhV2lkdGg6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gIC8qKlxuICAgKiBUaGUgZHVyYXRpb24gZm9yIHRoZSB0cmFuc2l0aW9uLCBpbiBtaWxsaXNlY29uZHMuXG4gICAqIFlvdSBtYXkgc3BlY2lmeSBhIHNpbmdsZSB0aW1lb3V0IGZvciBhbGwgdHJhbnNpdGlvbnMsIG9yIGluZGl2aWR1YWxseSB3aXRoIGFuIG9iamVjdC5cbiAgICogQGRlZmF1bHQge1xuICAgKiAgIGVudGVyOiB0aGVtZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5lbnRlcmluZ1NjcmVlbixcbiAgICogICBleGl0OiB0aGVtZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5sZWF2aW5nU2NyZWVuLFxuICAgKiB9XG4gICAqL1xuICB0cmFuc2l0aW9uRHVyYXRpb246IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsIF9wcm9wVHlwZXMuZGVmYXVsdC5zaGFwZSh7XG4gICAgYXBwZWFyOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIGVudGVyOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIGV4aXQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXJcbiAgfSldKSxcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHZhcmlhbnQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbJ3Blcm1hbmVudCcsICdwZXJzaXN0ZW50JywgJ3RlbXBvcmFyeSddKVxufSA6IHZvaWQgMDtcbnZhciBfZGVmYXVsdCA9IFN3aXBlYWJsZURyYXdlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTtBQUNaLFlBQVk7O0FBRVosSUFBSUEsc0JBQXNCLEdBQUdDLE9BQU8sQ0FBQyw4Q0FBOEMsQ0FBQztBQUNwRkMsTUFBTSxDQUFDQyxjQUFjLENBQUNDLE9BQU8sRUFBRSxZQUFZLEVBQUU7RUFDM0NDLEtBQUssRUFBRTtBQUNULENBQUMsQ0FBQztBQUNGRCxPQUFPLENBQUNFLE9BQU8sR0FBRyxLQUFLLENBQUM7QUFDeEJGLE9BQU8sQ0FBQ0csS0FBSyxHQUFHQSxLQUFLO0FBQ3JCLElBQUlDLFNBQVMsR0FBR1Isc0JBQXNCLENBQUNDLE9BQU8sQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO0FBQ2pGLElBQUlRLDhCQUE4QixHQUFHVCxzQkFBc0IsQ0FBQ0MsT0FBTyxDQUFDLHFEQUFxRCxDQUFDLENBQUM7QUFDM0gsSUFBSVMsS0FBSyxHQUFHQyx1QkFBdUIsQ0FBQ1YsT0FBTyxDQUFDLE9B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