b7481e4cc1bbd62ba198e5919c185e20
/**
 * @popperjs/core v2.11.8 - MIT License
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window,
    visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}
function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement(element) ? element.ownerDocument :
  // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}
function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle(element),
    overflow = _getComputedStyle.overflow,
    overflowX = _getComputedStyle.overflowX,
    overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.

function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' ||
    // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}
function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot ||
    // step into the shadow DOM of the parent of a slotted node
    element.parentNode || (
    // DOM Element detected
    isShadowRoot(element) ? element.host : null) ||
    // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback
  );
}

function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList :
  // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}
function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) ||
  // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === 'fixed') {
    return null;
  }
  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block

function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = getComputedStyle(element);
    if (elementCss.position === 'fixed') {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.

function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
    return window;
  }
  return offsetParent || getContainingBlock(element) || window;
}
var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX(element),
    y: y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      } // $FlowFixMe[prop-missing]: need a better way to handle this...

      next = next.parentNode || next.host;
    } while (next);
  } // Give up, the result is false

  return false;
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`

function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414

  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents

function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function getBasePlacement(placement) {
  return placement.split('-')[0];
}
function getVariation(placement) {
  return placement.split('-')[1];
}
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}
function computeOffsets(_ref) {
  var reference = _ref.reference,
    element = _ref.element,
    placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options,
    _options$placement = _options.placement,
    placement = _options$placement === void 0 ? state.placement : _options$placement,
    _options$strategy = _options.strategy,
    strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
    _options$boundary = _options.boundary,
    boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
    _options$rootBoundary = _options.rootBoundary,
    rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
    _options$elementConte = _options.elementContext,
    elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
    _options$altBoundary = _options.altBoundary,
    altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
    _options$padding = _options.padding,
    padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }
  return overflowOffsets;
}
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions,
    _generatorOptions$def = _generatorOptions.defaultModifiers,
    defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
    _generatorOptions$def2 = _generatorOptions.defaultOptions,
    defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements,
          reference = _state$elements.reference,
          popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          return;
        } // Store the reference and popper rects to be read by modifiers

        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index],
            fn = _state$orderedModifie.fn,
            _state$orderedModifie2 = _state$orderedModifie.options,
            _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
            name = _state$orderedModifie.name;
          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference, popper)) {
      return instance;
    }
    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref) {
        var name = _ref.name,
          _ref$options = _ref.options,
          options = _ref$options === void 0 ? {} : _ref$options,
          effect = _ref.effect;
        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });
          var noopFn = function noopFn() {};
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var passive = {
  passive: true
};
function effect$2(_ref) {
  var state = _ref.state,
    instance = _ref.instance,
    options = _ref.options;
  var _options$scroll = options.scroll,
    scroll = _options$scroll === void 0 ? true : _options$scroll,
    _options$resize = options.resize,
    resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }
  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }
  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }
    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules

var eventListeners = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect$2,
  data: {}
};
function popperOffsets(_ref) {
  var state = _ref.state,
    name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules

var popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};
var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x,
    y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper = _ref2.popper,
    popperRect = _ref2.popperRect,
    placement = _ref2.placement,
    variation = _ref2.variation,
    offsets = _ref2.offsets,
    position = _ref2.position,
    gpuAcceleration = _ref2.gpuAcceleration,
    adaptive = _ref2.adaptive,
    roundOffsets = _ref2.roundOffsets,
    isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
    x = _offsets$x === void 0 ? 0 : _offsets$x,
    _offsets$y = offsets.y,
    y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';
    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);
      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it

    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height :
      // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width :
      // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }, getWindow(popper)) : {
    x: x,
    y: y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state,
    options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
    gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
    _options$adaptive = options.adaptive,
    adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
    _options$roundOffsets = options.roundOffsets,
    roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules

var computeStyles$1 = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]

    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];
      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}
function effect$1(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules

var applyStyles$1 = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect$1,
  requires: ['computeStyles']
};
function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
      placement: placement
    })) : offset,
    skidding = _ref[0],
    distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state,
    options = _ref2.options,
    name = _ref2.name;
  var _options$offset = options.offset,
    offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
    x = _data$state$placement.x,
    y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules

var offset$1 = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};
var hash$1 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options,
    placement = _options.placement,
    boundary = _options.boundary,
    rootBoundary = _options.rootBoundary,
    padding = _options.padding,
    flipVariations = _options.flipVariations,
    _options$allowedAutoP = _options.allowedAutoPlacements,
    allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...

  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state,
    options = _ref.options,
    name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis,
    checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
    _options$altAxis = options.altAxis,
    checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
    specifiedFallbackPlacements = options.fallbackPlacements,
    padding = options.padding,
    boundary = options.boundary,
    rootBoundary = options.rootBoundary,
    altBoundary = options.altBoundary,
    _options$flipVariatio = options.flipVariations,
    flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
    allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];
  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    // `2` may be desired in some cases – research later
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);
        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules

var flip$1 = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};
function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}
function preventOverflow(_ref) {
  var state = _ref.state,
    options = _ref.options,
    name = _ref.name;
  var _options$mainAxis = options.mainAxis,
    checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
    _options$altAxis = options.altAxis,
    checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
    boundary = options.boundary,
    rootBoundary = options.rootBoundary,
    altBoundary = options.altBoundary,
    padding = options.padding,
    _options$tether = options.tether,
    tether = _options$tether === void 0 ? true : _options$tether,
    _options$tetherOffset = options.tetherOffset,
    tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === 'y' ? top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min$1 = offset + overflow[mainSide];
    var max$1 = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === 'x' ? top : left;
    var _altSide = mainAxis === 'x' ? bottom : right;
    var _offset = popperOffsets[altAxis];
    var _len = altAxis === 'y' ? 'height' : 'width';
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules

var preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};
var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state,
    name = _ref.name,
    options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';
  if (!arrowElement || !popperOffsets) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}
function effect(_ref2) {
  var state = _ref2.state,
    options = _ref2.options;
  var _options$element = options.element,
    arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;
  if (arrowElement == null) {
    return;
  } // CSS selector

  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules

var arrow$1 = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state,
    name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules

var hide$1 = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};
var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
var createPopper$1 = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers$1
}); // eslint-disable-next-line import/no-unused-modules

var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

exports.applyStyles = applyStyles$1;
exports.arrow = arrow$1;
exports.computeStyles = computeStyles$1;
exports.createPopper = createPopper;
exports.createPopperLite = createPopper$1;
exports.defaultModifiers = defaultModifiers;
exports.detectOverflow = detectOverflow;
exports.eventListeners = eventListeners;
exports.flip = flip$1;
exports.hide = hide$1;
exports.offset = offset$1;
exports.popperGenerator = popperGenerator;
exports.popperOffsets = popperOffsets$1;
exports.preventOverflow = preventOverflow$1;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJnZXRXaW5kb3ciLCJub2RlIiwid2luZG93IiwidG9TdHJpbmciLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJpc0VsZW1lbnQiLCJPd25FbGVtZW50IiwiRWxlbWVudCIsImlzSFRNTEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzU2hhZG93Um9vdCIsIlNoYWRvd1Jvb3QiLCJtYXgiLCJNYXRoIiwibWluIiwicm91bmQiLCJnZXRVQVN0cmluZyIsInVhRGF0YSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudERhdGEiLCJicmFuZHMiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJpdGVtIiwiYnJhbmQiLCJ2ZXJzaW9uIiwiam9pbiIsInVzZXJBZ2VudCIsImlzTGF5b3V0Vmlld3BvcnQiLCJ0ZXN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZWxlbWVudCIsImluY2x1ZGVTY2FsZSIsImlzRml4ZWRTdHJhdGVneSIsImNsaWVudFJlY3QiLCJzY2FsZVgiLCJzY2FsZVkiLCJvZmZzZXRXaWR0aCIsIndpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiaGVpZ2h0IiwiX3JlZiIsInZpc3VhbFZpZXdwb3J0IiwiYWRkVmlzdWFsT2Zmc2V0cyIsIngiLCJsZWZ0Iiwib2Zmc2V0TGVmdCIsInkiLCJ0b3AiLCJvZmZzZXRUb3AiLCJyaWdodCIsImJvdHRvbSIsImdldFdpbmRvd1Njcm9sbCIsIndpbiIsInNjcm9sbExlZnQiLCJwYWdlWE9mZnNldCIsInNjcm9sbFRvcCIsInBhZ2VZT2Zmc2V0IiwiZ2V0SFRNTEVsZW1lbnRTY3JvbGwiLCJnZXROb2RlU2Nyb2xsIiwiZ2V0Tm9kZU5hbWUiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRXaW5kb3dTY3JvbGxCYXJYIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImlzU2Nyb2xsUGFyZW50IiwiX2dldENvbXB1dGVkU3R5bGUiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImlzRWxlbWVudFNjYWxlZCIsInJlY3QiLCJnZXRDb21wb3NpdGVSZWN0IiwiZWxlbWVudE9yVmlydHVhbEVsZW1lbnQiLCJvZmZzZXRQYXJlbnQiLCJpc0ZpeGVkIiwiaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQiLCJvZmZzZXRQYXJlbnRJc1NjYWxlZCIsInNjcm9sbCIsIm9mZnNldHMiLCJjbGllbnRMZWZ0IiwiY2xpZW50VG9wIiwiZ2V0TGF5b3V0UmVjdCIsImFicyIsImdldFBhcmVudE5vZGUiLCJhc3NpZ25lZFNsb3QiLCJwYXJlbnROb2RlIiwiaG9zdCIsImdldFNjcm9sbFBhcmVudCIsImluZGV4T2YiLCJib2R5IiwibGlzdFNjcm9sbFBhcmVudHMiLCJsaXN0IiwiX2VsZW1lbnQkb3duZXJEb2N1bWVuIiwic2Nyb2xsUGFyZW50IiwiaXNCb2R5IiwidGFyZ2V0IiwiY29uY2F0IiwidXBkYXRlZExpc3QiLCJpc1RhYmxlRWxlbWVudCIsImdldFRydWVPZmZzZXRQYXJlbnQiLCJwb3NpdGlvbiIsImdldENvbnRhaW5pbmdCbG9jayIsImlzRmlyZWZveCIsImlzSUUiLCJlbGVtZW50Q3NzIiwiY3VycmVudE5vZGUiLCJjc3MiLCJ0cmFuc2Zvcm0iLCJwZXJzcGVjdGl2ZSIsImNvbnRhaW4iLCJ3aWxsQ2hhbmdlIiwiZmlsdGVyIiwiZ2V0T2Zmc2V0UGFyZW50IiwiYXV0byIsImJhc2VQbGFjZW1lbnRzIiwic3RhcnQiLCJlbmQiLCJjbGlwcGluZ1BhcmVudHMiLCJ2aWV3cG9ydCIsInBvcHBlciIsInJlZmVyZW5jZSIsInZhcmlhdGlvblBsYWNlbWVudHMiLCJyZWR1Y2UiLCJhY2MiLCJwbGFjZW1lbnQiLCJwbGFjZW1lbnRzIiwiYmVmb3JlUmVhZCIsInJlYWQiLCJhZnRlclJlYWQiLCJiZWZvcmVNYWluIiwibWFpbiIsImFmdGVyTWFpbiIsImJlZm9yZVdyaXRlIiwid3JpdGUiLCJhZnRlcldyaXRlIiwibW9kaWZpZXJQaGFzZXMiLCJvcmRlciIsIm1vZGlmaWVycyIsIk1hcCIsInZpc2l0ZWQiLCJTZXQiLCJyZXN1bHQiLCJmb3JFYWNoIiwibW9kaWZpZXIiLCJzZXQiLCJuYW1lIiwic29ydCIsImFkZCIsInJlcXVpcmVzIiwicmVxdWlyZXNJZkV4aXN0cyIsImRlcCIsImhhcyIsImRlcE1vZGlmaWVyIiwiZ2V0IiwicHVzaCIsIm9yZGVyTW9kaWZpZXJzIiwib3JkZXJlZE1vZGlmaWVycyIsInBoYXNlIiwiZGVib3VuY2UiLCJmbiIsInBlbmRpbmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJ1bmRlZmluZWQiLCJtZXJnZUJ5TmFtZSIsIm1lcmdlZCIsImN1cnJlbnQiLCJleGlzdGluZyIsIk9iamVjdCIsImFzc2lnbiIsIm9wdGlvbnMiLCJkYXRhIiwia2V5cyIsImtleSIsImdldFZpZXdwb3J0UmVjdCIsInN0cmF0ZWd5IiwiaHRtbCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwibGF5b3V0Vmlld3BvcnQiLCJnZXREb2N1bWVudFJlY3QiLCJ3aW5TY3JvbGwiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsImRpcmVjdGlvbiIsImNvbnRhaW5zIiwicGFyZW50IiwiY2hpbGQiLCJyb290Tm9kZSIsImdldFJvb3ROb2RlIiwibmV4dCIsImlzU2FtZU5vZGUiLCJyZWN0VG9DbGllbnRSZWN0IiwiZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QiLCJnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZSIsImNsaXBwaW5nUGFyZW50IiwiZ2V0Q2xpcHBpbmdQYXJlbnRzIiwiY2FuRXNjYXBlQ2xpcHBpbmciLCJjbGlwcGVyRWxlbWVudCIsImdldENsaXBwaW5nUmVjdCIsImJvdW5kYXJ5Iiwicm9vdEJvdW5kYXJ5IiwibWFpbkNsaXBwaW5nUGFyZW50cyIsImZpcnN0Q2xpcHBpbmdQYXJlbnQiLCJjbGlwcGluZ1JlY3QiLCJhY2NSZWN0IiwiZ2V0QmFzZVBsYWNlbWVudCIsInNwbGl0IiwiZ2V0VmFyaWF0aW9uIiwiZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IiwiY29tcHV0ZU9mZnNldHMiLCJiYXNlUGxhY2VtZW50IiwidmFyaWF0aW9uIiwiY29tbW9uWCIsImNvbW1vblkiLCJtYWluQXhpcyIsImxlbiIsImdldEZyZXNoU2lkZU9iamVjdCIsIm1lcmdlUGFkZGluZ09iamVjdCIsInBhZGRpbmdPYmplY3QiLCJleHBhbmRUb0hhc2hNYXAiLCJ2YWx1ZSIsImhhc2hNYXAiLCJkZXRlY3RPdmVyZmxvdyIsInN0YXRlIiwiX29wdGlvbnMiLCJfb3B0aW9ucyRwbGFjZW1lbnQiLCJfb3B0aW9ucyRzdHJhdGVneSIsIl9vcHRpb25zJGJvdW5kYXJ5IiwiX29wdGlvbnMkcm9vdEJvdW5kYXJ5IiwiX29wdGlvbnMkZWxlbWVudENvbnRlIiwiZWxlbWVudENvbnRleHQiLCJfb3B0aW9ucyRhbHRCb3VuZGFyeSIsImFsdEJvdW5kYXJ5IiwiX29wdGlvbnMkcGFkZGluZyIsInBhZGRpbmciLCJhbHRDb250ZXh0IiwicG9wcGVyUmVjdCIsInJlY3RzIiwiZWxlbWVudHMiLCJjbGlwcGluZ0NsaWVudFJlY3QiLCJjb250ZXh0RWxlbWVudCIsInJlZmVyZW5jZUNsaWVudFJlY3QiLCJwb3BwZXJPZmZzZXRzIiwicG9wcGVyQ2xpZW50UmVjdCIsImVsZW1lbnRDbGllbnRSZWN0Iiwib3ZlcmZsb3dPZmZzZXRzIiwib2Zmc2V0RGF0YSIsIm1vZGlmaWVyc0RhdGEiLCJvZmZzZXQiLCJtdWx0aXBseSIsImF4aXMiLCJERUZBVUxUX09QVElPTlMiLCJhcmVWYWxpZEVsZW1lbnRzIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJfa2V5Iiwic29tZSIsInBvcHBlckdlbmVyYXRvciIsImdlbmVyYXRvck9wdGlvbnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZiIsImRlZmF1bHRNb2RpZmllcnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyIiwiZGVmYXVsdE9wdGlvbnMiLCJjcmVhdGVQb3BwZXIiLCJhdHRyaWJ1dGVzIiwic3R5bGVzIiwiZWZmZWN0Q2xlYW51cEZucyIsImlzRGVzdHJveWVkIiwiaW5zdGFuY2UiLCJzZXRPcHRpb25zIiwic2V0T3B0aW9uc0FjdGlvbiIsImNsZWFudXBNb2RpZmllckVmZmVjdHMiLCJzY3JvbGxQYXJlbnRzIiwibSIsImVuYWJsZWQiLCJydW5Nb2RpZmllckVmZmVjdHMiLCJ1cGRhdGUiLCJmb3JjZVVwZGF0ZSIsIl9zdGF0ZSRlbGVtZW50cyIsInJlc2V0IiwiaW5kZXgiLCJfc3RhdGUkb3JkZXJlZE1vZGlmaWUiLCJfc3RhdGUkb3JkZXJlZE1vZGlmaWUyIiwiZGVzdHJveSIsIm9uRmlyc3RVcGRhdGUiLCJfcmVmJG9wdGlvbnMiLCJlZmZlY3QiLCJjbGVhbnVwRm4iLCJub29wRm4iLCJwYXNzaXZlIiwiZWZmZWN0JDIiLCJfb3B0aW9ucyRzY3JvbGwiLCJfb3B0aW9ucyRyZXNpemUiLCJyZXNpemUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2ZW50TGlzdGVuZXJzIiwicG9wcGVyT2Zmc2V0cyQxIiwidW5zZXRTaWRlcyIsInJvdW5kT2Zmc2V0c0J5RFBSIiwiZHByIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIm1hcFRvU3R5bGVzIiwiX3JlZjIiLCJfT2JqZWN0JGFzc2lnbjIiLCJncHVBY2NlbGVyYXRpb24iLCJhZGFwdGl2ZSIsInJvdW5kT2Zmc2V0cyIsIl9vZmZzZXRzJHgiLCJfb2Zmc2V0cyR5IiwiX3JlZjMiLCJoYXNYIiwiaGFzT3duUHJvcGVydHkiLCJoYXNZIiwic2lkZVgiLCJzaWRlWSIsImhlaWdodFByb3AiLCJ3aWR0aFByb3AiLCJvZmZzZXRZIiwib2Zmc2V0WCIsImNvbW1vblN0eWxlcyIsIl9yZWY0IiwiX09iamVjdCRhc3NpZ24iLCJjb21wdXRlU3R5bGVzIiwiX3JlZjUiLCJfb3B0aW9ucyRncHVBY2NlbGVyYXQiLCJfb3B0aW9ucyRhZGFwdGl2ZSIsIl9vcHRpb25zJHJvdW5kT2Zmc2V0cyIsImFycm93IiwiY29tcHV0ZVN0eWxlcyQxIiwiYXBwbHlTdHlsZXMiLCJzdHlsZSIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsImVmZmVjdCQxIiwiaW5pdGlhbFN0eWxlcyIsIm1hcmdpbiIsInN0eWxlUHJvcGVydGllcyIsInByb3BlcnR5IiwiYXR0cmlidXRlIiwiYXBwbHlTdHlsZXMkMSIsImRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZIiwiaW52ZXJ0RGlzdGFuY2UiLCJza2lkZGluZyIsImRpc3RhbmNlIiwiX29wdGlvbnMkb2Zmc2V0IiwiX2RhdGEkc3RhdGUkcGxhY2VtZW50Iiwib2Zmc2V0JDEiLCJoYXNoJDEiLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsInJlcGxhY2UiLCJtYXRjaGVkIiwiaGFzaCIsImdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IiwiY29tcHV0ZUF1dG9QbGFjZW1lbnQiLCJmbGlwVmFyaWF0aW9ucyIsIl9vcHRpb25zJGFsbG93ZWRBdXRvUCIsImFsbG93ZWRBdXRvUGxhY2VtZW50cyIsInBsYWNlbWVudHMkMSIsImFsbG93ZWRQbGFjZW1lbnRzIiwib3ZlcmZsb3dzIiwiYSIsImIiLCJnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyIsIm9wcG9zaXRlUGxhY2VtZW50IiwiZmxpcCIsIl9za2lwIiwiX29wdGlvbnMkbWFpbkF4aXMiLCJjaGVja01haW5BeGlzIiwiX29wdGlvbnMkYWx0QXhpcyIsImFsdEF4aXMiLCJjaGVja0FsdEF4aXMiLCJzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMiLCJmYWxsYmFja1BsYWNlbWVudHMiLCJfb3B0aW9ucyRmbGlwVmFyaWF0aW8iLCJwcmVmZXJyZWRQbGFjZW1lbnQiLCJpc0Jhc2VQbGFjZW1lbnQiLCJyZWZlcmVuY2VSZWN0IiwiY2hlY2tzTWFwIiwibWFrZUZhbGxiYWNrQ2hlY2tzIiwiZmlyc3RGaXR0aW5nUGxhY2VtZW50IiwiaSIsIl9iYXNlUGxhY2VtZW50IiwiaXNTdGFydFZhcmlhdGlvbiIsImlzVmVydGljYWwiLCJtYWluVmFyaWF0aW9uU2lkZSIsImFsdFZhcmlhdGlvblNpZGUiLCJjaGVja3MiLCJldmVyeSIsImNoZWNrIiwibnVtYmVyT2ZDaGVja3MiLCJfbG9vcCIsIl9pIiwiZml0dGluZ1BsYWNlbWVudCIsImZpbmQiLCJzbGljZSIsIl9yZXQiLCJmbGlwJDEiLCJnZXRBbHRBeGlzIiwid2l0aGluIiwibWluJDEiLCJtYXgkMSIsIndpdGhpbk1heENsYW1wIiwidiIsInByZXZlbnRPdmVyZmxvdyIsIl9vcHRpb25zJHRldGhlciIsInRldGhlciIsIl9vcHRpb25zJHRldGhlck9mZnNldCIsInRldGhlck9mZnNldCIsInRldGhlck9mZnNldFZhbHVlIiwibm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlIiwib2Zmc2V0TW9kaWZpZXJTdGF0ZSIsIl9vZmZzZXRNb2RpZmllclN0YXRlJCIsIm1haW5TaWRlIiwiYWx0U2lkZSIsImFkZGl0aXZlIiwibWluTGVuIiwibWF4TGVuIiwiYXJyb3dFbGVtZW50IiwiYXJyb3dSZWN0IiwiYXJyb3dQYWRkaW5nT2JqZWN0IiwiYXJyb3dQYWRkaW5nTWluIiwiYXJyb3dQYWRkaW5nTWF4IiwiYXJyb3dMZW4iLCJtaW5PZmZzZXQiLCJtYXhPZmZzZXQiLCJhcnJvd09mZnNldFBhcmVudCIsImNsaWVudE9mZnNldCIsIm9mZnNldE1vZGlmaWVyVmFsdWUiLCJ0ZXRoZXJNaW4iLCJ0ZXRoZXJNYXgiLCJwcmV2ZW50ZWRPZmZzZXQiLCJfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyIiwiX21haW5TaWRlIiwiX2FsdFNpZGUiLCJfb2Zmc2V0IiwiX21pbiIsIl9tYXgiLCJpc09yaWdpblNpZGUiLCJfb2Zmc2V0TW9kaWZpZXJWYWx1ZSIsIl90ZXRoZXJNaW4iLCJfdGV0aGVyTWF4IiwiX3ByZXZlbnRlZE9mZnNldCIsInByZXZlbnRPdmVyZmxvdyQxIiwidG9QYWRkaW5nT2JqZWN0IiwiX3N0YXRlJG1vZGlmaWVyc0RhdGEkIiwibWluUHJvcCIsIm1heFByb3AiLCJlbmREaWZmIiwic3RhcnREaWZmIiwiY2xpZW50U2l6ZSIsImNlbnRlclRvUmVmZXJlbmNlIiwiY2VudGVyIiwiYXhpc1Byb3AiLCJjZW50ZXJPZmZzZXQiLCJfb3B0aW9ucyRlbGVtZW50IiwicXVlcnlTZWxlY3RvciIsImFycm93JDEiLCJnZXRTaWRlT2Zmc2V0cyIsInByZXZlbnRlZE9mZnNldHMiLCJpc0FueVNpZGVGdWxseUNsaXBwZWQiLCJzaWRlIiwiaGlkZSIsInJlZmVyZW5jZU92ZXJmbG93IiwicG9wcGVyQWx0T3ZlcmZsb3ciLCJyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMiLCJwb3BwZXJFc2NhcGVPZmZzZXRzIiwiaXNSZWZlcmVuY2VIaWRkZW4iLCJoYXNQb3BwZXJFc2NhcGVkIiwiaGlkZSQxIiwiZGVmYXVsdE1vZGlmaWVycyQxIiwiY3JlYXRlUG9wcGVyJDEiXSwic291cmNlcyI6WyIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldFdpbmRvdy5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvaW5zdGFuY2VPZi5qcyIsIi4uLy4uL3NyYy91dGlscy9tYXRoLmpzIiwiLi4vLi4vc3JjL3V0aWxzL3VzZXJBZ2VudC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvaXNMYXlvdXRWaWV3cG9ydC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXROb2RlTmFtZS5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9pc1Njcm9sbFBhcmVudC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0UGFyZW50Tm9kZS5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0U2Nyb2xsUGFyZW50LmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvaXNUYWJsZUVsZW1lbnQuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcyIsIi4uLy4uL3NyYy9lbnVtcy5qcyIsIi4uLy4uL3NyYy91dGlscy9vcmRlck1vZGlmaWVycy5qcyIsIi4uLy4uL3NyYy91dGlscy9kZWJvdW5jZS5qcyIsIi4uLy4uL3NyYy91dGlscy9tZXJnZUJ5TmFtZS5qcyIsIi4uLy4uL3NyYy9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzIiwiLi4vLi4vc3JjL2RvbS11dGlscy9nZXREb2N1bWVudFJlY3QuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2NvbnRhaW5zLmpzIiwiLi4vLi4vc3JjL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanMiLCIuLi8uLi9zcmMvZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdC5qcyIsIi4uLy4uL3NyYy91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzIiwiLi4vLi4vc3JjL3V0aWxzL2dldFZhcmlhdGlvbi5qcyIsIi4uLy4uL3NyYy91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanMiLCIuLi8uLi9zcmMvdXRpbHMvY29tcHV0ZU9mZnNldHMuanMiLCIuLi8uLi9zcmMvdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzIiwiLi4vLi4vc3JjL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcyIsIi4uLy4uL3NyYy91dGlscy9leHBhbmRUb0hhc2hNYXAuanMiLCIuLi8uLi9zcmMvdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanMiLCIuLi8uLi9zcmMvY3JlYXRlUG9wcGVyLmpzIiwiLi4vLi4vc3JjL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qcyIsIi4uLy4uL3NyYy9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcyIsIi4uLy4uL3NyYy9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qcyIsIi4uLy4uL3NyYy9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanMiLCIuLi8uLi9zcmMvbW9kaWZpZXJzL29mZnNldC5qcyIsIi4uLy4uL3NyYy91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qcyIsIi4uLy4uL3NyYy91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qcyIsIi4uLy4uL3NyYy91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qcyIsIi4uLy4uL3NyYy9tb2RpZmllcnMvZmxpcC5qcyIsIi4uLy4uL3NyYy91dGlscy9nZXRBbHRBeGlzLmpzIiwiLi4vLi4vc3JjL3V0aWxzL3dpdGhpbi5qcyIsIi4uLy4uL3NyYy9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzIiwiLi4vLi4vc3JjL21vZGlmaWVycy9hcnJvdy5qcyIsIi4uLy4uL3NyYy9tb2RpZmllcnMvaGlkZS5qcyIsIi4uLy4uL3NyYy9wb3BwZXItbGl0ZS5qcyIsIi4uLy4uL3NyYy9wb3BwZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgV2luZG93IH0gZnJvbSAnLi4vdHlwZXMnO1xuZGVjbGFyZSBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZTogTm9kZSB8IFdpbmRvdyk6IFdpbmRvdztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIGNvbnN0IG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSAnLi9nZXRXaW5kb3cnO1xuXG5kZWNsYXJlIGZ1bmN0aW9uIGlzRWxlbWVudChub2RlOiBtaXhlZCk6IGJvb2xlYW4gJWNoZWNrcyhub2RlIGluc3RhbmNlb2ZcbiAgRWxlbWVudCk7XG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICBjb25zdCBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuZGVjbGFyZSBmdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGU6IG1peGVkKTogYm9vbGVhbiAlY2hlY2tzKG5vZGUgaW5zdGFuY2VvZlxuICBIVE1MRWxlbWVudCk7XG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGUpIHtcbiAgY29uc3QgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuZGVjbGFyZSBmdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZTogbWl4ZWQpOiBib29sZWFuICVjaGVja3Mobm9kZSBpbnN0YW5jZW9mXG4gIFNoYWRvd1Jvb3QpO1xuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cblxuZXhwb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfTtcbiIsIi8vIEBmbG93XG5leHBvcnQgY29uc3QgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgY29uc3QgbWluID0gTWF0aC5taW47XG5leHBvcnQgY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kO1xuIiwiLy8gQGZsb3dcbnR5cGUgTmF2aWdhdG9yID0gTmF2aWdhdG9yICYgeyB1c2VyQWdlbnREYXRhPzogTmF2aWdhdG9yVUFEYXRhIH07XG5cbmludGVyZmFjZSBOYXZpZ2F0b3JVQURhdGEge1xuICBicmFuZHM6IEFycmF5PHsgYnJhbmQ6IHN0cmluZywgdmVyc2lvbjogc3RyaW5nIH0+O1xuICBtb2JpbGU6IGJvb2xlYW47XG4gIHBsYXRmb3JtOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFVBU3RyaW5nKCk6IHN0cmluZyB7XG4gIGNvbnN0IHVhRGF0YSA9IChuYXZpZ2F0b3I6IE5hdmlnYXRvcikudXNlckFnZW50RGF0YTtcblxuICBpZiAodWFEYXRhPy5icmFuZHMgJiYgQXJyYXkuaXNBcnJheSh1YURhdGEuYnJhbmRzKSkge1xuICAgIHJldHVybiB1YURhdGEuYnJhbmRzXG4gICAgICAubWFwKChpdGVtKSA9PiBgJHtpdGVtLmJyYW5kfS8ke2l0ZW0udmVyc2lvbn1gKVxuICAgICAgLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRVQVN0cmluZyBmcm9tICcuLi91dGlscy91c2VyQWdlbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0xheW91dFZpZXdwb3J0KCkge1xuICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBDbGllbnRSZWN0T2JqZWN0LCBWaXJ0dWFsRWxlbWVudCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9IGZyb20gJy4vaW5zdGFuY2VPZic7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gJy4uL3V0aWxzL21hdGgnO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tICcuL2dldFdpbmRvdyc7XG5pbXBvcnQgaXNMYXlvdXRWaWV3cG9ydCBmcm9tICcuL2lzTGF5b3V0Vmlld3BvcnQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoXG4gIGVsZW1lbnQ6IEVsZW1lbnQgfCBWaXJ0dWFsRWxlbWVudCxcbiAgaW5jbHVkZVNjYWxlOiBib29sZWFuID0gZmFsc2UsXG4gIGlzRml4ZWRTdHJhdGVneTogYm9vbGVhbiA9IGZhbHNlXG4pOiBDbGllbnRSZWN0T2JqZWN0IHtcbiAgY29uc3QgY2xpZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGxldCBzY2FsZVggPSAxO1xuICBsZXQgc2NhbGVZID0gMTtcblxuICBpZiAoaW5jbHVkZVNjYWxlICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICBzY2FsZVggPVxuICAgICAgKGVsZW1lbnQ6IEhUTUxFbGVtZW50KS5vZmZzZXRXaWR0aCA+IDBcbiAgICAgICAgPyByb3VuZChjbGllbnRSZWN0LndpZHRoKSAvIChlbGVtZW50OiBIVE1MRWxlbWVudCkub2Zmc2V0V2lkdGggfHwgMVxuICAgICAgICA6IDE7XG4gICAgc2NhbGVZID1cbiAgICAgIChlbGVtZW50OiBIVE1MRWxlbWVudCkub2Zmc2V0SGVpZ2h0ID4gMFxuICAgICAgICA/IHJvdW5kKGNsaWVudFJlY3QuaGVpZ2h0KSAvIChlbGVtZW50OiBIVE1MRWxlbWVudCkub2Zmc2V0SGVpZ2h0IHx8IDFcbiAgICAgICAgOiAxO1xuICB9XG5cbiAgY29uc3QgeyB2aXN1YWxWaWV3cG9ydCB9ID0gaXNFbGVtZW50KGVsZW1lbnQpID8gZ2V0V2luZG93KGVsZW1lbnQpIDogd2luZG93O1xuICBjb25zdCBhZGRWaXN1YWxPZmZzZXRzID0gIWlzTGF5b3V0Vmlld3BvcnQoKSAmJiBpc0ZpeGVkU3RyYXRlZ3k7XG5cbiAgY29uc3QgeCA9XG4gICAgKGNsaWVudFJlY3QubGVmdCArXG4gICAgICAoYWRkVmlzdWFsT2Zmc2V0cyAmJiB2aXN1YWxWaWV3cG9ydCA/IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQgOiAwKSkgL1xuICAgIHNjYWxlWDtcbiAgY29uc3QgeSA9XG4gICAgKGNsaWVudFJlY3QudG9wICtcbiAgICAgIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wIDogMCkpIC9cbiAgICBzY2FsZVk7XG4gIGNvbnN0IHdpZHRoID0gY2xpZW50UmVjdC53aWR0aCAvIHNjYWxlWDtcbiAgY29uc3QgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgdG9wOiB5LFxuICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgYm90dG9tOiB5ICsgaGVpZ2h0LFxuICAgIGxlZnQ6IHgsXG4gICAgeCxcbiAgICB5LFxuICB9O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSAnLi9nZXRXaW5kb3cnO1xuaW1wb3J0IHR5cGUgeyBXaW5kb3cgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbChub2RlOiBOb2RlIHwgV2luZG93KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhub2RlKTtcbiAgY29uc3Qgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgY29uc3Qgc2Nyb2xsVG9wID0gd2luLnBhZ2VZT2Zmc2V0O1xuXG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3AsXG4gIH07XG59XG4iLCIvLyBAZmxvd1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRIVE1MRWxlbWVudFNjcm9sbChlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wLFxuICB9O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSAnLi9nZXRXaW5kb3dTY3JvbGwnO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tICcuL2dldFdpbmRvdyc7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSAnLi9pbnN0YW5jZU9mJztcbmltcG9ydCBnZXRIVE1MRWxlbWVudFNjcm9sbCBmcm9tICcuL2dldEhUTUxFbGVtZW50U2Nyb2xsJztcbmltcG9ydCB0eXBlIHsgV2luZG93IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlU2Nyb2xsKG5vZGU6IE5vZGUgfCBXaW5kb3cpIHtcbiAgaWYgKG5vZGUgPT09IGdldFdpbmRvdyhub2RlKSB8fCAhaXNIVE1MRWxlbWVudChub2RlKSkge1xuICAgIHJldHVybiBnZXRXaW5kb3dTY3JvbGwobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50U2Nyb2xsKG5vZGUpO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBXaW5kb3cgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVOYW1lKGVsZW1lbnQ6ID9Ob2RlIHwgV2luZG93KTogP3N0cmluZyB7XG4gIHJldHVybiBlbGVtZW50ID8gKGVsZW1lbnQubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gJy4vaW5zdGFuY2VPZic7XG5pbXBvcnQgdHlwZSB7IFdpbmRvdyB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KFxuICBlbGVtZW50OiBFbGVtZW50IHwgV2luZG93XG4pOiBIVE1MRWxlbWVudCB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgcmV0dXJuIChcbiAgICAoaXNFbGVtZW50KGVsZW1lbnQpXG4gICAgICA/IGVsZW1lbnQub3duZXJEb2N1bWVudFxuICAgICAgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAgZWxlbWVudC5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50XG4gICkuZG9jdW1lbnRFbGVtZW50O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSAnLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QnO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tICcuL2dldERvY3VtZW50RWxlbWVudCc7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gJy4vZ2V0V2luZG93U2Nyb2xsJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50OiBFbGVtZW50KTogbnVtYmVyIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcbiAgLy8gaXQncyBub3QgYW4gaXNzdWUuIEkgZG9uJ3QgdGhpbmsgYW55b25lIGV2ZXIgc3BlY2lmaWVzIHdpZHRoIG9uIDxodG1sPlxuICAvLyBhbnl3YXkuXG4gIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXG4gIC8vIHRoaXMgKGUuZy4gRWRnZSAyMDE5LCBJRTExLCBTYWZhcmkpXG4gIHJldHVybiAoXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArXG4gICAgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnRcbiAgKTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gJy4vZ2V0V2luZG93JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShcbiAgZWxlbWVudDogRWxlbWVudFxuKTogQ1NTU3R5bGVEZWNsYXJhdGlvbiB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tICcuL2dldENvbXB1dGVkU3R5bGUnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1Njcm9sbFBhcmVudChlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIGNvbnN0IHsgb3ZlcmZsb3csIG92ZXJmbG93WCwgb3ZlcmZsb3dZIH0gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IFJlY3QsIFZpcnR1YWxFbGVtZW50LCBXaW5kb3cgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gJy4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0JztcbmltcG9ydCBnZXROb2RlU2Nyb2xsIGZyb20gJy4vZ2V0Tm9kZVNjcm9sbCc7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSAnLi9nZXROb2RlTmFtZSc7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSAnLi9pbnN0YW5jZU9mJztcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gJy4vZ2V0V2luZG93U2Nyb2xsQmFyWCc7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gJy4vZ2V0RG9jdW1lbnRFbGVtZW50JztcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tICcuL2lzU2Nyb2xsUGFyZW50JztcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSAnLi4vdXRpbHMvbWF0aCc7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudFNjYWxlZChlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3Qgc2NhbGVYID0gcm91bmQocmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XG4gIGNvbnN0IHNjYWxlWSA9IHJvdW5kKHJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDE7XG5cbiAgcmV0dXJuIHNjYWxlWCAhPT0gMSB8fCBzY2FsZVkgIT09IDE7XG59XG5cbi8vIFJldHVybnMgdGhlIGNvbXBvc2l0ZSByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC5cbi8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoXG4gIGVsZW1lbnRPclZpcnR1YWxFbGVtZW50OiBFbGVtZW50IHwgVmlydHVhbEVsZW1lbnQsXG4gIG9mZnNldFBhcmVudDogRWxlbWVudCB8IFdpbmRvdyxcbiAgaXNGaXhlZDogYm9vbGVhbiA9IGZhbHNlXG4pOiBSZWN0IHtcbiAgY29uc3QgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IG9mZnNldFBhcmVudElzU2NhbGVkID1cbiAgICBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNFbGVtZW50U2NhbGVkKG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KFxuICAgIGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LFxuICAgIG9mZnNldFBhcmVudElzU2NhbGVkLFxuICAgIGlzRml4ZWRcbiAgKTtcblxuICBsZXQgc2Nyb2xsID0geyBzY3JvbGxMZWZ0OiAwLCBzY3JvbGxUb3A6IDAgfTtcbiAgbGV0IG9mZnNldHMgPSB7IHg6IDAsIHk6IDAgfTtcblxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgKCFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkpIHtcbiAgICBpZiAoXG4gICAgICBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHxcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICAgICAgaXNTY3JvbGxQYXJlbnQoZG9jdW1lbnRFbGVtZW50KVxuICAgICkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIG9mZnNldHMgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlKTtcbiAgICAgIG9mZnNldHMueCArPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSArPSBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgfTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IFJlY3QgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gJy4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0JztcblxuLy8gUmV0dXJucyB0aGUgbGF5b3V0IHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LiBMYXlvdXRcbi8vIG1lYW5zIGl0IGRvZXNuJ3QgdGFrZSBpbnRvIGFjY291bnQgdHJhbnNmb3Jtcy5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBSZWN0IHtcbiAgY29uc3QgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTtcblxuICAvLyBVc2UgdGhlIGNsaWVudFJlY3Qgc2l6ZXMgaWYgaXQncyBub3QgYmVlbiB0cmFuc2Zvcm1lZC5cbiAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMjIzXG4gIGxldCB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIGxldCBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XG4gICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XG4gICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gIH07XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gJy4vZ2V0Tm9kZU5hbWUnO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tICcuL2dldERvY3VtZW50RWxlbWVudCc7XG5pbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tICcuL2luc3RhbmNlT2YnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQ6IE5vZGUgfCBTaGFkb3dSb290KTogTm9kZSB7XG4gIGlmIChnZXROb2RlTmFtZShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgZWxlbWVudC5wYXJlbnROb2RlIHx8IC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgKGlzU2hhZG93Um9vdChlbGVtZW50KSA/IGVsZW1lbnQuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIC8vIGZhbGxiYWNrXG4gICk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSAnLi9nZXRQYXJlbnROb2RlJztcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tICcuL2lzU2Nyb2xsUGFyZW50JztcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tICcuL2dldE5vZGVOYW1lJztcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tICcuL2luc3RhbmNlT2YnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZTogTm9kZSk6IEhUTUxFbGVtZW50IHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tICcuL2dldFNjcm9sbFBhcmVudCc7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tICcuL2dldFBhcmVudE5vZGUnO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tICcuL2dldFdpbmRvdyc7XG5pbXBvcnQgdHlwZSB7IFdpbmRvdywgVmlzdWFsVmlld3BvcnQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSAnLi9pc1Njcm9sbFBhcmVudCc7XG5cbi8qXG5naXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xudW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcbnJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4qL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoXG4gIGVsZW1lbnQ6IE5vZGUsXG4gIGxpc3Q6IEFycmF5PEVsZW1lbnQgfCBXaW5kb3c+ID0gW11cbik6IEFycmF5PEVsZW1lbnQgfCBXaW5kb3cgfCBWaXN1YWxWaWV3cG9ydD4ge1xuICBjb25zdCBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIGNvbnN0IGlzQm9keSA9IHNjcm9sbFBhcmVudCA9PT0gZWxlbWVudC5vd25lckRvY3VtZW50Py5ib2R5O1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsUGFyZW50KTtcbiAgY29uc3QgdGFyZ2V0ID0gaXNCb2R5XG4gICAgPyBbd2luXS5jb25jYXQoXG4gICAgICAgIHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSxcbiAgICAgICAgaXNTY3JvbGxQYXJlbnQoc2Nyb2xsUGFyZW50KSA/IHNjcm9sbFBhcmVudCA6IFtdXG4gICAgICApXG4gICAgOiBzY3JvbGxQYXJlbnQ7XG4gIGNvbnN0IHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcblxuICByZXR1cm4gaXNCb2R5XG4gICAgPyB1cGRhdGVkTGlzdFxuICAgIDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gICAgICB1cGRhdGVkTGlzdC5jb25jYXQobGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZSh0YXJnZXQpKSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gJy4vZ2V0Tm9kZU5hbWUnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50OiBFbGVtZW50KTogYm9vbGVhbiB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5kZXhPZihnZXROb2RlTmFtZShlbGVtZW50KSkgPj0gMDtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gJy4vZ2V0V2luZG93JztcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tICcuL2dldE5vZGVOYW1lJztcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gJy4vZ2V0Q29tcHV0ZWRTdHlsZSc7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfSBmcm9tICcuL2luc3RhbmNlT2YnO1xuaW1wb3J0IGlzVGFibGVFbGVtZW50IGZyb20gJy4vaXNUYWJsZUVsZW1lbnQnO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSAnLi9nZXRQYXJlbnROb2RlJztcbmltcG9ydCBnZXRVQVN0cmluZyBmcm9tICcuLi91dGlscy91c2VyQWdlbnQnO1xuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQ6IEVsZW1lbnQpOiA/RWxlbWVudCB7XG4gIGlmIChcbiAgICAhaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XG4gICAgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJ1xuICApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbn1cblxuLy8gYC5vZmZzZXRQYXJlbnRgIHJlcG9ydHMgYG51bGxgIGZvciBmaXhlZCBlbGVtZW50cywgd2hpbGUgYWJzb2x1dGUgZWxlbWVudHNcbi8vIHJldHVybiB0aGUgY29udGFpbmluZyBibG9ja1xuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgY29uc3QgaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuICBjb25zdCBpc0lFID0gL1RyaWRlbnQvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuXG4gIGlmIChpc0lFICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAvLyBJbiBJRSA5LCAxMCBhbmQgMTEgZml4ZWQgZWxlbWVudHMgY29udGFpbmluZyBibG9jayBpcyBhbHdheXMgZXN0YWJsaXNoZWQgYnkgdGhlIHZpZXdwb3J0XG4gICAgY29uc3QgZWxlbWVudENzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgaWYgKGVsZW1lbnRDc3MucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGxldCBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG5cbiAgaWYgKGlzU2hhZG93Um9vdChjdXJyZW50Tm9kZSkpIHtcbiAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLmhvc3Q7XG4gIH1cblxuICB3aGlsZSAoXG4gICAgaXNIVE1MRWxlbWVudChjdXJyZW50Tm9kZSkgJiZcbiAgICBbJ2h0bWwnLCAnYm9keSddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoY3VycmVudE5vZGUpKSA8IDBcbiAgKSB7XG4gICAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7XG5cbiAgICAvLyBUaGlzIGlzIG5vbi1leGhhdXN0aXZlIGJ1dCBjb3ZlcnMgdGhlIG1vc3QgY29tbW9uIENTUyBwcm9wZXJ0aWVzIHRoYXRcbiAgICAvLyBjcmVhdGUgYSBjb250YWluaW5nIGJsb2NrLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG4gICAgaWYgKFxuICAgICAgY3NzLnRyYW5zZm9ybSAhPT0gJ25vbmUnIHx8XG4gICAgICBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fFxuICAgICAgY3NzLmNvbnRhaW4gPT09ICdwYWludCcgfHxcbiAgICAgIFsndHJhbnNmb3JtJywgJ3BlcnNwZWN0aXZlJ10uaW5kZXhPZihjc3Mud2lsbENoYW5nZSkgIT09IC0xIHx8XG4gICAgICAoaXNGaXJlZm94ICYmIGNzcy53aWxsQ2hhbmdlID09PSAnZmlsdGVyJykgfHxcbiAgICAgIChpc0ZpcmVmb3ggJiYgY3NzLmZpbHRlciAmJiBjc3MuZmlsdGVyICE9PSAnbm9uZScpXG4gICAgKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50OiBFbGVtZW50KSB7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcblxuICBsZXQgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KTtcblxuICB3aGlsZSAoXG4gICAgb2Zmc2V0UGFyZW50ICYmXG4gICAgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJlxuICAgIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYydcbiAgKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgaWYgKFxuICAgIG9mZnNldFBhcmVudCAmJlxuICAgIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHxcbiAgICAgIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiZcbiAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykpXG4gICkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG59XG4iLCIvLyBAZmxvd1xuZXhwb3J0IGNvbnN0IHRvcDogJ3RvcCcgPSAndG9wJztcbmV4cG9ydCBjb25zdCBib3R0b206ICdib3R0b20nID0gJ2JvdHRvbSc7XG5leHBvcnQgY29uc3QgcmlnaHQ6ICdyaWdodCcgPSAncmlnaHQnO1xuZXhwb3J0IGNvbnN0IGxlZnQ6ICdsZWZ0JyA9ICdsZWZ0JztcbmV4cG9ydCBjb25zdCBhdXRvOiAnYXV0bycgPSAnYXV0byc7XG5leHBvcnQgdHlwZSBCYXNlUGxhY2VtZW50ID1cbiAgfCB0eXBlb2YgdG9wXG4gIHwgdHlwZW9mIGJvdHRvbVxuICB8IHR5cGVvZiByaWdodFxuICB8IHR5cGVvZiBsZWZ0O1xuZXhwb3J0IGNvbnN0IGJhc2VQbGFjZW1lbnRzOiBBcnJheTxCYXNlUGxhY2VtZW50PiA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xuXG5leHBvcnQgY29uc3Qgc3RhcnQ6ICdzdGFydCcgPSAnc3RhcnQnO1xuZXhwb3J0IGNvbnN0IGVuZDogJ2VuZCcgPSAnZW5kJztcbmV4cG9ydCB0eXBlIFZhcmlhdGlvbiA9IHR5cGVvZiBzdGFydCB8IHR5cGVvZiBlbmQ7XG5cbmV4cG9ydCBjb25zdCBjbGlwcGluZ1BhcmVudHM6ICdjbGlwcGluZ1BhcmVudHMnID0gJ2NsaXBwaW5nUGFyZW50cyc7XG5leHBvcnQgY29uc3Qgdmlld3BvcnQ6ICd2aWV3cG9ydCcgPSAndmlld3BvcnQnO1xuZXhwb3J0IHR5cGUgQm91bmRhcnkgPSBFbGVtZW50IHwgQXJyYXk8RWxlbWVudD4gfCB0eXBlb2YgY2xpcHBpbmdQYXJlbnRzO1xuZXhwb3J0IHR5cGUgUm9vdEJvdW5kYXJ5ID0gdHlwZW9mIHZpZXdwb3J0IHwgJ2RvY3VtZW50JztcblxuZXhwb3J0IGNvbnN0IHBvcHBlcjogJ3BvcHBlcicgPSAncG9wcGVyJztcbmV4cG9ydCBjb25zdCByZWZlcmVuY2U6ICdyZWZlcmVuY2UnID0gJ3JlZmVyZW5jZSc7XG5leHBvcnQgdHlwZSBDb250ZXh0ID0gdHlwZW9mIHBvcHBlciB8IHR5cGVvZiByZWZlcmVuY2U7XG5cbmV4cG9ydCB0eXBlIFZhcmlhdGlvblBsYWNlbWVudCA9XG4gIHwgJ3RvcC1zdGFydCdcbiAgfCAndG9wLWVuZCdcbiAgfCAnYm90dG9tLXN0YXJ0J1xuICB8ICdib3R0b20tZW5kJ1xuICB8ICdyaWdodC1zdGFydCdcbiAgfCAncmlnaHQtZW5kJ1xuICB8ICdsZWZ0LXN0YXJ0J1xuICB8ICdsZWZ0LWVuZCc7XG5leHBvcnQgdHlwZSBBdXRvUGxhY2VtZW50ID0gJ2F1dG8nIHwgJ2F1dG8tc3RhcnQnIHwgJ2F1dG8tZW5kJztcbmV4cG9ydCB0eXBlIENvbXB1dGVkUGxhY2VtZW50ID0gVmFyaWF0aW9uUGxhY2VtZW50IHwgQmFzZVBsYWNlbWVudDtcbmV4cG9ydCB0eXBlIFBsYWNlbWVudCA9IEF1dG9QbGFjZW1lbnQgfCBCYXNlUGxhY2VtZW50IHwgVmFyaWF0aW9uUGxhY2VtZW50O1xuXG5leHBvcnQgY29uc3QgdmFyaWF0aW9uUGxhY2VtZW50czogQXJyYXk8VmFyaWF0aW9uUGxhY2VtZW50PiA9IGJhc2VQbGFjZW1lbnRzLnJlZHVjZShcbiAgKGFjYzogQXJyYXk8VmFyaWF0aW9uUGxhY2VtZW50PiwgcGxhY2VtZW50OiBCYXNlUGxhY2VtZW50KSA9PlxuICAgIGFjYy5jb25jYXQoWyhgJHtwbGFjZW1lbnR9LSR7c3RhcnR9YDogYW55KSwgKGAke3BsYWNlbWVudH0tJHtlbmR9YDogYW55KV0pLFxuICBbXVxuKTtcbmV4cG9ydCBjb25zdCBwbGFjZW1lbnRzOiBBcnJheTxQbGFjZW1lbnQ+ID0gWy4uLmJhc2VQbGFjZW1lbnRzLCBhdXRvXS5yZWR1Y2UoXG4gIChcbiAgICBhY2M6IEFycmF5PFBsYWNlbWVudD4sXG4gICAgcGxhY2VtZW50OiBCYXNlUGxhY2VtZW50IHwgdHlwZW9mIGF1dG9cbiAgKTogQXJyYXk8UGxhY2VtZW50PiA9PlxuICAgIGFjYy5jb25jYXQoW1xuICAgICAgcGxhY2VtZW50LFxuICAgICAgKGAke3BsYWNlbWVudH0tJHtzdGFydH1gOiBhbnkpLFxuICAgICAgKGAke3BsYWNlbWVudH0tJHtlbmR9YDogYW55KSxcbiAgICBdKSxcbiAgW11cbik7XG5cbi8vIG1vZGlmaWVycyB0aGF0IG5lZWQgdG8gcmVhZCB0aGUgRE9NXG5leHBvcnQgY29uc3QgYmVmb3JlUmVhZDogJ2JlZm9yZVJlYWQnID0gJ2JlZm9yZVJlYWQnO1xuZXhwb3J0IGNvbnN0IHJlYWQ6ICdyZWFkJyA9ICdyZWFkJztcbmV4cG9ydCBjb25zdCBhZnRlclJlYWQ6ICdhZnRlclJlYWQnID0gJ2FmdGVyUmVhZCc7XG4vLyBwdXJlLWxvZ2ljIG1vZGlmaWVyc1xuZXhwb3J0IGNvbnN0IGJlZm9yZU1haW46ICdiZWZvcmVNYWluJyA9ICdiZWZvcmVNYWluJztcbmV4cG9ydCBjb25zdCBtYWluOiAnbWFpbicgPSAnbWFpbic7XG5leHBvcnQgY29uc3QgYWZ0ZXJNYWluOiAnYWZ0ZXJNYWluJyA9ICdhZnRlck1haW4nO1xuLy8gbW9kaWZpZXIgd2l0aCB0aGUgcHVycG9zZSB0byB3cml0ZSB0byB0aGUgRE9NIChvciB3cml0ZSBpbnRvIGEgZnJhbWV3b3JrIHN0YXRlKVxuZXhwb3J0IGNvbnN0IGJlZm9yZVdyaXRlOiAnYmVmb3JlV3JpdGUnID0gJ2JlZm9yZVdyaXRlJztcbmV4cG9ydCBjb25zdCB3cml0ZTogJ3dyaXRlJyA9ICd3cml0ZSc7XG5leHBvcnQgY29uc3QgYWZ0ZXJXcml0ZTogJ2FmdGVyV3JpdGUnID0gJ2FmdGVyV3JpdGUnO1xuZXhwb3J0IGNvbnN0IG1vZGlmaWVyUGhhc2VzOiBBcnJheTxNb2RpZmllclBoYXNlcz4gPSBbXG4gIGJlZm9yZVJlYWQsXG4gIHJlYWQsXG4gIGFmdGVyUmVhZCxcbiAgYmVmb3JlTWFpbixcbiAgbWFpbixcbiAgYWZ0ZXJNYWluLFxuICBiZWZvcmVXcml0ZSxcbiAgd3JpdGUsXG4gIGFmdGVyV3JpdGUsXG5dO1xuXG5leHBvcnQgdHlwZSBNb2RpZmllclBoYXNlcyA9XG4gIHwgdHlwZW9mIGJlZm9yZVJlYWRcbiAgfCB0eXBlb2YgcmVhZFxuICB8IHR5cGVvZiBhZnRlclJlYWRcbiAgfCB0eXBlb2YgYmVmb3JlTWFpblxuICB8IHR5cGVvZiBtYWluXG4gIHwgdHlwZW9mIGFmdGVyTWFpblxuICB8IHR5cGVvZiBiZWZvcmVXcml0ZVxuICB8IHR5cGVvZiB3cml0ZVxuICB8IHR5cGVvZiBhZnRlcldyaXRlO1xuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgTW9kaWZpZXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBtb2RpZmllclBoYXNlcyB9IGZyb20gJy4uL2VudW1zJztcblxuLy8gc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTg3NTI1NVxuZnVuY3Rpb24gb3JkZXIobW9kaWZpZXJzKSB7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgbW9kaWZpZXJzLmZvckVhY2gobW9kaWZpZXIgPT4ge1xuICAgIG1hcC5zZXQobW9kaWZpZXIubmFtZSwgbW9kaWZpZXIpO1xuICB9KTtcblxuICAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XG4gIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXI6IE1vZGlmaWVyPGFueSwgYW55Pikge1xuICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xuXG4gICAgY29uc3QgcmVxdWlyZXMgPSBbXG4gICAgICAuLi4obW9kaWZpZXIucmVxdWlyZXMgfHwgW10pLFxuICAgICAgLi4uKG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pLFxuICAgIF07XG5cbiAgICByZXF1aXJlcy5mb3JFYWNoKGRlcCA9PiB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcbiAgICAgICAgY29uc3QgZGVwTW9kaWZpZXIgPSBtYXAuZ2V0KGRlcCk7XG5cbiAgICAgICAgaWYgKGRlcE1vZGlmaWVyKSB7XG4gICAgICAgICAgc29ydChkZXBNb2RpZmllcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlc3VsdC5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIG1vZGlmaWVycy5mb3JFYWNoKG1vZGlmaWVyID0+IHtcbiAgICBpZiAoIXZpc2l0ZWQuaGFzKG1vZGlmaWVyLm5hbWUpKSB7XG4gICAgICAvLyBjaGVjayBmb3IgdmlzaXRlZCBvYmplY3RcbiAgICAgIHNvcnQobW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMoXG4gIG1vZGlmaWVyczogQXJyYXk8TW9kaWZpZXI8YW55LCBhbnk+PlxuKTogQXJyYXk8TW9kaWZpZXI8YW55LCBhbnk+PiB7XG4gIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xuICBjb25zdCBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXIobW9kaWZpZXJzKTtcblxuICAvLyBvcmRlciBiYXNlZCBvbiBwaGFzZVxuICByZXR1cm4gbW9kaWZpZXJQaGFzZXMucmVkdWNlKChhY2MsIHBoYXNlKSA9PiB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihtb2RpZmllciA9PiBtb2RpZmllci5waGFzZSA9PT0gcGhhc2UpXG4gICAgKTtcbiAgfSwgW10pO1xufVxuIiwiLy8gQGZsb3dcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2U8VD4oZm46IEZ1bmN0aW9uKTogKCkgPT4gUHJvbWlzZTxUPiB7XG4gIGxldCBwZW5kaW5nO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlPFQ+KHJlc29sdmUgPT4ge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBwZW5kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlc29sdmUoZm4oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBlbmRpbmc7XG4gIH07XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBNb2RpZmllciB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VCeU5hbWUoXG4gIG1vZGlmaWVyczogQXJyYXk8JFNoYXBlPE1vZGlmaWVyPGFueSwgYW55Pj4+XG4pOiBBcnJheTwkU2hhcGU8TW9kaWZpZXI8YW55LCBhbnk+Pj4ge1xuICBjb25zdCBtZXJnZWQgPSBtb2RpZmllcnMucmVkdWNlKChtZXJnZWQsIGN1cnJlbnQpID0+IHtcbiAgICBjb25zdCBleGlzdGluZyA9IG1lcmdlZFtjdXJyZW50Lm5hbWVdO1xuICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmdcbiAgICAgID8ge1xuICAgICAgICAgIC4uLmV4aXN0aW5nLFxuICAgICAgICAgIC4uLmN1cnJlbnQsXG4gICAgICAgICAgb3B0aW9uczogeyAuLi5leGlzdGluZy5vcHRpb25zLCAuLi5jdXJyZW50Lm9wdGlvbnMgfSxcbiAgICAgICAgICBkYXRhOiB7IC4uLmV4aXN0aW5nLmRhdGEsIC4uLmN1cnJlbnQuZGF0YSB9LFxuICAgICAgICB9XG4gICAgICA6IGN1cnJlbnQ7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pO1xuXG4gIC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChrZXkgPT4gbWVyZ2VkW2tleV0pO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSAnLi9nZXRXaW5kb3cnO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tICcuL2dldERvY3VtZW50RWxlbWVudCc7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tICcuL2dldFdpbmRvd1Njcm9sbEJhclgnO1xuaW1wb3J0IGlzTGF5b3V0Vmlld3BvcnQgZnJvbSAnLi9pc0xheW91dFZpZXdwb3J0JztcbmltcG9ydCB0eXBlIHsgUG9zaXRpb25pbmdTdHJhdGVneSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KFxuICBlbGVtZW50OiBFbGVtZW50LFxuICBzdHJhdGVneTogUG9zaXRpb25pbmdTdHJhdGVneVxuKSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgY29uc3QgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG5cbiAgbGV0IHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgbGV0IGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcblxuICAgIGNvbnN0IGxheW91dFZpZXdwb3J0ID0gaXNMYXlvdXRWaWV3cG9ydCgpO1xuXG4gICAgaWYgKGxheW91dFZpZXdwb3J0IHx8ICghbGF5b3V0Vmlld3BvcnQgJiYgc3RyYXRlZ3kgPT09ICdmaXhlZCcpKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXG4gICAgeSxcbiAgfTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IFJlY3QgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gJy4vZ2V0RG9jdW1lbnRFbGVtZW50JztcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gJy4vZ2V0Q29tcHV0ZWRTdHlsZSc7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tICcuL2dldFdpbmRvd1Njcm9sbEJhclgnO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tICcuL2dldFdpbmRvd1Njcm9sbCc7XG5pbXBvcnQgeyBtYXggfSBmcm9tICcuLi91dGlscy9tYXRoJztcblxuLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogUmVjdCB7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgY29uc3QgYm9keSA9IGVsZW1lbnQub3duZXJEb2N1bWVudD8uYm9keTtcblxuICBjb25zdCB3aWR0aCA9IG1heChcbiAgICBodG1sLnNjcm9sbFdpZHRoLFxuICAgIGh0bWwuY2xpZW50V2lkdGgsXG4gICAgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLFxuICAgIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMFxuICApO1xuICBjb25zdCBoZWlnaHQgPSBtYXgoXG4gICAgaHRtbC5zY3JvbGxIZWlnaHQsXG4gICAgaHRtbC5jbGllbnRIZWlnaHQsXG4gICAgYm9keSA/IGJvZHkuc2Nyb2xsSGVpZ2h0IDogMCxcbiAgICBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwXG4gICk7XG5cbiAgbGV0IHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICBjb25zdCB5ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XG5cbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCwgeCwgeSB9O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gJy4vaW5zdGFuY2VPZic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudDogRWxlbWVudCwgY2hpbGQ6IEVsZW1lbnQpIHtcbiAgY29uc3Qgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpO1xuXG4gIC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgbGV0IG5leHQgPSBjaGlsZDtcbiAgICBkbyB7XG4gICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cbiAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgIH0gd2hpbGUgKG5leHQpO1xuICB9XG5cbiAgLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBSZWN0LCBDbGllbnRSZWN0T2JqZWN0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3Q6IFJlY3QpOiBDbGllbnRSZWN0T2JqZWN0IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5yZWN0LFxuICAgIGxlZnQ6IHJlY3QueCxcbiAgICB0b3A6IHJlY3QueSxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0LFxuICB9O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgQ2xpZW50UmVjdE9iamVjdCwgUG9zaXRpb25pbmdTdHJhdGVneSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB0eXBlIHsgQm91bmRhcnksIFJvb3RCb3VuZGFyeSB9IGZyb20gJy4uL2VudW1zJztcbmltcG9ydCB7IHZpZXdwb3J0IH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IGdldFZpZXdwb3J0UmVjdCBmcm9tICcuL2dldFZpZXdwb3J0UmVjdCc7XG5pbXBvcnQgZ2V0RG9jdW1lbnRSZWN0IGZyb20gJy4vZ2V0RG9jdW1lbnRSZWN0JztcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tICcuL2xpc3RTY3JvbGxQYXJlbnRzJztcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSAnLi9nZXRPZmZzZXRQYXJlbnQnO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tICcuL2dldERvY3VtZW50RWxlbWVudCc7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tICcuL2dldENvbXB1dGVkU3R5bGUnO1xuaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH0gZnJvbSAnLi9pbnN0YW5jZU9mJztcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSAnLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QnO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSAnLi9nZXRQYXJlbnROb2RlJztcbmltcG9ydCBjb250YWlucyBmcm9tICcuL2NvbnRhaW5zJztcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tICcuL2dldE5vZGVOYW1lJztcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gJy4uL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QnO1xuaW1wb3J0IHsgbWF4LCBtaW4gfSBmcm9tICcuLi91dGlscy9tYXRoJztcblxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoXG4gIGVsZW1lbnQ6IEVsZW1lbnQsXG4gIHN0cmF0ZWd5OiBQb3NpdGlvbmluZ1N0cmF0ZWd5XG4pIHtcbiAgY29uc3QgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBmYWxzZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuXG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcblxuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoXG4gIGVsZW1lbnQ6IEVsZW1lbnQsXG4gIGNsaXBwaW5nUGFyZW50OiBFbGVtZW50IHwgUm9vdEJvdW5kYXJ5LFxuICBzdHJhdGVneTogUG9zaXRpb25pbmdTdHJhdGVneVxuKTogQ2xpZW50UmVjdE9iamVjdCB7XG4gIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gdmlld3BvcnRcbiAgICA/IHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSlcbiAgICA6IGlzRWxlbWVudChjbGlwcGluZ1BhcmVudClcbiAgICA/IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSlcbiAgICA6IHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xufVxuXG4vLyBBIFwiY2xpcHBpbmcgcGFyZW50XCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXG4vLyBgaW5pdGlhbGBcbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50OiBFbGVtZW50KTogQXJyYXk8RWxlbWVudD4ge1xuICBjb25zdCBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgY29uc3QgY2FuRXNjYXBlQ2xpcHBpbmcgPVxuICAgIFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24pID49IDA7XG4gIGNvbnN0IGNsaXBwZXJFbGVtZW50ID1cbiAgICBjYW5Fc2NhcGVDbGlwcGluZyAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpXG4gICAgICA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KVxuICAgICAgOiBlbGVtZW50O1xuXG4gIGlmICghaXNFbGVtZW50KGNsaXBwZXJFbGVtZW50KSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG4gIHJldHVybiBjbGlwcGluZ1BhcmVudHMuZmlsdGVyKFxuICAgIChjbGlwcGluZ1BhcmVudCkgPT5cbiAgICAgIGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgJiZcbiAgICAgIGNvbnRhaW5zKGNsaXBwaW5nUGFyZW50LCBjbGlwcGVyRWxlbWVudCkgJiZcbiAgICAgIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknXG4gICk7XG59XG5cbi8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIHBhcmVudHNcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChcbiAgZWxlbWVudDogRWxlbWVudCxcbiAgYm91bmRhcnk6IEJvdW5kYXJ5LFxuICByb290Qm91bmRhcnk6IFJvb3RCb3VuZGFyeSxcbiAgc3RyYXRlZ3k6IFBvc2l0aW9uaW5nU3RyYXRlZ3lcbik6IENsaWVudFJlY3RPYmplY3Qge1xuICBjb25zdCBtYWluQ2xpcHBpbmdQYXJlbnRzID1cbiAgICBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nUGFyZW50cydcbiAgICAgID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpXG4gICAgICA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIGNvbnN0IGNsaXBwaW5nUGFyZW50cyA9IFsuLi5tYWluQ2xpcHBpbmdQYXJlbnRzLCByb290Qm91bmRhcnldO1xuICBjb25zdCBmaXJzdENsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzWzBdO1xuXG4gIGNvbnN0IGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSA9PiB7XG4gICAgY29uc3QgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSk7XG5cbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuXG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSk7XG5cbiAgY2xpcHBpbmdSZWN0LndpZHRoID0gY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC5oZWlnaHQgPSBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgY2xpcHBpbmdSZWN0LnggPSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LnkgPSBjbGlwcGluZ1JlY3QudG9wO1xuXG4gIHJldHVybiBjbGlwcGluZ1JlY3Q7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHsgdHlwZSBCYXNlUGxhY2VtZW50LCB0eXBlIFBsYWNlbWVudCwgYXV0byB9IGZyb20gJy4uL2VudW1zJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChcbiAgcGxhY2VtZW50OiBQbGFjZW1lbnQgfCB0eXBlb2YgYXV0b1xuKTogQmFzZVBsYWNlbWVudCB7XG4gIHJldHVybiAocGxhY2VtZW50LnNwbGl0KCctJylbMF06IGFueSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHsgdHlwZSBWYXJpYXRpb24sIHR5cGUgUGxhY2VtZW50IH0gZnJvbSAnLi4vZW51bXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50OiBQbGFjZW1lbnQpOiA/VmFyaWF0aW9uIHtcbiAgcmV0dXJuIChwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTogYW55KTtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IFBsYWNlbWVudCB9IGZyb20gJy4uL2VudW1zJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KFxuICBwbGFjZW1lbnQ6IFBsYWNlbWVudFxuKTogJ3gnIHwgJ3knIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gJy4vZ2V0QmFzZVBsYWNlbWVudCc7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gJy4vZ2V0VmFyaWF0aW9uJztcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSAnLi9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQnO1xuaW1wb3J0IHR5cGUge1xuICBSZWN0LFxuICBQb3NpdGlvbmluZ1N0cmF0ZWd5LFxuICBPZmZzZXRzLFxuICBDbGllbnRSZWN0T2JqZWN0LFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHN0YXJ0LCBlbmQsIHR5cGUgUGxhY2VtZW50IH0gZnJvbSAnLi4vZW51bXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyh7XG4gIHJlZmVyZW5jZSxcbiAgZWxlbWVudCxcbiAgcGxhY2VtZW50LFxufToge1xuICByZWZlcmVuY2U6IFJlY3QgfCBDbGllbnRSZWN0T2JqZWN0LFxuICBlbGVtZW50OiBSZWN0IHwgQ2xpZW50UmVjdE9iamVjdCxcbiAgc3RyYXRlZ3k6IFBvc2l0aW9uaW5nU3RyYXRlZ3ksXG4gIHBsYWNlbWVudD86IFBsYWNlbWVudCxcbn0pOiBPZmZzZXRzIHtcbiAgY29uc3QgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudCA/IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA6IG51bGw7XG4gIGNvbnN0IHZhcmlhdGlvbiA9IHBsYWNlbWVudCA/IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIDogbnVsbDtcbiAgY29uc3QgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICBjb25zdCBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGVsZW1lbnQuaGVpZ2h0IC8gMjtcblxuICBsZXQgb2Zmc2V0cztcbiAgc3dpdGNoIChiYXNlUGxhY2VtZW50KSB7XG4gICAgY2FzZSB0b3A6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGVsZW1lbnQuaGVpZ2h0LFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYm90dG9tOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0LFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWSxcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIGxlZnQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGVsZW1lbnQud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vblksXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICB5OiByZWZlcmVuY2UueSxcbiAgICAgIH07XG4gIH1cblxuICBjb25zdCBtYWluQXhpcyA9IGJhc2VQbGFjZW1lbnRcbiAgICA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KVxuICAgIDogbnVsbDtcblxuICBpZiAobWFpbkF4aXMgIT0gbnVsbCkge1xuICAgIGNvbnN0IGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICBzd2l0Y2ggKHZhcmlhdGlvbikge1xuICAgICAgY2FzZSBzdGFydDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPVxuICAgICAgICAgIG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZW5kOlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9XG4gICAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7IFNpZGVPYmplY3QgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEZyZXNoU2lkZU9iamVjdCgpOiBTaWRlT2JqZWN0IHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDAsXG4gIH07XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBTaWRlT2JqZWN0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tICcuL2dldEZyZXNoU2lkZU9iamVjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChcbiAgcGFkZGluZ09iamVjdDogJFNoYXBlPFNpZGVPYmplY3Q+XG4pOiBTaWRlT2JqZWN0IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5nZXRGcmVzaFNpZGVPYmplY3QoKSxcbiAgICAuLi5wYWRkaW5nT2JqZWN0LFxuICB9O1xufVxuIiwiLy8gQGZsb3dcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwPFxuICBUOiBudW1iZXIgfCBzdHJpbmcgfCBib29sZWFuLFxuICBLOiBzdHJpbmdcbj4odmFsdWU6IFQsIGtleXM6IEFycmF5PEs+KTogeyBba2V5OiBzdHJpbmddOiBUIH0ge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoKGhhc2hNYXAsIGtleSkgPT4ge1xuICAgIGhhc2hNYXBba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBoYXNoTWFwO1xuICB9LCB7fSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBTdGF0ZSwgU2lkZU9iamVjdCwgUGFkZGluZywgUG9zaXRpb25pbmdTdHJhdGVneSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB0eXBlIHsgUGxhY2VtZW50LCBCb3VuZGFyeSwgUm9vdEJvdW5kYXJ5LCBDb250ZXh0IH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IGdldENsaXBwaW5nUmVjdCBmcm9tICcuLi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0JztcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSAnLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudCc7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gJy4uL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QnO1xuaW1wb3J0IGNvbXB1dGVPZmZzZXRzIGZyb20gJy4vY29tcHV0ZU9mZnNldHMnO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSAnLi9yZWN0VG9DbGllbnRSZWN0JztcbmltcG9ydCB7XG4gIGNsaXBwaW5nUGFyZW50cyxcbiAgcmVmZXJlbmNlLFxuICBwb3BwZXIsXG4gIGJvdHRvbSxcbiAgdG9wLFxuICByaWdodCxcbiAgYmFzZVBsYWNlbWVudHMsXG4gIHZpZXdwb3J0LFxufSBmcm9tICcuLi9lbnVtcyc7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tICcuLi9kb20tdXRpbHMvaW5zdGFuY2VPZic7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gJy4vbWVyZ2VQYWRkaW5nT2JqZWN0JztcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSAnLi9leHBhbmRUb0hhc2hNYXAnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBPcHRpb25zID0ge1xuICBwbGFjZW1lbnQ6IFBsYWNlbWVudCxcbiAgc3RyYXRlZ3k6IFBvc2l0aW9uaW5nU3RyYXRlZ3ksXG4gIGJvdW5kYXJ5OiBCb3VuZGFyeSxcbiAgcm9vdEJvdW5kYXJ5OiBSb290Qm91bmRhcnksXG4gIGVsZW1lbnRDb250ZXh0OiBDb250ZXh0LFxuICBhbHRCb3VuZGFyeTogYm9vbGVhbixcbiAgcGFkZGluZzogUGFkZGluZyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KFxuICBzdGF0ZTogU3RhdGUsXG4gIG9wdGlvbnM6ICRTaGFwZTxPcHRpb25zPiA9IHt9XG4pOiBTaWRlT2JqZWN0IHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9IHN0YXRlLnBsYWNlbWVudCxcbiAgICBzdHJhdGVneSA9IHN0YXRlLnN0cmF0ZWd5LFxuICAgIGJvdW5kYXJ5ID0gY2xpcHBpbmdQYXJlbnRzLFxuICAgIHJvb3RCb3VuZGFyeSA9IHZpZXdwb3J0LFxuICAgIGVsZW1lbnRDb250ZXh0ID0gcG9wcGVyLFxuICAgIGFsdEJvdW5kYXJ5ID0gZmFsc2UsXG4gICAgcGFkZGluZyA9IDAsXG4gIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QoXG4gICAgdHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInXG4gICAgICA/IHBhZGRpbmdcbiAgICAgIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKVxuICApO1xuXG4gIGNvbnN0IGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcmVmZXJlbmNlIDogcG9wcGVyO1xuXG4gIGNvbnN0IHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIGNvbnN0IGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG5cbiAgY29uc3QgY2xpcHBpbmdDbGllbnRSZWN0ID0gZ2V0Q2xpcHBpbmdSZWN0KFxuICAgIGlzRWxlbWVudChlbGVtZW50KVxuICAgICAgPyBlbGVtZW50XG4gICAgICA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHN0cmF0ZWd5XG4gICk7XG5cbiAgY29uc3QgcmVmZXJlbmNlQ2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChzdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2UpO1xuXG4gIGNvbnN0IHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50LFxuICB9KTtcblxuICBjb25zdCBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdCh7XG4gICAgLi4ucG9wcGVyUmVjdCxcbiAgICAuLi5wb3BwZXJPZmZzZXRzLFxuICB9KTtcblxuICBjb25zdCBlbGVtZW50Q2xpZW50UmVjdCA9XG4gICAgZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHBvcHBlckNsaWVudFJlY3QgOiByZWZlcmVuY2VDbGllbnRSZWN0O1xuXG4gIC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuICBjb25zdCBvdmVyZmxvd09mZnNldHMgPSB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOlxuICAgICAgZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC1cbiAgICAgIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gK1xuICAgICAgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OlxuICAgICAgZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0LFxuICB9O1xuXG4gIGNvbnN0IG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDtcblxuICAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG4gIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG5cbiAgICBPYmplY3Qua2V5cyhvdmVyZmxvd09mZnNldHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICBjb25zdCBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7XG4gIFN0YXRlLFxuICBPcHRpb25zR2VuZXJpYyxcbiAgTW9kaWZpZXIsXG4gIEluc3RhbmNlLFxuICBWaXJ0dWFsRWxlbWVudCxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgZ2V0Q29tcG9zaXRlUmVjdCBmcm9tICcuL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0JztcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gJy4vZG9tLXV0aWxzL2dldExheW91dFJlY3QnO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gJy4vZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzJztcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSAnLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50JztcbmltcG9ydCBvcmRlck1vZGlmaWVycyBmcm9tICcuL3V0aWxzL29yZGVyTW9kaWZpZXJzJztcbmltcG9ydCBkZWJvdW5jZSBmcm9tICcuL3V0aWxzL2RlYm91bmNlJztcbmltcG9ydCBtZXJnZUJ5TmFtZSBmcm9tICcuL3V0aWxzL21lcmdlQnlOYW1lJztcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tICcuL3V0aWxzL2RldGVjdE92ZXJmbG93JztcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gJy4vZG9tLXV0aWxzL2luc3RhbmNlT2YnO1xuXG5jb25zdCBERUZBVUxUX09QVElPTlM6IE9wdGlvbnNHZW5lcmljPGFueT4gPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxufTtcblxudHlwZSBQb3BwZXJHZW5lcmF0b3JBcmdzID0ge1xuICBkZWZhdWx0TW9kaWZpZXJzPzogQXJyYXk8TW9kaWZpZXI8YW55LCBhbnk+PixcbiAgZGVmYXVsdE9wdGlvbnM/OiAkU2hhcGU8T3B0aW9uc0dlbmVyaWM8YW55Pj4sXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKC4uLmFyZ3M6IEFycmF5PGFueT4pOiBib29sZWFuIHtcbiAgcmV0dXJuICFhcmdzLnNvbWUoXG4gICAgKGVsZW1lbnQpID0+XG4gICAgICAhKGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnM6IFBvcHBlckdlbmVyYXRvckFyZ3MgPSB7fSkge1xuICBjb25zdCB7IGRlZmF1bHRNb2RpZmllcnMgPSBbXSwgZGVmYXVsdE9wdGlvbnMgPSBERUZBVUxUX09QVElPTlMgfSA9XG4gICAgZ2VuZXJhdG9yT3B0aW9ucztcblxuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUG9wcGVyPFRNb2RpZmllcjogJFNoYXBlPE1vZGlmaWVyPGFueSwgYW55Pj4+KFxuICAgIHJlZmVyZW5jZTogRWxlbWVudCB8IFZpcnR1YWxFbGVtZW50LFxuICAgIHBvcHBlcjogSFRNTEVsZW1lbnQsXG4gICAgb3B0aW9uczogJFNoYXBlPE9wdGlvbnNHZW5lcmljPFRNb2RpZmllcj4+ID0gZGVmYXVsdE9wdGlvbnNcbiAgKTogSW5zdGFuY2Uge1xuICAgIGxldCBzdGF0ZTogJFNoYXBlPFN0YXRlPiA9IHtcbiAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IHsgLi4uREVGQVVMVF9PUFRJT05TLCAuLi5kZWZhdWx0T3B0aW9ucyB9LFxuICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlcixcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge30sXG4gICAgfTtcblxuICAgIGxldCBlZmZlY3RDbGVhbnVwRm5zOiBBcnJheTwoKSA9PiB2b2lkPiA9IFtdO1xuICAgIGxldCBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgICBzdGF0ZSxcbiAgICAgIHNldE9wdGlvbnMoc2V0T3B0aW9uc0FjdGlvbikge1xuICAgICAgICBjb25zdCBvcHRpb25zID1cbiAgICAgICAgICB0eXBlb2Ygc2V0T3B0aW9uc0FjdGlvbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBzZXRPcHRpb25zQWN0aW9uKHN0YXRlLm9wdGlvbnMpXG4gICAgICAgICAgICA6IHNldE9wdGlvbnNBY3Rpb247XG5cbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuXG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVtleHBvbmVudGlhbC1zcHJlYWRdXG4gICAgICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgICAgLi4uc3RhdGUub3B0aW9ucyxcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9O1xuXG4gICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKVxuICAgICAgICAgICAgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UpXG4gICAgICAgICAgICA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudFxuICAgICAgICAgICAgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpXG4gICAgICAgICAgICA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogbGlzdFNjcm9sbFBhcmVudHMocG9wcGVyKSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBPcmRlcnMgdGhlIG1vZGlmaWVycyBiYXNlZCBvbiB0aGVpciBkZXBlbmRlbmNpZXMgYW5kIGBwaGFzZWBcbiAgICAgICAgLy8gcHJvcGVydGllc1xuICAgICAgICBjb25zdCBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJNb2RpZmllcnMoXG4gICAgICAgICAgbWVyZ2VCeU5hbWUoWy4uLmRlZmF1bHRNb2RpZmllcnMsIC4uLnN0YXRlLm9wdGlvbnMubW9kaWZpZXJzXSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTdHJpcCBvdXQgZGlzYWJsZWQgbW9kaWZpZXJzXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcigobSkgPT4gbS5lbmFibGVkKTtcblxuICAgICAgICBydW5Nb2RpZmllckVmZmVjdHMoKTtcblxuICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9LFxuXG4gICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKGlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyByZWZlcmVuY2UsIHBvcHBlciB9ID0gc3RhdGUuZWxlbWVudHM7XG5cbiAgICAgICAgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXG4gICAgICAgIC8vIGFueW1vcmVcbiAgICAgICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgYW5kIHBvcHBlciByZWN0cyB0byBiZSByZWFkIGJ5IG1vZGlmaWVyc1xuICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGdldENvbXBvc2l0ZVJlY3QoXG4gICAgICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgICAgICBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKSxcbiAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCdcbiAgICAgICAgICApLFxuICAgICAgICAgIHBvcHBlcjogZ2V0TGF5b3V0UmVjdChwb3BwZXIpLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIHJlc2V0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZS4gVGhlXG4gICAgICAgIC8vIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRoZSBgZmxpcGAgbW9kaWZpZXIgY2hhbmdpbmcgdGhlXG4gICAgICAgIC8vIHBsYWNlbWVudCwgd2hpY2ggdGhlbiBuZWVkcyB0byByZS1ydW4gYWxsIHRoZSBtb2RpZmllcnMsIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIGxvZ2ljIHdhcyBwcmV2aW91c2x5IHJhbiBmb3IgdGhlIHByZXZpb3VzIHBsYWNlbWVudCBhbmQgaXMgdGhlcmVmb3JlXG4gICAgICAgIC8vIHN0YWxlL2luY29ycmVjdFxuICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuXG4gICAgICAgIHN0YXRlLnBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuXG4gICAgICAgIC8vIE9uIGVhY2ggdXBkYXRlIGN5Y2xlLCB0aGUgYG1vZGlmaWVyc0RhdGFgIHByb3BlcnR5IGZvciBlYWNoIG1vZGlmaWVyXG4gICAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIHRoZSBpbml0aWFsIGRhdGEgc3BlY2lmaWVkIGJ5IHRoZSBtb2RpZmllci4gVGhpcyBtZWFuc1xuICAgICAgICAvLyBpdCBkb2Vzbid0IHBlcnNpc3QgYW5kIGlzIGZyZXNoIG9uIGVhY2ggdXBkYXRlLlxuICAgICAgICAvLyBUbyBlbnN1cmUgcGVyc2lzdGVudCBkYXRhLCB1c2UgYCR7bmFtZX0jcGVyc2lzdGVudGBcbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKFxuICAgICAgICAgIChtb2RpZmllcikgPT5cbiAgICAgICAgICAgIChzdGF0ZS5tb2RpZmllcnNEYXRhW21vZGlmaWVyLm5hbWVdID0ge1xuICAgICAgICAgICAgICAuLi5tb2RpZmllci5kYXRhLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpZiAoc3RhdGUucmVzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgeyBmbiwgb3B0aW9ucyA9IHt9LCBuYW1lIH0gPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oeyBzdGF0ZSwgb3B0aW9ucywgbmFtZSwgaW5zdGFuY2UgfSkgfHwgc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyBBc3luYyBhbmQgb3B0aW1pc3RpY2FsbHkgb3B0aW1pemVkIHVwZGF0ZSDigJMgaXQgd2lsbCBub3QgYmUgZXhlY3V0ZWQgaWZcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgKGRlYm91bmNlZCB0byBydW4gYXQgbW9zdCBvbmNlLXBlci10aWNrKVxuICAgICAgdXBkYXRlOiBkZWJvdW5jZTwkU2hhcGU8U3RhdGU+PihcbiAgICAgICAgKCkgPT5cbiAgICAgICAgICBuZXcgUHJvbWlzZTwkU2hhcGU8U3RhdGU+PigocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xuICAgICAgICAgIH0pXG4gICAgICApLFxuXG4gICAgICBkZXN0cm95KCkge1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIGlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpLnRoZW4oKHN0YXRlKSA9PiB7XG4gICAgICBpZiAoIWlzRGVzdHJveWVkICYmIG9wdGlvbnMub25GaXJzdFVwZGF0ZSkge1xuICAgICAgICBvcHRpb25zLm9uRmlyc3RVcGRhdGUoc3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXG4gICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcbiAgICAvLyBvdGhlciBtb2RpZmllcnMgbmVlZCB0byB1c2UsIGJ1dCB0aGUgbW9kaWZpZXIgaXMgcnVuIGFmdGVyIHRoZSBkZXBlbmRlbnRcbiAgICAvLyBvbmUuXG4gICAgZnVuY3Rpb24gcnVuTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKCh7IG5hbWUsIG9wdGlvbnMgPSB7fSwgZWZmZWN0IH0pID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjb25zdCBjbGVhbnVwRm4gPSBlZmZlY3QoeyBzdGF0ZSwgbmFtZSwgaW5zdGFuY2UsIG9wdGlvbnMgfSk7XG4gICAgICAgICAgY29uc3Qgbm9vcEZuID0gKCkgPT4ge307XG4gICAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5wdXNoKGNsZWFudXBGbiB8fCBub29wRm4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlUG9wcGVyID0gcG9wcGVyR2VuZXJhdG9yKCk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB7IGRldGVjdE92ZXJmbG93IH07XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBNb2RpZmllckFyZ3VtZW50cywgTW9kaWZpZXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gJy4uL2RvbS11dGlscy9nZXRXaW5kb3cnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBPcHRpb25zID0ge1xuICBzY3JvbGw6IGJvb2xlYW4sXG4gIHJlc2l6ZTogYm9vbGVhbixcbn07XG5cbmNvbnN0IHBhc3NpdmUgPSB7IHBhc3NpdmU6IHRydWUgfTtcblxuZnVuY3Rpb24gZWZmZWN0KHsgc3RhdGUsIGluc3RhbmNlLCBvcHRpb25zIH06IE1vZGlmaWVyQXJndW1lbnRzPE9wdGlvbnM+KSB7XG4gIGNvbnN0IHsgc2Nyb2xsID0gdHJ1ZSwgcmVzaXplID0gdHJ1ZSB9ID0gb3B0aW9ucztcblxuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgY29uc3Qgc2Nyb2xsUGFyZW50cyA9IFtcbiAgICAuLi5zdGF0ZS5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSxcbiAgICAuLi5zdGF0ZS5zY3JvbGxQYXJlbnRzLnBvcHBlcixcbiAgXTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKHNjcm9sbFBhcmVudCA9PiB7XG4gICAgICBzY3JvbGxQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgfVxuXG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKHNjcm9sbFBhcmVudCA9PiB7XG4gICAgICAgIHNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBFdmVudExpc3RlbmVyc01vZGlmaWVyID0gTW9kaWZpZXI8J2V2ZW50TGlzdGVuZXJzJywgT3B0aW9ucz47XG5leHBvcnQgZGVmYXVsdCAoe1xuICBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46ICgpID0+IHt9LFxuICBlZmZlY3QsXG4gIGRhdGE6IHt9LFxufTogRXZlbnRMaXN0ZW5lcnNNb2RpZmllcik7XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBNb2RpZmllckFyZ3VtZW50cywgTW9kaWZpZXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSAnLi4vdXRpbHMvY29tcHV0ZU9mZnNldHMnO1xuXG5mdW5jdGlvbiBwb3BwZXJPZmZzZXRzKHsgc3RhdGUsIG5hbWUgfTogTW9kaWZpZXJBcmd1bWVudHM8e3x8fT4pIHtcbiAgLy8gT2Zmc2V0cyBhcmUgdGhlIGFjdHVhbCBwb3NpdGlvbiB0aGUgcG9wcGVyIG5lZWRzIHRvIGhhdmUgdG8gYmVcbiAgLy8gcHJvcGVybHkgcG9zaXRpb25lZCBuZWFyIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUaGlzIGlzIHRoZSBtb3N0IGJhc2ljIHBsYWNlbWVudCwgYW5kIHdpbGwgYmUgYWRqdXN0ZWQgYnlcbiAgLy8gdGhlIG1vZGlmaWVycyBpbiB0aGUgbmV4dCBzdGVwXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiBzdGF0ZS5yZWN0cy5yZWZlcmVuY2UsXG4gICAgZWxlbWVudDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50LFxuICB9KTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgUG9wcGVyT2Zmc2V0c01vZGlmaWVyID0gTW9kaWZpZXI8J3BvcHBlck9mZnNldHMnLCB7fHx9PjtcbmV4cG9ydCBkZWZhdWx0ICh7XG4gIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdyZWFkJyxcbiAgZm46IHBvcHBlck9mZnNldHMsXG4gIGRhdGE6IHt9LFxufTogUG9wcGVyT2Zmc2V0c01vZGlmaWVyKTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7XG4gIFBvc2l0aW9uaW5nU3RyYXRlZ3ksXG4gIE9mZnNldHMsXG4gIE1vZGlmaWVyLFxuICBNb2RpZmllckFyZ3VtZW50cyxcbiAgUmVjdCxcbiAgV2luZG93LFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge1xuICB0eXBlIEJhc2VQbGFjZW1lbnQsXG4gIHR5cGUgVmFyaWF0aW9uLFxuICB0b3AsXG4gIGxlZnQsXG4gIHJpZ2h0LFxuICBib3R0b20sXG4gIGVuZCxcbn0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tICcuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50JztcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSAnLi4vZG9tLXV0aWxzL2dldFdpbmRvdyc7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gJy4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQnO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSAnLi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUnO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSAnLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudCc7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gJy4uL3V0aWxzL2dldFZhcmlhdGlvbic7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gJy4uL3V0aWxzL21hdGgnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBSb3VuZE9mZnNldHMgPSAoXG4gIG9mZnNldHM6ICRTaGFwZTx7IHg6IG51bWJlciwgeTogbnVtYmVyLCBjZW50ZXJPZmZzZXQ6IG51bWJlciB9PlxuKSA9PiBPZmZzZXRzO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBPcHRpb25zID0ge1xuICBncHVBY2NlbGVyYXRpb246IGJvb2xlYW4sXG4gIGFkYXB0aXZlOiBib29sZWFuLFxuICByb3VuZE9mZnNldHM/OiBib29sZWFuIHwgUm91bmRPZmZzZXRzLFxufTtcblxuY29uc3QgdW5zZXRTaWRlcyA9IHtcbiAgdG9wOiAnYXV0bycsXG4gIHJpZ2h0OiAnYXV0bycsXG4gIGJvdHRvbTogJ2F1dG8nLFxuICBsZWZ0OiAnYXV0bycsXG59O1xuXG4vLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuZnVuY3Rpb24gcm91bmRPZmZzZXRzQnlEUFIoeyB4LCB5IH0sIHdpbjogV2luZG93KTogT2Zmc2V0cyB7XG4gIGNvbnN0IGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByb3VuZCh4ICogZHByKSAvIGRwciB8fCAwLFxuICAgIHk6IHJvdW5kKHkgKiBkcHIpIC8gZHByIHx8IDAsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb1N0eWxlcyh7XG4gIHBvcHBlcixcbiAgcG9wcGVyUmVjdCxcbiAgcGxhY2VtZW50LFxuICB2YXJpYXRpb24sXG4gIG9mZnNldHMsXG4gIHBvc2l0aW9uLFxuICBncHVBY2NlbGVyYXRpb24sXG4gIGFkYXB0aXZlLFxuICByb3VuZE9mZnNldHMsXG4gIGlzRml4ZWQsXG59OiB7XG4gIHBvcHBlcjogSFRNTEVsZW1lbnQsXG4gIHBvcHBlclJlY3Q6IFJlY3QsXG4gIHBsYWNlbWVudDogQmFzZVBsYWNlbWVudCxcbiAgdmFyaWF0aW9uOiA/VmFyaWF0aW9uLFxuICBvZmZzZXRzOiAkU2hhcGU8eyB4OiBudW1iZXIsIHk6IG51bWJlciwgY2VudGVyT2Zmc2V0OiBudW1iZXIgfT4sXG4gIHBvc2l0aW9uOiBQb3NpdGlvbmluZ1N0cmF0ZWd5LFxuICBncHVBY2NlbGVyYXRpb246IGJvb2xlYW4sXG4gIGFkYXB0aXZlOiBib29sZWFuLFxuICByb3VuZE9mZnNldHM6IGJvb2xlYW4gfCBSb3VuZE9mZnNldHMsXG4gIGlzRml4ZWQ6IGJvb2xlYW4sXG59KSB7XG4gIGxldCB7IHggPSAwLCB5ID0gMCB9ID0gb2Zmc2V0cztcblxuICAoeyB4LCB5IH0gPVxuICAgIHR5cGVvZiByb3VuZE9mZnNldHMgPT09ICdmdW5jdGlvbicgPyByb3VuZE9mZnNldHMoeyB4LCB5IH0pIDogeyB4LCB5IH0pO1xuXG4gIGNvbnN0IGhhc1ggPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd4Jyk7XG4gIGNvbnN0IGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG5cbiAgbGV0IHNpZGVYOiBzdHJpbmcgPSBsZWZ0O1xuICBsZXQgc2lkZVk6IHN0cmluZyA9IHRvcDtcblxuICBjb25zdCB3aW46IFdpbmRvdyA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICBsZXQgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgbGV0IGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICBsZXQgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKFxuICAgICAgICBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gIT09ICdzdGF0aWMnICYmXG4gICAgICAgIHBvc2l0aW9uID09PSAnYWJzb2x1dGUnXG4gICAgICApIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhc3RdOiBmb3JjZSB0eXBlIHJlZmluZW1lbnQsIHdlIGNvbXBhcmUgb2Zmc2V0UGFyZW50IHdpdGggd2luZG93IGFib3ZlLCBidXQgRmxvdyBkb2Vzbid0IGRldGVjdCBpdFxuICAgIG9mZnNldFBhcmVudCA9IChvZmZzZXRQYXJlbnQ6IEVsZW1lbnQpO1xuXG4gICAgaWYgKFxuICAgICAgcGxhY2VtZW50ID09PSB0b3AgfHxcbiAgICAgICgocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKVxuICAgICkge1xuICAgICAgc2lkZVkgPSBib3R0b207XG4gICAgICBjb25zdCBvZmZzZXRZID1cbiAgICAgICAgaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnRcbiAgICAgICAgICA/IHdpbi52aXN1YWxWaWV3cG9ydC5oZWlnaHRcbiAgICAgICAgICA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICAgICAgb2Zmc2V0UGFyZW50W2hlaWdodFByb3BdO1xuICAgICAgeSAtPSBvZmZzZXRZIC0gcG9wcGVyUmVjdC5oZWlnaHQ7XG4gICAgICB5ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBwbGFjZW1lbnQgPT09IGxlZnQgfHxcbiAgICAgICgocGxhY2VtZW50ID09PSB0b3AgfHwgcGxhY2VtZW50ID09PSBib3R0b20pICYmIHZhcmlhdGlvbiA9PT0gZW5kKVxuICAgICkge1xuICAgICAgc2lkZVggPSByaWdodDtcbiAgICAgIGNvbnN0IG9mZnNldFggPVxuICAgICAgICBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydFxuICAgICAgICAgID8gd2luLnZpc3VhbFZpZXdwb3J0LndpZHRoXG4gICAgICAgICAgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAgICAgIG9mZnNldFBhcmVudFt3aWR0aFByb3BdO1xuICAgICAgeCAtPSBvZmZzZXRYIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNvbW1vblN0eWxlcyA9IHtcbiAgICBwb3NpdGlvbixcbiAgICAuLi4oYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyksXG4gIH07XG5cbiAgKHsgeCwgeSB9ID1cbiAgICByb3VuZE9mZnNldHMgPT09IHRydWVcbiAgICAgID8gcm91bmRPZmZzZXRzQnlEUFIoeyB4LCB5IH0sIGdldFdpbmRvdyhwb3BwZXIpKVxuICAgICAgOiB7IHgsIHkgfSk7XG5cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jb21tb25TdHlsZXMsXG4gICAgICBbc2lkZVldOiBoYXNZID8gJzAnIDogJycsXG4gICAgICBbc2lkZVhdOiBoYXNYID8gJzAnIDogJycsXG4gICAgICAvLyBMYXllciBhY2NlbGVyYXRpb24gY2FuIGRpc2FibGUgc3VicGl4ZWwgcmVuZGVyaW5nIHdoaWNoIGNhdXNlcyBzbGlnaHRseVxuICAgICAgLy8gYmx1cnJ5IHRleHQgb24gbG93IFBQSSBkaXNwbGF5cywgc28gd2Ugd2FudCB0byB1c2UgMkQgdHJhbnNmb3Jtc1xuICAgICAgLy8gaW5zdGVhZFxuICAgICAgdHJhbnNmb3JtOlxuICAgICAgICAod2luLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPD0gMVxuICAgICAgICAgID8gYHRyYW5zbGF0ZSgke3h9cHgsICR7eX1weClgXG4gICAgICAgICAgOiBgdHJhbnNsYXRlM2QoJHt4fXB4LCAke3l9cHgsIDApYCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5jb21tb25TdHlsZXMsXG4gICAgW3NpZGVZXTogaGFzWSA/IGAke3l9cHhgIDogJycsXG4gICAgW3NpZGVYXTogaGFzWCA/IGAke3h9cHhgIDogJycsXG4gICAgdHJhbnNmb3JtOiAnJyxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVN0eWxlcyh7IHN0YXRlLCBvcHRpb25zIH06IE1vZGlmaWVyQXJndW1lbnRzPE9wdGlvbnM+KSB7XG4gIGNvbnN0IHtcbiAgICBncHVBY2NlbGVyYXRpb24gPSB0cnVlLFxuICAgIGFkYXB0aXZlID0gdHJ1ZSxcbiAgICAvLyBkZWZhdWx0cyB0byB1c2UgYnVpbHRpbiBgcm91bmRPZmZzZXRzQnlEUFJgXG4gICAgcm91bmRPZmZzZXRzID0gdHJ1ZSxcbiAgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3QgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbixcbiAgICBpc0ZpeGVkOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnLFxuICB9O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIgPSB7XG4gICAgICAuLi5zdGF0ZS5zdHlsZXMucG9wcGVyLFxuICAgICAgLi4ubWFwVG9TdHlsZXMoe1xuICAgICAgICAuLi5jb21tb25TdHlsZXMsXG4gICAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICAgIGFkYXB0aXZlLFxuICAgICAgICByb3VuZE9mZnNldHMsXG4gICAgICB9KSxcbiAgICB9O1xuICB9XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3cgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5hcnJvdyA9IHtcbiAgICAgIC4uLnN0YXRlLnN0eWxlcy5hcnJvdyxcbiAgICAgIC4uLm1hcFRvU3R5bGVzKHtcbiAgICAgICAgLi4uY29tbW9uU3R5bGVzLFxuICAgICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgICByb3VuZE9mZnNldHMsXG4gICAgICB9KSxcbiAgICB9O1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSB7XG4gICAgLi4uc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsXG4gICAgJ2RhdGEtcG9wcGVyLXBsYWNlbWVudCc6IHN0YXRlLnBsYWNlbWVudCxcbiAgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgQ29tcHV0ZVN0eWxlc01vZGlmaWVyID0gTW9kaWZpZXI8J2NvbXB1dGVTdHlsZXMnLCBPcHRpb25zPjtcbmV4cG9ydCBkZWZhdWx0ICh7XG4gIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gIGZuOiBjb21wdXRlU3R5bGVzLFxuICBkYXRhOiB7fSxcbn06IENvbXB1dGVTdHlsZXNNb2RpZmllcik7XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBNb2RpZmllciwgTW9kaWZpZXJBcmd1bWVudHMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSAnLi4vZG9tLXV0aWxzL2dldE5vZGVOYW1lJztcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tICcuLi9kb20tdXRpbHMvaW5zdGFuY2VPZic7XG5cbi8vIFRoaXMgbW9kaWZpZXIgdGFrZXMgdGhlIHN0eWxlcyBwcmVwYXJlZCBieSB0aGUgYGNvbXB1dGVTdHlsZXNgIG1vZGlmaWVyXG4vLyBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSBIVE1MRWxlbWVudHMgc3VjaCBhcyBwb3BwZXIgYW5kIGFycm93XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGVzKHsgc3RhdGUgfTogTW9kaWZpZXJBcmd1bWVudHM8e3x8fT4pIHtcbiAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICBjb25zdCBzdHlsZSA9IHN0YXRlLnN0eWxlc1tuYW1lXSB8fCB7fTtcblxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgIGNvbnN0IGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTtcblxuICAgIC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0byBleHRlbmQgdGhpcyBwcm9wZXJ0eSwgYnV0IGl0J3MgdGhlIG1vc3RcbiAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuXG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoeyBzdGF0ZSB9OiBNb2RpZmllckFyZ3VtZW50czx7fHx9Pikge1xuICBjb25zdCBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnLFxuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIH0sXG4gICAgcmVmZXJlbmNlOiB7fSxcbiAgfTtcblxuICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgaW5pdGlhbFN0eWxlcy5wb3BwZXIpO1xuICBzdGF0ZS5zdHlsZXMgPSBpbml0aWFsU3R5bGVzO1xuXG4gIGlmIChzdGF0ZS5lbGVtZW50cy5hcnJvdykge1xuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGluaXRpYWxTdHlsZXMuYXJyb3cpO1xuICB9XG5cbiAgcmV0dXJuICgpID0+IHtcbiAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG5cbiAgICAgIGNvbnN0IHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKFxuICAgICAgICBzdGF0ZS5zdHlsZXMuaGFzT3duUHJvcGVydHkobmFtZSlcbiAgICAgICAgICA/IHN0YXRlLnN0eWxlc1tuYW1lXVxuICAgICAgICAgIDogaW5pdGlhbFN0eWxlc1tuYW1lXVxuICAgICAgKTtcblxuICAgICAgLy8gU2V0IGFsbCB2YWx1ZXMgdG8gYW4gZW1wdHkgc3RyaW5nIHRvIHVuc2V0IHRoZW1cbiAgICAgIGNvbnN0IHN0eWxlID0gc3R5bGVQcm9wZXJ0aWVzLnJlZHVjZSgoc3R5bGUsIHByb3BlcnR5KSA9PiB7XG4gICAgICAgIHN0eWxlW3Byb3BlcnR5XSA9ICcnO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9LCB7fSk7XG5cbiAgICAgIC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuXG4gICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKChhdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBBcHBseVN0eWxlc01vZGlmaWVyID0gTW9kaWZpZXI8J2FwcGx5U3R5bGVzJywge3x8fT47XG5leHBvcnQgZGVmYXVsdCAoe1xuICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGFwcGx5U3R5bGVzLFxuICBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXSxcbn06IEFwcGx5U3R5bGVzTW9kaWZpZXIpO1xuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgUGxhY2VtZW50IH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IHR5cGUgeyBNb2RpZmllckFyZ3VtZW50cywgTW9kaWZpZXIsIFJlY3QsIE9mZnNldHMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tICcuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50JztcbmltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIHBsYWNlbWVudHMgfSBmcm9tICcuLi9lbnVtcyc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIE9mZnNldHNGdW5jdGlvbiA9ICh7XG4gIHBvcHBlcjogUmVjdCxcbiAgcmVmZXJlbmNlOiBSZWN0LFxuICBwbGFjZW1lbnQ6IFBsYWNlbWVudCxcbn0pID0+IFs/bnVtYmVyLCA/bnVtYmVyXTtcblxudHlwZSBPZmZzZXQgPSBPZmZzZXRzRnVuY3Rpb24gfCBbP251bWJlciwgP251bWJlcl07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIE9wdGlvbnMgPSB7XG4gIG9mZnNldDogT2Zmc2V0LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKFxuICBwbGFjZW1lbnQ6IFBsYWNlbWVudCxcbiAgcmVjdHM6IHsgcG9wcGVyOiBSZWN0LCByZWZlcmVuY2U6IFJlY3QgfSxcbiAgb2Zmc2V0OiBPZmZzZXRcbik6IE9mZnNldHMge1xuICBjb25zdCBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBpbnZlcnREaXN0YW5jZSA9IFtsZWZ0LCB0b3BdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcblxuICBsZXQgW3NraWRkaW5nLCBkaXN0YW5jZV0gPVxuICAgIHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbidcbiAgICAgID8gb2Zmc2V0KHtcbiAgICAgICAgICAuLi5yZWN0cyxcbiAgICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIH0pXG4gICAgICA6IG9mZnNldDtcblxuICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XG4gIGRpc3RhbmNlID0gKGRpc3RhbmNlIHx8IDApICogaW52ZXJ0RGlzdGFuY2U7XG5cbiAgcmV0dXJuIFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwXG4gICAgPyB7IHg6IGRpc3RhbmNlLCB5OiBza2lkZGluZyB9XG4gICAgOiB7IHg6IHNraWRkaW5nLCB5OiBkaXN0YW5jZSB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoeyBzdGF0ZSwgb3B0aW9ucywgbmFtZSB9OiBNb2RpZmllckFyZ3VtZW50czxPcHRpb25zPikge1xuICBjb25zdCB7IG9mZnNldCA9IFswLCAwXSB9ID0gb3B0aW9ucztcblxuICBjb25zdCBkYXRhID0gcGxhY2VtZW50cy5yZWR1Y2UoKGFjYywgcGxhY2VtZW50KSA9PiB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcblxuICBjb25zdCB7IHgsIHkgfSA9IGRhdGFbc3RhdGUucGxhY2VtZW50XTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgT2Zmc2V0TW9kaWZpZXIgPSBNb2RpZmllcjwnb2Zmc2V0JywgT3B0aW9ucz47XG5leHBvcnQgZGVmYXVsdCAoe1xuICBuYW1lOiAnb2Zmc2V0JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICBmbjogb2Zmc2V0LFxufTogT2Zmc2V0TW9kaWZpZXIpO1xuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgUGxhY2VtZW50IH0gZnJvbSAnLi4vZW51bXMnO1xuXG5jb25zdCBoYXNoID0geyBsZWZ0OiAncmlnaHQnLCByaWdodDogJ2xlZnQnLCBib3R0b206ICd0b3AnLCB0b3A6ICdib3R0b20nIH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudDogUGxhY2VtZW50KTogUGxhY2VtZW50IHtcbiAgcmV0dXJuIChwbGFjZW1lbnQucmVwbGFjZShcbiAgICAvbGVmdHxyaWdodHxib3R0b218dG9wL2csXG4gICAgbWF0Y2hlZCA9PiBoYXNoW21hdGNoZWRdXG4gICk6IGFueSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBQbGFjZW1lbnQgfSBmcm9tICcuLi9lbnVtcyc7XG5cbmNvbnN0IGhhc2ggPSB7IHN0YXJ0OiAnZW5kJywgZW5kOiAnc3RhcnQnIH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KFxuICBwbGFjZW1lbnQ6IFBsYWNlbWVudFxuKTogUGxhY2VtZW50IHtcbiAgcmV0dXJuIChwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIG1hdGNoZWQgPT4gaGFzaFttYXRjaGVkXSk6IGFueSk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBTdGF0ZSwgUGFkZGluZyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB0eXBlIHtcbiAgUGxhY2VtZW50LFxuICBDb21wdXRlZFBsYWNlbWVudCxcbiAgQm91bmRhcnksXG4gIFJvb3RCb3VuZGFyeSxcbn0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tICcuL2dldFZhcmlhdGlvbic7XG5pbXBvcnQge1xuICB2YXJpYXRpb25QbGFjZW1lbnRzLFxuICBiYXNlUGxhY2VtZW50cyxcbiAgcGxhY2VtZW50cyBhcyBhbGxQbGFjZW1lbnRzLFxufSBmcm9tICcuLi9lbnVtcyc7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSAnLi9kZXRlY3RPdmVyZmxvdyc7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tICcuL2dldEJhc2VQbGFjZW1lbnQnO1xuXG50eXBlIE9wdGlvbnMgPSB7XG4gIHBsYWNlbWVudDogUGxhY2VtZW50LFxuICBwYWRkaW5nOiBQYWRkaW5nLFxuICBib3VuZGFyeTogQm91bmRhcnksXG4gIHJvb3RCb3VuZGFyeTogUm9vdEJvdW5kYXJ5LFxuICBmbGlwVmFyaWF0aW9uczogYm9vbGVhbixcbiAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzPzogQXJyYXk8UGxhY2VtZW50Pixcbn07XG5cbnR5cGUgT3ZlcmZsb3dzTWFwID0geyBbQ29tcHV0ZWRQbGFjZW1lbnRdOiBudW1iZXIgfTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoXG4gIHN0YXRlOiAkU2hhcGU8U3RhdGU+LFxuICBvcHRpb25zOiBPcHRpb25zID0ge31cbik6IEFycmF5PENvbXB1dGVkUGxhY2VtZW50PiB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQsXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmcsXG4gICAgZmxpcFZhcmlhdGlvbnMsXG4gICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gYWxsUGxhY2VtZW50cyxcbiAgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3QgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG5cbiAgY29uc3QgcGxhY2VtZW50cyA9IHZhcmlhdGlvblxuICAgID8gZmxpcFZhcmlhdGlvbnNcbiAgICAgID8gdmFyaWF0aW9uUGxhY2VtZW50c1xuICAgICAgOiB2YXJpYXRpb25QbGFjZW1lbnRzLmZpbHRlcihcbiAgICAgICAgICAocGxhY2VtZW50KSA9PiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uXG4gICAgICAgIClcbiAgICA6IGJhc2VQbGFjZW1lbnRzO1xuXG4gIGxldCBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMuZmlsdGVyKFxuICAgIChwbGFjZW1lbnQpID0+IGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMFxuICApO1xuXG4gIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG4gIH1cblxuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuICBjb25zdCBvdmVyZmxvd3M6IE92ZXJmbG93c01hcCA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZSgoYWNjLCBwbGFjZW1lbnQpID0+IHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcsXG4gICAgfSlbZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpXTtcblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KChhLCBiKSA9PiBvdmVyZmxvd3NbYV0gLSBvdmVyZmxvd3NbYl0pO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgUGxhY2VtZW50LCBCb3VuZGFyeSwgUm9vdEJvdW5kYXJ5IH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IHR5cGUgeyBNb2RpZmllckFyZ3VtZW50cywgTW9kaWZpZXIsIFBhZGRpbmcgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQgZnJvbSAnLi4vdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQnO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSAnLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudCc7XG5pbXBvcnQgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQgZnJvbSAnLi4vdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQnO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gJy4uL3V0aWxzL2RldGVjdE92ZXJmbG93JztcbmltcG9ydCBjb21wdXRlQXV0b1BsYWNlbWVudCBmcm9tICcuLi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudCc7XG5pbXBvcnQgeyBib3R0b20sIHRvcCwgc3RhcnQsIHJpZ2h0LCBsZWZ0LCBhdXRvIH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tICcuLi91dGlscy9nZXRWYXJpYXRpb24nO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBPcHRpb25zID0ge1xuICBtYWluQXhpczogYm9vbGVhbixcbiAgYWx0QXhpczogYm9vbGVhbixcbiAgZmFsbGJhY2tQbGFjZW1lbnRzOiBBcnJheTxQbGFjZW1lbnQ+LFxuICBwYWRkaW5nOiBQYWRkaW5nLFxuICBib3VuZGFyeTogQm91bmRhcnksXG4gIHJvb3RCb3VuZGFyeTogUm9vdEJvdW5kYXJ5LFxuICBhbHRCb3VuZGFyeTogYm9vbGVhbixcbiAgZmxpcFZhcmlhdGlvbnM6IGJvb2xlYW4sXG4gIGFsbG93ZWRBdXRvUGxhY2VtZW50czogQXJyYXk8UGxhY2VtZW50Pixcbn07XG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudDogUGxhY2VtZW50KTogQXJyYXk8UGxhY2VtZW50PiB7XG4gIGlmIChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgcmV0dXJuIFtcbiAgICBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLFxuICAgIG9wcG9zaXRlUGxhY2VtZW50LFxuICAgIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KSxcbiAgXTtcbn1cblxuZnVuY3Rpb24gZmxpcCh7IHN0YXRlLCBvcHRpb25zLCBuYW1lIH06IE1vZGlmaWVyQXJndW1lbnRzPE9wdGlvbnM+KSB7XG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICBhbHRBeGlzOiBjaGVja0FsdEF4aXMgPSB0cnVlLFxuICAgIGZhbGxiYWNrUGxhY2VtZW50czogc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgIHBhZGRpbmcsXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIGFsdEJvdW5kYXJ5LFxuICAgIGZsaXBWYXJpYXRpb25zID0gdHJ1ZSxcbiAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMsXG4gIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuICBjb25zdCBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpO1xuICBjb25zdCBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG5cbiAgY29uc3QgZmFsbGJhY2tQbGFjZW1lbnRzID1cbiAgICBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHxcbiAgICAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9uc1xuICAgICAgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV1cbiAgICAgIDogZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocHJlZmVycmVkUGxhY2VtZW50KSk7XG5cbiAgY29uc3QgcGxhY2VtZW50cyA9IFtwcmVmZXJyZWRQbGFjZW1lbnQsIC4uLmZhbGxiYWNrUGxhY2VtZW50c10ucmVkdWNlKFxuICAgIChhY2MsIHBsYWNlbWVudCkgPT4ge1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQoXG4gICAgICAgIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0b1xuICAgICAgICAgID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICAgICAgICBib3VuZGFyeSxcbiAgICAgICAgICAgICAgcm9vdEJvdW5kYXJ5LFxuICAgICAgICAgICAgICBwYWRkaW5nLFxuICAgICAgICAgICAgICBmbGlwVmFyaWF0aW9ucyxcbiAgICAgICAgICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICA6IHBsYWNlbWVudFxuICAgICAgKTtcbiAgICB9LFxuICAgIFtdXG4gICk7XG5cbiAgY29uc3QgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgY29uc3QgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcblxuICBjb25zdCBjaGVja3NNYXAgPSBuZXcgTWFwKCk7XG4gIGxldCBtYWtlRmFsbGJhY2tDaGVja3MgPSB0cnVlO1xuICBsZXQgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwbGFjZW1lbnQgPSBwbGFjZW1lbnRzW2ldO1xuICAgIGNvbnN0IGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gICAgY29uc3QgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcbiAgICBjb25zdCBpc1ZlcnRpY2FsID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gICAgY29uc3QgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICAgIGNvbnN0IG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nLFxuICAgIH0pO1xuXG4gICAgbGV0IG1haW5WYXJpYXRpb25TaWRlOiBhbnkgPSBpc1ZlcnRpY2FsXG4gICAgICA/IGlzU3RhcnRWYXJpYXRpb25cbiAgICAgICAgPyByaWdodFxuICAgICAgICA6IGxlZnRcbiAgICAgIDogaXNTdGFydFZhcmlhdGlvblxuICAgICAgPyBib3R0b21cbiAgICAgIDogdG9wO1xuXG4gICAgaWYgKHJlZmVyZW5jZVJlY3RbbGVuXSA+IHBvcHBlclJlY3RbbGVuXSkge1xuICAgICAgbWFpblZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgfVxuXG4gICAgY29uc3QgYWx0VmFyaWF0aW9uU2lkZTogYW55ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuXG4gICAgY29uc3QgY2hlY2tzID0gW107XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbYmFzZVBsYWNlbWVudF0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgY2hlY2tzLnB1c2goXG4gICAgICAgIG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLFxuICAgICAgICBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChjaGVja3MuZXZlcnkoKGNoZWNrKSA9PiBjaGVjaykpIHtcbiAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgIG1ha2VGYWxsYmFja0NoZWNrcyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XG4gIH1cblxuICBpZiAobWFrZUZhbGxiYWNrQ2hlY2tzKSB7XG4gICAgLy8gYDJgIG1heSBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMg4oCTIHJlc2VhcmNoIGxhdGVyXG4gICAgY29uc3QgbnVtYmVyT2ZDaGVja3MgPSBmbGlwVmFyaWF0aW9ucyA/IDMgOiAxO1xuXG4gICAgZm9yIChsZXQgaSA9IG51bWJlck9mQ2hlY2tzOyBpID4gMDsgaS0tKSB7XG4gICAgICBjb25zdCBmaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50cy5maW5kKChwbGFjZW1lbnQpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xuICAgICAgICBpZiAoY2hlY2tzKSB7XG4gICAgICAgICAgcmV0dXJuIGNoZWNrcy5zbGljZSgwLCBpKS5ldmVyeSgoY2hlY2spID0+IGNoZWNrKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgRmxpcE1vZGlmaWVyID0gTW9kaWZpZXI8J2ZsaXAnLCBPcHRpb25zPjtcbmV4cG9ydCBkZWZhdWx0ICh7XG4gIG5hbWU6ICdmbGlwJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGZsaXAsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXG4gIGRhdGE6IHsgX3NraXA6IGZhbHNlIH0sXG59OiBGbGlwTW9kaWZpZXIpO1xuIiwiLy8gQGZsb3dcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QWx0QXhpcyhheGlzOiAneCcgfCAneScpOiAneCcgfCAneScge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB7IG1heCBhcyBtYXRoTWF4LCBtaW4gYXMgbWF0aE1pbiB9IGZyb20gJy4vbWF0aCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW4obWluOiBudW1iZXIsIHZhbHVlOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIG1hdGhNYXgobWluLCBtYXRoTWluKHZhbHVlLCBtYXgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbk1heENsYW1wKG1pbjogbnVtYmVyLCB2YWx1ZTogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICBjb25zdCB2ID0gd2l0aGluKG1pbiwgdmFsdWUsIG1heCk7XG4gIHJldHVybiB2ID4gbWF4ID8gbWF4IDogdjtcbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHN0YXJ0IH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IHR5cGUgeyBQbGFjZW1lbnQsIEJvdW5kYXJ5LCBSb290Qm91bmRhcnkgfSBmcm9tICcuLi9lbnVtcyc7XG5pbXBvcnQgdHlwZSB7IFJlY3QsIE1vZGlmaWVyQXJndW1lbnRzLCBNb2RpZmllciwgUGFkZGluZyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gJy4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQnO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tICcuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQnO1xuaW1wb3J0IGdldEFsdEF4aXMgZnJvbSAnLi4vdXRpbHMvZ2V0QWx0QXhpcyc7XG5pbXBvcnQgeyB3aXRoaW4sIHdpdGhpbk1heENsYW1wIH0gZnJvbSAnLi4vdXRpbHMvd2l0aGluJztcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gJy4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0JztcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSAnLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudCc7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSAnLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cnO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tICcuLi91dGlscy9nZXRWYXJpYXRpb24nO1xuaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tICcuLi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QnO1xuaW1wb3J0IHsgbWluIGFzIG1hdGhNaW4sIG1heCBhcyBtYXRoTWF4IH0gZnJvbSAnLi4vdXRpbHMvbWF0aCc7XG5cbnR5cGUgVGV0aGVyT2Zmc2V0ID1cbiAgfCAoKHtcbiAgICAgIHBvcHBlcjogUmVjdCxcbiAgICAgIHJlZmVyZW5jZTogUmVjdCxcbiAgICAgIHBsYWNlbWVudDogUGxhY2VtZW50LFxuICAgIH0pID0+IG51bWJlciB8IHsgbWFpbkF4aXM6IG51bWJlciwgYWx0QXhpczogbnVtYmVyIH0pXG4gIHwgbnVtYmVyXG4gIHwgeyBtYWluQXhpczogbnVtYmVyLCBhbHRBeGlzOiBudW1iZXIgfTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuZXhwb3J0IHR5cGUgT3B0aW9ucyA9IHtcbiAgLyogUHJldmVudHMgYm91bmRhcmllcyBvdmVyZmxvdyBvbiB0aGUgbWFpbiBheGlzICovXG4gIG1haW5BeGlzOiBib29sZWFuLFxuICAvKiBQcmV2ZW50cyBib3VuZGFyaWVzIG92ZXJmbG93IG9uIHRoZSBhbHRlcm5hdGUgYXhpcyAqL1xuICBhbHRBeGlzOiBib29sZWFuLFxuICAvKiBUaGUgYXJlYSB0byBjaGVjayB0aGUgcG9wcGVyIGlzIG92ZXJmbG93aW5nIGluICovXG4gIGJvdW5kYXJ5OiBCb3VuZGFyeSxcbiAgLyogSWYgdGhlIHBvcHBlciBpcyBub3Qgb3ZlcmZsb3dpbmcgdGhlIG1haW4gYXJlYSwgZmFsbGJhY2sgdG8gdGhpcyBvbmUgKi9cbiAgcm9vdEJvdW5kYXJ5OiBSb290Qm91bmRhcnksXG4gIC8qIFVzZSB0aGUgcmVmZXJlbmNlJ3MgXCJjbGlwcGluZ1BhcmVudHNcIiBib3VuZGFyeSBjb250ZXh0ICovXG4gIGFsdEJvdW5kYXJ5OiBib29sZWFuLFxuICAvKipcbiAgICogQWxsb3dzIHRoZSBwb3BwZXIgdG8gb3ZlcmZsb3cgZnJvbSBpdHMgYm91bmRhcmllcyB0byBrZWVwIGl0IG5lYXIgaXRzXG4gICAqIHJlZmVyZW5jZSBlbGVtZW50XG4gICAqL1xuICB0ZXRoZXI6IGJvb2xlYW4sXG4gIC8qIE9mZnNldHMgd2hlbiB0aGUgYHRldGhlcmAgb3B0aW9uIHNob3VsZCBhY3RpdmF0ZSAqL1xuICB0ZXRoZXJPZmZzZXQ6IFRldGhlck9mZnNldCxcbiAgLyogU2V0cyBhIHBhZGRpbmcgdG8gdGhlIHByb3ZpZGVkIGJvdW5kYXJ5ICovXG4gIHBhZGRpbmc6IFBhZGRpbmcsXG59O1xuXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coeyBzdGF0ZSwgb3B0aW9ucywgbmFtZSB9OiBNb2RpZmllckFyZ3VtZW50czxPcHRpb25zPikge1xuICBjb25zdCB7XG4gICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgIGFsdEF4aXM6IGNoZWNrQWx0QXhpcyA9IGZhbHNlLFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBhbHRCb3VuZGFyeSxcbiAgICBwYWRkaW5nLFxuICAgIHRldGhlciA9IHRydWUsXG4gICAgdGV0aGVyT2Zmc2V0ID0gMCxcbiAgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3Qgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBwYWRkaW5nLFxuICAgIGFsdEJvdW5kYXJ5LFxuICB9KTtcbiAgY29uc3QgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgY29uc3QgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCk7XG4gIGNvbnN0IGlzQmFzZVBsYWNlbWVudCA9ICF2YXJpYXRpb247XG4gIGNvbnN0IG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICBjb25zdCBhbHRBeGlzID0gZ2V0QWx0QXhpcyhtYWluQXhpcyk7XG4gIGNvbnN0IHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIGNvbnN0IHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIGNvbnN0IHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIGNvbnN0IHRldGhlck9mZnNldFZhbHVlID1cbiAgICB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHRldGhlck9mZnNldCh7XG4gICAgICAgICAgLi4uc3RhdGUucmVjdHMsXG4gICAgICAgICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnQsXG4gICAgICAgIH0pXG4gICAgICA6IHRldGhlck9mZnNldDtcbiAgY29uc3Qgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlID1cbiAgICB0eXBlb2YgdGV0aGVyT2Zmc2V0VmFsdWUgPT09ICdudW1iZXInXG4gICAgICA/IHsgbWFpbkF4aXM6IHRldGhlck9mZnNldFZhbHVlLCBhbHRBeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZSB9XG4gICAgICA6IHsgbWFpbkF4aXM6IDAsIGFsdEF4aXM6IDAsIC4uLnRldGhlck9mZnNldFZhbHVlIH07XG4gIGNvbnN0IG9mZnNldE1vZGlmaWVyU3RhdGUgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFxuICAgID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XVxuICAgIDogbnVsbDtcblxuICBjb25zdCBkYXRhID0geyB4OiAwLCB5OiAwIH07XG5cbiAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICBjb25zdCBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgIGNvbnN0IGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICBjb25zdCBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcblxuICAgIGNvbnN0IG1pbiA9IG9mZnNldCArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICBjb25zdCBtYXggPSBvZmZzZXQgLSBvdmVyZmxvd1thbHRTaWRlXTtcblxuICAgIGNvbnN0IGFkZGl0aXZlID0gdGV0aGVyID8gLXBvcHBlclJlY3RbbGVuXSAvIDIgOiAwO1xuXG4gICAgY29uc3QgbWluTGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IHJlZmVyZW5jZVJlY3RbbGVuXSA6IHBvcHBlclJlY3RbbGVuXTtcbiAgICBjb25zdCBtYXhMZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gLXBvcHBlclJlY3RbbGVuXSA6IC1yZWZlcmVuY2VSZWN0W2xlbl07XG5cbiAgICAvLyBXZSBuZWVkIHRvIGluY2x1ZGUgdGhlIGFycm93IGluIHRoZSBjYWxjdWxhdGlvbiBzbyB0aGUgYXJyb3cgZG9lc24ndCBnb1xuICAgIC8vIG91dHNpZGUgdGhlIHJlZmVyZW5jZSBib3VuZHNcbiAgICBjb25zdCBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgICBjb25zdCBhcnJvd1JlY3QgPVxuICAgICAgdGV0aGVyICYmIGFycm93RWxlbWVudFxuICAgICAgICA/IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KVxuICAgICAgICA6IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICAgIGNvbnN0IGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXVxuICAgICAgPyBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10ucGFkZGluZ1xuICAgICAgOiBnZXRGcmVzaFNpZGVPYmplY3QoKTtcbiAgICBjb25zdCBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xuICAgIGNvbnN0IGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTtcblxuICAgIC8vIElmIHRoZSByZWZlcmVuY2UgbGVuZ3RoIGlzIHNtYWxsZXIgdGhhbiB0aGUgYXJyb3cgbGVuZ3RoLCB3ZSBkb24ndCB3YW50XG4gICAgLy8gdG8gaW5jbHVkZSBpdHMgZnVsbCBzaXplIGluIHRoZSBjYWxjdWxhdGlvbi4gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbFxuICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXG4gICAgLy8gcmVmZXJlbmNlIGlzIG5vdCBvdmVyZmxvd2luZyBhcyB3ZWxsIChlLmcuIHZpcnR1YWwgZWxlbWVudHMgd2l0aCBub1xuICAgIC8vIHdpZHRoIG9yIGhlaWdodClcbiAgICBjb25zdCBhcnJvd0xlbiA9IHdpdGhpbigwLCByZWZlcmVuY2VSZWN0W2xlbl0sIGFycm93UmVjdFtsZW5dKTtcblxuICAgIGNvbnN0IG1pbk9mZnNldCA9IGlzQmFzZVBsYWNlbWVudFxuICAgICAgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC1cbiAgICAgICAgYWRkaXRpdmUgLVxuICAgICAgICBhcnJvd0xlbiAtXG4gICAgICAgIGFycm93UGFkZGluZ01pbiAtXG4gICAgICAgIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpc1xuICAgICAgOiBtaW5MZW4gLVxuICAgICAgICBhcnJvd0xlbiAtXG4gICAgICAgIGFycm93UGFkZGluZ01pbiAtXG4gICAgICAgIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICBjb25zdCBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnRcbiAgICAgID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgK1xuICAgICAgICBhZGRpdGl2ZSArXG4gICAgICAgIGFycm93TGVuICtcbiAgICAgICAgYXJyb3dQYWRkaW5nTWF4ICtcbiAgICAgICAgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzXG4gICAgICA6IG1heExlbiArXG4gICAgICAgIGFycm93TGVuICtcbiAgICAgICAgYXJyb3dQYWRkaW5nTWF4ICtcbiAgICAgICAgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuXG4gICAgY29uc3QgYXJyb3dPZmZzZXRQYXJlbnQgPVxuICAgICAgc3RhdGUuZWxlbWVudHMuYXJyb3cgJiYgZ2V0T2Zmc2V0UGFyZW50KHN0YXRlLmVsZW1lbnRzLmFycm93KTtcbiAgICBjb25zdCBjbGllbnRPZmZzZXQgPSBhcnJvd09mZnNldFBhcmVudFxuICAgICAgPyBtYWluQXhpcyA9PT0gJ3knXG4gICAgICAgID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50VG9wIHx8IDBcbiAgICAgICAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRMZWZ0IHx8IDBcbiAgICAgIDogMDtcblxuICAgIGNvbnN0IG9mZnNldE1vZGlmaWVyVmFsdWUgPSBvZmZzZXRNb2RpZmllclN0YXRlPy5bbWFpbkF4aXNdID8/IDA7XG4gICAgY29uc3QgdGV0aGVyTWluID0gb2Zmc2V0ICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcbiAgICBjb25zdCB0ZXRoZXJNYXggPSBvZmZzZXQgKyBtYXhPZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlO1xuXG4gICAgY29uc3QgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKFxuICAgICAgdGV0aGVyID8gbWF0aE1pbihtaW4sIHRldGhlck1pbikgOiBtaW4sXG4gICAgICBvZmZzZXQsXG4gICAgICB0ZXRoZXIgPyBtYXRoTWF4KG1heCwgdGV0aGVyTWF4KSA6IG1heFxuICAgICk7XG5cbiAgICBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcbiAgfVxuXG4gIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICBjb25zdCBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xuICAgIGNvbnN0IGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gYm90dG9tIDogcmlnaHQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1thbHRBeGlzXTtcblxuICAgIGNvbnN0IGxlbiA9IGFsdEF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIGNvbnN0IG1pbiA9IG9mZnNldCArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICBjb25zdCBtYXggPSBvZmZzZXQgLSBvdmVyZmxvd1thbHRTaWRlXTtcblxuICAgIGNvbnN0IGlzT3JpZ2luU2lkZSA9IFt0b3AsIGxlZnRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgY29uc3Qgb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IG9mZnNldE1vZGlmaWVyU3RhdGU/LlthbHRBeGlzXSA/PyAwO1xuICAgIGNvbnN0IHRldGhlck1pbiA9IGlzT3JpZ2luU2lkZVxuICAgICAgPyBtaW5cbiAgICAgIDogb2Zmc2V0IC1cbiAgICAgICAgcmVmZXJlbmNlUmVjdFtsZW5dIC1cbiAgICAgICAgcG9wcGVyUmVjdFtsZW5dIC1cbiAgICAgICAgb2Zmc2V0TW9kaWZpZXJWYWx1ZSArXG4gICAgICAgIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzO1xuICAgIGNvbnN0IHRldGhlck1heCA9IGlzT3JpZ2luU2lkZVxuICAgICAgPyBvZmZzZXQgK1xuICAgICAgICByZWZlcmVuY2VSZWN0W2xlbl0gK1xuICAgICAgICBwb3BwZXJSZWN0W2xlbl0gLVxuICAgICAgICBvZmZzZXRNb2RpZmllclZhbHVlIC1cbiAgICAgICAgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXNcbiAgICAgIDogbWF4O1xuXG4gICAgY29uc3QgcHJldmVudGVkT2Zmc2V0ID1cbiAgICAgIHRldGhlciAmJiBpc09yaWdpblNpZGVcbiAgICAgICAgPyB3aXRoaW5NYXhDbGFtcCh0ZXRoZXJNaW4sIG9mZnNldCwgdGV0aGVyTWF4KVxuICAgICAgICA6IHdpdGhpbih0ZXRoZXIgPyB0ZXRoZXJNaW4gOiBtaW4sIG9mZnNldCwgdGV0aGVyID8gdGV0aGVyTWF4IDogbWF4KTtcblxuICAgIHBvcHBlck9mZnNldHNbYWx0QXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVthbHRBeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBQcmV2ZW50T3ZlcmZsb3dNb2RpZmllciA9IE1vZGlmaWVyPCdwcmV2ZW50T3ZlcmZsb3cnLCBPcHRpb25zPjtcbmV4cG9ydCBkZWZhdWx0ICh7XG4gIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogcHJldmVudE92ZXJmbG93LFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddLFxufTogUHJldmVudE92ZXJmbG93TW9kaWZpZXIpO1xuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgTW9kaWZpZXIsIE1vZGlmaWVyQXJndW1lbnRzLCBQYWRkaW5nLCBSZWN0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBQbGFjZW1lbnQgfSBmcm9tICcuLi9lbnVtcyc7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tICcuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50JztcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gJy4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0JztcbmltcG9ydCBjb250YWlucyBmcm9tICcuLi9kb20tdXRpbHMvY29udGFpbnMnO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tICcuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50JztcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSAnLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50JztcbmltcG9ydCB7IHdpdGhpbiB9IGZyb20gJy4uL3V0aWxzL3dpdGhpbic7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gJy4uL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdCc7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gJy4uL3V0aWxzL2V4cGFuZFRvSGFzaE1hcCc7XG5pbXBvcnQgeyBsZWZ0LCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHRvcCwgYm90dG9tIH0gZnJvbSAnLi4vZW51bXMnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBPcHRpb25zID0ge1xuICBlbGVtZW50OiBIVE1MRWxlbWVudCB8IHN0cmluZyB8IG51bGwsXG4gIHBhZGRpbmc6XG4gICAgfCBQYWRkaW5nXG4gICAgfCAoKHt8XG4gICAgICAgIHBvcHBlcjogUmVjdCxcbiAgICAgICAgcmVmZXJlbmNlOiBSZWN0LFxuICAgICAgICBwbGFjZW1lbnQ6IFBsYWNlbWVudCxcbiAgICAgIHx9KSA9PiBQYWRkaW5nKSxcbn07XG5cbmNvbnN0IHRvUGFkZGluZ09iamVjdCA9IChwYWRkaW5nLCBzdGF0ZSkgPT4ge1xuICBwYWRkaW5nID1cbiAgICB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwYWRkaW5nKHsgLi4uc3RhdGUucmVjdHMsIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50IH0pXG4gICAgICA6IHBhZGRpbmc7XG5cbiAgcmV0dXJuIG1lcmdlUGFkZGluZ09iamVjdChcbiAgICB0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcidcbiAgICAgID8gcGFkZGluZ1xuICAgICAgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpXG4gICk7XG59O1xuXG5mdW5jdGlvbiBhcnJvdyh7IHN0YXRlLCBuYW1lLCBvcHRpb25zIH06IE1vZGlmaWVyQXJndW1lbnRzPE9wdGlvbnM+KSB7XG4gIGNvbnN0IGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICBjb25zdCBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICBjb25zdCBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICBjb25zdCBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gIGNvbnN0IGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgaWYgKCFhcnJvd0VsZW1lbnQgfHwgIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gdG9QYWRkaW5nT2JqZWN0KG9wdGlvbnMucGFkZGluZywgc3RhdGUpO1xuICBjb25zdCBhcnJvd1JlY3QgPSBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCk7XG4gIGNvbnN0IG1pblByb3AgPSBheGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICBjb25zdCBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG5cbiAgY29uc3QgZW5kRGlmZiA9XG4gICAgc3RhdGUucmVjdHMucmVmZXJlbmNlW2xlbl0gK1xuICAgIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXSAtXG4gICAgcG9wcGVyT2Zmc2V0c1theGlzXSAtXG4gICAgc3RhdGUucmVjdHMucG9wcGVyW2xlbl07XG4gIGNvbnN0IHN0YXJ0RGlmZiA9IHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc107XG5cbiAgY29uc3QgYXJyb3dPZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoYXJyb3dFbGVtZW50KTtcbiAgY29uc3QgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50XG4gICAgPyBheGlzID09PSAneSdcbiAgICAgID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDBcbiAgICAgIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMFxuICAgIDogMDtcblxuICBjb25zdCBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjtcblxuICAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIHBvcHBlciBpZiB0aGUgY2VudGVyIHBvaW50IGlzXG4gIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcbiAgY29uc3QgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgY29uc3QgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgY29uc3QgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd1JlY3RbbGVuXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgY29uc3Qgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpO1xuXG4gIC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cbiAgY29uc3QgYXhpc1Byb3A6IHN0cmluZyA9IGF4aXM7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XG4gICAgW2F4aXNQcm9wXTogb2Zmc2V0LFxuICAgIGNlbnRlck9mZnNldDogb2Zmc2V0IC0gY2VudGVyLFxuICB9O1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoeyBzdGF0ZSwgb3B0aW9ucyB9OiBNb2RpZmllckFyZ3VtZW50czxPcHRpb25zPikge1xuICBsZXQgeyBlbGVtZW50OiBhcnJvd0VsZW1lbnQgPSAnW2RhdGEtcG9wcGVyLWFycm93XScgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKGFycm93RWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ1NTIHNlbGVjdG9yXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB0eXBlIEFycm93TW9kaWZpZXIgPSBNb2RpZmllcjwnYXJyb3cnLCBPcHRpb25zPjtcbmV4cG9ydCBkZWZhdWx0ICh7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0LFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J10sXG59OiBBcnJvd01vZGlmaWVyKTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgdHlwZSB7XG4gIE1vZGlmaWVyQXJndW1lbnRzLFxuICBNb2RpZmllcixcbiAgUmVjdCxcbiAgU2lkZU9iamVjdCxcbiAgT2Zmc2V0cyxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IH0gZnJvbSAnLi4vZW51bXMnO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gJy4uL3V0aWxzL2RldGVjdE92ZXJmbG93JztcblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMoXG4gIG92ZXJmbG93OiBTaWRlT2JqZWN0LFxuICByZWN0OiBSZWN0LFxuICBwcmV2ZW50ZWRPZmZzZXRzOiBPZmZzZXRzID0geyB4OiAwLCB5OiAwIH1cbik6IFNpZGVPYmplY3Qge1xuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQgLSBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCArIHByZXZlbnRlZE9mZnNldHMueCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0ICsgcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoIC0gcHJldmVudGVkT2Zmc2V0cy54LFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3c6IFNpZGVPYmplY3QpOiBib29sZWFuIHtcbiAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoKHNpZGUpID0+IG92ZXJmbG93W3NpZGVdID49IDApO1xufVxuXG5mdW5jdGlvbiBoaWRlKHsgc3RhdGUsIG5hbWUgfTogTW9kaWZpZXJBcmd1bWVudHM8e3x8fT4pIHtcbiAgY29uc3QgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgY29uc3QgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgY29uc3QgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuXG4gIGNvbnN0IHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZScsXG4gIH0pO1xuICBjb25zdCBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYWx0Qm91bmRhcnk6IHRydWUsXG4gIH0pO1xuXG4gIGNvbnN0IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKFxuICAgIHJlZmVyZW5jZU92ZXJmbG93LFxuICAgIHJlZmVyZW5jZVJlY3RcbiAgKTtcbiAgY29uc3QgcG9wcGVyRXNjYXBlT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKFxuICAgIHBvcHBlckFsdE92ZXJmbG93LFxuICAgIHBvcHBlclJlY3QsXG4gICAgcHJldmVudGVkT2Zmc2V0c1xuICApO1xuXG4gIGNvbnN0IGlzUmVmZXJlbmNlSGlkZGVuID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyk7XG4gIGNvbnN0IGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0cyxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkLFxuICB9O1xuXG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0ge1xuICAgIC4uLnN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLFxuICAgICdkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuJzogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgJ2RhdGEtcG9wcGVyLWVzY2FwZWQnOiBoYXNQb3BwZXJFc2NhcGVkLFxuICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgdHlwZSBIaWRlTW9kaWZpZXIgPSBNb2RpZmllcjwnaGlkZScsIHt8fH0+O1xuZXhwb3J0IGRlZmF1bHQgKHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZSxcbn06IEhpZGVNb2RpZmllcik7XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHsgcG9wcGVyR2VuZXJhdG9yLCBkZXRlY3RPdmVyZmxvdyB9IGZyb20gJy4vY3JlYXRlUG9wcGVyJztcblxuaW1wb3J0IGV2ZW50TGlzdGVuZXJzIGZyb20gJy4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzJztcbmltcG9ydCBwb3BwZXJPZmZzZXRzIGZyb20gJy4vbW9kaWZpZXJzL3BvcHBlck9mZnNldHMnO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSAnLi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcyc7XG5pbXBvcnQgYXBwbHlTdHlsZXMgZnJvbSAnLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMnO1xuXG5leHBvcnQgdHlwZSAqIGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBkZWZhdWx0TW9kaWZpZXJzID0gW1xuICBldmVudExpc3RlbmVycyxcbiAgcG9wcGVyT2Zmc2V0cyxcbiAgY29tcHV0ZVN0eWxlcyxcbiAgYXBwbHlTdHlsZXMsXG5dO1xuXG5jb25zdCBjcmVhdGVQb3BwZXIgPSBwb3BwZXJHZW5lcmF0b3IoeyBkZWZhdWx0TW9kaWZpZXJzIH0pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3cgfTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSAnLi9jcmVhdGVQb3BwZXInO1xuXG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSAnLi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMnO1xuaW1wb3J0IHBvcHBlck9mZnNldHMgZnJvbSAnLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cyc7XG5pbXBvcnQgY29tcHV0ZVN0eWxlcyBmcm9tICcuL21vZGlmaWVycy9jb21wdXRlU3R5bGVzJztcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tICcuL21vZGlmaWVycy9hcHBseVN0eWxlcyc7XG5pbXBvcnQgb2Zmc2V0IGZyb20gJy4vbW9kaWZpZXJzL29mZnNldCc7XG5pbXBvcnQgZmxpcCBmcm9tICcuL21vZGlmaWVycy9mbGlwJztcbmltcG9ydCBwcmV2ZW50T3ZlcmZsb3cgZnJvbSAnLi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93JztcbmltcG9ydCBhcnJvdyBmcm9tICcuL21vZGlmaWVycy9hcnJvdyc7XG5pbXBvcnQgaGlkZSBmcm9tICcuL21vZGlmaWVycy9oaWRlJztcblxuZXhwb3J0IHR5cGUgKiBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgZGVmYXVsdE1vZGlmaWVycyA9IFtcbiAgZXZlbnRMaXN0ZW5lcnMsXG4gIHBvcHBlck9mZnNldHMsXG4gIGNvbXB1dGVTdHlsZXMsXG4gIGFwcGx5U3R5bGVzLFxuICBvZmZzZXQsXG4gIGZsaXAsXG4gIHByZXZlbnRPdmVyZmxvdyxcbiAgYXJyb3csXG4gIGhpZGUsXG5dO1xuXG5jb25zdCBjcmVhdGVQb3BwZXIgPSBwb3BwZXJHZW5lcmF0b3IoeyBkZWZhdWx0TW9kaWZpZXJzIH0pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3cgfTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciBhcyBjcmVhdGVQb3BwZXJMaXRlIH0gZnJvbSAnLi9wb3BwZXItbGl0ZSc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5leHBvcnQgKiBmcm9tICcuL21vZGlmaWVycyc7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUllLFNBQVNBLFNBQVRBLENBQW1CQyxJQUFuQixFQUF5QjtFQUN0QyxJQUFJQSxJQUFJLElBQUksSUFBWixFQUFrQjtJQUNoQixPQUFPQyxNQUFQO0VBQ0Q7RUFFRCxJQUFJRCxJQUFJLENBQUNFLFFBQUwsT0FBb0IsaUJBQXhCLEVBQTJDO0lBQ3pDLElBQU1DLGFBQWEsR0FBR0gsSUFBSSxDQUFDRyxhQUEzQjtJQUNBLE9BQU9BLGFBQWEsR0FBR0EsYUFBYSxDQUFDQyxXQUFkLElBQTZCSCxNQUFoQyxH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