aad9e4ada501e01dd9e7851d456d7fb2
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.alpha = alpha;
exports.colorChannel = void 0;
exports.darken = darken;
exports.decomposeColor = decomposeColor;
exports.emphasize = emphasize;
exports.getContrastRatio = getContrastRatio;
exports.getLuminance = getLuminance;
exports.hexToRgb = hexToRgb;
exports.hslToRgb = hslToRgb;
exports.lighten = lighten;
exports.private_safeAlpha = private_safeAlpha;
exports.private_safeColorChannel = void 0;
exports.private_safeDarken = private_safeDarken;
exports.private_safeEmphasize = private_safeEmphasize;
exports.private_safeLighten = private_safeLighten;
exports.recomposeColor = recomposeColor;
exports.rgbToHex = rgbToHex;
var _utils = require("@mui/utils");
/* eslint-disable @typescript-eslint/naming-convention */

/**
 * Returns a number whose value is limited to the given range.
 * @param {number} value The value to be clamped
 * @param {number} min The lower boundary of the output range
 * @param {number} max The upper boundary of the output range
 * @returns {number} A number in the range [min, max]
 */
function clamp(value, min = 0, max = 1) {
  if (process.env.NODE_ENV !== 'production') {
    if (value < min || value > max) {
      console.error(`MUI: The value provided ${value} is out of range [${min}, ${max}].`);
    }
  }
  return Math.min(Math.max(min, value), max);
}

/**
 * Converts a color from CSS hex format to CSS rgb format.
 * @param {string} color - Hex color, i.e. #nnn or #nnnnnn
 * @returns {string} A CSS rgb color string
 */
function hexToRgb(color) {
  color = color.slice(1);
  const re = new RegExp(`.{1,${color.length >= 6 ? 2 : 1}}`, 'g');
  let colors = color.match(re);
  if (colors && colors[0].length === 1) {
    colors = colors.map(n => n + n);
  }
  return colors ? `rgb${colors.length === 4 ? 'a' : ''}(${colors.map((n, index) => {
    return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1000) / 1000;
  }).join(', ')})` : '';
}
function intToHex(int) {
  const hex = int.toString(16);
  return hex.length === 1 ? `0${hex}` : hex;
}

/**
 * Returns an object with the type and values of a color.
 *
 * Note: Does not support rgb % values.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @returns {object} - A MUI color object: {type: string, values: number[]}
 */
function decomposeColor(color) {
  // Idempotent
  if (color.type) {
    return color;
  }
  if (color.charAt(0) === '#') {
    return decomposeColor(hexToRgb(color));
  }
  const marker = color.indexOf('(');
  const type = color.substring(0, marker);
  if (['rgb', 'rgba', 'hsl', 'hsla', 'color'].indexOf(type) === -1) {
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: Unsupported \`${color}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : (0, _utils.formatMuiErrorMessage)(9, color));
  }
  let values = color.substring(marker + 1, color.length - 1);
  let colorSpace;
  if (type === 'color') {
    values = values.split(' ');
    colorSpace = values.shift();
    if (values.length === 4 && values[3].charAt(0) === '/') {
      values[3] = values[3].slice(1);
    }
    if (['srgb', 'display-p3', 'a98-rgb', 'prophoto-rgb', 'rec-2020'].indexOf(colorSpace) === -1) {
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: unsupported \`${colorSpace}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : (0, _utils.formatMuiErrorMessage)(10, colorSpace));
    }
  } else {
    values = values.split(',');
  }
  values = values.map(value => parseFloat(value));
  return {
    type,
    values,
    colorSpace
  };
}

/**
 * Returns a channel created from the input color.
 *
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @returns {string} - The channel for the color, that can be used in rgba or hsla colors
 */
const colorChannel = color => {
  const decomposedColor = decomposeColor(color);
  return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.indexOf('hsl') !== -1 && idx !== 0 ? `${val}%` : val).join(' ');
};
exports.colorChannel = colorChannel;
const private_safeColorChannel = (color, warning) => {
  try {
    return colorChannel(color);
  } catch (error) {
    if (warning && process.env.NODE_ENV !== 'production') {
      console.warn(warning);
    }
    return color;
  }
};

/**
 * Converts a color object with type and values to a string.
 * @param {object} color - Decomposed color
 * @param {string} color.type - One of: 'rgb', 'rgba', 'hsl', 'hsla', 'color'
 * @param {array} color.values - [n,n,n] or [n,n,n,n]
 * @returns {string} A CSS color string
 */
exports.private_safeColorChannel = private_safeColorChannel;
function recomposeColor(color) {
  const {
    type,
    colorSpace
  } = color;
  let {
    values
  } = color;
  if (type.indexOf('rgb') !== -1) {
    // Only convert the first 3 values to int (i.e. not alpha)
    values = values.map((n, i) => i < 3 ? parseInt(n, 10) : n);
  } else if (type.indexOf('hsl') !== -1) {
    values[1] = `${values[1]}%`;
    values[2] = `${values[2]}%`;
  }
  if (type.indexOf('color') !== -1) {
    values = `${colorSpace} ${values.join(' ')}`;
  } else {
    values = `${values.join(', ')}`;
  }
  return `${type}(${values})`;
}

/**
 * Converts a color from CSS rgb format to CSS hex format.
 * @param {string} color - RGB color, i.e. rgb(n, n, n)
 * @returns {string} A CSS rgb color string, i.e. #nnnnnn
 */
function rgbToHex(color) {
  // Idempotent
  if (color.indexOf('#') === 0) {
    return color;
  }
  const {
    values
  } = decomposeColor(color);
  return `#${values.map((n, i) => intToHex(i === 3 ? Math.round(255 * n) : n)).join('')}`;
}

/**
 * Converts a color from hsl format to rgb format.
 * @param {string} color - HSL color values
 * @returns {string} rgb color values
 */
function hslToRgb(color) {
  color = decomposeColor(color);
  const {
    values
  } = color;
  const h = values[0];
  const s = values[1] / 100;
  const l = values[2] / 100;
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  let type = 'rgb';
  const rgb = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
  if (color.type === 'hsla') {
    type += 'a';
    rgb.push(values[3]);
  }
  return recomposeColor({
    type,
    values: rgb
  });
}
/**
 * The relative brightness of any point in a color space,
 * normalized to 0 for darkest black and 1 for lightest white.
 *
 * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @returns {number} The relative brightness of the color in the range 0 - 1
 */
function getLuminance(color) {
  color = decomposeColor(color);
  let rgb = color.type === 'hsl' || color.type === 'hsla' ? decomposeColor(hslToRgb(color)).values : color.values;
  rgb = rgb.map(val => {
    if (color.type !== 'color') {
      val /= 255; // normalized
    }

    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  });

  // Truncate at 3 digits
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}

/**
 * Calculates the contrast ratio between two colors.
 *
 * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
 * @param {string} foreground - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @param {string} background - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @returns {number} A contrast ratio value in the range 0 - 21.
 */
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}

/**
 * Sets the absolute transparency of a color.
 * Any existing alpha values are overwritten.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param {number} value - value to set the alpha channel to in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */
function alpha(color, value) {
  color = decomposeColor(color);
  value = clamp(value);
  if (color.type === 'rgb' || color.type === 'hsl') {
    color.type += 'a';
  }
  if (color.type === 'color') {
    color.values[3] = `/${value}`;
  } else {
    color.values[3] = value;
  }
  return recomposeColor(color);
}
function private_safeAlpha(color, value, warning) {
  try {
    return alpha(color, value);
  } catch (error) {
    if (warning && process.env.NODE_ENV !== 'production') {
      console.warn(warning);
    }
    return color;
  }
}

/**
 * Darkens a color.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param {number} coefficient - multiplier in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */
function darken(color, coefficient) {
  color = decomposeColor(color);
  coefficient = clamp(coefficient);
  if (color.type.indexOf('hsl') !== -1) {
    color.values[2] *= 1 - coefficient;
  } else if (color.type.indexOf('rgb') !== -1 || color.type.indexOf('color') !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color.values[i] *= 1 - coefficient;
    }
  }
  return recomposeColor(color);
}
function private_safeDarken(color, coefficient, warning) {
  try {
    return darken(color, coefficient);
  } catch (error) {
    if (warning && process.env.NODE_ENV !== 'production') {
      console.warn(warning);
    }
    return color;
  }
}

/**
 * Lightens a color.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param {number} coefficient - multiplier in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */
function lighten(color, coefficient) {
  color = decomposeColor(color);
  coefficient = clamp(coefficient);
  if (color.type.indexOf('hsl') !== -1) {
    color.values[2] += (100 - color.values[2]) * coefficient;
  } else if (color.type.indexOf('rgb') !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color.values[i] += (255 - color.values[i]) * coefficient;
    }
  } else if (color.type.indexOf('color') !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color.values[i] += (1 - color.values[i]) * coefficient;
    }
  }
  return recomposeColor(color);
}
function private_safeLighten(color, coefficient, warning) {
  try {
    return lighten(color, coefficient);
  } catch (error) {
    if (warning && process.env.NODE_ENV !== 'production') {
      console.warn(warning);
    }
    return color;
  }
}

/**
 * Darken or lighten a color, depending on its luminance.
 * Light colors are darkened, dark colors are lightened.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param {number} coefficient=0.15 - multiplier in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */
function emphasize(color, coefficient = 0.15) {
  return getLuminance(color) > 0.5 ? darken(color, coefficient) : lighten(color, coefficient);
}
function private_safeEmphasize(color, coefficient, warning) {
  try {
    return private_safeEmphasize(color, coefficient);
  } catch (error) {
    if (warning && process.env.NODE_ENV !== 'production') {
      console.warn(warning);
    }
    return color;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFscGhhIiwiY29sb3JDaGFubmVsIiwiZGFya2VuIiwiZGVjb21wb3NlQ29sb3IiLCJlbXBoYXNpemUiLCJnZXRDb250cmFzdFJhdGlvIiwiZ2V0THVtaW5hbmNlIiwiaGV4VG9SZ2IiLCJoc2xUb1JnYiIsImxpZ2h0ZW4iLCJwcml2YXRlX3NhZmVBbHBoYSIsInByaXZhdGVfc2FmZUNvbG9yQ2hhbm5lbCIsInByaXZhdGVfc2FmZURhcmtlbiIsInByaXZhdGVfc2FmZUVtcGhhc2l6ZSIsInByaXZhdGVfc2FmZUxpZ2h0ZW4iLCJyZWNvbXBvc2VDb2xvciIsInJnYlRvSGV4IiwiX3V0aWxzIiwicmVxdWlyZSIsImNsYW1wIiwibWluIiwibWF4IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiY29uc29sZSIsImVycm9yIiwiTWF0aCIsImNvbG9yIiwic2xpY2UiLCJyZSIsIlJlZ0V4cCIsImxlbmd0aCIsImNvbG9ycyIsIm1hdGNoIiwibWFwIiwibiIsImluZGV4IiwicGFyc2VJbnQiLCJyb3VuZCIsImpvaW4iLCJpbnRUb0hleCIsImludCIsImhleCIsInRvU3RyaW5nIiwidHlwZSIsImNoYXJBdCIsIm1hcmtlciIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJFcnJvciIsImZvcm1hdE11aUVycm9yTWVzc2FnZSIsInZhbHVlcyIsImNvbG9yU3BhY2UiLCJzcGxpdCIsInNoaWZ0IiwicGFyc2VGbG9hdCIsImRlY29tcG9zZWRDb2xvciIsInZhbCIsImlkeCIsIndhcm5pbmciLCJ3YXJuIiwiaSIsImgiLCJzIiwibCIsImEiLCJmIiwiayIsInJnYiIsInB1c2giLCJOdW1iZXIiLCJ0b0ZpeGVkIiwiZm9yZWdyb3VuZCIsImJhY2tncm91bmQiLCJsdW1BIiwibHVtQiIsImNvZWZmaWNpZW50Il0sInNvdXJjZXMiOlsiY29sb3JNYW5pcHVsYXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYWxwaGEgPSBhbHBoYTtcbmV4cG9ydHMuY29sb3JDaGFubmVsID0gdm9pZCAwO1xuZXhwb3J0cy5kYXJrZW4gPSBkYXJrZW47XG5leHBvcnRzLmRlY29tcG9zZUNvbG9yID0gZGVjb21wb3NlQ29sb3I7XG5leHBvcnRzLmVtcGhhc2l6ZSA9IGVtcGhhc2l6ZTtcbmV4cG9ydHMuZ2V0Q29udHJhc3RSYXRpbyA9IGdldENvbnRyYXN0UmF0aW87XG5leHBvcnRzLmdldEx1bWluYW5jZSA9IGdldEx1bWluYW5jZTtcbmV4cG9ydHMuaGV4VG9SZ2IgPSBoZXhUb1JnYjtcbmV4cG9ydHMuaHNsVG9SZ2IgPSBoc2xUb1JnYjtcbmV4cG9ydHMubGlnaHRlbiA9IGxpZ2h0ZW47XG5leHBvcnRzLnByaXZhdGVfc2FmZUFscGhhID0gcHJpdmF0ZV9zYWZlQWxwaGE7XG5leHBvcnRzLnByaXZhdGVfc2FmZUNvbG9yQ2hhbm5lbCA9IHZvaWQgMDtcbmV4cG9ydHMucHJpdmF0ZV9zYWZlRGFya2VuID0gcHJpdmF0ZV9zYWZlRGFya2VuO1xuZXhwb3J0cy5wcml2YXRlX3NhZmVFbXBoYXNpemUgPSBwcml2YXRlX3NhZmVFbXBoYXNpemU7XG5leHBvcnRzLnByaXZhdGVfc2FmZUxpZ2h0ZW4gPSBwcml2YXRlX3NhZmVMaWdodGVuO1xuZXhwb3J0cy5yZWNvbXBvc2VDb2xvciA9IHJlY29tcG9zZUNvbG9yO1xuZXhwb3J0cy5yZ2JUb0hleCA9IHJnYlRvSGV4O1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCJAbXVpL3V0aWxzXCIpO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG5cbi8qKlxuICogUmV0dXJucyBhIG51bWJlciB3aG9zZSB2YWx1ZSBpcyBsaW1pdGVkIHRvIHRoZSBnaXZlbiByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2xhbXBlZFxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbG93ZXIgYm91bmRhcnkgb2YgdGhlIG91dHB1dCByYW5nZVxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgdXBwZXIgYm91bmRhcnkgb2YgdGhlIG91dHB1dCByYW5nZVxuICogQHJldHVybnMge251bWJlcn0gQSBudW1iZXIgaW4gdGhlIHJhbmdlIFttaW4sIG1heF1cbiAqL1xuZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiA9IDAsIG1heCA9IDEpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodmFsdWUgPCBtaW4gfHwgdmFsdWUgPiBtYXgpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYE1VSTogVGhlIHZhbHVlIHByb3ZpZGVkICR7dmFsdWV9IGlzIG91dCBvZiByYW5nZSBbJHttaW59LCAke21heH1dLmApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCB2YWx1ZSksIG1heCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBjb2xvciBmcm9tIENTUyBoZXggZm9ybWF0IHRvIENTUyByZ2IgZm9ybWF0LlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gSGV4IGNvbG9yLCBpLmUuICNubm4gb3IgI25ubm5ublxuICogQHJldHVybnMge3N0cmluZ30gQSBDU1MgcmdiIGNvbG9yIHN0cmluZ1xuICovXG5mdW5jdGlvbiBoZXhUb1JnYihjb2xvcikge1xuICBjb2xvciA9IGNvbG9yLnNsaWNlKDEpO1xuICBjb25zdCByZSA9IG5ldyBSZWdFeHAoYC57MSwke2NvbG9yLmxlbmd0aCA+PSA2ID8gMiA6IDF9fWAsICdnJyk7XG4gIGxldCBjb2xvcnMgPSBjb2xvci5tYXRjaChyZSk7XG4gIGlmIChjb2xvcnMgJiYgY29sb3JzWzBdLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbG9ycyA9IGNvbG9ycy5tYXAobiA9PiBuICsgbik7XG4gIH1cbiAgcmV0dXJuIGNvbG9ycyA/IGByZ2Ike2NvbG9ycy5sZW5ndGggPT09IDQgPyAnYScgOiAnJ30oJHtjb2xvcnMubWFwKChuLCBpbmRleCkgPT4ge1xuICAgIHJldHVybiBpbmRleCA8IDMgPyBwYXJzZUludChuLCAxNikgOiBNYXRoLnJvdW5kKHBhcnNlSW50KG4sIDE2KSAvIDI1NSAqIDEwMDApIC8gMTAwMDtcbiAgfSkuam9pbignLCAnKX0pYCA6ICcnO1xufVxuZnVuY3Rpb24gaW50VG9IZXgoaW50KSB7XG4gIGNvbnN0IGhleCA9IGludC50b1N0cmluZygxNik7XG4gIHJldHVybiBoZXgubGVuZ3RoID09PSAxID8gYDAke2hleH1gIDogaGV4O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHR5cGUgYW5kIHZhbHVlcyBvZiBhIGNvbG9yLlxuICpcbiAqIE5vdGU6IERvZXMgbm90IHN1cHBvcnQgcmdiICUgdmFsdWVzLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKSwgY29sb3IoKVxuICogQHJldHVybnMge29iamVjdH0gLSBBIE1VSSBjb2xvciBvYmplY3Q6IHt0eXBlOiBzdHJpbmcsIHZhbHVlczogbnVtYmVyW119XG4gKi9cbmZ1bmN0aW9uIGRlY29tcG9zZUNvbG9yKGNvbG9yKSB7XG4gIC8vIElkZW1wb3RlbnRcbiAgaWYgKGNvbG9yLnR5cGUpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cbiAgaWYgKGNvbG9yLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgcmV0dXJuIGRlY29tcG9zZUNvbG9yKGhleFRvUmdiKGNvbG9yKSk7XG4gIH1cbiAgY29uc3QgbWFya2VyID0gY29sb3IuaW5kZXhPZignKCcpO1xuICBjb25zdCB0eXBlID0gY29sb3Iuc3Vic3RyaW5nKDAsIG1hcmtlcik7XG4gIGlmIChbJ3JnYicsICdyZ2JhJywgJ2hzbCcsICdoc2xhJywgJ2NvbG9yJ10uaW5kZXhPZih0eXBlKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gYE1VSTogVW5zdXBwb3J0ZWQgXFxgJHtjb2xvcn1cXGAgY29sb3IuXG5UaGUgZm9sbG93aW5nIGZvcm1hdHMgYXJlIHN1cHBvcnRlZDogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKSwgY29sb3IoKS5gIDogKDAsIF91dGlscy5mb3JtYXRNdWlFcnJvck1lc3NhZ2UpKDksIGNvbG9yKSk7XG4gIH1cbiAgbGV0IHZhbHVlcyA9IGNvbG9yLnN1YnN0cmluZyhtYXJrZXIgKyAxLCBjb2xvci5sZW5ndGggLSAxKTtcbiAgbGV0IGNvbG9yU3BhY2U7XG4gIGlmICh0eXBlID09PSAnY29sb3InKSB7XG4gICAgdmFsdWVzID0gdmFsdWVzLnNwbGl0KCcgJyk7XG4gICAgY29sb3JTcGFjZSA9IHZhbHVlcy5zaGlmdCgpO1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSA0ICYmIHZhbHVlc1szXS5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgdmFsdWVzWzNdID0gdmFsdWVzWzNdLnNsaWNlKDEpO1xuICAgIH1cbiAgICBpZiAoWydzcmdiJywgJ2Rpc3BsYXktcDMnLCAnYTk4LXJnYicsICdwcm9waG90by1yZ2InLCAncmVjLTIwMjAnXS5pbmRleE9mKGNvbG9yU3BhY2UpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGBNVUk6IHVuc3VwcG9ydGVkIFxcYCR7Y29sb3JTcGFjZX1cXGAgY29sb3Igc3BhY2UuXG5UaGUgZm9sbG93aW5nIGNvbG9yIHNwYWNlcyBhcmUgc3VwcG9ydGVkOiBzcmdiLCBkaXNwbGF5LXAzLCBhOTgtcmdiLCBwcm9waG90by1yZ2IsIHJlYy0yMDIwLmAgOiAoMCwgX3V0aWxzLmZvcm1hdE11aUVycm9yTWVzc2FnZSkoMTAsIGNvbG9yU3BhY2UpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWVzID0gdmFsdWVzLnNwbGl0KCcsJyk7XG4gIH1cbiAgdmFsdWVzID0gdmFsdWVzLm1hcCh2YWx1ZSA9PiBwYXJzZUZsb2F0KHZhbHVlKSk7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICB2YWx1ZXMsXG4gICAgY29sb3JTcGFjZVxuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBjaGFubmVsIGNyZWF0ZWQgZnJvbSB0aGUgaW5wdXQgY29sb3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKSwgY29sb3IoKVxuICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgY2hhbm5lbCBmb3IgdGhlIGNvbG9yLCB0aGF0IGNhbiBiZSB1c2VkIGluIHJnYmEgb3IgaHNsYSBjb2xvcnNcbiAqL1xuY29uc3QgY29sb3JDaGFubmVsID0gY29sb3IgPT4ge1xuICBjb25zdCBkZWNvbXBvc2VkQ29sb3IgPSBkZWNvbXBvc2VDb2xvcihjb2xvcik7XG4gIHJldHVybiBkZWNvbXBvc2VkQ29sb3IudmFsdWVzLnNsaWNlKDAsIDMpLm1hcCgodmFsLCBpZHgpID0+IGRlY29tcG9zZWRDb2xvci50eXBlLmluZGV4T2YoJ2hzbCcpICE9PSAtMSAmJiBpZHggIT09IDAgPyBgJHt2YWx9JWAgOiB2YWwpLmpvaW4oJyAnKTtcbn07XG5leHBvcnRzLmNvbG9yQ2hhbm5lbCA9IGNvbG9yQ2hhbm5lbDtcbmNvbnN0IHByaXZhdGVfc2FmZUNvbG9yQ2hhbm5lbCA9IChjb2xvciwgd2FybmluZykgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBjb2xvckNoYW5uZWwoY29sb3IpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICh3YXJuaW5nICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgY29sb3Igb2JqZWN0IHdpdGggdHlwZSBhbmQgdmFsdWVzIHRvIGEgc3RyaW5nLlxuICogQHBhcmFtIHtvYmplY3R9IGNvbG9yIC0gRGVjb21wb3NlZCBjb2xvclxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yLnR5cGUgLSBPbmUgb2Y6ICdyZ2InLCAncmdiYScsICdoc2wnLCAnaHNsYScsICdjb2xvcidcbiAqIEBwYXJhbSB7YXJyYXl9IGNvbG9yLnZhbHVlcyAtIFtuLG4sbl0gb3IgW24sbixuLG5dXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIENTUyBjb2xvciBzdHJpbmdcbiAqL1xuZXhwb3J0cy5wcml2YXRlX3NhZmVDb2xvckNoYW5uZWwgPSBwcml2YXRlX3NhZmVDb2xvckNoYW5uZWw7XG5mdW5jdGlvbiByZWNvbXBvc2VDb2xvcihjb2xvcikge1xuICBjb25zdCB7XG4gICAgdHlwZSxcbiAgICBjb2xvclNwYWNlXG4gIH0gPSBjb2xvcjtcbiAgbGV0IHtcbiAgICB2YWx1ZXNcbiAgfSA9IGNvbG9yO1xuICBpZiAodHlwZS5pbmRleE9mKCdyZ2InKSAhPT0gLTEpIHtcbiAgICAvLyBPbmx5IGNvbnZlcnQgdGhlIGZpcnN0IDMgdmFsdWVzIHRvIGludCAoaS5lLiBub3QgYWxwaGEpXG4gICAgdmFsdWVzID0gdmFsdWVzLm1hcCgobiwgaSkgPT4gaSA8IDMgPyBwYXJzZUludChuLCAxMCkgOiBuKTtcbiAgfSBlbHNlIGlmICh0eXBlLmluZGV4T2YoJ2hzbCcpICE9PSAtMSkge1xuICAgIHZhbHVlc1sxXSA9IGAke3ZhbHVlc1sxXX0lYDtcbiAgICB2YWx1ZXNbMl0gPSBgJHt2YWx1ZXNbMl19JWA7XG4gIH1cbiAgaWYgKHR5cGUuaW5kZXhPZignY29sb3InKSAhPT0gLTEpIHtcbiAgICB2YWx1ZXMgPSBgJHtjb2xvclNwYWNlfSAke3ZhbHVlcy5qb2luKCcgJyl9YDtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZXMgPSBgJHt2YWx1ZXMuam9pbignLCAnKX1gO1xuICB9XG4gIHJldHVybiBgJHt0eXBlfSgke3ZhbHVlc30pYDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGNvbG9yIGZyb20gQ1NTIHJnYiBmb3JtYXQgdG8gQ1NTIGhleCBmb3JtYXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgLSBSR0IgY29sb3IsIGkuZS4gcmdiKG4sIG4sIG4pXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIENTUyByZ2IgY29sb3Igc3RyaW5nLCBpLmUuICNubm5ubm5cbiAqL1xuZnVuY3Rpb24gcmdiVG9IZXgoY29sb3IpIHtcbiAgLy8gSWRlbXBvdGVudFxuICBpZiAoY29sb3IuaW5kZXhPZignIycpID09PSAwKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG4gIGNvbnN0IHtcbiAgICB2YWx1ZXNcbiAgfSA9IGRlY29tcG9zZUNvbG9yKGNvbG9yKTtcbiAgcmV0dXJuIGAjJHt2YWx1ZXMubWFwKChuLCBpKSA9PiBpbnRUb0hleChpID09PSAzID8gTWF0aC5yb3VuZCgyNTUgKiBuKSA6IG4pKS5qb2luKCcnKX1gO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgY29sb3IgZnJvbSBoc2wgZm9ybWF0IHRvIHJnYiBmb3JtYXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgLSBIU0wgY29sb3IgdmFsdWVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSByZ2IgY29sb3IgdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIGhzbFRvUmdiKGNvbG9yKSB7XG4gIGNvbG9yID0gZGVjb21wb3NlQ29sb3IoY29sb3IpO1xuICBjb25zdCB7XG4gICAgdmFsdWVzXG4gIH0gPSBjb2xvcjtcbiAgY29uc3QgaCA9IHZhbHVlc1swXTtcbiAgY29uc3QgcyA9IHZhbHVlc1sxXSAvIDEwMDtcbiAgY29uc3QgbCA9IHZhbHVlc1syXSAvIDEwMDtcbiAgY29uc3QgYSA9IHMgKiBNYXRoLm1pbihsLCAxIC0gbCk7XG4gIGNvbnN0IGYgPSAobiwgayA9IChuICsgaCAvIDMwKSAlIDEyKSA9PiBsIC0gYSAqIE1hdGgubWF4KE1hdGgubWluKGsgLSAzLCA5IC0gaywgMSksIC0xKTtcbiAgbGV0IHR5cGUgPSAncmdiJztcbiAgY29uc3QgcmdiID0gW01hdGgucm91bmQoZigwKSAqIDI1NSksIE1hdGgucm91bmQoZig4KSAqIDI1NSksIE1hdGgucm91bmQoZig0KSAqIDI1NSldO1xuICBpZiAoY29sb3IudHlwZSA9PT0gJ2hzbGEnKSB7XG4gICAgdHlwZSArPSAnYSc7XG4gICAgcmdiLnB1c2godmFsdWVzWzNdKTtcbiAgfVxuICByZXR1cm4gcmVjb21wb3NlQ29sb3Ioe1xuICAgIHR5cGUsXG4gICAgdmFsdWVzOiByZ2JcbiAgfSk7XG59XG4vKipcbiAqIFRoZSByZWxhdGl2ZSBicmlnaHRuZXNzIG9mIGFueSBwb2ludCBpbiBhIGNvbG9yIHNwYWNlLFxuICogbm9ybWFsaXplZCB0byAwIGZvciBkYXJrZXN0IGJsYWNrIGFuZCAxIGZvciBsaWdodGVzdCB3aGl0ZS5cbiAqXG4gKiBGb3JtdWxhOiBodHRwczovL3d3dy53My5vcmcvVFIvV0NBRzIwLVRFQ0hTL0cxNy5odG1sI0cxNy10ZXN0c1xuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKSwgY29sb3IoKVxuICogQHJldHVybnMge251bWJlcn0gVGhlIHJlbGF0aXZlIGJyaWdodG5lc3Mgb2YgdGhlIGNvbG9yIGluIHRoZSByYW5nZSAwIC0gMVxuICovXG5mdW5jdGlvbiBnZXRMdW1pbmFuY2UoY29sb3IpIHtcbiAgY29sb3IgPSBkZWNvbXBvc2VDb2xvcihjb2xvcik7XG4gIGxldCByZ2IgPSBjb2xvci50eXBlID09PSAnaHNsJyB8fCBjb2xvci50eXBlID09PSAnaHNsYScgPyBkZWNvbXBvc2VDb2xvcihoc2xUb1JnYihjb2xvcikpLnZhbHVlcyA6IGNvbG9yLnZhbHVlcztcbiAgcmdiID0gcmdiLm1hcCh2YWwgPT4ge1xuICAgIGlmIChjb2xvci50eXBlICE9PSAnY29sb3InKSB7XG4gICAgICB2YWwgLz0gMjU1OyAvLyBub3JtYWxpemVkXG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbCA8PSAwLjAzOTI4ID8gdmFsIC8gMTIuOTIgOiAoKHZhbCArIDAuMDU1KSAvIDEuMDU1KSAqKiAyLjQ7XG4gIH0pO1xuXG4gIC8vIFRydW5jYXRlIGF0IDMgZGlnaXRzXG4gIHJldHVybiBOdW1iZXIoKDAuMjEyNiAqIHJnYlswXSArIDAuNzE1MiAqIHJnYlsxXSArIDAuMDcyMiAqIHJnYlsyXSkudG9GaXhlZCgzKSk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgY29udHJhc3QgcmF0aW8gYmV0d2VlbiB0d28gY29sb3JzLlxuICpcbiAqIEZvcm11bGE6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAtVEVDSFMvRzE3Lmh0bWwjRzE3LXRlc3RzXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9yZWdyb3VuZCAtIENTUyBjb2xvciwgaS5lLiBvbmUgb2Y6ICNubm4sICNubm5ubm4sIHJnYigpLCByZ2JhKCksIGhzbCgpLCBoc2xhKClcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYWNrZ3JvdW5kIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKVxuICogQHJldHVybnMge251bWJlcn0gQSBjb250cmFzdCByYXRpbyB2YWx1ZSBpbiB0aGUgcmFuZ2UgMCAtIDIxLlxuICovXG5mdW5jdGlvbiBnZXRDb250cmFzdFJhdGlvKGZvcmVncm91bmQsIGJhY2tncm91bmQpIHtcbiAgY29uc3QgbHVtQSA9IGdldEx1bWluYW5jZShmb3JlZ3JvdW5kKTtcbiAgY29uc3QgbHVtQiA9IGdldEx1bWluYW5jZShiYWNrZ3JvdW5kKTtcbiAgcmV0dXJuIChNYXRoLm1heChsdW1BLCBsdW1CKSArIDAuMDUpIC8gKE1hdGgubWluKGx1bUEsIGx1bUIpICsgMC4wNSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgYWJzb2x1dGUgdHJhbnNwYXJlbmN5IG9mIGEgY29sb3IuXG4gKiBBbnkgZXhpc3RpbmcgYWxwaGEgdmFsdWVzIGFyZSBvdmVyd3JpdHRlbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAtIENTUyBjb2xvciwgaS5lLiBvbmUgb2Y6ICNubm4sICNubm5ubm4sIHJnYigpLCByZ2JhKCksIGhzbCgpLCBoc2xhKCksIGNvbG9yKClcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHZhbHVlIHRvIHNldCB0aGUgYWxwaGEgY2hhbm5lbCB0byBpbiB0aGUgcmFuZ2UgMCAtIDFcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgQ1NTIGNvbG9yIHN0cmluZy4gSGV4IGlucHV0IHZhbHVlcyBhcmUgcmV0dXJuZWQgYXMgcmdiXG4gKi9cbmZ1bmN0aW9uIGFscGhhKGNvbG9yLCB2YWx1ZSkge1xuICBjb2xvciA9IGRlY29tcG9zZUNvbG9yKGNvbG9yKTtcbiAgdmFsdWUgPSBjbGFtcCh2YWx1ZSk7XG4gIGlmIChjb2xvci50eXBlID09PSAncmdiJyB8fCBjb2xvci50eXBlID09PSAnaHNsJykge1xuICAgIGNvbG9yLnR5cGUgKz0gJ2EnO1xuICB9XG4gIGlmIChjb2xvci50eXBlID09PSAnY29sb3InKSB7XG4gICAgY29sb3IudmFsdWVzWzNdID0gYC8ke3ZhbHVlfWA7XG4gIH0gZWxzZSB7XG4gICAgY29sb3IudmFsdWVzWzNdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJlY29tcG9zZUNvbG9yKGNvbG9yKTtcbn1cbmZ1bmN0aW9uIHByaXZhdGVfc2FmZUFscGhhKGNvbG9yLCB2YWx1ZSwgd2FybmluZykge1xuICB0cnkge1xuICAgIHJldHVybiBhbHBoYShjb2xvciwgdmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICh3YXJuaW5nICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG59XG5cbi8qKlxuICogRGFya2VucyBhIGNvbG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKSwgY29sb3IoKVxuICogQHBhcmFtIHtudW1iZXJ9IGNvZWZmaWNpZW50IC0gbXVsdGlwbGllciBpbiB0aGUgcmFuZ2UgMCAtIDFcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgQ1NTIGNvbG9yIHN0cmluZy4gSGV4IGlucHV0IHZhbHVlcyBhcmUgcmV0dXJuZWQgYXMgcmdiXG4gKi9cbmZ1bmN0aW9uIGRhcmtlbihjb2xvciwgY29lZmZpY2llbnQpIHtcbiAgY29sb3IgPSBkZWNvbXBvc2VDb2xvcihjb2xvcik7XG4gIGNvZWZmaWNpZW50ID0gY2xhbXAoY29lZmZpY2llbnQpO1xuICBpZiAoY29sb3IudHlwZS5pbmRleE9mKCdoc2wnKSAhPT0gLTEpIHtcbiAgICBjb2xvci52YWx1ZXNbMl0gKj0gMSAtIGNvZWZmaWNpZW50O1xuICB9IGVsc2UgaWYgKGNvbG9yLnR5cGUuaW5kZXhPZigncmdiJykgIT09IC0xIHx8IGNvbG9yLnR5cGUuaW5kZXhPZignY29sb3InKSAhPT0gLTEpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkgKz0gMSkge1xuICAgICAgY29sb3IudmFsdWVzW2ldICo9IDEgLSBjb2VmZmljaWVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlY29tcG9zZUNvbG9yKGNvbG9yKTtcbn1cbmZ1bmN0aW9uIHByaXZhdGVfc2FmZURhcmtlbihjb2xvciwgY29lZmZpY2llbnQsIHdhcm5pbmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGFya2VuKGNvbG9yLCBjb2VmZmljaWVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKHdhcm5pbmcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY29sb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBMaWdodGVucyBhIGNvbG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKSwgY29sb3IoKVxuICogQHBhcmFtIHtudW1iZXJ9IGNvZWZmaWNpZW50IC0gbXVsdGlwbGllciBpbiB0aGUgcmFuZ2UgMCAtIDFcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgQ1NTIGNvbG9yIHN0cmluZy4gSGV4IGlucHV0IHZhbHVlcyBhcmUgcmV0dXJuZWQgYXMgcmdiXG4gKi9cbmZ1bmN0aW9uIGxpZ2h0ZW4oY29sb3IsIGNvZWZmaWNpZW50KSB7XG4gIGNvbG9yID0gZGVjb21wb3NlQ29sb3IoY29sb3IpO1xuICBjb2VmZmljaWVudCA9IGNsYW1wKGNvZWZmaWNpZW50KTtcbiAgaWYgKGNvbG9yLnR5cGUuaW5kZXhPZignaHNsJykgIT09IC0xKSB7XG4gICAgY29sb3IudmFsdWVzWzJdICs9ICgxMDAgLSBjb2xvci52YWx1ZXNbMl0pICogY29lZmZpY2llbnQ7XG4gIH0gZWxzZSBpZiAoY29sb3IudHlwZS5pbmRleE9mKCdyZ2InKSAhPT0gLTEpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkgKz0gMSkge1xuICAgICAgY29sb3IudmFsdWVzW2ldICs9ICgyNTUgLSBjb2xvci52YWx1ZXNbaV0pICogY29lZmZpY2llbnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNvbG9yLnR5cGUuaW5kZXhPZignY29sb3InKSAhPT0gLTEpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkgKz0gMSkge1xuICAgICAgY29sb3IudmFsdWVzW2ldICs9ICgxIC0gY29sb3IudmFsdWVzW2ldKSAqIGNvZWZmaWNpZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVjb21wb3NlQ29sb3IoY29sb3IpO1xufVxuZnVuY3Rpb24gcHJpdmF0ZV9zYWZlTGlnaHRlbihjb2xvciwgY29lZmZpY2llbnQsIHdhcm5pbmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbGlnaHRlbihjb2xvciwgY29lZmZpY2llbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICh3YXJuaW5nICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG59XG5cbi8qKlxuICogRGFya2VuIG9yIGxpZ2h0ZW4gYSBjb2xvciwgZGVwZW5kaW5nIG9uIGl0cyBsdW1pbmFuY2UuXG4gKiBMaWdodCBjb2xvcnMgYXJlIGRhcmtlbmVkLCBkYXJrIGNvbG9ycyBhcmUgbGlnaHRlbmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIC0gQ1NTIGNvbG9yLCBpLmUuIG9uZSBvZjogI25ubiwgI25ubm5ubiwgcmdiKCksIHJnYmEoKSwgaHNsKCksIGhzbGEoKSwgY29sb3IoKVxuICogQHBhcmFtIHtudW1iZXJ9IGNvZWZmaWNpZW50PTAuMTUgLSBtdWx0aXBsaWVyIGluIHRoZSByYW5nZSAwIC0gMVxuICogQHJldHVybnMge3N0cmluZ30gQSBDU1MgY29sb3Igc3RyaW5nLiBIZXggaW5wdXQgdmFsdWVzIGFyZSByZXR1cm5lZCBhcyByZ2JcbiAqL1xuZnVuY3Rpb24gZW1waGFzaXplKGNvbG9yLCBjb2VmZmljaWVudCA9IDAuMTUpIHtcbiAgcmV0dXJuIGdldEx1bWluYW5jZShjb2xvcikgPiAwLjUgPyBkYXJrZW4oY29sb3IsIGNvZWZmaWNpZW50KSA6IGxpZ2h0ZW4oY29sb3IsIGNvZWZmaWNpZW50KTtcbn1cbmZ1bmN0aW9uIHByaXZhdGVfc2FmZUVtcGhhc2l6ZShjb2xvciwgY29lZmZpY2llbnQsIHdhcm5pbmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJpdmF0ZV9zYWZlRW1waGFzaXplKGNvbG9yLCBjb2VmZmljaWVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKHdhcm5pbmcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY29sb3I7XG4gIH1cbn0iXSwibWFwcGluZ3MiOiJBQUFBLFlBQVk7O0FBRVpBLE1BQU0sQ0FBQ0MsY0FBYyxDQUFDQyxPQUFPLEVBQUUsWUFBWSxFQUFFO0VBQzNDQyxLQUFLLEVBQUU7QUFDVCxDQUFDLENBQUM7QUFDRkQsT0FBTyxDQUFDRSxLQUFLLEdBQUdBLEtBQUs7QUFDckJGLE9BQU8sQ0FBQ0csWUFBWSxHQUFHLEtBQUssQ0FBQztBQUM3QkgsT0FBTyxDQUFDSSxNQUFNLEdBQUdBLE1BQU07QUFDdkJKLE9BQU8sQ0FBQ0ssY0FBYyxHQUFHQSxjQUFjO0FBQ3ZDTCxPQUFPLENBQUNNLFNBQVMsR0FBR0EsU0FBUztBQUM3Qk4sT0FBTyxDQUFDTyxnQkFBZ0IsR0FBR0EsZ0JBQWdCO0FBQzNDUCxPQUFPLENBQUNRLFlBQVksR0FBR0EsWUFBWTtBQUNuQ1IsT0FBTyxDQUFDUyxRQUFRLEdBQUdBLFFBQVE7QUFDM0JULE9BQU8sQ0FBQ1UsUUFBUSxHQUFHQSxRQUFRO0FBQzNCVixPQUFPLENBQUNXLE9BQU8sR0FBR0EsT0FBTztBQUN6QlgsT0FBTyxDQUFDWSxpQkFBaUIsR0FBR0EsaUJBQWlCO0FBQzdDWixPQUFPLENBQUNhLHdCQUF3QixHQUFHLEtBQUssQ0FBQztBQUN6Q2IsT0FBTyxDQUFDYyxrQkFBa0IsR0FBR0Es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