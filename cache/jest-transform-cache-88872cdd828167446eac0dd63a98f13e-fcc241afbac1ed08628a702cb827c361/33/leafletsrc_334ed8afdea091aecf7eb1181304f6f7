8c0ad562a75038dccdb905bf8f5d09f3
"use strict";

/* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.leaflet = {}));
})(void 0, function (exports) {
  'use strict';

  var version = "1.9.4";

  /*
   * @namespace Util
   *
   * Various utility functions, used by Leaflet internally.
   */

  // @function extend(dest: Object, src?: Object): Object
  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
  function extend(dest) {
    var i, j, len, src;
    for (j = 1, len = arguments.length; j < len; j++) {
      src = arguments[j];
      for (i in src) {
        dest[i] = src[i];
      }
    }
    return dest;
  }

  // @function create(proto: Object, properties?: Object): Object
  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
  var create$2 = Object.create || function () {
    function F() {}
    return function (proto) {
      F.prototype = proto;
      return new F();
    };
  }();

  // @function bind(fn: Function, …): Function
  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
  // Has a `L.bind()` shortcut.
  function bind(fn, obj) {
    var slice = Array.prototype.slice;
    if (fn.bind) {
      return fn.bind.apply(fn, slice.call(arguments, 1));
    }
    var args = slice.call(arguments, 2);
    return function () {
      return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
    };
  }

  // @property lastId: Number
  // Last unique ID used by [`stamp()`](#util-stamp)
  var lastId = 0;

  // @function stamp(obj: Object): Number
  // Returns the unique ID of an object, assigning it one if it doesn't have it.
  function stamp(obj) {
    if (!('_leaflet_id' in obj)) {
      obj['_leaflet_id'] = ++lastId;
    }
    return obj._leaflet_id;
  }

  // @function throttle(fn: Function, time: Number, context: Object): Function
  // Returns a function which executes function `fn` with the given scope `context`
  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function
  // `fn` will be called no more than one time per given amount of `time`. The arguments
  // received by the bound function will be any arguments passed when binding the
  // function, followed by any arguments passed when invoking the bound function.
  // Has an `L.throttle` shortcut.
  function throttle(fn, time, context) {
    var lock, args, wrapperFn, later;
    later = function () {
      // reset lock and call if queued
      lock = false;
      if (args) {
        wrapperFn.apply(context, args);
        args = false;
      }
    };
    wrapperFn = function () {
      if (lock) {
        // called too soon, queue to call later
        args = arguments;
      } else {
        // call and lock until later
        fn.apply(context, arguments);
        setTimeout(later, time);
        lock = true;
      }
    };
    return wrapperFn;
  }

  // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
  // Returns the number `num` modulo `range` in such a way so it lies within
  // `range[0]` and `range[1]`. The returned value will be always smaller than
  // `range[1]` unless `includeMax` is set to `true`.
  function wrapNum(x, range, includeMax) {
    var max = range[1],
      min = range[0],
      d = max - min;
    return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
  }

  // @function falseFn(): Function
  // Returns a function which always returns `false`.
  function falseFn() {
    return false;
  }

  // @function formatNum(num: Number, precision?: Number|false): Number
  // Returns the number `num` rounded with specified `precision`.
  // The default `precision` value is 6 decimal places.
  // `false` can be passed to skip any processing (can be useful to avoid round-off errors).
  function formatNum(num, precision) {
    if (precision === false) {
      return num;
    }
    var pow = Math.pow(10, precision === undefined ? 6 : precision);
    return Math.round(num * pow) / pow;
  }

  // @function trim(str: String): String
  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
  function trim(str) {
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
  }

  // @function splitWords(str: String): String[]
  // Trims and splits the string on whitespace and returns the array of parts.
  function splitWords(str) {
    return trim(str).split(/\s+/);
  }

  // @function setOptions(obj: Object, options: Object): Object
  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
  function setOptions(obj, options) {
    if (!Object.prototype.hasOwnProperty.call(obj, 'options')) {
      obj.options = obj.options ? create$2(obj.options) : {};
    }
    for (var i in options) {
      obj.options[i] = options[i];
    }
    return obj.options;
  }

  // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
  // Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
  // be appended at the end. If `uppercase` is `true`, the parameter names will
  // be uppercased (e.g. `'?A=foo&B=bar'`)
  function getParamString(obj, existingUrl, uppercase) {
    var params = [];
    for (var i in obj) {
      params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
    }
    return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');
  }
  var templateRe = /\{ *([\w_ -]+) *\}/g;

  // @function template(str: String, data: Object): String
  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
  // `('Hello foo, bar')`. You can also specify functions instead of strings for
  // data values — they will be evaluated passing `data` as an argument.
  function template(str, data) {
    return str.replace(templateRe, function (str, key) {
      var value = data[key];
      if (value === undefined) {
        throw new Error('No value provided for variable ' + str);
      } else if (typeof value === 'function') {
        value = value(data);
      }
      return value;
    });
  }

  // @function isArray(obj): Boolean
  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
  var isArray = Array.isArray || function (obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  };

  // @function indexOf(array: Array, el: Object): Number
  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
  function indexOf(array, el) {
    for (var i = 0; i < array.length; i++) {
      if (array[i] === el) {
        return i;
      }
    }
    return -1;
  }

  // @property emptyImageUrl: String
  // Data URI string containing a base64-encoded empty GIF image.
  // Used as a hack to free memory from unused images on WebKit-powered
  // mobile devices (by setting image `src` to this string).
  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

  // inspired by https://paulirish.com/2011/requestanimationframe-for-smart-animating/

  function getPrefixed(name) {
    return window['webkit' + name] || window['moz' + name] || window['ms' + name];
  }
  var lastTime = 0;

  // fallback for IE 7-8
  function timeoutDefer(fn) {
    var time = +new Date(),
      timeToCall = Math.max(0, 16 - (time - lastTime));
    lastTime = time + timeToCall;
    return window.setTimeout(fn, timeToCall);
  }
  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {
    window.clearTimeout(id);
  };

  // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to
  // `context` if given. When `immediate` is set, `fn` is called immediately if
  // the browser doesn't have native support for
  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.
  function requestAnimFrame(fn, context, immediate) {
    if (immediate && requestFn === timeoutDefer) {
      fn.call(context);
    } else {
      return requestFn.call(window, bind(fn, context));
    }
  }

  // @function cancelAnimFrame(id: Number): undefined
  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
  function cancelAnimFrame(id) {
    if (id) {
      cancelFn.call(window, id);
    }
  }
  var Util = {
    __proto__: null,
    extend: extend,
    create: create$2,
    bind: bind,
    get lastId() {
      return lastId;
    },
    stamp: stamp,
    throttle: throttle,
    wrapNum: wrapNum,
    falseFn: falseFn,
    formatNum: formatNum,
    trim: trim,
    splitWords: splitWords,
    setOptions: setOptions,
    getParamString: getParamString,
    template: template,
    isArray: isArray,
    indexOf: indexOf,
    emptyImageUrl: emptyImageUrl,
    requestFn: requestFn,
    cancelFn: cancelFn,
    requestAnimFrame: requestAnimFrame,
    cancelAnimFrame: cancelAnimFrame
  };

  // @class Class
  // @aka L.Class

  // @section
  // @uninheritable

  // Thanks to John Resig and Dean Edwards for inspiration!

  function Class() {}
  Class.extend = function (props) {
    // @function extend(props: Object): Function
    // [Extends the current class](#class-inheritance) given the properties to be included.
    // Returns a Javascript function that is a class constructor (to be called with `new`).
    var NewClass = function () {
      setOptions(this);

      // call the constructor
      if (this.initialize) {
        this.initialize.apply(this, arguments);
      }

      // call all constructor hooks
      this.callInitHooks();
    };
    var parentProto = NewClass.__super__ = this.prototype;
    var proto = create$2(parentProto);
    proto.constructor = NewClass;
    NewClass.prototype = proto;

    // inherit parent's statics
    for (var i in this) {
      if (Object.prototype.hasOwnProperty.call(this, i) && i !== 'prototype' && i !== '__super__') {
        NewClass[i] = this[i];
      }
    }

    // mix static properties into the class
    if (props.statics) {
      extend(NewClass, props.statics);
    }

    // mix includes into the prototype
    if (props.includes) {
      checkDeprecatedMixinEvents(props.includes);
      extend.apply(null, [proto].concat(props.includes));
    }

    // mix given properties into the prototype
    extend(proto, props);
    delete proto.statics;
    delete proto.includes;

    // merge options
    if (proto.options) {
      proto.options = parentProto.options ? create$2(parentProto.options) : {};
      extend(proto.options, props.options);
    }
    proto._initHooks = [];

    // add method for calling all hooks
    proto.callInitHooks = function () {
      if (this._initHooksCalled) {
        return;
      }
      if (parentProto.callInitHooks) {
        parentProto.callInitHooks.call(this);
      }
      this._initHooksCalled = true;
      for (var i = 0, len = proto._initHooks.length; i < len; i++) {
        proto._initHooks[i].call(this);
      }
    };
    return NewClass;
  };

  // @function include(properties: Object): this
  // [Includes a mixin](#class-includes) into the current class.
  Class.include = function (props) {
    var parentOptions = this.prototype.options;
    extend(this.prototype, props);
    if (props.options) {
      this.prototype.options = parentOptions;
      this.mergeOptions(props.options);
    }
    return this;
  };

  // @function mergeOptions(options: Object): this
  // [Merges `options`](#class-options) into the defaults of the class.
  Class.mergeOptions = function (options) {
    extend(this.prototype.options, options);
    return this;
  };

  // @function addInitHook(fn: Function): this
  // Adds a [constructor hook](#class-constructor-hooks) to the class.
  Class.addInitHook = function (fn) {
    // (Function) || (String, args...)
    var args = Array.prototype.slice.call(arguments, 1);
    var init = typeof fn === 'function' ? fn : function () {
      this[fn].apply(this, args);
    };
    this.prototype._initHooks = this.prototype._initHooks || [];
    this.prototype._initHooks.push(init);
    return this;
  };
  function checkDeprecatedMixinEvents(includes) {
    /* global L: true */
    if (typeof L === 'undefined' || !L || !L.Mixin) {
      return;
    }
    includes = isArray(includes) ? includes : [includes];
    for (var i = 0; i < includes.length; i++) {
      if (includes[i] === L.Mixin.Events) {
        console.warn('Deprecated include of L.Mixin.Events: ' + 'this property will be removed in future releases, ' + 'please inherit from L.Evented instead.', new Error().stack);
      }
    }
  }

  /*
   * @class Evented
   * @aka L.Evented
   * @inherits Class
   *
   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
   *
   * @example
   *
   * ```js
   * map.on('click', function(e) {
   * 	alert(e.latlng);
   * } );
   * ```
   *
   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
   *
   * ```js
   * function onClick(e) { ... }
   *
   * map.on('click', onClick);
   * map.off('click', onClick);
   * ```
   */

  var Events = {
    /* @method on(type: String, fn: Function, context?: Object): this
     * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
     *
     * @alternative
     * @method on(eventMap: Object): this
     * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
     */
    on: function (types, fn, context) {
      // types can be a map of types/handlers
      if (typeof types === 'object') {
        for (var type in types) {
          // we don't process space-separated events here for performance;
          // it's a hot path since Layer uses the on(obj) syntax
          this._on(type, types[type], fn);
        }
      } else {
        // types can be a string of space-separated words
        types = splitWords(types);
        for (var i = 0, len = types.length; i < len; i++) {
          this._on(types[i], fn, context);
        }
      }
      return this;
    },
    /* @method off(type: String, fn?: Function, context?: Object): this
     * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
     *
     * @alternative
     * @method off(eventMap: Object): this
     * Removes a set of type/listener pairs.
     *
     * @alternative
     * @method off: this
     * Removes all listeners to all events on the object. This includes implicitly attached events.
     */
    off: function (types, fn, context) {
      if (!arguments.length) {
        // clear all listeners if called without arguments
        delete this._events;
      } else if (typeof types === 'object') {
        for (var type in types) {
          this._off(type, types[type], fn);
        }
      } else {
        types = splitWords(types);
        var removeAll = arguments.length === 1;
        for (var i = 0, len = types.length; i < len; i++) {
          if (removeAll) {
            this._off(types[i]);
          } else {
            this._off(types[i], fn, context);
          }
        }
      }
      return this;
    },
    // attach listener (without syntactic sugar now)
    _on: function (type, fn, context, _once) {
      if (typeof fn !== 'function') {
        console.warn('wrong listener type: ' + typeof fn);
        return;
      }

      // check if fn already there
      if (this._listens(type, fn, context) !== false) {
        return;
      }
      if (context === this) {
        // Less memory footprint.
        context = undefined;
      }
      var newListener = {
        fn: fn,
        ctx: context
      };
      if (_once) {
        newListener.once = true;
      }
      this._events = this._events || {};
      this._events[type] = this._events[type] || [];
      this._events[type].push(newListener);
    },
    _off: function (type, fn, context) {
      var listeners, i, len;
      if (!this._events) {
        return;
      }
      listeners = this._events[type];
      if (!listeners) {
        return;
      }
      if (arguments.length === 1) {
        // remove all
        if (this._firingCount) {
          // Set all removed listeners to noop
          // so they are not called if remove happens in fire
          for (i = 0, len = listeners.length; i < len; i++) {
            listeners[i].fn = falseFn;
          }
        }
        // clear all listeners for a type if function isn't specified
        delete this._events[type];
        return;
      }
      if (typeof fn !== 'function') {
        console.warn('wrong listener type: ' + typeof fn);
        return;
      }

      // find fn and remove it
      var index = this._listens(type, fn, context);
      if (index !== false) {
        var listener = listeners[index];
        if (this._firingCount) {
          // set the removed listener to noop so that's not called if remove happens in fire
          listener.fn = falseFn;

          /* copy array in case events are being fired */
          this._events[type] = listeners = listeners.slice();
        }
        listeners.splice(index, 1);
      }
    },
    // @method fire(type: String, data?: Object, propagate?: Boolean): this
    // Fires an event of the specified type. You can optionally provide a data
    // object — the first argument of the listener function will contain its
    // properties. The event can optionally be propagated to event parents.
    fire: function (type, data, propagate) {
      if (!this.listens(type, propagate)) {
        return this;
      }
      var event = extend({}, data, {
        type: type,
        target: this,
        sourceTarget: data && data.sourceTarget || this
      });
      if (this._events) {
        var listeners = this._events[type];
        if (listeners) {
          this._firingCount = this._firingCount + 1 || 1;
          for (var i = 0, len = listeners.length; i < len; i++) {
            var l = listeners[i];
            // off overwrites l.fn, so we need to copy fn to a var
            var fn = l.fn;
            if (l.once) {
              this.off(type, fn, l.ctx);
            }
            fn.call(l.ctx || this, event);
          }
          this._firingCount--;
        }
      }
      if (propagate) {
        // propagate the event to parents (set with addEventParent)
        this._propagateEvent(event);
      }
      return this;
    },
    // @method listens(type: String, propagate?: Boolean): Boolean
    // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
    // Returns `true` if a particular event type has any listeners attached to it.
    // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
    listens: function (type, fn, context, propagate) {
      if (typeof type !== 'string') {
        console.warn('"string" type argument expected');
      }

      // we don't overwrite the input `fn` value, because we need to use it for propagation
      var _fn = fn;
      if (typeof fn !== 'function') {
        propagate = !!fn;
        _fn = undefined;
        context = undefined;
      }
      var listeners = this._events && this._events[type];
      if (listeners && listeners.length) {
        if (this._listens(type, _fn, context) !== false) {
          return true;
        }
      }
      if (propagate) {
        // also check parents for listeners if event propagates
        for (var id in this._eventParents) {
          if (this._eventParents[id].listens(type, fn, context, propagate)) {
            return true;
          }
        }
      }
      return false;
    },
    // returns the index (number) or false
    _listens: function (type, fn, context) {
      if (!this._events) {
        return false;
      }
      var listeners = this._events[type] || [];
      if (!fn) {
        return !!listeners.length;
      }
      if (context === this) {
        // Less memory footprint.
        context = undefined;
      }
      for (var i = 0, len = listeners.length; i < len; i++) {
        if (listeners[i].fn === fn && listeners[i].ctx === context) {
          return i;
        }
      }
      return false;
    },
    // @method once(…): this
    // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
    once: function (types, fn, context) {
      // types can be a map of types/handlers
      if (typeof types === 'object') {
        for (var type in types) {
          // we don't process space-separated events here for performance;
          // it's a hot path since Layer uses the on(obj) syntax
          this._on(type, types[type], fn, true);
        }
      } else {
        // types can be a string of space-separated words
        types = splitWords(types);
        for (var i = 0, len = types.length; i < len; i++) {
          this._on(types[i], fn, context, true);
        }
      }
      return this;
    },
    // @method addEventParent(obj: Evented): this
    // Adds an event parent - an `Evented` that will receive propagated events
    addEventParent: function (obj) {
      this._eventParents = this._eventParents || {};
      this._eventParents[stamp(obj)] = obj;
      return this;
    },
    // @method removeEventParent(obj: Evented): this
    // Removes an event parent, so it will stop receiving propagated events
    removeEventParent: function (obj) {
      if (this._eventParents) {
        delete this._eventParents[stamp(obj)];
      }
      return this;
    },
    _propagateEvent: function (e) {
      for (var id in this._eventParents) {
        this._eventParents[id].fire(e.type, extend({
          layer: e.target,
          propagatedFrom: e.target
        }, e), true);
      }
    }
  };

  // aliases; we should ditch those eventually

  // @method addEventListener(…): this
  // Alias to [`on(…)`](#evented-on)
  Events.addEventListener = Events.on;

  // @method removeEventListener(…): this
  // Alias to [`off(…)`](#evented-off)

  // @method clearAllEventListeners(…): this
  // Alias to [`off()`](#evented-off)
  Events.removeEventListener = Events.clearAllEventListeners = Events.off;

  // @method addOneTimeEventListener(…): this
  // Alias to [`once(…)`](#evented-once)
  Events.addOneTimeEventListener = Events.once;

  // @method fireEvent(…): this
  // Alias to [`fire(…)`](#evented-fire)
  Events.fireEvent = Events.fire;

  // @method hasEventListeners(…): Boolean
  // Alias to [`listens(…)`](#evented-listens)
  Events.hasEventListeners = Events.listens;
  var Evented = Class.extend(Events);

  /*
   * @class Point
   * @aka L.Point
   *
   * Represents a point with `x` and `y` coordinates in pixels.
   *
   * @example
   *
   * ```js
   * var point = L.point(200, 300);
   * ```
   *
   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
   *
   * ```js
   * map.panBy([200, 300]);
   * map.panBy(L.point(200, 300));
   * ```
   *
   * Note that `Point` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function Point(x, y, round) {
    // @property x: Number; The `x` coordinate of the point
    this.x = round ? Math.round(x) : x;
    // @property y: Number; The `y` coordinate of the point
    this.y = round ? Math.round(y) : y;
  }
  var trunc = Math.trunc || function (v) {
    return v > 0 ? Math.floor(v) : Math.ceil(v);
  };
  Point.prototype = {
    // @method clone(): Point
    // Returns a copy of the current point.
    clone: function () {
      return new Point(this.x, this.y);
    },
    // @method add(otherPoint: Point): Point
    // Returns the result of addition of the current and the given points.
    add: function (point) {
      // non-destructive, returns a new point
      return this.clone()._add(toPoint(point));
    },
    _add: function (point) {
      // destructive, used directly for performance in situations where it's safe to modify existing point
      this.x += point.x;
      this.y += point.y;
      return this;
    },
    // @method subtract(otherPoint: Point): Point
    // Returns the result of subtraction of the given point from the current.
    subtract: function (point) {
      return this.clone()._subtract(toPoint(point));
    },
    _subtract: function (point) {
      this.x -= point.x;
      this.y -= point.y;
      return this;
    },
    // @method divideBy(num: Number): Point
    // Returns the result of division of the current point by the given number.
    divideBy: function (num) {
      return this.clone()._divideBy(num);
    },
    _divideBy: function (num) {
      this.x /= num;
      this.y /= num;
      return this;
    },
    // @method multiplyBy(num: Number): Point
    // Returns the result of multiplication of the current point by the given number.
    multiplyBy: function (num) {
      return this.clone()._multiplyBy(num);
    },
    _multiplyBy: function (num) {
      this.x *= num;
      this.y *= num;
      return this;
    },
    // @method scaleBy(scale: Point): Point
    // Multiply each coordinate of the current point by each coordinate of
    // `scale`. In linear algebra terms, multiply the point by the
    // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
    // defined by `scale`.
    scaleBy: function (point) {
      return new Point(this.x * point.x, this.y * point.y);
    },
    // @method unscaleBy(scale: Point): Point
    // Inverse of `scaleBy`. Divide each coordinate of the current point by
    // each coordinate of `scale`.
    unscaleBy: function (point) {
      return new Point(this.x / point.x, this.y / point.y);
    },
    // @method round(): Point
    // Returns a copy of the current point with rounded coordinates.
    round: function () {
      return this.clone()._round();
    },
    _round: function () {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    },
    // @method floor(): Point
    // Returns a copy of the current point with floored coordinates (rounded down).
    floor: function () {
      return this.clone()._floor();
    },
    _floor: function () {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    },
    // @method ceil(): Point
    // Returns a copy of the current point with ceiled coordinates (rounded up).
    ceil: function () {
      return this.clone()._ceil();
    },
    _ceil: function () {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    },
    // @method trunc(): Point
    // Returns a copy of the current point with truncated coordinates (rounded towards zero).
    trunc: function () {
      return this.clone()._trunc();
    },
    _trunc: function () {
      this.x = trunc(this.x);
      this.y = trunc(this.y);
      return this;
    },
    // @method distanceTo(otherPoint: Point): Number
    // Returns the cartesian distance between the current and the given points.
    distanceTo: function (point) {
      point = toPoint(point);
      var x = point.x - this.x,
        y = point.y - this.y;
      return Math.sqrt(x * x + y * y);
    },
    // @method equals(otherPoint: Point): Boolean
    // Returns `true` if the given point has the same coordinates.
    equals: function (point) {
      point = toPoint(point);
      return point.x === this.x && point.y === this.y;
    },
    // @method contains(otherPoint: Point): Boolean
    // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
    contains: function (point) {
      point = toPoint(point);
      return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
    },
    // @method toString(): String
    // Returns a string representation of the point for debugging purposes.
    toString: function () {
      return 'Point(' + formatNum(this.x) + ', ' + formatNum(this.y) + ')';
    }
  };

  // @factory L.point(x: Number, y: Number, round?: Boolean)
  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

  // @alternative
  // @factory L.point(coords: Number[])
  // Expects an array of the form `[x, y]` instead.

  // @alternative
  // @factory L.point(coords: Object)
  // Expects a plain object of the form `{x: Number, y: Number}` instead.
  function toPoint(x, y, round) {
    if (x instanceof Point) {
      return x;
    }
    if (isArray(x)) {
      return new Point(x[0], x[1]);
    }
    if (x === undefined || x === null) {
      return x;
    }
    if (typeof x === 'object' && 'x' in x && 'y' in x) {
      return new Point(x.x, x.y);
    }
    return new Point(x, y, round);
  }

  /*
   * @class Bounds
   * @aka L.Bounds
   *
   * Represents a rectangular area in pixel coordinates.
   *
   * @example
   *
   * ```js
   * var p1 = L.point(10, 10),
   * p2 = L.point(40, 60),
   * bounds = L.bounds(p1, p2);
   * ```
   *
   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * otherBounds.intersects([[10, 10], [40, 60]]);
   * ```
   *
   * Note that `Bounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function Bounds(a, b) {
    if (!a) {
      return;
    }
    var points = b ? [a, b] : a;
    for (var i = 0, len = points.length; i < len; i++) {
      this.extend(points[i]);
    }
  }
  Bounds.prototype = {
    // @method extend(point: Point): this
    // Extends the bounds to contain the given point.

    // @alternative
    // @method extend(otherBounds: Bounds): this
    // Extend the bounds to contain the given bounds
    extend: function (obj) {
      var min2, max2;
      if (!obj) {
        return this;
      }
      if (obj instanceof Point || typeof obj[0] === 'number' || 'x' in obj) {
        min2 = max2 = toPoint(obj);
      } else {
        obj = toBounds(obj);
        min2 = obj.min;
        max2 = obj.max;
        if (!min2 || !max2) {
          return this;
        }
      }

      // @property min: Point
      // The top left corner of the rectangle.
      // @property max: Point
      // The bottom right corner of the rectangle.
      if (!this.min && !this.max) {
        this.min = min2.clone();
        this.max = max2.clone();
      } else {
        this.min.x = Math.min(min2.x, this.min.x);
        this.max.x = Math.max(max2.x, this.max.x);
        this.min.y = Math.min(min2.y, this.min.y);
        this.max.y = Math.max(max2.y, this.max.y);
      }
      return this;
    },
    // @method getCenter(round?: Boolean): Point
    // Returns the center point of the bounds.
    getCenter: function (round) {
      return toPoint((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
    },
    // @method getBottomLeft(): Point
    // Returns the bottom-left point of the bounds.
    getBottomLeft: function () {
      return toPoint(this.min.x, this.max.y);
    },
    // @method getTopRight(): Point
    // Returns the top-right point of the bounds.
    getTopRight: function () {
      // -> Point
      return toPoint(this.max.x, this.min.y);
    },
    // @method getTopLeft(): Point
    // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
    getTopLeft: function () {
      return this.min; // left, top
    },

    // @method getBottomRight(): Point
    // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
    getBottomRight: function () {
      return this.max; // right, bottom
    },

    // @method getSize(): Point
    // Returns the size of the given bounds
    getSize: function () {
      return this.max.subtract(this.min);
    },
    // @method contains(otherBounds: Bounds): Boolean
    // Returns `true` if the rectangle contains the given one.
    // @alternative
    // @method contains(point: Point): Boolean
    // Returns `true` if the rectangle contains the given point.
    contains: function (obj) {
      var min, max;
      if (typeof obj[0] === 'number' || obj instanceof Point) {
        obj = toPoint(obj);
      } else {
        obj = toBounds(obj);
      }
      if (obj instanceof Bounds) {
        min = obj.min;
        max = obj.max;
      } else {
        min = max = obj;
      }
      return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
    },
    // @method intersects(otherBounds: Bounds): Boolean
    // Returns `true` if the rectangle intersects the given bounds. Two bounds
    // intersect if they have at least one point in common.
    intersects: function (bounds) {
      // (Bounds) -> Boolean
      bounds = toBounds(bounds);
      var min = this.min,
        max = this.max,
        min2 = bounds.min,
        max2 = bounds.max,
        xIntersects = max2.x >= min.x && min2.x <= max.x,
        yIntersects = max2.y >= min.y && min2.y <= max.y;
      return xIntersects && yIntersects;
    },
    // @method overlaps(otherBounds: Bounds): Boolean
    // Returns `true` if the rectangle overlaps the given bounds. Two bounds
    // overlap if their intersection is an area.
    overlaps: function (bounds) {
      // (Bounds) -> Boolean
      bounds = toBounds(bounds);
      var min = this.min,
        max = this.max,
        min2 = bounds.min,
        max2 = bounds.max,
        xOverlaps = max2.x > min.x && min2.x < max.x,
        yOverlaps = max2.y > min.y && min2.y < max.y;
      return xOverlaps && yOverlaps;
    },
    // @method isValid(): Boolean
    // Returns `true` if the bounds are properly initialized.
    isValid: function () {
      return !!(this.min && this.max);
    },
    // @method pad(bufferRatio: Number): Bounds
    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
    // Negative values will retract the bounds.
    pad: function (bufferRatio) {
      var min = this.min,
        max = this.max,
        heightBuffer = Math.abs(min.x - max.x) * bufferRatio,
        widthBuffer = Math.abs(min.y - max.y) * bufferRatio;
      return toBounds(toPoint(min.x - heightBuffer, min.y - widthBuffer), toPoint(max.x + heightBuffer, max.y + widthBuffer));
    },
    // @method equals(otherBounds: Bounds): Boolean
    // Returns `true` if the rectangle is equivalent to the given bounds.
    equals: function (bounds) {
      if (!bounds) {
        return false;
      }
      bounds = toBounds(bounds);
      return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());
    }
  };

  // @factory L.bounds(corner1: Point, corner2: Point)
  // Creates a Bounds object from two corners coordinate pairs.
  // @alternative
  // @factory L.bounds(points: Point[])
  // Creates a Bounds object from the given array of points.
  function toBounds(a, b) {
    if (!a || a instanceof Bounds) {
      return a;
    }
    return new Bounds(a, b);
  }

  /*
   * @class LatLngBounds
   * @aka L.LatLngBounds
   *
   * Represents a rectangular geographical area on a map.
   *
   * @example
   *
   * ```js
   * var corner1 = L.latLng(40.712, -74.227),
   * corner2 = L.latLng(40.774, -74.125),
   * bounds = L.latLngBounds(corner1, corner2);
   * ```
   *
   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * map.fitBounds([
   * 	[40.712, -74.227],
   * 	[40.774, -74.125]
   * ]);
   * ```
   *
   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
   *
   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function LatLngBounds(corner1, corner2) {
    // (LatLng, LatLng) or (LatLng[])
    if (!corner1) {
      return;
    }
    var latlngs = corner2 ? [corner1, corner2] : corner1;
    for (var i = 0, len = latlngs.length; i < len; i++) {
      this.extend(latlngs[i]);
    }
  }
  LatLngBounds.prototype = {
    // @method extend(latlng: LatLng): this
    // Extend the bounds to contain the given point

    // @alternative
    // @method extend(otherBounds: LatLngBounds): this
    // Extend the bounds to contain the given bounds
    extend: function (obj) {
      var sw = this._southWest,
        ne = this._northEast,
        sw2,
        ne2;
      if (obj instanceof LatLng) {
        sw2 = obj;
        ne2 = obj;
      } else if (obj instanceof LatLngBounds) {
        sw2 = obj._southWest;
        ne2 = obj._northEast;
        if (!sw2 || !ne2) {
          return this;
        }
      } else {
        return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
      }
      if (!sw && !ne) {
        this._southWest = new LatLng(sw2.lat, sw2.lng);
        this._northEast = new LatLng(ne2.lat, ne2.lng);
      } else {
        sw.lat = Math.min(sw2.lat, sw.lat);
        sw.lng = Math.min(sw2.lng, sw.lng);
        ne.lat = Math.max(ne2.lat, ne.lat);
        ne.lng = Math.max(ne2.lng, ne.lng);
      }
      return this;
    },
    // @method pad(bufferRatio: Number): LatLngBounds
    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
    // Negative values will retract the bounds.
    pad: function (bufferRatio) {
      var sw = this._southWest,
        ne = this._northEast,
        heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
        widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
      return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
    },
    // @method getCenter(): LatLng
    // Returns the center point of the bounds.
    getCenter: function () {
      return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
    },
    // @method getSouthWest(): LatLng
    // Returns the south-west point of the bounds.
    getSouthWest: function () {
      return this._southWest;
    },
    // @method getNorthEast(): LatLng
    // Returns the north-east point of the bounds.
    getNorthEast: function () {
      return this._northEast;
    },
    // @method getNorthWest(): LatLng
    // Returns the north-west point of the bounds.
    getNorthWest: function () {
      return new LatLng(this.getNorth(), this.getWest());
    },
    // @method getSouthEast(): LatLng
    // Returns the south-east point of the bounds.
    getSouthEast: function () {
      return new LatLng(this.getSouth(), this.getEast());
    },
    // @method getWest(): Number
    // Returns the west longitude of the bounds
    getWest: function () {
      return this._southWest.lng;
    },
    // @method getSouth(): Number
    // Returns the south latitude of the bounds
    getSouth: function () {
      return this._southWest.lat;
    },
    // @method getEast(): Number
    // Returns the east longitude of the bounds
    getEast: function () {
      return this._northEast.lng;
    },
    // @method getNorth(): Number
    // Returns the north latitude of the bounds
    getNorth: function () {
      return this._northEast.lat;
    },
    // @method contains(otherBounds: LatLngBounds): Boolean
    // Returns `true` if the rectangle contains the given one.

    // @alternative
    // @method contains (latlng: LatLng): Boolean
    // Returns `true` if the rectangle contains the given point.
    contains: function (obj) {
      // (LatLngBounds) or (LatLng) -> Boolean
      if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {
        obj = toLatLng(obj);
      } else {
        obj = toLatLngBounds(obj);
      }
      var sw = this._southWest,
        ne = this._northEast,
        sw2,
        ne2;
      if (obj instanceof LatLngBounds) {
        sw2 = obj.getSouthWest();
        ne2 = obj.getNorthEast();
      } else {
        sw2 = ne2 = obj;
      }
      return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
    },
    // @method intersects(otherBounds: LatLngBounds): Boolean
    // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
    intersects: function (bounds) {
      bounds = toLatLngBounds(bounds);
      var sw = this._southWest,
        ne = this._northEast,
        sw2 = bounds.getSouthWest(),
        ne2 = bounds.getNorthEast(),
        latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,
        lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
      return latIntersects && lngIntersects;
    },
    // @method overlaps(otherBounds: LatLngBounds): Boolean
    // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
    overlaps: function (bounds) {
      bounds = toLatLngBounds(bounds);
      var sw = this._southWest,
        ne = this._northEast,
        sw2 = bounds.getSouthWest(),
        ne2 = bounds.getNorthEast(),
        latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,
        lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
      return latOverlaps && lngOverlaps;
    },
    // @method toBBoxString(): String
    // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
    toBBoxString: function () {
      return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
    },
    // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
    // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
    equals: function (bounds, maxMargin) {
      if (!bounds) {
        return false;
      }
      bounds = toLatLngBounds(bounds);
      return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
    },
    // @method isValid(): Boolean
    // Returns `true` if the bounds are properly initialized.
    isValid: function () {
      return !!(this._southWest && this._northEast);
    }
  };

  // TODO International date line?

  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

  // @alternative
  // @factory L.latLngBounds(latlngs: LatLng[])
  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
  function toLatLngBounds(a, b) {
    if (a instanceof LatLngBounds) {
      return a;
    }
    return new LatLngBounds(a, b);
  }

  /* @class LatLng
   * @aka L.LatLng
   *
   * Represents a geographical point with a certain latitude and longitude.
   *
   * @example
   *
   * ```
   * var latlng = L.latLng(50.5, 30.5);
   * ```
   *
   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
   *
   * ```
   * map.panTo([50, 30]);
   * map.panTo({lon: 30, lat: 50});
   * map.panTo({lat: 50, lng: 30});
   * map.panTo(L.latLng(50, 30));
   * ```
   *
   * Note that `LatLng` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function LatLng(lat, lng, alt) {
    if (isNaN(lat) || isNaN(lng)) {
      throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
    }

    // @property lat: Number
    // Latitude in degrees
    this.lat = +lat;

    // @property lng: Number
    // Longitude in degrees
    this.lng = +lng;

    // @property alt: Number
    // Altitude in meters (optional)
    if (alt !== undefined) {
      this.alt = +alt;
    }
  }
  LatLng.prototype = {
    // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
    // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
    equals: function (obj, maxMargin) {
      if (!obj) {
        return false;
      }
      obj = toLatLng(obj);
      var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));
      return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
    },
    // @method toString(): String
    // Returns a string representation of the point (for debugging purposes).
    toString: function (precision) {
      return 'LatLng(' + formatNum(this.lat, precision) + ', ' + formatNum(this.lng, precision) + ')';
    },
    // @method distanceTo(otherLatLng: LatLng): Number
    // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
    distanceTo: function (other) {
      return Earth.distance(this, toLatLng(other));
    },
    // @method wrap(): LatLng
    // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
    wrap: function () {
      return Earth.wrapLatLng(this);
    },
    // @method toBounds(sizeInMeters: Number): LatLngBounds
    // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
    toBounds: function (sizeInMeters) {
      var latAccuracy = 180 * sizeInMeters / 40075017,
        lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
      return toLatLngBounds([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);
    },
    clone: function () {
      return new LatLng(this.lat, this.lng, this.alt);
    }
  };

  // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

  // @alternative
  // @factory L.latLng(coords: Array): LatLng
  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

  // @alternative
  // @factory L.latLng(coords: Object): LatLng
  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

  function toLatLng(a, b, c) {
    if (a instanceof LatLng) {
      return a;
    }
    if (isArray(a) && typeof a[0] !== 'object') {
      if (a.length === 3) {
        return new LatLng(a[0], a[1], a[2]);
      }
      if (a.length === 2) {
        return new LatLng(a[0], a[1]);
      }
      return null;
    }
    if (a === undefined || a === null) {
      return a;
    }
    if (typeof a === 'object' && 'lat' in a) {
      return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
    }
    if (b === undefined) {
      return null;
    }
    return new LatLng(a, b, c);
  }

  /*
   * @namespace CRS
   * @crs L.CRS.Base
   * Object that defines coordinate reference systems for projecting
   * geographical points into pixel (screen) coordinates and back (and to
   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
   * [spatial reference system](https://en.wikipedia.org/wiki/Spatial_reference_system).
   *
   * Leaflet defines the most usual CRSs by default. If you want to use a
   * CRS not defined by default, take a look at the
   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
   *
   * Note that the CRS instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.
   */

  var CRS = {
    // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
    // Projects geographical coordinates into pixel coordinates for a given zoom.
    latLngToPoint: function (latlng, zoom) {
      var projectedPoint = this.projection.project(latlng),
        scale = this.scale(zoom);
      return this.transformation._transform(projectedPoint, scale);
    },
    // @method pointToLatLng(point: Point, zoom: Number): LatLng
    // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
    // zoom into geographical coordinates.
    pointToLatLng: function (point, zoom) {
      var scale = this.scale(zoom),
        untransformedPoint = this.transformation.untransform(point, scale);
      return this.projection.unproject(untransformedPoint);
    },
    // @method project(latlng: LatLng): Point
    // Projects geographical coordinates into coordinates in units accepted for
    // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
    project: function (latlng) {
      return this.projection.project(latlng);
    },
    // @method unproject(point: Point): LatLng
    // Given a projected coordinate returns the corresponding LatLng.
    // The inverse of `project`.
    unproject: function (point) {
      return this.projection.unproject(point);
    },
    // @method scale(zoom: Number): Number
    // Returns the scale used when transforming projected coordinates into
    // pixel coordinates for a particular zoom. For example, it returns
    // `256 * 2^zoom` for Mercator-based CRS.
    scale: function (zoom) {
      return 256 * Math.pow(2, zoom);
    },
    // @method zoom(scale: Number): Number
    // Inverse of `scale()`, returns the zoom level corresponding to a scale
    // factor of `scale`.
    zoom: function (scale) {
      return Math.log(scale / 256) / Math.LN2;
    },
    // @method getProjectedBounds(zoom: Number): Bounds
    // Returns the projection's bounds scaled and transformed for the provided `zoom`.
    getProjectedBounds: function (zoom) {
      if (this.infinite) {
        return null;
      }
      var b = this.projection.bounds,
        s = this.scale(zoom),
        min = this.transformation.transform(b.min, s),
        max = this.transformation.transform(b.max, s);
      return new Bounds(min, max);
    },
    // @method distance(latlng1: LatLng, latlng2: LatLng): Number
    // Returns the distance between two geographical coordinates.

    // @property code: String
    // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
    //
    // @property wrapLng: Number[]
    // An array of two numbers defining whether the longitude (horizontal) coordinate
    // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
    // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
    //
    // @property wrapLat: Number[]
    // Like `wrapLng`, but for the latitude (vertical) axis.

    // wrapLng: [min, max],
    // wrapLat: [min, max],

    // @property infinite: Boolean
    // If true, the coordinate space will be unbounded (infinite in both axes)
    infinite: false,
    // @method wrapLatLng(latlng: LatLng): LatLng
    // Returns a `LatLng` where lat and lng has been wrapped according to the
    // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
    wrapLatLng: function (latlng) {
      var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
        lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
        alt = latlng.alt;
      return new LatLng(lat, lng, alt);
    },
    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
    // Returns a `LatLngBounds` with the same size as the given one, ensuring
    // that its center is within the CRS's bounds.
    // Only accepts actual `L.LatLngBounds` instances, not arrays.
    wrapLatLngBounds: function (bounds) {
      var center = bounds.getCenter(),
        newCenter = this.wrapLatLng(center),
        latShift = center.lat - newCenter.lat,
        lngShift = center.lng - newCenter.lng;
      if (latShift === 0 && lngShift === 0) {
        return bounds;
      }
      var sw = bounds.getSouthWest(),
        ne = bounds.getNorthEast(),
        newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),
        newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
      return new LatLngBounds(newSw, newNe);
    }
  };

  /*
   * @namespace CRS
   * @crs L.CRS.Earth
   *
   * Serves as the base for CRS that are global such that they cover the earth.
   * Can only be used as the base for other CRS and cannot be used directly,
   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
   * meters.
   */

  var Earth = extend({}, CRS, {
    wrapLng: [-180, 180],
    // Mean Earth Radius, as recommended for use by
    // the International Union of Geodesy and Geophysics,
    // see https://rosettacode.org/wiki/Haversine_formula
    R: 6371000,
    // distance between two geographical points using spherical law of cosines approximation
    distance: function (latlng1, latlng2) {
      var rad = Math.PI / 180,
        lat1 = latlng1.lat * rad,
        lat2 = latlng2.lat * rad,
        sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),
        sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),
        a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,
        c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return this.R * c;
    }
  });

  /*
   * @namespace Projection
   * @projection L.Projection.SphericalMercator
   *
   * Spherical Mercator projection — the most common projection for online maps,
   * used by almost all free and commercial tile providers. Assumes that Earth is
   * a sphere. Used by the `EPSG:3857` CRS.
   */

  var earthRadius = 6378137;
  var SphericalMercator = {
    R: earthRadius,
    MAX_LATITUDE: 85.0511287798,
    project: function (latlng) {
      var d = Math.PI / 180,
        max = this.MAX_LATITUDE,
        lat = Math.max(Math.min(max, latlng.lat), -max),
        sin = Math.sin(lat * d);
      return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);
    },
    unproject: function (point) {
      var d = 180 / Math.PI;
      return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);
    },
    bounds: function () {
      var d = earthRadius * Math.PI;
      return new Bounds([-d, -d], [d, d]);
    }()
  };

  /*
   * @class Transformation
   * @aka L.Transformation
   *
   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
   * the reverse. Used by Leaflet in its projections code.
   *
   * @example
   *
   * ```js
   * var transformation = L.transformation(2, 5, -1, 10),
   * 	p = L.point(1, 2),
   * 	p2 = transformation.transform(p), //  L.point(7, 8)
   * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
   * ```
   */

  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
  // Creates a `Transformation` object with the given coefficients.
  function Transformation(a, b, c, d) {
    if (isArray(a)) {
      // use array properties
      this._a = a[0];
      this._b = a[1];
      this._c = a[2];
      this._d = a[3];
      return;
    }
    this._a = a;
    this._b = b;
    this._c = c;
    this._d = d;
  }
  Transformation.prototype = {
    // @method transform(point: Point, scale?: Number): Point
    // Returns a transformed point, optionally multiplied by the given scale.
    // Only accepts actual `L.Point` instances, not arrays.
    transform: function (point, scale) {
      // (Point, Number) -> Point
      return this._transform(point.clone(), scale);
    },
    // destructive transform (faster)
    _transform: function (point, scale) {
      scale = scale || 1;
      point.x = scale * (this._a * point.x + this._b);
      point.y = scale * (this._c * point.y + this._d);
      return point;
    },
    // @method untransform(point: Point, scale?: Number): Point
    // Returns the reverse transformation of the given point, optionally divided
    // by the given scale. Only accepts actual `L.Point` instances, not arrays.
    untransform: function (point, scale) {
      scale = scale || 1;
      return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);
    }
  };

  // factory L.transformation(a: Number, b: Number, c: Number, d: Number)

  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
  // Instantiates a Transformation object with the given coefficients.

  // @alternative
  // @factory L.transformation(coefficients: Array): Transformation
  // Expects an coefficients array of the form
  // `[a: Number, b: Number, c: Number, d: Number]`.

  function toTransformation(a, b, c, d) {
    return new Transformation(a, b, c, d);
  }

  /*
   * @namespace CRS
   * @crs L.CRS.EPSG3857
   *
   * The most common CRS for online maps, used by almost all free and commercial
   * tile providers. Uses Spherical Mercator projection. Set in by default in
   * Map's `crs` option.
   */

  var EPSG3857 = extend({}, Earth, {
    code: 'EPSG:3857',
    projection: SphericalMercator,
    transformation: function () {
      var scale = 0.5 / (Math.PI * SphericalMercator.R);
      return toTransformation(scale, 0.5, -scale, 0.5);
    }()
  });
  var EPSG900913 = extend({}, EPSG3857, {
    code: 'EPSG:900913'
  });

  // @namespace SVG; @section
  // There are several static functions which can be called without instantiating L.SVG:

  // @function create(name: String): SVGElement
  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
  // corresponding to the class name passed. For example, using 'line' will return
  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
  function svgCreate(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
  }

  // @function pointsToPath(rings: Point[], closed: Boolean): String
  // Generates a SVG path string for multiple rings, with each ring turning
  // into "M..L..L.." instructions
  function pointsToPath(rings, closed) {
    var str = '',
      i,
      j,
      len,
      len2,
      points,
      p;
    for (i = 0, len = rings.length; i < len; i++) {
      points = rings[i];
      for (j = 0, len2 = points.length; j < len2; j++) {
        p = points[j];
        str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
      }

      // closes the ring for polygons; "x" is VML syntax
      str += closed ? Browser.svg ? 'z' : 'x' : '';
    }

    // SVG complains about empty path strings
    return str || 'M0 0';
  }

  /*
   * @namespace Browser
   * @aka L.Browser
   *
   * A namespace with static properties for browser/feature detection used by Leaflet internally.
   *
   * @example
   *
   * ```js
   * if (L.Browser.ielt9) {
   *   alert('Upgrade your browser, dude!');
   * }
   * ```
   */

  var style = document.documentElement.style;

  // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).
  var ie = ('ActiveXObject' in window);

  // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.
  var ielt9 = ie && !document.addEventListener;

  // @property edge: Boolean; `true` for the Edge web browser.
  var edge = 'msLaunchUri' in navigator && !('documentMode' in document);

  // @property webkit: Boolean;
  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
  var webkit = userAgentContains('webkit');

  // @property android: Boolean
  // **Deprecated.** `true` for any browser running on an Android platform.
  var android = userAgentContains('android');

  // @property android23: Boolean; **Deprecated.** `true` for browsers running on Android 2 or Android 3.
  var android23 = userAgentContains('android 2') || userAgentContains('android 3');

  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */
  var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit
  // @property androidStock: Boolean; **Deprecated.** `true` for the Android stock browser (i.e. not Chrome)
  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);

  // @property opera: Boolean; `true` for the Opera browser
  var opera = !!window.opera;

  // @property chrome: Boolean; `true` for the Chrome browser.
  var chrome = !edge && userAgentContains('chrome');

  // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.
  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;

  // @property safari: Boolean; `true` for the Safari browser.
  var safari = !chrome && userAgentContains('safari');
  var phantom = userAgentContains('phantom');

  // @property opera12: Boolean
  // `true` for the Opera browser supporting CSS transforms (version 12 or later).
  var opera12 = ('OTransition' in style);

  // @property win: Boolean; `true` when the browser is running in a Windows platform
  var win = navigator.platform.indexOf('Win') === 0;

  // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.
  var ie3d = ie && 'transition' in style;

  // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.
  var webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23;

  // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.
  var gecko3d = ('MozPerspective' in style);

  // @property any3d: Boolean
  // `true` for all browsers supporting CSS transforms.
  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;

  // @property mobile: Boolean; `true` for all browsers running in a mobile device.
  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');

  // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
  var mobileWebkit = mobile && webkit;

  // @property mobileWebkit3d: Boolean
  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
  var mobileWebkit3d = mobile && webkit3d;

  // @property msPointer: Boolean
  // `true` for browsers implementing the Microsoft touch events model (notably IE10).
  var msPointer = !window.PointerEvent && window.MSPointerEvent;

  // @property pointer: Boolean
  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
  var pointer = !!(window.PointerEvent || msPointer);

  // @property touchNative: Boolean
  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
  // **This does not necessarily mean** that the browser is running in a computer with
  // a touchscreen, it only means that the browser is capable of understanding
  // touch events.
  var touchNative = 'ontouchstart' in window || !!window.TouchEvent;

  // @property touch: Boolean
  // `true` for all browsers supporting either [touch](#browser-touch) or [pointer](#browser-pointer) events.
  // Note: pointer events will be preferred (if available), and processed for all `touch*` listeners.
  var touch = !window.L_NO_TOUCH && (touchNative || pointer);

  // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.
  var mobileOpera = mobile && opera;

  // @property mobileGecko: Boolean
  // `true` for gecko-based browsers running in a mobile device.
  var mobileGecko = mobile && gecko;

  // @property retina: Boolean
  // `true` for browsers on a high-resolution "retina" screen or on any screen when browser's display zoom is more than 100%.
  var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;

  // @property passiveEvents: Boolean
  // `true` for browsers that support passive events.
  var passiveEvents = function () {
    var supportsPassiveOption = false;
    try {
      var opts = Object.defineProperty({}, 'passive', {
        get: function () {
          // eslint-disable-line getter-return
          supportsPassiveOption = true;
        }
      });
      window.addEventListener('testPassiveEventSupport', falseFn, opts);
      window.removeEventListener('testPassiveEventSupport', falseFn, opts);
    } catch (e) {
      // Errors can safely be ignored since this is only a browser support test.
    }
    return supportsPassiveOption;
  }();

  // @property canvas: Boolean
  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
  var canvas$1 = function () {
    return !!document.createElement('canvas').getContext;
  }();

  // @property svg: Boolean
  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
  var svg$1 = !!(document.createElementNS && svgCreate('svg').createSVGRect);
  var inlineSvg = !!svg$1 && function () {
    var div = document.createElement('div');
    div.innerHTML = '<svg/>';
    return (div.firstChild && div.firstChild.namespaceURI) === 'http://www.w3.org/2000/svg';
  }();

  // @property vml: Boolean
  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
  var vml = !svg$1 && function () {
    try {
      var div = document.createElement('div');
      div.innerHTML = '<v:shape adj="1"/>';
      var shape = div.firstChild;
      shape.style.behavior = 'url(#default#VML)';
      return shape && typeof shape.adj === 'object';
    } catch (e) {
      return false;
    }
  }();

  // @property mac: Boolean; `true` when the browser is running in a Mac platform
  var mac = navigator.platform.indexOf('Mac') === 0;

  // @property mac: Boolean; `true` when the browser is running in a Linux platform
  var linux = navigator.platform.indexOf('Linux') === 0;
  function userAgentContains(str) {
    return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
  }
  var Browser = {
    ie: ie,
    ielt9: ielt9,
    edge: edge,
    webkit: webkit,
    android: android,
    android23: android23,
    androidStock: androidStock,
    opera: opera,
    chrome: chrome,
    gecko: gecko,
    safari: safari,
    phantom: phantom,
    opera12: opera12,
    win: win,
    ie3d: ie3d,
    webkit3d: webkit3d,
    gecko3d: gecko3d,
    any3d: any3d,
    mobile: mobile,
    mobileWebkit: mobileWebkit,
    mobileWebkit3d: mobileWebkit3d,
    msPointer: msPointer,
    pointer: pointer,
    touch: touch,
    touchNative: touchNative,
    mobileOpera: mobileOpera,
    mobileGecko: mobileGecko,
    retina: retina,
    passiveEvents: passiveEvents,
    canvas: canvas$1,
    svg: svg$1,
    vml: vml,
    inlineSvg: inlineSvg,
    mac: mac,
    linux: linux
  };

  /*
   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
   */

  var POINTER_DOWN = Browser.msPointer ? 'MSPointerDown' : 'pointerdown';
  var POINTER_MOVE = Browser.msPointer ? 'MSPointerMove' : 'pointermove';
  var POINTER_UP = Browser.msPointer ? 'MSPointerUp' : 'pointerup';
  var POINTER_CANCEL = Browser.msPointer ? 'MSPointerCancel' : 'pointercancel';
  var pEvent = {
    touchstart: POINTER_DOWN,
    touchmove: POINTER_MOVE,
    touchend: POINTER_UP,
    touchcancel: POINTER_CANCEL
  };
  var handle = {
    touchstart: _onPointerStart,
    touchmove: _handlePointer,
    touchend: _handlePointer,
    touchcancel: _handlePointer
  };
  var _pointers = {};
  var _pointerDocListener = false;

  // Provides a touch events wrapper for (ms)pointer events.
  // ref https://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

  function addPointerListener(obj, type, handler) {
    if (type === 'touchstart') {
      _addPointerDocListener();
    }
    if (!handle[type]) {
      console.warn('wrong event specified:', type);
      return falseFn;
    }
    handler = handle[type].bind(this, handler);
    obj.addEventListener(pEvent[type], handler, false);
    return handler;
  }
  function removePointerListener(obj, type, handler) {
    if (!pEvent[type]) {
      console.warn('wrong event specified:', type);
      return;
    }
    obj.removeEventListener(pEvent[type], handler, false);
  }
  function _globalPointerDown(e) {
    _pointers[e.pointerId] = e;
  }
  function _globalPointerMove(e) {
    if (_pointers[e.pointerId]) {
      _pointers[e.pointerId] = e;
    }
  }
  function _globalPointerUp(e) {
    delete _pointers[e.pointerId];
  }
  function _addPointerDocListener() {
    // need to keep track of what pointers and how many are active to provide e.touches emulation
    if (!_pointerDocListener) {
      // we listen document as any drags that end by moving the touch off the screen get fired there
      document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
      document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
      document.addEventListener(POINTER_UP, _globalPointerUp, true);
      document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
      _pointerDocListener = true;
    }
  }
  function _handlePointer(handler, e) {
    if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse')) {
      return;
    }
    e.touches = [];
    for (var i in _pointers) {
      e.touches.push(_pointers[i]);
    }
    e.changedTouches = [e];
    handler(e);
  }
  function _onPointerStart(handler, e) {
    // IE10 specific: MsTouch needs preventDefault. See #2000
    if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
      preventDefault(e);
    }
    _handlePointer(handler, e);
  }

  /*
   * Extends the event handling code with double tap support for mobile browsers.
   *
   * Note: currently most browsers fire native dblclick, with only a few exceptions
   * (see https://github.com/Leaflet/Leaflet/issues/7012#issuecomment-595087386)
   */

  function makeDblclick(event) {
    // in modern browsers `type` cannot be just overridden:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only
    var newEvent = {},
      prop,
      i;
    for (i in event) {
      prop = event[i];
      newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
    }
    event = newEvent;
    newEvent.type = 'dblclick';
    newEvent.detail = 2;
    newEvent.isTrusted = false;
    newEvent._simulated = true; // for debug purposes
    return newEvent;
  }
  var delay = 200;
  function addDoubleTapListener(obj, handler) {
    // Most browsers handle double tap natively
    obj.addEventListener('dblclick', handler);

    // On some platforms the browser doesn't fire native dblclicks for touch events.
    // It seems that in all such cases `detail` property of `click` event is always `1`.
    // So here we rely on that fact to avoid excessive 'dblclick' simulation when not needed.
    var last = 0,
      detail;
    function simDblclick(e) {
      if (e.detail !== 1) {
        detail = e.detail; // keep in sync to avoid false dblclick in some cases
        return;
      }
      if (e.pointerType === 'mouse' || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {
        return;
      }

      // When clicking on an <input>, the browser generates a click on its
      // <label> (and vice versa) triggering two clicks in quick succession.
      // This ignores clicks on elements which are a label with a 'for'
      // attribute (or children of such a label), but not children of
      // a <input>.
      var path = getPropagationPath(e);
      if (path.some(function (el) {
        return el instanceof HTMLLabelElement && el.attributes.for;
      }) && !path.some(function (el) {
        return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
      })) {
        return;
      }
      var now = Date.now();
      if (now - last <= delay) {
        detail++;
        if (detail === 2) {
          handler(makeDblclick(e));
        }
      } else {
        detail = 1;
      }
      last = now;
    }
    obj.addEventListener('click', simDblclick);
    return {
      dblclick: handler,
      simDblclick: simDblclick
    };
  }
  function removeDoubleTapListener(obj, handlers) {
    obj.removeEventListener('dblclick', handlers.dblclick);
    obj.removeEventListener('click', handlers.simDblclick);
  }

  /*
   * @namespace DomUtil
   *
   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
   * tree, used by Leaflet internally.
   *
   * Most functions expecting or returning a `HTMLElement` also work for
   * SVG elements. The only difference is that classes refer to CSS classes
   * in HTML and SVG classes in SVG.
   */

  // @property TRANSFORM: String
  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).
  var TRANSFORM = testProp(['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

  // webkitTransition comes first because some browser versions that drop vendor prefix don't do
  // the same for the transitionend event, in particular the Android 4.1 stock browser

  // @property TRANSITION: String
  // Vendor-prefixed transition style name.
  var TRANSITION = testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

  // @property TRANSITION_END: String
  // Vendor-prefixed transitionend event name.
  var TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';

  // @function get(id: String|HTMLElement): HTMLElement
  // Returns an element given its DOM id, or returns the element itself
  // if it was passed directly.
  function get(id) {
    return typeof id === 'string' ? document.getElementById(id) : id;
  }

  // @function getStyle(el: HTMLElement, styleAttrib: String): String
  // Returns the value for a certain style attribute on an element,
  // including computed values or values set through CSS.
  function getStyle(el, style) {
    var value = el.style[style] || el.currentStyle && el.currentStyle[style];
    if ((!value || value === 'auto') && document.defaultView) {
      var css = document.defaultView.getComputedStyle(el, null);
      value = css ? css[style] : null;
    }
    return value === 'auto' ? null : value;
  }

  // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
  function create$1(tagName, className, container) {
    var el = document.createElement(tagName);
    el.className = className || '';
    if (container) {
      container.appendChild(el);
    }
    return el;
  }

  // @function remove(el: HTMLElement)
  // Removes `el` from its parent element
  function remove(el) {
    var parent = el.parentNode;
    if (parent) {
      parent.removeChild(el);
    }
  }

  // @function empty(el: HTMLElement)
  // Removes all of `el`'s children elements from `el`
  function empty(el) {
    while (el.firstChild) {
      el.removeChild(el.firstChild);
    }
  }

  // @function toFront(el: HTMLElement)
  // Makes `el` the last child of its parent, so it renders in front of the other children.
  function toFront(el) {
    var parent = el.parentNode;
    if (parent && parent.lastChild !== el) {
      parent.appendChild(el);
    }
  }

  // @function toBack(el: HTMLElement)
  // Makes `el` the first child of its parent, so it renders behind the other children.
  function toBack(el) {
    var parent = el.parentNode;
    if (parent && parent.firstChild !== el) {
      parent.insertBefore(el, parent.firstChild);
    }
  }

  // @function hasClass(el: HTMLElement, name: String): Boolean
  // Returns `true` if the element's class attribute contains `name`.
  function hasClass(el, name) {
    if (el.classList !== undefined) {
      return el.classList.contains(name);
    }
    var className = getClass(el);
    return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
  }

  // @function addClass(el: HTMLElement, name: String)
  // Adds `name` to the element's class attribute.
  function addClass(el, name) {
    if (el.classList !== undefined) {
      var classes = splitWords(name);
      for (var i = 0, len = classes.length; i < len; i++) {
        el.classList.add(classes[i]);
      }
    } else if (!hasClass(el, name)) {
      var className = getClass(el);
      setClass(el, (className ? className + ' ' : '') + name);
    }
  }

  // @function removeClass(el: HTMLElement, name: String)
  // Removes `name` from the element's class attribute.
  function removeClass(el, name) {
    if (el.classList !== undefined) {
      el.classList.remove(name);
    } else {
      setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
    }
  }

  // @function setClass(el: HTMLElement, name: String)
  // Sets the element's class.
  function setClass(el, name) {
    if (el.className.baseVal === undefined) {
      el.className = name;
    } else {
      // in case of SVG element
      el.className.baseVal = name;
    }
  }

  // @function getClass(el: HTMLElement): String
  // Returns the element's class.
  function getClass(el) {
    // Check if the element is an SVGElementInstance and use the correspondingElement instead
    // (Required for linked SVG elements in IE11.)
    if (el.correspondingElement) {
      el = el.correspondingElement;
    }
    return el.className.baseVal === undefined ? el.className : el.className.baseVal;
  }

  // @function setOpacity(el: HTMLElement, opacity: Number)
  // Set the opacity of an element (including old IE support).
  // `opacity` must be a number from `0` to `1`.
  function setOpacity(el, value) {
    if ('opacity' in el.style) {
      el.style.opacity = value;
    } else if ('filter' in el.style) {
      _setOpacityIE(el, value);
    }
  }
  function _setOpacityIE(el, value) {
    var filter = false,
      filterName = 'DXImageTransform.Microsoft.Alpha';

    // filters collection throws an error if we try to retrieve a filter that doesn't exist
    try {
      filter = el.filters.item(filterName);
    } catch (e) {
      // don't set opacity to 1 if we haven't already set an opacity,
      // it isn't needed and breaks transparent pngs.
      if (value === 1) {
        return;
      }
    }
    value = Math.round(value * 100);
    if (filter) {
      filter.Enabled = value !== 100;
      filter.Opacity = value;
    } else {
      el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
    }
  }

  // @function testProp(props: String[]): String|false
  // Goes through the array of style names and returns the first name
  // that is a valid style name for an element. If no such name is found,
  // it returns false. Useful for vendor-prefixed styles like `transform`.
  function testProp(props) {
    var style = document.documentElement.style;
    for (var i = 0; i < props.length; i++) {
      if (props[i] in style) {
        return props[i];
      }
    }
    return false;
  }

  // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
  // and optionally scaled by `scale`. Does not have an effect if the
  // browser doesn't support 3D CSS transforms.
  function setTransform(el, offset, scale) {
    var pos = offset || new Point(0, 0);
    el.style[TRANSFORM] = (Browser.ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : '');
  }

  // @function setPosition(el: HTMLElement, position: Point)
  // Sets the position of `el` to coordinates specified by `position`,
  // using CSS translate or top/left positioning depending on the browser
  // (used by Leaflet internally to position its layers).
  function setPosition(el, point) {
    /*eslint-disable */
    el._leaflet_pos = point;
    /* eslint-enable */

    if (Browser.any3d) {
      setTransform(el, point);
    } else {
      el.style.left = point.x + 'px';
      el.style.top = point.y + 'px';
    }
  }

  // @function getPosition(el: HTMLElement): Point
  // Returns the coordinates of an element previously positioned with setPosition.
  function getPosition(el) {
    // this method is only used for elements previously positioned using setPosition,
    // so it's safe to cache the position for performance

    return el._leaflet_pos || new Point(0, 0);
  }

  // @function disableTextSelection()
  // Prevents the user from generating `selectstart` DOM events, usually generated
  // when the user drags the mouse through a page with text. Used internally
  // by Leaflet to override the behaviour of any click-and-drag interaction on
  // the map. Affects drag interactions on the whole document.

  // @function enableTextSelection()
  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
  var disableTextSelection;
  var enableTextSelection;
  var _userSelect;
  if ('onselectstart' in document) {
    disableTextSelection = function () {
      on(window, 'selectstart', preventDefault);
    };
    enableTextSelection = function () {
      off(window, 'selectstart', preventDefault);
    };
  } else {
    var userSelectProperty = testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);
    disableTextSelection = function () {
      if (userSelectProperty) {
        var style = document.documentElement.style;
        _userSelect = style[userSelectProperty];
        style[userSelectProperty] = 'none';
      }
    };
    enableTextSelection = function () {
      if (userSelectProperty) {
        document.documentElement.style[userSelectProperty] = _userSelect;
        _userSelect = undefined;
      }
    };
  }

  // @function disableImageDrag()
  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
  // for `dragstart` DOM events, usually generated when the user drags an image.
  function disableImageDrag() {
    on(window, 'dragstart', preventDefault);
  }

  // @function enableImageDrag()
  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
  function enableImageDrag() {
    off(window, 'dragstart', preventDefault);
  }
  var _outlineElement, _outlineStyle;
  // @function preventOutline(el: HTMLElement)
  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
  // of the element `el` invisible. Used internally by Leaflet to prevent
  // focusable elements from displaying an outline when the user performs a
  // drag interaction on them.
  function preventOutline(element) {
    while (element.tabIndex === -1) {
      element = element.parentNode;
    }
    if (!element.style) {
      return;
    }
    restoreOutline();
    _outlineElement = element;
    _outlineStyle = element.style.outlineStyle;
    element.style.outlineStyle = 'none';
    on(window, 'keydown', restoreOutline);
  }

  // @function restoreOutline()
  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
  function restoreOutline() {
    if (!_outlineElement) {
      return;
    }
    _outlineElement.style.outlineStyle = _outlineStyle;
    _outlineElement = undefined;
    _outlineStyle = undefined;
    off(window, 'keydown', restoreOutline);
  }

  // @function getSizedParentNode(el: HTMLElement): HTMLElement
  // Finds the closest parent node which size (width and height) is not null.
  function getSizedParentNode(element) {
    do {
      element = element.parentNode;
    } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
    return element;
  }

  // @function getScale(el: HTMLElement): Object
  // Computes the CSS scale currently applied on the element.
  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,
  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).
  function getScale(element) {
    var rect = element.getBoundingClientRect(); // Read-only in old browsers.

    return {
      x: rect.width / element.offsetWidth || 1,
      y: rect.height / element.offsetHeight || 1,
      boundingClientRect: rect
    };
  }
  var DomUtil = {
    __proto__: null,
    TRANSFORM: TRANSFORM,
    TRANSITION: TRANSITION,
    TRANSITION_END: TRANSITION_END,
    get: get,
    getStyle: getStyle,
    create: create$1,
    remove: remove,
    empty: empty,
    toFront: toFront,
    toBack: toBack,
    hasClass: hasClass,
    addClass: addClass,
    removeClass: removeClass,
    setClass: setClass,
    getClass: getClass,
    setOpacity: setOpacity,
    testProp: testProp,
    setTransform: setTransform,
    setPosition: setPosition,
    getPosition: getPosition,
    get disableTextSelection() {
      return disableTextSelection;
    },
    get enableTextSelection() {
      return enableTextSelection;
    },
    disableImageDrag: disableImageDrag,
    enableImageDrag: enableImageDrag,
    preventOutline: preventOutline,
    restoreOutline: restoreOutline,
    getSizedParentNode: getSizedParentNode,
    getScale: getScale
  };

  /*
   * @namespace DomEvent
   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
   */

  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.

  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
  // Adds a listener function (`fn`) to a particular DOM event type of the
  // element `el`. You can optionally specify the context of the listener
  // (object the `this` keyword will point to). You can also pass several
  // space-separated types (e.g. `'click dblclick'`).

  // @alternative
  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this
  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
  function on(obj, types, fn, context) {
    if (types && typeof types === 'object') {
      for (var type in types) {
        addOne(obj, type, types[type], fn);
      }
    } else {
      types = splitWords(types);
      for (var i = 0, len = types.length; i < len; i++) {
        addOne(obj, types[i], fn, context);
      }
    }
    return this;
  }
  var eventsKey = '_leaflet_events';

  // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
  // Removes a previously added listener function.
  // Note that if you passed a custom context to on, you must pass the same
  // context to `off` in order to remove the listener.

  // @alternative
  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this
  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`

  // @alternative
  // @function off(el: HTMLElement, types: String): this
  // Removes all previously added listeners of given types.

  // @alternative
  // @function off(el: HTMLElement): this
  // Removes all previously added listeners from given HTMLElement
  function off(obj, types, fn, context) {
    if (arguments.length === 1) {
      batchRemove(obj);
      delete obj[eventsKey];
    } else if (types && typeof types === 'object') {
      for (var type in types) {
        removeOne(obj, type, types[type], fn);
      }
    } else {
      types = splitWords(types);
      if (arguments.length === 2) {
        batchRemove(obj, function (type) {
          return indexOf(types, type) !== -1;
        });
      } else {
        for (var i = 0, len = types.length; i < len; i++) {
          removeOne(obj, types[i], fn, context);
        }
      }
    }
    return this;
  }
  function batchRemove(obj, filterFn) {
    for (var id in obj[eventsKey]) {
      var type = id.split(/\d/)[0];
      if (!filterFn || filterFn(type)) {
        removeOne(obj, type, null, null, id);
      }
    }
  }
  var mouseSubst = {
    mouseenter: 'mouseover',
    mouseleave: 'mouseout',
    wheel: !('onwheel' in window) && 'mousewheel'
  };
  function addOne(obj, type, fn, context) {
    var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');
    if (obj[eventsKey] && obj[eventsKey][id]) {
      return this;
    }
    var handler = function (e) {
      return fn.call(context || obj, e || window.event);
    };
    var originalHandler = handler;
    if (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {
      // Needs DomEvent.Pointer.js
      handler = addPointerListener(obj, type, handler);
    } else if (Browser.touch && type === 'dblclick') {
      handler = addDoubleTapListener(obj, handler);
    } else if ('addEventListener' in obj) {
      if (type === 'touchstart' || type === 'touchmove' || type === 'wheel' || type === 'mousewheel') {
        obj.addEventListener(mouseSubst[type] || type, handler, Browser.passiveEvents ? {
          passive: false
        } : false);
      } else if (type === 'mouseenter' || type === 'mouseleave') {
        handler = function (e) {
          e = e || window.event;
          if (isExternalTarget(obj, e)) {
            originalHandler(e);
          }
        };
        obj.addEventListener(mouseSubst[type], handler, false);
      } else {
        obj.addEventListener(type, originalHandler, false);
      }
    } else {
      obj.attachEvent('on' + type, handler);
    }
    obj[eventsKey] = obj[eventsKey] || {};
    obj[eventsKey][id] = handler;
  }
  function removeOne(obj, type, fn, context, id) {
    id = id || type + stamp(fn) + (context ? '_' + stamp(context) : '');
    var handler = obj[eventsKey] && obj[eventsKey][id];
    if (!handler) {
      return this;
    }
    if (!Browser.touchNative && Browser.pointer && type.indexOf('touch') === 0) {
      removePointerListener(obj, type, handler);
    } else if (Browser.touch && type === 'dblclick') {
      removeDoubleTapListener(obj, handler);
    } else if ('removeEventListener' in obj) {
      obj.removeEventListener(mouseSubst[type] || type, handler, false);
    } else {
      obj.detachEvent('on' + type, handler);
    }
    obj[eventsKey][id] = null;
  }

  // @function stopPropagation(ev: DOMEvent): this
  // Stop the given event from propagation to parent elements. Used inside the listener functions:
  // ```js
  // L.DomEvent.on(div, 'click', function (ev) {
  // 	L.DomEvent.stopPropagation(ev);
  // });
  // ```
  function stopPropagation(e) {
    if (e.stopPropagation) {
      e.stopPropagation();
    } else if (e.originalEvent) {
      // In case of Leaflet event.
      e.originalEvent._stopped = true;
    } else {
      e.cancelBubble = true;
    }
    return this;
  }

  // @function disableScrollPropagation(el: HTMLElement): this
  // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).
  function disableScrollPropagation(el) {
    addOne(el, 'wheel', stopPropagation);
    return this;
  }

  // @function disableClickPropagation(el: HTMLElement): this
  // Adds `stopPropagation` to the element's `'click'`, `'dblclick'`, `'contextmenu'`,
  // `'mousedown'` and `'touchstart'` events (plus browser variants).
  function disableClickPropagation(el) {
    on(el, 'mousedown touchstart dblclick contextmenu', stopPropagation);
    el['_leaflet_disable_click'] = true;
    return this;
  }

  // @function preventDefault(ev: DOMEvent): this
  // Prevents the default action of the DOM Event `ev` from happening (such as
  // following a link in the href of the a element, or doing a POST request
  // with page reload when a `<form>` is submitted).
  // Use it inside listener functions.
  function preventDefault(e) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }
    return this;
  }

  // @function stop(ev: DOMEvent): this
  // Does `stopPropagation` and `preventDefault` at the same time.
  function stop(e) {
    preventDefault(e);
    stopPropagation(e);
    return this;
  }

  // @function getPropagationPath(ev: DOMEvent): Array
  // Compatibility polyfill for [`Event.composedPath()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath).
  // Returns an array containing the `HTMLElement`s that the given DOM event
  // should propagate to (if not stopped).
  function getPropagationPath(ev) {
    if (ev.composedPath) {
      return ev.composedPath();
    }
    var path = [];
    var el = ev.target;
    while (el) {
      path.push(el);
      el = el.parentNode;
    }
    return path;
  }

  // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
  // Gets normalized mouse position from a DOM event relative to the
  // `container` (border excluded) or to the whole page if not specified.
  function getMousePosition(e, container) {
    if (!container) {
      return new Point(e.clientX, e.clientY);
    }
    var scale = getScale(container),
      offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)

    return new Point(
    // offset.left/top values are in page scale (like clientX/Y),
    // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
    (e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);
  }

  //  except , Safari and
  // We need double the scroll pixels (see #7403 and #4538) for all Browsers
  // except OSX (Mac) -> 3x, Chrome running on Linux 1x

  var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
  // @function getWheelDelta(ev: DOMEvent): Number
  // Gets normalized wheel delta from a wheel DOM event, in vertical
  // pixels scrolled (negative if scrolling down).
  // Events from pointing devices without precise scrolling are mapped to
  // a best guess of 60 pixels.
  function getWheelDelta(e) {
    return Browser.edge ? e.wheelDeltaY / 2 :
    // Don't trust window-geometry-based delta
    e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor :
    // Pixels
    e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 :
    // Lines
    e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 :
    // Pages
    e.deltaX || e.deltaZ ? 0 :
    // Skip horizontal/depth wheel events
    e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 :
    // Legacy IE pixels
    e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 :
    // Legacy Moz lines
    e.detail ? e.detail / -32765 * 60 :
    // Legacy Moz pages
    0;
  }

  // check if element really left/entered the event target (for mouseenter/mouseleave)
  function isExternalTarget(el, e) {
    var related = e.relatedTarget;
    if (!related) {
      return true;
    }
    try {
      while (related && related !== el) {
        related = related.parentNode;
      }
    } catch (err) {
      return false;
    }
    return related !== el;
  }
  var DomEvent = {
    __proto__: null,
    on: on,
    off: off,
    stopPropagation: stopPropagation,
    disableScrollPropagation: disableScrollPropagation,
    disableClickPropagation: disableClickPropagation,
    preventDefault: preventDefault,
    stop: stop,
    getPropagationPath: getPropagationPath,
    getMousePosition: getMousePosition,
    getWheelDelta: getWheelDelta,
    isExternalTarget: isExternalTarget,
    addListener: on,
    removeListener: off
  };

  /*
   * @class PosAnimation
   * @aka L.PosAnimation
   * @inherits Evented
   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
   *
   * @example
   * ```js
   * var myPositionMarker = L.marker([48.864716, 2.294694]).addTo(map);
   *
   * myPositionMarker.on("click", function() {
   * 	var pos = map.latLngToLayerPoint(myPositionMarker.getLatLng());
   * 	pos.y -= 25;
   * 	var fx = new L.PosAnimation();
   *
   * 	fx.once('end',function() {
   * 		pos.y += 25;
   * 		fx.run(myPositionMarker._icon, pos, 0.8);
   * 	});
   *
   * 	fx.run(myPositionMarker._icon, pos, 0.3);
   * });
   *
   * ```
   *
   * @constructor L.PosAnimation()
   * Creates a `PosAnimation` object.
   *
   */

  var PosAnimation = Evented.extend({
    // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
    // Run an animation of a given element to a new position, optionally setting
    // duration in seconds (`0.25` by default) and easing linearity factor (3rd
    // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
    // `0.5` by default).
    run: function (el, newPos, duration, easeLinearity) {
      this.stop();
      this._el = el;
      this._inProgress = true;
      this._duration = duration || 0.25;
      this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
      this._startPos = getPosition(el);
      this._offset = newPos.subtract(this._startPos);
      this._startTime = +new Date();

      // @event start: Event
      // Fired when the animation starts
      this.fire('start');
      this._animate();
    },
    // @method stop()
    // Stops the animation (if currently running).
    stop: function () {
      if (!this._inProgress) {
        return;
      }
      this._step(true);
      this._complete();
    },
    _animate: function () {
      // animation loop
      this._animId = requestAnimFrame(this._animate, this);
      this._step();
    },
    _step: function (round) {
      var elapsed = +new Date() - this._startTime,
        duration = this._duration * 1000;
      if (elapsed < duration) {
        this._runFrame(this._easeOut(elapsed / duration), round);
      } else {
        this._runFrame(1);
        this._complete();
      }
    },
    _runFrame: function (progress, round) {
      var pos = this._startPos.add(this._offset.multiplyBy(progress));
      if (round) {
        pos._round();
      }
      setPosition(this._el, pos);

      // @event step: Event
      // Fired continuously during the animation.
      this.fire('step');
    },
    _complete: function () {
      cancelAnimFrame(this._animId);
      this._inProgress = false;
      // @event end: Event
      // Fired when the animation ends.
      this.fire('end');
    },
    _easeOut: function (t) {
      return 1 - Math.pow(1 - t, this._easeOutPower);
    }
  });

  /*
   * @class Map
   * @aka L.Map
   * @inherits Evented
   *
   * The central class of the API — it is used to create a map on a page and manipulate it.
   *
   * @example
   *
   * ```js
   * // initialize the map on the "map" div with a given center and zoom
   * var map = L.map('map', {
   * 	center: [51.505, -0.09],
   * 	zoom: 13
   * });
   * ```
   *
   */

  var Map = Evented.extend({
    options: {
      // @section Map State Options
      // @option crs: CRS = L.CRS.EPSG3857
      // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
      // sure what it means.
      crs: EPSG3857,
      // @option center: LatLng = undefined
      // Initial geographic center of the map
      center: undefined,
      // @option zoom: Number = undefined
      // Initial map zoom level
      zoom: undefined,
      // @option minZoom: Number = *
      // Minimum zoom level of the map.
      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
      // the lowest of their `minZoom` options will be used instead.
      minZoom: undefined,
      // @option maxZoom: Number = *
      // Maximum zoom level of the map.
      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
      // the highest of their `maxZoom` options will be used instead.
      maxZoom: undefined,
      // @option layers: Layer[] = []
      // Array of layers that will be added to the map initially
      layers: [],
      // @option maxBounds: LatLngBounds = null
      // When this option is set, the map restricts the view to the given
      // geographical bounds, bouncing the user back if the user tries to pan
      // outside the view. To set the restriction dynamically, use
      // [`setMaxBounds`](#map-setmaxbounds) method.
      maxBounds: undefined,
      // @option renderer: Renderer = *
      // The default method for drawing vector layers on the map. `L.SVG`
      // or `L.Canvas` by default depending on browser support.
      renderer: undefined,
      // @section Animation Options
      // @option zoomAnimation: Boolean = true
      // Whether the map zoom animation is enabled. By default it's enabled
      // in all browsers that support CSS3 Transitions except Android.
      zoomAnimation: true,
      // @option zoomAnimationThreshold: Number = 4
      // Won't animate zoom if the zoom difference exceeds this value.
      zoomAnimationThreshold: 4,
      // @option fadeAnimation: Boolean = true
      // Whether the tile fade animation is enabled. By default it's enabled
      // in all browsers that support CSS3 Transitions except Android.
      fadeAnimation: true,
      // @option markerZoomAnimation: Boolean = true
      // Whether markers animate their zoom with the zoom animation, if disabled
      // they will disappear for the length of the animation. By default it's
      // enabled in all browsers that support CSS3 Transitions except Android.
      markerZoomAnimation: true,
      // @option transform3DLimit: Number = 2^23
      // Defines the maximum size of a CSS translation transform. The default
      // value should not be changed unless a web browser positions layers in
      // the wrong place after doing a large `panBy`.
      transform3DLimit: 8388608,
      // Precision limit of a 32-bit float

      // @section Interaction Options
      // @option zoomSnap: Number = 1
      // Forces the map's zoom level to always be a multiple of this, particularly
      // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
      // By default, the zoom level snaps to the nearest integer; lower values
      // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
      // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
      zoomSnap: 1,
      // @option zoomDelta: Number = 1
      // Controls how much the map's zoom level will change after a
      // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
      // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
      // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
      zoomDelta: 1,
      // @option trackResize: Boolean = true
      // Whether the map automatically handles browser window resize to update itself.
      trackResize: true
    },
    initialize: function (id, options) {
      // (HTMLElement or String, Object)
      options = setOptions(this, options);

      // Make sure to assign internal flags at the beginning,
      // to avoid inconsistent state in some edge cases.
      this._handlers = [];
      this._layers = {};
      this._zoomBoundLayers = {};
      this._sizeChanged = true;
      this._initContainer(id);
      this._initLayout();

      // hack for https://github.com/Leaflet/Leaflet/issues/1980
      this._onResize = bind(this._onResize, this);
      this._initEvents();
      if (options.maxBounds) {
        this.setMaxBounds(options.maxBounds);
      }
      if (options.zoom !== undefined) {
        this._zoom = this._limitZoom(options.zoom);
      }
      if (options.center && options.zoom !== undefined) {
        this.setView(toLatLng(options.center), options.zoom, {
          reset: true
        });
      }
      this.callInitHooks();

      // don't animate on browsers without hardware-accelerated transitions or old Android/Opera
      this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation;

      // zoom transitions run with the same duration for all layers, so if one of transitionend events
      // happens after starting zoom animation (propagating to the map pane), we know that it ended globally
      if (this._zoomAnimated) {
        this._createAnimProxy();
        on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
      }
      this._addLayers(this.options.layers);
    },
    // @section Methods for modifying map state

    // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
    // Sets the view of the map (geographical center and zoom) with the given
    // animation options.
    setView: function (center, zoom, options) {
      zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
      center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
      options = options || {};
      this._stop();
      if (this._loaded && !options.reset && options !== true) {
        if (options.animate !== undefined) {
          options.zoom = extend({
            animate: options.animate
          }, options.zoom);
          options.pan = extend({
            animate: options.animate,
            duration: options.duration
          }, options.pan);
        }

        // try animating pan or zoom
        var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);
        if (moved) {
          // prevent resize handler call, the view will refresh after animation anyway
          clearTimeout(this._sizeTimer);
          return this;
        }
      }

      // animation didn't start, just reset the map view
      this._resetView(center, zoom, options.pan && options.pan.noMoveStart);
      return this;
    },
    // @method setZoom(zoom: Number, options?: Zoom/pan options): this
    // Sets the zoom of the map.
    setZoom: function (zoom, options) {
      if (!this._loaded) {
        this._zoom = zoom;
        return this;
      }
      return this.setView(this.getCenter(), zoom, {
        zoom: options
      });
    },
    // @method zoomIn(delta?: Number, options?: Zoom options): this
    // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
    zoomIn: function (delta, options) {
      delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
      return this.setZoom(this._zoom + delta, options);
    },
    // @method zoomOut(delta?: Number, options?: Zoom options): this
    // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
    zoomOut: function (delta, options) {
      delta = delta || (Browser.any3d ? this.options.zoomDelta : 1);
      return this.setZoom(this._zoom - delta, options);
    },
    // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
    // Zooms the map while keeping a specified geographical point on the map
    // stationary (e.g. used internally for scroll zoom and double-click zoom).
    // @alternative
    // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
    // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
    setZoomAround: function (latlng, zoom, options) {
      var scale = this.getZoomScale(zoom),
        viewHalf = this.getSize().divideBy(2),
        containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),
        centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
        newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
      return this.setView(newCenter, zoom, {
        zoom: options
      });
    },
    _getBoundsCenterZoom: function (bounds, options) {
      options = options || {};
      bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
        paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
        zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
      zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;
      if (zoom === Infinity) {
        return {
          center: bounds.getCenter(),
          zoom: zoom
        };
      }
      var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),
        swPoint = this.project(bounds.getSouthWest(), zoom),
        nePoint = this.project(bounds.getNorthEast(), zoom),
        center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);
      return {
        center: center,
        zoom: zoom
      };
    },
    // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
    // Sets a map view that contains the given geographical bounds with the
    // maximum zoom level possible.
    fitBounds: function (bounds, options) {
      bounds = toLatLngBounds(bounds);
      if (!bounds.isValid()) {
        throw new Error('Bounds are not valid.');
      }
      var target = this._getBoundsCenterZoom(bounds, options);
      return this.setView(target.center, target.zoom, options);
    },
    // @method fitWorld(options?: fitBounds options): this
    // Sets a map view that mostly contains the whole world with the maximum
    // zoom level possible.
    fitWorld: function (options) {
      return this.fitBounds([[-90, -180], [90, 180]], options);
    },
    // @method panTo(latlng: LatLng, options?: Pan options): this
    // Pans the map to a given center.
    panTo: function (center, options) {
      // (LatLng)
      return this.setView(center, this._zoom, {
        pan: options
      });
    },
    // @method panBy(offset: Point, options?: Pan options): this
    // Pans the map by a given number of pixels (animated).
    panBy: function (offset, options) {
      offset = toPoint(offset).round();
      options = options || {};
      if (!offset.x && !offset.y) {
        return this.fire('moveend');
      }
      // If we pan too far, Chrome gets issues with tiles
      // and makes them disappear or appear in the wrong place (slightly offset) #2602
      if (options.animate !== true && !this.getSize().contains(offset)) {
        this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
        return this;
      }
      if (!this._panAnim) {
        this._panAnim = new PosAnimation();
        this._panAnim.on({
          'step': this._onPanTransitionStep,
          'end': this._onPanTransitionEnd
        }, this);
      }

      // don't fire movestart if animating inertia
      if (!options.noMoveStart) {
        this.fire('movestart');
      }

      // animate pan unless animate: false specified
      if (options.animate !== false) {
        addClass(this._mapPane, 'leaflet-pan-anim');
        var newPos = this._getMapPanePos().subtract(offset).round();
        this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
      } else {
        this._rawPanBy(offset);
        this.fire('move').fire('moveend');
      }
      return this;
    },
    // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
    // Sets the view of the map (geographical center and zoom) performing a smooth
    // pan-zoom animation.
    flyTo: function (targetCenter, targetZoom, options) {
      options = options || {};
      if (options.animate === false || !Browser.any3d) {
        return this.setView(targetCenter, targetZoom, options);
      }
      this._stop();
      var from = this.project(this.getCenter()),
        to = this.project(targetCenter),
        size = this.getSize(),
        startZoom = this._zoom;
      targetCenter = toLatLng(targetCenter);
      targetZoom = targetZoom === undefined ? startZoom : targetZoom;
      var w0 = Math.max(size.x, size.y),
        w1 = w0 * this.getZoomScale(startZoom, targetZoom),
        u1 = to.distanceTo(from) || 1,
        rho = 1.42,
        rho2 = rho * rho;
      function r(i) {
        var s1 = i ? -1 : 1,
          s2 = i ? w1 : w0,
          t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
          b1 = 2 * s2 * rho2 * u1,
          b = t1 / b1,
          sq = Math.sqrt(b * b + 1) - b;

        // workaround for floating point precision bug when sq = 0, log = -Infinite,
        // thus triggering an infinite loop in flyTo
        var log = sq < 0.000000001 ? -18 : Math.log(sq);
        return log;
      }
      function sinh(n) {
        return (Math.exp(n) - Math.exp(-n)) / 2;
      }
      function cosh(n) {
        return (Math.exp(n) + Math.exp(-n)) / 2;
      }
      function tanh(n) {
        return sinh(n) / cosh(n);
      }
      var r0 = r(0);
      function w(s) {
        return w0 * (cosh(r0) / cosh(r0 + rho * s));
      }
      function u(s) {
        return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
      }
      function easeOut(t) {
        return 1 - Math.pow(1 - t, 1.5);
      }
      var start = Date.now(),
        S = (r(1) - r0) / rho,
        duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;
      function frame() {
        var t = (Date.now() - start) / duration,
          s = easeOut(t) * S;
        if (t <= 1) {
          this._flyToFrame = requestAnimFrame(frame, this);
          this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {
            flyTo: true
          });
        } else {
          this._move(targetCenter, targetZoom)._moveEnd(true);
        }
      }
      this._moveStart(true, options.noMoveStart);
      frame.call(this);
      return this;
    },
    // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
    // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
    // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
    flyToBounds: function (bounds, options) {
      var target = this._getBoundsCenterZoom(bounds, options);
      return this.flyTo(target.center, target.zoom, options);
    },
    // @method setMaxBounds(bounds: LatLngBounds): this
    // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
    setMaxBounds: function (bounds) {
      bounds = toLatLngBounds(bounds);
      if (this.listens('moveend', this._panInsideMaxBounds)) {
        this.off('moveend', this._panInsideMaxBounds);
      }
      if (!bounds.isValid()) {
        this.options.maxBounds = null;
        return this;
      }
      this.options.maxBounds = bounds;
      if (this._loaded) {
        this._panInsideMaxBounds();
      }
      return this.on('moveend', this._panInsideMaxBounds);
    },
    // @method setMinZoom(zoom: Number): this
    // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
    setMinZoom: function (zoom) {
      var oldZoom = this.options.minZoom;
      this.options.minZoom = zoom;
      if (this._loaded && oldZoom !== zoom) {
        this.fire('zoomlevelschange');
        if (this.getZoom() < this.options.minZoom) {
          return this.setZoom(zoom);
        }
      }
      return this;
    },
    // @method setMaxZoom(zoom: Number): this
    // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
    setMaxZoom: function (zoom) {
      var oldZoom = this.options.maxZoom;
      this.options.maxZoom = zoom;
      if (this._loaded && oldZoom !== zoom) {
        this.fire('zoomlevelschange');
        if (this.getZoom() > this.options.maxZoom) {
          return this.setZoom(zoom);
        }
      }
      return this;
    },
    // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
    // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
    panInsideBounds: function (bounds, options) {
      this._enforcingBounds = true;
      var center = this.getCenter(),
        newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
      if (!center.equals(newCenter)) {
        this.panTo(newCenter, options);
      }
      this._enforcingBounds = false;
      return this;
    },
    // @method panInside(latlng: LatLng, options?: padding options): this
    // Pans the map the minimum amount to make the `latlng` visible. Use
    // padding options to fit the display to more restricted bounds.
    // If `latlng` is already within the (optionally padded) display bounds,
    // the map will not be panned.
    panInside: function (latlng, options) {
      options = options || {};
      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
        paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
        pixelCenter = this.project(this.getCenter()),
        pixelPoint = this.project(latlng),
        pixelBounds = this.getPixelBounds(),
        paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]),
        paddedSize = paddedBounds.getSize();
      if (!paddedBounds.contains(pixelPoint)) {
        this._enforcingBounds = true;
        var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
        var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
        pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
        pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
        this.panTo(this.unproject(pixelCenter), options);
        this._enforcingBounds = false;
      }
      return this;
    },
    // @method invalidateSize(options: Zoom/pan options): this
    // Checks if the map container size changed and updates the map if so —
    // call it after you've changed the map size dynamically, also animating
    // pan by default. If `options.pan` is `false`, panning will not occur.
    // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
    // that it doesn't happen often even if the method is called many
    // times in a row.

    // @alternative
    // @method invalidateSize(animate: Boolean): this
    // Checks if the map container size changed and updates the map if so —
    // call it after you've changed the map size dynamically, also animating
    // pan by default.
    invalidateSize: function (options) {
      if (!this._loaded) {
        return this;
      }
      options = extend({
        animate: false,
        pan: true
      }, options === true ? {
        animate: true
      } : options);
      var oldSize = this.getSize();
      this._sizeChanged = true;
      this._lastCenter = null;
      var newSize = this.getSize(),
        oldCenter = oldSize.divideBy(2).round(),
        newCenter = newSize.divideBy(2).round(),
        offset = oldCenter.subtract(newCenter);
      if (!offset.x && !offset.y) {
        return this;
      }
      if (options.animate && options.pan) {
        this.panBy(offset);
      } else {
        if (options.pan) {
          this._rawPanBy(offset);
        }
        this.fire('move');
        if (options.debounceMoveend) {
          clearTimeout(this._sizeTimer);
          this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);
        } else {
          this.fire('moveend');
        }
      }

      // @section Map state change events
      // @event resize: ResizeEvent
      // Fired when the map is resized.
      return this.fire('resize', {
        oldSize: oldSize,
        newSize: newSize
      });
    },
    // @section Methods for modifying map state
    // @method stop(): this
    // Stops the currently running `panTo` or `flyTo` animation, if any.
    stop: function () {
      this.setZoom(this._limitZoom(this._zoom));
      if (!this.options.zoomSnap) {
        this.fire('viewreset');
      }
      return this._stop();
    },
    // @section Geolocation methods
    // @method locate(options?: Locate options): this
    // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
    // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
    // and optionally sets the map view to the user's location with respect to
    // detection accuracy (or to the world view if geolocation failed).
    // Note that, if your page doesn't use HTTPS, this method will fail in
    // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
    // See `Locate options` for more details.
    locate: function (options) {
      options = this._locateOptions = extend({
        timeout: 10000,
        watch: false
        // setView: false
        // maxZoom: <Number>
        // maximumAge: 0
        // enableHighAccuracy: false
      }, options);
      if (!('geolocation' in navigator)) {
        this._handleGeolocationError({
          code: 0,
          message: 'Geolocation not supported.'
        });
        return this;
      }
      var onResponse = bind(this._handleGeolocationResponse, this),
        onError = bind(this._handleGeolocationError, this);
      if (options.watch) {
        this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
      } else {
        navigator.geolocation.getCurrentPosition(onResponse, onError, options);
      }
      return this;
    },
    // @method stopLocate(): this
    // Stops watching location previously initiated by `map.locate({watch: true})`
    // and aborts resetting the map view if map.locate was called with
    // `{setView: true}`.
    stopLocate: function () {
      if (navigator.geolocation && navigator.geolocation.clearWatch) {
        navigator.geolocation.clearWatch(this._locationWatchId);
      }
      if (this._locateOptions) {
        this._locateOptions.setView = false;
      }
      return this;
    },
    _handleGeolocationError: function (error) {
      if (!this._container._leaflet_id) {
        return;
      }
      var c = error.code,
        message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');
      if (this._locateOptions.setView && !this._loaded) {
        this.fitWorld();
      }

      // @section Location events
      // @event locationerror: ErrorEvent
      // Fired when geolocation (using the [`locate`](#map-locate) method) failed.
      this.fire('locationerror', {
        code: c,
        message: 'Geolocation error: ' + message + '.'
      });
    },
    _handleGeolocationResponse: function (pos) {
      if (!this._container._leaflet_id) {
        return;
      }
      var lat = pos.coords.latitude,
        lng = pos.coords.longitude,
        latlng = new LatLng(lat, lng),
        bounds = latlng.toBounds(pos.coords.accuracy * 2),
        options = this._locateOptions;
      if (options.setView) {
        var zoom = this.getBoundsZoom(bounds);
        this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
      }
      var data = {
        latlng: latlng,
        bounds: bounds,
        timestamp: pos.timestamp
      };
      for (var i in pos.coords) {
        if (typeof pos.coords[i] === 'number') {
          data[i] = pos.coords[i];
        }
      }

      // @event locationfound: LocationEvent
      // Fired when geolocation (using the [`locate`](#map-locate) method)
      // went successfully.
      this.fire('locationfound', data);
    },
    // TODO Appropriate docs section?
    // @section Other Methods
    // @method addHandler(name: String, HandlerClass: Function): this
    // Adds a new `Handler` to the map, given its name and constructor function.
    addHandler: function (name, HandlerClass) {
      if (!HandlerClass) {
        return this;
      }
      var handler = this[name] = new HandlerClass(this);
      this._handlers.push(handler);
      if (this.options[name]) {
        handler.enable();
      }
      return this;
    },
    // @method remove(): this
    // Destroys the map and clears all related event listeners.
    remove: function () {
      this._initEvents(true);
      if (this.options.maxBounds) {
        this.off('moveend', this._panInsideMaxBounds);
      }
      if (this._containerId !== this._container._leaflet_id) {
        throw new Error('Map container is being reused by another instance');
      }
      try {
        // throws error in IE6-8
        delete this._container._leaflet_id;
        delete this._containerId;
      } catch (e) {
        /*eslint-disable */
        this._container._leaflet_id = undefined;
        /* eslint-enable */
        this._containerId = undefined;
      }
      if (this._locationWatchId !== undefined) {
        this.stopLocate();
      }
      this._stop();
      remove(this._mapPane);
      if (this._clearControlPos) {
        this._clearControlPos();
      }
      if (this._resizeRequest) {
        cancelAnimFrame(this._resizeRequest);
        this._resizeRequest = null;
      }
      this._clearHandlers();
      if (this._loaded) {
        // @section Map state change events
        // @event unload: Event
        // Fired when the map is destroyed with [remove](#map-remove) method.
        this.fire('unload');
      }
      var i;
      for (i in this._layers) {
        this._layers[i].remove();
      }
      for (i in this._panes) {
        remove(this._panes[i]);
      }
      this._layers = [];
      this._panes = [];
      delete this._mapPane;
      delete this._renderer;
      return this;
    },
    // @section Other Methods
    // @method createPane(name: String, container?: HTMLElement): HTMLElement
    // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
    // then returns it. The pane is created as a child of `container`, or
    // as a child of the main map pane if not set.
    createPane: function (name, container) {
      var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
        pane = create$1('div', className, container || this._mapPane);
      if (name) {
        this._panes[name] = pane;
      }
      return pane;
    },
    // @section Methods for Getting Map State

    // @method getCenter(): LatLng
    // Returns the geographical center of the map view
    getCenter: function () {
      this._checkIfLoaded();
      if (this._lastCenter && !this._moved()) {
        return this._lastCenter.clone();
      }
      return this.layerPointToLatLng(this._getCenterLayerPoint());
    },
    // @method getZoom(): Number
    // Returns the current zoom level of the map view
    getZoom: function () {
      return this._zoom;
    },
    // @method getBounds(): LatLngBounds
    // Returns the geographical bounds visible in the current map view
    getBounds: function () {
      var bounds = this.getPixelBounds(),
        sw = this.unproject(bounds.getBottomLeft()),
        ne = this.unproject(bounds.getTopRight());
      return new LatLngBounds(sw, ne);
    },
    // @method getMinZoom(): Number
    // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
    getMinZoom: function () {
      return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
    },
    // @method getMaxZoom(): Number
    // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
    getMaxZoom: function () {
      return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;
    },
    // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
    // Returns the maximum zoom level on which the given bounds fit to the map
    // view in its entirety. If `inside` (optional) is set to `true`, the method
    // instead returns the minimum zoom level on which the map view fits into
    // the given bounds in its entirety.
    getBoundsZoom: function (bounds, inside, padding) {
      // (LatLngBounds[, Boolean, Point]) -> Number
      bounds = toLatLngBounds(bounds);
      padding = toPoint(padding || [0, 0]);
      var zoom = this.getZoom() || 0,
        min = this.getMinZoom(),
        max = this.getMaxZoom(),
        nw = bounds.getNorthWest(),
        se = bounds.getSouthEast(),
        size = this.getSize().subtract(padding),
        boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
        snap = Browser.any3d ? this.options.zoomSnap : 1,
        scalex = size.x / boundsSize.x,
        scaley = size.y / boundsSize.y,
        scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
      zoom = this.getScaleZoom(scale, zoom);
      if (snap) {
        zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
        zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
      }
      return Math.max(min, Math.min(max, zoom));
    },
    // @method getSize(): Point
    // Returns the current size of the map container (in pixels).
    getSize: function () {
      if (!this._size || this._sizeChanged) {
        this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);
        this._sizeChanged = false;
      }
      return this._size.clone();
    },
    // @method getPixelBounds(): Bounds
    // Returns the bounds of the current map view in projected pixel
    // coordinates (sometimes useful in layer and overlay implementations).
    getPixelBounds: function (center, zoom) {
      var topLeftPoint = this._getTopLeftPoint(center, zoom);
      return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
    },
    // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
    // the map pane? "left point of the map layer" can be confusing, specially
    // since there can be negative offsets.
    // @method getPixelOrigin(): Point
    // Returns the projected pixel coordinates of the top left point of
    // the map layer (useful in custom layer and overlay implementations).
    getPixelOrigin: function () {
      this._checkIfLoaded();
      return this._pixelOrigin;
    },
    // @method getPixelWorldBounds(zoom?: Number): Bounds
    // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
    // If `zoom` is omitted, the map's current zoom level is used.
    getPixelWorldBounds: function (zoom) {
      return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
    },
    // @section Other Methods

    // @method getPane(pane: String|HTMLElement): HTMLElement
    // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
    getPane: function (pane) {
      return typeof pane === 'string' ? this._panes[pane] : pane;
    },
    // @method getPanes(): Object
    // Returns a plain object containing the names of all [panes](#map-pane) as keys and
    // the panes as values.
    getPanes: function () {
      return this._panes;
    },
    // @method getContainer: HTMLElement
    // Returns the HTML element that contains the map.
    getContainer: function () {
      return this._container;
    },
    // @section Conversion Methods

    // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
    // Returns the scale factor to be applied to a map transition from zoom level
    // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
    getZoomScale: function (toZoom, fromZoom) {
      // TODO replace with universal implementation after refactoring projections
      var crs = this.options.crs;
      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
      return crs.scale(toZoom) / crs.scale(fromZoom);
    },
    // @method getScaleZoom(scale: Number, fromZoom: Number): Number
    // Returns the zoom level that the map would end up at, if it is at `fromZoom`
    // level and everything is scaled by a factor of `scale`. Inverse of
    // [`getZoomScale`](#map-getZoomScale).
    getScaleZoom: function (scale, fromZoom) {
      var crs = this.options.crs;
      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
      var zoom = crs.zoom(scale * crs.scale(fromZoom));
      return isNaN(zoom) ? Infinity : zoom;
    },
    // @method project(latlng: LatLng, zoom: Number): Point
    // Projects a geographical coordinate `LatLng` according to the projection
    // of the map's CRS, then scales it according to `zoom` and the CRS's
    // `Transformation`. The result is pixel coordinate relative to
    // the CRS origin.
    project: function (latlng, zoom) {
      zoom = zoom === undefined ? this._zoom : zoom;
      return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
    },
    // @method unproject(point: Point, zoom: Number): LatLng
    // Inverse of [`project`](#map-project).
    unproject: function (point, zoom) {
      zoom = zoom === undefined ? this._zoom : zoom;
      return this.options.crs.pointToLatLng(toPoint(point), zoom);
    },
    // @method layerPointToLatLng(point: Point): LatLng
    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
    // returns the corresponding geographical coordinate (for the current zoom level).
    layerPointToLatLng: function (point) {
      var projectedPoint = toPoint(point).add(this.getPixelOrigin());
      return this.unproject(projectedPoint);
    },
    // @method latLngToLayerPoint(latlng: LatLng): Point
    // Given a geographical coordinate, returns the corresponding pixel coordinate
    // relative to the [origin pixel](#map-getpixelorigin).
    latLngToLayerPoint: function (latlng) {
      var projectedPoint = this.project(toLatLng(latlng))._round();
      return projectedPoint._subtract(this.getPixelOrigin());
    },
    // @method wrapLatLng(latlng: LatLng): LatLng
    // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
    // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
    // CRS's bounds.
    // By default this means longitude is wrapped around the dateline so its
    // value is between -180 and +180 degrees.
    wrapLatLng: function (latlng) {
      return this.options.crs.wrapLatLng(toLatLng(latlng));
    },
    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
    // Returns a `LatLngBounds` with the same size as the given one, ensuring that
    // its center is within the CRS's bounds.
    // By default this means the center longitude is wrapped around the dateline so its
    // value is between -180 and +180 degrees, and the majority of the bounds
    // overlaps the CRS's bounds.
    wrapLatLngBounds: function (latlng) {
      return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
    },
    // @method distance(latlng1: LatLng, latlng2: LatLng): Number
    // Returns the distance between two geographical coordinates according to
    // the map's CRS. By default this measures distance in meters.
    distance: function (latlng1, latlng2) {
      return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
    },
    // @method containerPointToLayerPoint(point: Point): Point
    // Given a pixel coordinate relative to the map container, returns the corresponding
    // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
    containerPointToLayerPoint: function (point) {
      // (Point)
      return toPoint(point).subtract(this._getMapPanePos());
    },
    // @method layerPointToContainerPoint(point: Point): Point
    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
    // returns the corresponding pixel coordinate relative to the map container.
    layerPointToContainerPoint: function (point) {
      // (Point)
      return toPoint(point).add(this._getMapPanePos());
    },
    // @method containerPointToLatLng(point: Point): LatLng
    // Given a pixel coordinate relative to the map container, returns
    // the corresponding geographical coordinate (for the current zoom level).
    containerPointToLatLng: function (point) {
      var layerPoint = this.containerPointToLayerPoint(toPoint(point));
      return this.layerPointToLatLng(layerPoint);
    },
    // @method latLngToContainerPoint(latlng: LatLng): Point
    // Given a geographical coordinate, returns the corresponding pixel coordinate
    // relative to the map container.
    latLngToContainerPoint: function (latlng) {
      return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
    },
    // @method mouseEventToContainerPoint(ev: MouseEvent): Point
    // Given a MouseEvent object, returns the pixel coordinate relative to the
    // map container where the event took place.
    mouseEventToContainerPoint: function (e) {
      return getMousePosition(e, this._container);
    },
    // @method mouseEventToLayerPoint(ev: MouseEvent): Point
    // Given a MouseEvent object, returns the pixel coordinate relative to
    // the [origin pixel](#map-getpixelorigin) where the event took place.
    mouseEventToLayerPoint: function (e) {
      return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
    },
    // @method mouseEventToLatLng(ev: MouseEvent): LatLng
    // Given a MouseEvent object, returns geographical coordinate where the
    // event took place.
    mouseEventToLatLng: function (e) {
      // (MouseEvent)
      return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
    },
    // map initialization methods

    _initContainer: function (id) {
      var container = this._container = get(id);
      if (!container) {
        throw new Error('Map container not found.');
      } else if (container._leaflet_id) {
        throw new Error('Map container is already initialized.');
      }
      on(container, 'scroll', this._onScroll, this);
      this._containerId = stamp(container);
    },
    _initLayout: function () {
      var container = this._container;
      this._fadeAnimated = this.options.fadeAnimation && Browser.any3d;
      addClass(container, 'leaflet-container' + (Browser.touch ? ' leaflet-touch' : '') + (Browser.retina ? ' leaflet-retina' : '') + (Browser.ielt9 ? ' leaflet-oldie' : '') + (Browser.safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));
      var position = getStyle(container, 'position');
      if (position !== 'absolute' && position !== 'relative' && position !== 'fixed' && position !== 'sticky') {
        container.style.position = 'relative';
      }
      this._initPanes();
      if (this._initControlPos) {
        this._initControlPos();
      }
    },
    _initPanes: function () {
      var panes = this._panes = {};
      this._paneRenderers = {};

      // @section
      //
      // Panes are DOM elements used to control the ordering of layers on the map. You
      // can access panes with [`map.getPane`](#map-getpane) or
      // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
      // [`map.createPane`](#map-createpane) method.
      //
      // Every map has the following default panes that differ only in zIndex.
      //
      // @pane mapPane: HTMLElement = 'auto'
      // Pane that contains all other map panes

      this._mapPane = this.createPane('mapPane', this._container);
      setPosition(this._mapPane, new Point(0, 0));

      // @pane tilePane: HTMLElement = 200
      // Pane for `GridLayer`s and `TileLayer`s
      this.createPane('tilePane');
      // @pane overlayPane: HTMLElement = 400
      // Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s
      this.createPane('overlayPane');
      // @pane shadowPane: HTMLElement = 500
      // Pane for overlay shadows (e.g. `Marker` shadows)
      this.createPane('shadowPane');
      // @pane markerPane: HTMLElement = 600
      // Pane for `Icon`s of `Marker`s
      this.createPane('markerPane');
      // @pane tooltipPane: HTMLElement = 650
      // Pane for `Tooltip`s.
      this.createPane('tooltipPane');
      // @pane popupPane: HTMLElement = 700
      // Pane for `Popup`s.
      this.createPane('popupPane');
      if (!this.options.markerZoomAnimation) {
        addClass(panes.markerPane, 'leaflet-zoom-hide');
        addClass(panes.shadowPane, 'leaflet-zoom-hide');
      }
    },
    // private methods that modify map state

    // @section Map state change events
    _resetView: function (center, zoom, noMoveStart) {
      setPosition(this._mapPane, new Point(0, 0));
      var loading = !this._loaded;
      this._loaded = true;
      zoom = this._limitZoom(zoom);
      this.fire('viewprereset');
      var zoomChanged = this._zoom !== zoom;
      this._moveStart(zoomChanged, noMoveStart)._move(center, zoom)._moveEnd(zoomChanged);

      // @event viewreset: Event
      // Fired when the map needs to redraw its content (this usually happens
      // on map zoom or load). Very useful for creating custom overlays.
      this.fire('viewreset');

      // @event load: Event
      // Fired when the map is initialized (when its center and zoom are set
      // for the first time).
      if (loading) {
        this.fire('load');
      }
    },
    _moveStart: function (zoomChanged, noMoveStart) {
      // @event zoomstart: Event
      // Fired when the map zoom is about to change (e.g. before zoom animation).
      // @event movestart: Event
      // Fired when the view of the map starts changing (e.g. user starts dragging the map).
      if (zoomChanged) {
        this.fire('zoomstart');
      }
      if (!noMoveStart) {
        this.fire('movestart');
      }
      return this;
    },
    _move: function (center, zoom, data, supressEvent) {
      if (zoom === undefined) {
        zoom = this._zoom;
      }
      var zoomChanged = this._zoom !== zoom;
      this._zoom = zoom;
      this._lastCenter = center;
      this._pixelOrigin = this._getNewPixelOrigin(center);
      if (!supressEvent) {
        // @event zoom: Event
        // Fired repeatedly during any change in zoom level,
        // including zoom and fly animations.
        if (zoomChanged || data && data.pinch) {
          // Always fire 'zoom' if pinching because #3530
          this.fire('zoom', data);
        }

        // @event move: Event
        // Fired repeatedly during any movement of the map,
        // including pan and fly animations.
        this.fire('move', data);
      } else if (data && data.pinch) {
        // Always fire 'zoom' if pinching because #3530
        this.fire('zoom', data);
      }
      return this;
    },
    _moveEnd: function (zoomChanged) {
      // @event zoomend: Event
      // Fired when the map zoom changed, after any animations.
      if (zoomChanged) {
        this.fire('zoomend');
      }

      // @event moveend: Event
      // Fired when the center of the map stops changing
      // (e.g. user stopped dragging the map or after non-centered zoom).
      return this.fire('moveend');
    },
    _stop: function () {
      cancelAnimFrame(this._flyToFrame);
      if (this._panAnim) {
        this._panAnim.stop();
      }
      return this;
    },
    _rawPanBy: function (offset) {
      setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
    },
    _getZoomSpan: function () {
      return this.getMaxZoom() - this.getMinZoom();
    },
    _panInsideMaxBounds: function () {
      if (!this._enforcingBounds) {
        this.panInsideBounds(this.options.maxBounds);
      }
    },
    _checkIfLoaded: function () {
      if (!this._loaded) {
        throw new Error('Set map center and zoom first.');
      }
    },
    // DOM event handling

    // @section Interaction events
    _initEvents: function (remove) {
      this._targets = {};
      this._targets[stamp(this._container)] = this;
      var onOff = remove ? off : on;

      // @event click: MouseEvent
      // Fired when the user clicks (or taps) the map.
      // @event dblclick: MouseEvent
      // Fired when the user double-clicks (or double-taps) the map.
      // @event mousedown: MouseEvent
      // Fired when the user pushes the mouse button on the map.
      // @event mouseup: MouseEvent
      // Fired when the user releases the mouse button on the map.
      // @event mouseover: MouseEvent
      // Fired when the mouse enters the map.
      // @event mouseout: MouseEvent
      // Fired when the mouse leaves the map.
      // @event mousemove: MouseEvent
      // Fired while the mouse moves over the map.
      // @event contextmenu: MouseEvent
      // Fired when the user pushes the right mouse button on the map, prevents
      // default browser context menu from showing if there are listeners on
      // this event. Also fired on mobile when the user holds a single touch
      // for a second (also called long press).
      // @event keypress: KeyboardEvent
      // Fired when the user presses a key from the keyboard that produces a character value while the map is focused.
      // @event keydown: KeyboardEvent
      // Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,
      // the `keydown` event is fired for keys that produce a character value and for keys
      // that do not produce a character value.
      // @event keyup: KeyboardEvent
      // Fired when the user releases a key from the keyboard while the map is focused.
      onOff(this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);
      if (this.options.trackResize) {
        onOff(window, 'resize', this._onResize, this);
      }
      if (Browser.any3d && this.options.transform3DLimit) {
        (remove ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
      }
    },
    _onResize: function () {
      cancelAnimFrame(this._resizeRequest);
      this._resizeRequest = requestAnimFrame(function () {
        this.invalidateSize({
          debounceMoveend: true
        });
      }, this);
    },
    _onScroll: function () {
      this._container.scrollTop = 0;
      this._container.scrollLeft = 0;
    },
    _onMoveEnd: function () {
      var pos = this._getMapPanePos();
      if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
        // a pixel offset on very high values, see: https://jsfiddle.net/dg6r5hhb/
        this._resetView(this.getCenter(), this.getZoom());
      }
    },
    _findEventTargets: function (e, type) {
      var targets = [],
        target,
        isHover = type === 'mouseout' || type === 'mouseover',
        src = e.target || e.srcElement,
        dragging = false;
      while (src) {
        target = this._targets[stamp(src)];
        if (target && (type === 'click' || type === 'preclick') && this._draggableMoved(target)) {
          // Prevent firing click after you just dragged an object.
          dragging = true;
          break;
        }
        if (target && target.listens(type, true)) {
          if (isHover && !isExternalTarget(src, e)) {
            break;
          }
          targets.push(target);
          if (isHover) {
            break;
          }
        }
        if (src === this._container) {
          break;
        }
        src = src.parentNode;
      }
      if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
        targets = [this];
      }
      return targets;
    },
    _isClickDisabled: function (el) {
      while (el && el !== this._container) {
        if (el['_leaflet_disable_click']) {
          return true;
        }
        el = el.parentNode;
      }
    },
    _handleDOMEvent: function (e) {
      var el = e.target || e.srcElement;
      if (!this._loaded || el['_leaflet_disable_events'] || e.type === 'click' && this._isClickDisabled(el)) {
        return;
      }
      var type = e.type;
      if (type === 'mousedown') {
        // prevents outline when clicking on keyboard-focusable element
        preventOutline(el);
      }
      this._fireDOMEvent(e, type);
    },
    _mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],
    _fireDOMEvent: function (e, type, canvasTargets) {
      if (e.type === 'click') {
        // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
        // @event preclick: MouseEvent
        // Fired before mouse click on the map (sometimes useful when you
        // want something to happen on click before any existing click
        // handlers start running).
        var synth = extend({}, e);
        synth.type = 'preclick';
        this._fireDOMEvent(synth, synth.type, canvasTargets);
      }

      // Find the layer the event is propagating from and its parents.
      var targets = this._findEventTargets(e, type);
      if (canvasTargets) {
        var filtered = []; // pick only targets with listeners
        for (var i = 0; i < canvasTargets.length; i++) {
          if (canvasTargets[i].listens(type, true)) {
            filtered.push(canvasTargets[i]);
          }
        }
        targets = filtered.concat(targets);
      }
      if (!targets.length) {
        return;
      }
      if (type === 'contextmenu') {
        preventDefault(e);
      }
      var target = targets[0];
      var data = {
        originalEvent: e
      };
      if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {
        var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
        data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
        data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
        data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
      }
      for (i = 0; i < targets.length; i++) {
        targets[i].fire(type, data, true);
        if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
          return;
        }
      }
    },
    _draggableMoved: function (obj) {
      obj = obj.dragging && obj.dragging.enabled() ? obj : this;
      return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
    },
    _clearHandlers: function () {
      for (var i = 0, len = this._handlers.length; i < len; i++) {
        this._handlers[i].disable();
      }
    },
    // @section Other Methods

    // @method whenReady(fn: Function, context?: Object): this
    // Runs the given function `fn` when the map gets initialized with
    // a view (center and zoom) and at least one layer, or immediately
    // if it's already initialized, optionally passing a function context.
    whenReady: function (callback, context) {
      if (this._loaded) {
        callback.call(context || this, {
          target: this
        });
      } else {
        this.on('load', callback, context);
      }
      return this;
    },
    // private methods for getting map state

    _getMapPanePos: function () {
      return getPosition(this._mapPane) || new Point(0, 0);
    },
    _moved: function () {
      var pos = this._getMapPanePos();
      return pos && !pos.equals([0, 0]);
    },
    _getTopLeftPoint: function (center, zoom) {
      var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();
      return pixelOrigin.subtract(this._getMapPanePos());
    },
    _getNewPixelOrigin: function (center, zoom) {
      var viewHalf = this.getSize()._divideBy(2);
      return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
    },
    _latLngToNewLayerPoint: function (latlng, zoom, center) {
      var topLeft = this._getNewPixelOrigin(center, zoom);
      return this.project(latlng, zoom)._subtract(topLeft);
    },
    _latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
      var topLeft = this._getNewPixelOrigin(center, zoom);
      return toBounds([this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)]);
    },
    // layer point of the current center
    _getCenterLayerPoint: function () {
      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
    },
    // offset of the specified place to the current center in pixels
    _getCenterOffset: function (latlng) {
      return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
    },
    // adjust center for view to get inside bounds
    _limitCenter: function (center, zoom, bounds) {
      if (!bounds) {
        return center;
      }
      var centerPoint = this.project(center, zoom),
        viewHalf = this.getSize().divideBy(2),
        viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
        offset = this._getBoundsOffset(viewBounds, bounds, zoom);

      // If offset is less than a pixel, ignore.
      // This prevents unstable projections from getting into
      // an infinite loop of tiny offsets.
      if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
        return center;
      }
      return this.unproject(centerPoint.add(offset), zoom);
    },
    // adjust offset for view to get inside bounds
    _limitOffset: function (offset, bounds) {
      if (!bounds) {
        return offset;
      }
      var viewBounds = this.getPixelBounds(),
        newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
      return offset.add(this._getBoundsOffset(newBounds, bounds));
    },
    // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
    _getBoundsOffset: function (pxBounds, maxBounds, zoom) {
      var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),
        minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
        maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),
        dx = this._rebound(minOffset.x, -maxOffset.x),
        dy = this._rebound(minOffset.y, -maxOffset.y);
      return new Point(dx, dy);
    },
    _rebound: function (left, right) {
      return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
    },
    _limitZoom: function (zoom) {
      var min = this.getMinZoom(),
        max = this.getMaxZoom(),
        snap = Browser.any3d ? this.options.zoomSnap : 1;
      if (snap) {
        zoom = Math.round(zoom / snap) * snap;
      }
      return Math.max(min, Math.min(max, zoom));
    },
    _onPanTransitionStep: function () {
      this.fire('move');
    },
    _onPanTransitionEnd: function () {
      removeClass(this._mapPane, 'leaflet-pan-anim');
      this.fire('moveend');
    },
    _tryAnimatedPan: function (center, options) {
      // difference between the new and current centers in pixels
      var offset = this._getCenterOffset(center)._trunc();

      // don't animate too far unless animate: true specified in options
      if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
        return false;
      }
      this.panBy(offset, options);
      return true;
    },
    _createAnimProxy: function () {
      var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');
      this._panes.mapPane.appendChild(proxy);
      this.on('zoomanim', function (e) {
        var prop = TRANSFORM,
          transform = this._proxy.style[prop];
        setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

        // workaround for case when transform is the same and so transitionend event is not fired
        if (transform === this._proxy.style[prop] && this._animatingZoom) {
          this._onZoomTransitionEnd();
        }
      }, this);
      this.on('load moveend', this._animMoveEnd, this);
      this._on('unload', this._destroyAnimProxy, this);
    },
    _destroyAnimProxy: function () {
      remove(this._proxy);
      this.off('load moveend', this._animMoveEnd, this);
      delete this._proxy;
    },
    _animMoveEnd: function () {
      var c = this.getCenter(),
        z = this.getZoom();
      setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
    },
    _catchTransitionEnd: function (e) {
      if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
        this._onZoomTransitionEnd();
      }
    },
    _nothingToAnimate: function () {
      return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
    },
    _tryAnimatedZoom: function (center, zoom, options) {
      if (this._animatingZoom) {
        return true;
      }
      options = options || {};

      // don't animate if disabled, not supported or zoom difference is too large
      if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {
        return false;
      }

      // offset is the pixel coords of the zoom origin relative to the current center
      var scale = this.getZoomScale(zoom),
        offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

      // don't animate if the zoom origin isn't within one screen from the current center, unless forced
      if (options.animate !== true && !this.getSize().contains(offset)) {
        return false;
      }
      requestAnimFrame(function () {
        this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom, true);
      }, this);
      return true;
    },
    _animateZoom: function (center, zoom, startAnim, noUpdate) {
      if (!this._mapPane) {
        return;
      }
      if (startAnim) {
        this._animatingZoom = true;

        // remember what center/zoom to set after animation
        this._animateToCenter = center;
        this._animateToZoom = zoom;
        addClass(this._mapPane, 'leaflet-zoom-anim');
      }

      // @section Other Events
      // @event zoomanim: ZoomAnimEvent
      // Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.
      this.fire('zoomanim', {
        center: center,
        zoom: zoom,
        noUpdate: noUpdate
      });
      if (!this._tempFireZoomEvent) {
        this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
      }
      this._move(this._animateToCenter, this._animateToZoom, undefined, true);

      // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
      setTimeout(bind(this._onZoomTransitionEnd, this), 250);
    },
    _onZoomTransitionEnd: function () {
      if (!this._animatingZoom) {
        return;
      }
      if (this._mapPane) {
        removeClass(this._mapPane, 'leaflet-zoom-anim');
      }
      this._animatingZoom = false;
      this._move(this._animateToCenter, this._animateToZoom, undefined, true);
      if (this._tempFireZoomEvent) {
        this.fire('zoom');
      }
      delete this._tempFireZoomEvent;
      this.fire('move');
      this._moveEnd(true);
    }
  });

  // @section

  // @factory L.map(id: String, options?: Map options)
  // Instantiates a map object given the DOM ID of a `<div>` element
  // and optionally an object literal with `Map options`.
  //
  // @alternative
  // @factory L.map(el: HTMLElement, options?: Map options)
  // Instantiates a map object given an instance of a `<div>` HTML element
  // and optionally an object literal with `Map options`.
  function createMap(id, options) {
    return new Map(id, options);
  }

  /*
   * @class Control
   * @aka L.Control
   * @inherits Class
   *
   * L.Control is a base class for implementing map controls. Handles positioning.
   * All other controls extend from this class.
   */

  var Control = Class.extend({
    // @section
    // @aka Control Options
    options: {
      // @option position: String = 'topright'
      // The position of the control (one of the map corners). Possible values are `'topleft'`,
      // `'topright'`, `'bottomleft'` or `'bottomright'`
      position: 'topright'
    },
    initialize: function (options) {
      setOptions(this, options);
    },
    /* @section
     * Classes extending L.Control will inherit the following methods:
     *
     * @method getPosition: string
     * Returns the position of the control.
     */
    getPosition: function () {
      return this.options.position;
    },
    // @method setPosition(position: string): this
    // Sets the position of the control.
    setPosition: function (position) {
      var map = this._map;
      if (map) {
        map.removeControl(this);
      }
      this.options.position = position;
      if (map) {
        map.addControl(this);
      }
      return this;
    },
    // @method getContainer: HTMLElement
    // Returns the HTMLElement that contains the control.
    getContainer: function () {
      return this._container;
    },
    // @method addTo(map: Map): this
    // Adds the control to the given map.
    addTo: function (map) {
      this.remove();
      this._map = map;
      var container = this._container = this.onAdd(map),
        pos = this.getPosition(),
        corner = map._controlCorners[pos];
      addClass(container, 'leaflet-control');
      if (pos.indexOf('bottom') !== -1) {
        corner.insertBefore(container, corner.firstChild);
      } else {
        corner.appendChild(container);
      }
      this._map.on('unload', this.remove, this);
      return this;
    },
    // @method remove: this
    // Removes the control from the map it is currently active on.
    remove: function () {
      if (!this._map) {
        return this;
      }
      remove(this._container);
      if (this.onRemove) {
        this.onRemove(this._map);
      }
      this._map.off('unload', this.remove, this);
      this._map = null;
      return this;
    },
    _refocusOnMap: function (e) {
      // if map exists and event is not a keyboard event
      if (this._map && e && e.screenX > 0 && e.screenY > 0) {
        this._map.getContainer().focus();
      }
    }
  });
  var control = function (options) {
    return new Control(options);
  };

  /* @section Extension methods
   * @uninheritable
   *
   * Every control should extend from `L.Control` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): HTMLElement
   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
   *
   * @method onRemove(map: Map)
   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
   */

  /* @namespace Map
   * @section Methods for Layers and Controls
   */
  Map.include({
    // @method addControl(control: Control): this
    // Adds the given control to the map
    addControl: function (control) {
      control.addTo(this);
      return this;
    },
    // @method removeControl(control: Control): this
    // Removes the given control from the map
    removeControl: function (control) {
      control.remove();
      return this;
    },
    _initControlPos: function () {
      var corners = this._controlCorners = {},
        l = 'leaflet-',
        container = this._controlContainer = create$1('div', l + 'control-container', this._container);
      function createCorner(vSide, hSide) {
        var className = l + vSide + ' ' + l + hSide;
        corners[vSide + hSide] = create$1('div', className, container);
      }
      createCorner('top', 'left');
      createCorner('top', 'right');
      createCorner('bottom', 'left');
      createCorner('bottom', 'right');
    },
    _clearControlPos: function () {
      for (var i in this._controlCorners) {
        remove(this._controlCorners[i]);
      }
      remove(this._controlContainer);
      delete this._controlCorners;
      delete this._controlContainer;
    }
  });

  /*
   * @class Control.Layers
   * @aka L.Control.Layers
   * @inherits Control
   *
   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](https://leafletjs.com/examples/layers-control/)). Extends `Control`.
   *
   * @example
   *
   * ```js
   * var baseLayers = {
   * 	"Mapbox": mapbox,
   * 	"OpenStreetMap": osm
   * };
   *
   * var overlays = {
   * 	"Marker": marker,
   * 	"Roads": roadsLayer
   * };
   *
   * L.control.layers(baseLayers, overlays).addTo(map);
   * ```
   *
   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
   *
   * ```js
   * {
   *     "<someName1>": layer1,
   *     "<someName2>": layer2
   * }
   * ```
   *
   * The layer names can contain HTML, which allows you to add additional styling to the items:
   *
   * ```js
   * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
   * ```
   */

  var Layers = Control.extend({
    // @section
    // @aka Control.Layers options
    options: {
      // @option collapsed: Boolean = true
      // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
      collapsed: true,
      position: 'topright',
      // @option autoZIndex: Boolean = true
      // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
      autoZIndex: true,
      // @option hideSingleBase: Boolean = false
      // If `true`, the base layers in the control will be hidden when there is only one.
      hideSingleBase: false,
      // @option sortLayers: Boolean = false
      // Whether to sort the layers. When `false`, layers will keep the order
      // in which they were added to the control.
      sortLayers: false,
      // @option sortFunction: Function = *
      // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
      // that will be used for sorting the layers, when `sortLayers` is `true`.
      // The function receives both the `L.Layer` instances and their names, as in
      // `sortFunction(layerA, layerB, nameA, nameB)`.
      // By default, it sorts layers alphabetically by their name.
      sortFunction: function (layerA, layerB, nameA, nameB) {
        return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
      }
    },
    initialize: function (baseLayers, overlays, options) {
      setOptions(this, options);
      this._layerControlInputs = [];
      this._layers = [];
      this._lastZIndex = 0;
      this._handlingClick = false;
      this._preventClick = false;
      for (var i in baseLayers) {
        this._addLayer(baseLayers[i], i);
      }
      for (i in overlays) {
        this._addLayer(overlays[i], i, true);
      }
    },
    onAdd: function (map) {
      this._initLayout();
      this._update();
      this._map = map;
      map.on('zoomend', this._checkDisabledLayers, this);
      for (var i = 0; i < this._layers.length; i++) {
        this._layers[i].layer.on('add remove', this._onLayerChange, this);
      }
      return this._container;
    },
    addTo: function (map) {
      Control.prototype.addTo.call(this, map);
      // Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
      return this._expandIfNotCollapsed();
    },
    onRemove: function () {
      this._map.off('zoomend', this._checkDisabledLayers, this);
      for (var i = 0; i < this._layers.length; i++) {
        this._layers[i].layer.off('add remove', this._onLayerChange, this);
      }
    },
    // @method addBaseLayer(layer: Layer, name: String): this
    // Adds a base layer (radio button entry) with the given name to the control.
    addBaseLayer: function (layer, name) {
      this._addLayer(layer, name);
      return this._map ? this._update() : this;
    },
    // @method addOverlay(layer: Layer, name: String): this
    // Adds an overlay (checkbox entry) with the given name to the control.
    addOverlay: function (layer, name) {
      this._addLayer(layer, name, true);
      return this._map ? this._update() : this;
    },
    // @method removeLayer(layer: Layer): this
    // Remove the given layer from the control.
    removeLayer: function (layer) {
      layer.off('add remove', this._onLayerChange, this);
      var obj = this._getLayer(stamp(layer));
      if (obj) {
        this._layers.splice(this._layers.indexOf(obj), 1);
      }
      return this._map ? this._update() : this;
    },
    // @method expand(): this
    // Expand the control container if collapsed.
    expand: function () {
      addClass(this._container, 'leaflet-control-layers-expanded');
      this._section.style.height = null;
      var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
      if (acceptableHeight < this._section.clientHeight) {
        addClass(this._section, 'leaflet-control-layers-scrollbar');
        this._section.style.height = acceptableHeight + 'px';
      } else {
        removeClass(this._section, 'leaflet-control-layers-scrollbar');
      }
      this._checkDisabledLayers();
      return this;
    },
    // @method collapse(): this
    // Collapse the control container if expanded.
    collapse: function () {
      removeClass(this._container, 'leaflet-control-layers-expanded');
      return this;
    },
    _initLayout: function () {
      var className = 'leaflet-control-layers',
        container = this._container = create$1('div', className),
        collapsed = this.options.collapsed;

      // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
      container.setAttribute('aria-haspopup', true);
      disableClickPropagation(container);
      disableScrollPropagation(container);
      var section = this._section = create$1('section', className + '-list');
      if (collapsed) {
        this._map.on('click', this.collapse, this);
        on(container, {
          mouseenter: this._expandSafely,
          mouseleave: this.collapse
        }, this);
      }
      var link = this._layersLink = create$1('a', className + '-toggle', container);
      link.href = '#';
      link.title = 'Layers';
      link.setAttribute('role', 'button');
      on(link, {
        keydown: function (e) {
          if (e.keyCode === 13) {
            this._expandSafely();
          }
        },
        // Certain screen readers intercept the key event and instead send a click event
        click: function (e) {
          preventDefault(e);
          this._expandSafely();
        }
      }, this);
      if (!collapsed) {
        this.expand();
      }
      this._baseLayersList = create$1('div', className + '-base', section);
      this._separator = create$1('div', className + '-separator', section);
      this._overlaysList = create$1('div', className + '-overlays', section);
      container.appendChild(section);
    },
    _getLayer: function (id) {
      for (var i = 0; i < this._layers.length; i++) {
        if (this._layers[i] && stamp(this._layers[i].layer) === id) {
          return this._layers[i];
        }
      }
    },
    _addLayer: function (layer, name, overlay) {
      if (this._map) {
        layer.on('add remove', this._onLayerChange, this);
      }
      this._layers.push({
        layer: layer,
        name: name,
        overlay: overlay
      });
      if (this.options.sortLayers) {
        this._layers.sort(bind(function (a, b) {
          return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
        }, this));
      }
      if (this.options.autoZIndex && layer.setZIndex) {
        this._lastZIndex++;
        layer.setZIndex(this._lastZIndex);
      }
      this._expandIfNotCollapsed();
    },
    _update: function () {
      if (!this._container) {
        return this;
      }
      empty(this._baseLayersList);
      empty(this._overlaysList);
      this._layerControlInputs = [];
      var baseLayersPresent,
        overlaysPresent,
        i,
        obj,
        baseLayersCount = 0;
      for (i = 0; i < this._layers.length; i++) {
        obj = this._layers[i];
        this._addItem(obj);
        overlaysPresent = overlaysPresent || obj.overlay;
        baseLayersPresent = baseLayersPresent || !obj.overlay;
        baseLayersCount += !obj.overlay ? 1 : 0;
      }

      // Hide base layers section if there's only one layer.
      if (this.options.hideSingleBase) {
        baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
        this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
      }
      this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
      return this;
    },
    _onLayerChange: function (e) {
      if (!this._handlingClick) {
        this._update();
      }
      var obj = this._getLayer(stamp(e.target));

      // @namespace Map
      // @section Layer events
      // @event baselayerchange: LayersControlEvent
      // Fired when the base layer is changed through the [layers control](#control-layers).
      // @event overlayadd: LayersControlEvent
      // Fired when an overlay is selected through the [layers control](#control-layers).
      // @event overlayremove: LayersControlEvent
      // Fired when an overlay is deselected through the [layers control](#control-layers).
      // @namespace Control.Layers
      var type = obj.overlay ? e.type === 'add' ? 'overlayadd' : 'overlayremove' : e.type === 'add' ? 'baselayerchange' : null;
      if (type) {
        this._map.fire(type, obj);
      }
    },
    // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
    _createRadioElement: function (name, checked) {
      var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : '') + '/>';
      var radioFragment = document.createElement('div');
      radioFragment.innerHTML = radioHtml;
      return radioFragment.firstChild;
    },
    _addItem: function (obj) {
      var label = document.createElement('label'),
        checked = this._map.hasLayer(obj.layer),
        input;
      if (obj.overlay) {
        input = document.createElement('input');
        input.type = 'checkbox';
        input.className = 'leaflet-control-layers-selector';
        input.defaultChecked = checked;
      } else {
        input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);
      }
      this._layerControlInputs.push(input);
      input.layerId = stamp(obj.layer);
      on(input, 'click', this._onInputClick, this);
      var name = document.createElement('span');
      name.innerHTML = ' ' + obj.name;

      // Helps from preventing layer control flicker when checkboxes are disabled
      // https://github.com/Leaflet/Leaflet/issues/2771
      var holder = document.createElement('span');
      label.appendChild(holder);
      holder.appendChild(input);
      holder.appendChild(name);
      var container = obj.overlay ? this._overlaysList : this._baseLayersList;
      container.appendChild(label);
      this._checkDisabledLayers();
      return label;
    },
    _onInputClick: function () {
      // expanding the control on mobile with a click can cause adding a layer - we don't want this
      if (this._preventClick) {
        return;
      }
      var inputs = this._layerControlInputs,
        input,
        layer;
      var addedLayers = [],
        removedLayers = [];
      this._handlingClick = true;
      for (var i = inputs.length - 1; i >= 0; i--) {
        input = inputs[i];
        layer = this._getLayer(input.layerId).layer;
        if (input.checked) {
          addedLayers.push(layer);
        } else if (!input.checked) {
          removedLayers.push(layer);
        }
      }

      // Bugfix issue 2318: Should remove all old layers before readding new ones
      for (i = 0; i < removedLayers.length; i++) {
        if (this._map.hasLayer(removedLayers[i])) {
          this._map.removeLayer(removedLayers[i]);
        }
      }
      for (i = 0; i < addedLayers.length; i++) {
        if (!this._map.hasLayer(addedLayers[i])) {
          this._map.addLayer(addedLayers[i]);
        }
      }
      this._handlingClick = false;
      this._refocusOnMap();
    },
    _checkDisabledLayers: function () {
      var inputs = this._layerControlInputs,
        input,
        layer,
        zoom = this._map.getZoom();
      for (var i = inputs.length - 1; i >= 0; i--) {
        input = inputs[i];
        layer = this._getLayer(input.layerId).layer;
        input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;
      }
    },
    _expandIfNotCollapsed: function () {
      if (this._map && !this.options.collapsed) {
        this.expand();
      }
      return this;
    },
    _expandSafely: function () {
      var section = this._section;
      this._preventClick = true;
      on(section, 'click', preventDefault);
      this.expand();
      var that = this;
      setTimeout(function () {
        off(section, 'click', preventDefault);
        that._preventClick = false;
      });
    }
  });

  // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
  var layers = function (baseLayers, overlays, options) {
    return new Layers(baseLayers, overlays, options);
  };

  /*
   * @class Control.Zoom
   * @aka L.Control.Zoom
   * @inherits Control
   *
   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
   */

  var Zoom = Control.extend({
    // @section
    // @aka Control.Zoom options
    options: {
      position: 'topleft',
      // @option zoomInText: String = '<span aria-hidden="true">+</span>'
      // The text set on the 'zoom in' button.
      zoomInText: '<span aria-hidden="true">+</span>',
      // @option zoomInTitle: String = 'Zoom in'
      // The title set on the 'zoom in' button.
      zoomInTitle: 'Zoom in',
      // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
      // The text set on the 'zoom out' button.
      zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
      // @option zoomOutTitle: String = 'Zoom out'
      // The title set on the 'zoom out' button.
      zoomOutTitle: 'Zoom out'
    },
    onAdd: function (map) {
      var zoomName = 'leaflet-control-zoom',
        container = create$1('div', zoomName + ' leaflet-bar'),
        options = this.options;
      this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + '-in', container, this._zoomIn);
      this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + '-out', container, this._zoomOut);
      this._updateDisabled();
      map.on('zoomend zoomlevelschange', this._updateDisabled, this);
      return container;
    },
    onRemove: function (map) {
      map.off('zoomend zoomlevelschange', this._updateDisabled, this);
    },
    disable: function () {
      this._disabled = true;
      this._updateDisabled();
      return this;
    },
    enable: function () {
      this._disabled = false;
      this._updateDisabled();
      return this;
    },
    _zoomIn: function (e) {
      if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
        this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
      }
    },
    _zoomOut: function (e) {
      if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
        this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
      }
    },
    _createButton: function (html, title, className, container, fn) {
      var link = create$1('a', className, container);
      link.innerHTML = html;
      link.href = '#';
      link.title = title;

      /*
       * Will force screen readers like VoiceOver to read this as "Zoom in - button"
       */
      link.setAttribute('role', 'button');
      link.setAttribute('aria-label', title);
      disableClickPropagation(link);
      on(link, 'click', stop);
      on(link, 'click', fn, this);
      on(link, 'click', this._refocusOnMap, this);
      return link;
    },
    _updateDisabled: function () {
      var map = this._map,
        className = 'leaflet-disabled';
      removeClass(this._zoomInButton, className);
      removeClass(this._zoomOutButton, className);
      this._zoomInButton.setAttribute('aria-disabled', 'false');
      this._zoomOutButton.setAttribute('aria-disabled', 'false');
      if (this._disabled || map._zoom === map.getMinZoom()) {
        addClass(this._zoomOutButton, className);
        this._zoomOutButton.setAttribute('aria-disabled', 'true');
      }
      if (this._disabled || map._zoom === map.getMaxZoom()) {
        addClass(this._zoomInButton, className);
        this._zoomInButton.setAttribute('aria-disabled', 'true');
      }
    }
  });

  // @namespace Map
  // @section Control options
  // @option zoomControl: Boolean = true
  // Whether a [zoom control](#control-zoom) is added to the map by default.
  Map.mergeOptions({
    zoomControl: true
  });
  Map.addInitHook(function () {
    if (this.options.zoomControl) {
      // @section Controls
      // @property zoomControl: Control.Zoom
      // The default zoom control (only available if the
      // [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).
      this.zoomControl = new Zoom();
      this.addControl(this.zoomControl);
    }
  });

  // @namespace Control.Zoom
  // @factory L.control.zoom(options: Control.Zoom options)
  // Creates a zoom control
  var zoom = function (options) {
    return new Zoom(options);
  };

  /*
   * @class Control.Scale
   * @aka L.Control.Scale
   * @inherits Control
   *
   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
   *
   * @example
   *
   * ```js
   * L.control.scale().addTo(map);
   * ```
   */

  var Scale = Control.extend({
    // @section
    // @aka Control.Scale options
    options: {
      position: 'bottomleft',
      // @option maxWidth: Number = 100
      // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
      maxWidth: 100,
      // @option metric: Boolean = True
      // Whether to show the metric scale line (m/km).
      metric: true,
      // @option imperial: Boolean = True
      // Whether to show the imperial scale line (mi/ft).
      imperial: true

      // @option updateWhenIdle: Boolean = false
      // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
    },

    onAdd: function (map) {
      var className = 'leaflet-control-scale',
        container = create$1('div', className),
        options = this.options;
      this._addScales(options, className + '-line', container);
      map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
      map.whenReady(this._update, this);
      return container;
    },
    onRemove: function (map) {
      map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
    },
    _addScales: function (options, className, container) {
      if (options.metric) {
        this._mScale = create$1('div', className, container);
      }
      if (options.imperial) {
        this._iScale = create$1('div', className, container);
      }
    },
    _update: function () {
      var map = this._map,
        y = map.getSize().y / 2;
      var maxMeters = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));
      this._updateScales(maxMeters);
    },
    _updateScales: function (maxMeters) {
      if (this.options.metric && maxMeters) {
        this._updateMetric(maxMeters);
      }
      if (this.options.imperial && maxMeters) {
        this._updateImperial(maxMeters);
      }
    },
    _updateMetric: function (maxMeters) {
      var meters = this._getRoundNum(maxMeters),
        label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';
      this._updateScale(this._mScale, label, meters / maxMeters);
    },
    _updateImperial: function (maxMeters) {
      var maxFeet = maxMeters * 3.2808399,
        maxMiles,
        miles,
        feet;
      if (maxFeet > 5280) {
        maxMiles = maxFeet / 5280;
        miles = this._getRoundNum(maxMiles);
        this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);
      } else {
        feet = this._getRoundNum(maxFeet);
        this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
      }
    },
    _updateScale: function (scale, text, ratio) {
      scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
      scale.innerHTML = text;
    },
    _getRoundNum: function (num) {
      var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
        d = num / pow10;
      d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
      return pow10 * d;
    }
  });

  // @factory L.control.scale(options?: Control.Scale options)
  // Creates an scale control with the given options.
  var scale = function (options) {
    return new Scale(options);
  };
  var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';

  /*
   * @class Control.Attribution
   * @aka L.Control.Attribution
   * @inherits Control
   *
   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
   */

  var Attribution = Control.extend({
    // @section
    // @aka Control.Attribution options
    options: {
      position: 'bottomright',
      // @option prefix: String|false = 'Leaflet'
      // The HTML text shown before the attributions. Pass `false` to disable.
      prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser.inlineSvg ? ukrainianFlag + ' ' : '') + 'Leaflet</a>'
    },
    initialize: function (options) {
      setOptions(this, options);
      this._attributions = {};
    },
    onAdd: function (map) {
      map.attributionControl = this;
      this._container = create$1('div', 'leaflet-control-attribution');
      disableClickPropagation(this._container);

      // TODO ugly, refactor
      for (var i in map._layers) {
        if (map._layers[i].getAttribution) {
          this.addAttribution(map._layers[i].getAttribution());
        }
      }
      this._update();
      map.on('layeradd', this._addAttribution, this);
      return this._container;
    },
    onRemove: function (map) {
      map.off('layeradd', this._addAttribution, this);
    },
    _addAttribution: function (ev) {
      if (ev.layer.getAttribution) {
        this.addAttribution(ev.layer.getAttribution());
        ev.layer.once('remove', function () {
          this.removeAttribution(ev.layer.getAttribution());
        }, this);
      }
    },
    // @method setPrefix(prefix: String|false): this
    // The HTML text shown before the attributions. Pass `false` to disable.
    setPrefix: function (prefix) {
      this.options.prefix = prefix;
      this._update();
      return this;
    },
    // @method addAttribution(text: String): this
    // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
    addAttribution: function (text) {
      if (!text) {
        return this;
      }
      if (!this._attributions[text]) {
        this._attributions[text] = 0;
      }
      this._attributions[text]++;
      this._update();
      return this;
    },
    // @method removeAttribution(text: String): this
    // Removes an attribution text.
    removeAttribution: function (text) {
      if (!text) {
        return this;
      }
      if (this._attributions[text]) {
        this._attributions[text]--;
        this._update();
      }
      return this;
    },
    _update: function () {
      if (!this._map) {
        return;
      }
      var attribs = [];
      for (var i in this._attributions) {
        if (this._attributions[i]) {
          attribs.push(i);
        }
      }
      var prefixAndAttribs = [];
      if (this.options.prefix) {
        prefixAndAttribs.push(this.options.prefix);
      }
      if (attribs.length) {
        prefixAndAttribs.push(attribs.join(', '));
      }
      this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
    }
  });

  // @namespace Map
  // @section Control options
  // @option attributionControl: Boolean = true
  // Whether a [attribution control](#control-attribution) is added to the map by default.
  Map.mergeOptions({
    attributionControl: true
  });
  Map.addInitHook(function () {
    if (this.options.attributionControl) {
      new Attribution().addTo(this);
    }
  });

  // @namespace Control.Attribution
  // @factory L.control.attribution(options: Control.Attribution options)
  // Creates an attribution control.
  var attribution = function (options) {
    return new Attribution(options);
  };
  Control.Layers = Layers;
  Control.Zoom = Zoom;
  Control.Scale = Scale;
  Control.Attribution = Attribution;
  control.layers = layers;
  control.zoom = zoom;
  control.scale = scale;
  control.attribution = attribution;

  /*
  	L.Handler is a base class for handler classes that are used internally to inject
  	interaction features like dragging to classes like Map and Marker.
  */

  // @class Handler
  // @aka L.Handler
  // Abstract class for map interaction handlers

  var Handler = Class.extend({
    initialize: function (map) {
      this._map = map;
    },
    // @method enable(): this
    // Enables the handler
    enable: function () {
      if (this._enabled) {
        return this;
      }
      this._enabled = true;
      this.addHooks();
      return this;
    },
    // @method disable(): this
    // Disables the handler
    disable: function () {
      if (!this._enabled) {
        return this;
      }
      this._enabled = false;
      this.removeHooks();
      return this;
    },
    // @method enabled(): Boolean
    // Returns `true` if the handler is enabled
    enabled: function () {
      return !!this._enabled;
    }

    // @section Extension methods
    // Classes inheriting from `Handler` must implement the two following methods:
    // @method addHooks()
    // Called when the handler is enabled, should add event hooks.
    // @method removeHooks()
    // Called when the handler is disabled, should remove the event hooks added previously.
  });

  // @section There is static function which can be called without instantiating L.Handler:
  // @function addTo(map: Map, name: String): this
  // Adds a new Handler to the given map with the given name.
  Handler.addTo = function (map, name) {
    map.addHandler(name, this);
    return this;
  };
  var Mixin = {
    Events: Events
  };

  /*
   * @class Draggable
   * @aka L.Draggable
   * @inherits Evented
   *
   * A class for making DOM elements draggable (including touch support).
   * Used internally for map and marker dragging. Only works for elements
   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
   *
   * @example
   * ```js
   * var draggable = new L.Draggable(elementToDrag);
   * draggable.enable();
   * ```
   */

  var START = Browser.touch ? 'touchstart mousedown' : 'mousedown';
  var Draggable = Evented.extend({
    options: {
      // @section
      // @aka Draggable options
      // @option clickTolerance: Number = 3
      // The max number of pixels a user can shift the mouse pointer during a click
      // for it to be considered a valid click (as opposed to a mouse drag).
      clickTolerance: 3
    },
    // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
    // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
    initialize: function (element, dragStartTarget, preventOutline, options) {
      setOptions(this, options);
      this._element = element;
      this._dragStartTarget = dragStartTarget || element;
      this._preventOutline = preventOutline;
    },
    // @method enable()
    // Enables the dragging ability
    enable: function () {
      if (this._enabled) {
        return;
      }
      on(this._dragStartTarget, START, this._onDown, this);
      this._enabled = true;
    },
    // @method disable()
    // Disables the dragging ability
    disable: function () {
      if (!this._enabled) {
        return;
      }

      // If we're currently dragging this draggable,
      // disabling it counts as first ending the drag.
      if (Draggable._dragging === this) {
        this.finishDrag(true);
      }
      off(this._dragStartTarget, START, this._onDown, this);
      this._enabled = false;
      this._moved = false;
    },
    _onDown: function (e) {
      // Ignore the event if disabled; this happens in IE11
      // under some circumstances, see #3666.
      if (!this._enabled) {
        return;
      }
      this._moved = false;
      if (hasClass(this._element, 'leaflet-zoom-anim')) {
        return;
      }
      if (e.touches && e.touches.length !== 1) {
        // Finish dragging to avoid conflict with touchZoom
        if (Draggable._dragging === this) {
          this.finishDrag();
        }
        return;
      }
      if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
        return;
      }
      Draggable._dragging = this; // Prevent dragging multiple objects at once.

      if (this._preventOutline) {
        preventOutline(this._element);
      }
      disableImageDrag();
      disableTextSelection();
      if (this._moving) {
        return;
      }

      // @event down: Event
      // Fired when a drag is about to start.
      this.fire('down');
      var first = e.touches ? e.touches[0] : e,
        sizedParent = getSizedParentNode(this._element);
      this._startPoint = new Point(first.clientX, first.clientY);
      this._startPos = getPosition(this._element);

      // Cache the scale, so that we can continuously compensate for it during drag (_onMove).
      this._parentScale = getScale(sizedParent);
      var mouseevent = e.type === 'mousedown';
      on(document, mouseevent ? 'mousemove' : 'touchmove', this._onMove, this);
      on(document, mouseevent ? 'mouseup' : 'touchend touchcancel', this._onUp, this);
    },
    _onMove: function (e) {
      // Ignore the event if disabled; this happens in IE11
      // under some circumstances, see #3666.
      if (!this._enabled) {
        return;
      }
      if (e.touches && e.touches.length > 1) {
        this._moved = true;
        return;
      }
      var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,
        offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
      if (!offset.x && !offset.y) {
        return;
      }
      if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
        return;
      }

      // We assume that the parent container's position, border and scale do not change for the duration of the drag.
      // Therefore there is no need to account for the position and border (they are eliminated by the subtraction)
      // and we can use the cached value for the scale.
      offset.x /= this._parentScale.x;
      offset.y /= this._parentScale.y;
      preventDefault(e);
      if (!this._moved) {
        // @event dragstart: Event
        // Fired when a drag starts
        this.fire('dragstart');
        this._moved = true;
        addClass(document.body, 'leaflet-dragging');
        this._lastTarget = e.target || e.srcElement;
        // IE and Edge do not give the <use> element, so fetch it
        // if necessary
        if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
          this._lastTarget = this._lastTarget.correspondingUseElement;
        }
        addClass(this._lastTarget, 'leaflet-drag-target');
      }
      this._newPos = this._startPos.add(offset);
      this._moving = true;
      this._lastEvent = e;
      this._updatePosition();
    },
    _updatePosition: function () {
      var e = {
        originalEvent: this._lastEvent
      };

      // @event predrag: Event
      // Fired continuously during dragging *before* each corresponding
      // update of the element's position.
      this.fire('predrag', e);
      setPosition(this._element, this._newPos);

      // @event drag: Event
      // Fired continuously during dragging.
      this.fire('drag', e);
    },
    _onUp: function () {
      // Ignore the event if disabled; this happens in IE11
      // under some circumstances, see #3666.
      if (!this._enabled) {
        return;
      }
      this.finishDrag();
    },
    finishDrag: function (noInertia) {
      removeClass(document.body, 'leaflet-dragging');
      if (this._lastTarget) {
        removeClass(this._lastTarget, 'leaflet-drag-target');
        this._lastTarget = null;
      }
      off(document, 'mousemove touchmove', this._onMove, this);
      off(document, 'mouseup touchend touchcancel', this._onUp, this);
      enableImageDrag();
      enableTextSelection();
      var fireDragend = this._moved && this._moving;
      this._moving = false;
      Draggable._dragging = false;
      if (fireDragend) {
        // @event dragend: DragEndEvent
        // Fired when the drag ends.
        this.fire('dragend', {
          noInertia: noInertia,
          distance: this._newPos.distanceTo(this._startPos)
        });
      }
    }
  });

  /*
   * @namespace PolyUtil
   * Various utility functions for polygon geometries.
   */

  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
   * Used by Leaflet to only show polygon points that are on the screen or near, increasing
   * performance. Note that polygon points needs different algorithm for clipping
   * than polyline, so there's a separate method for it.
   */
  function clipPolygon(points, bounds, round) {
    var clippedPoints,
      edges = [1, 4, 2, 8],
      i,
      j,
      k,
      a,
      b,
      len,
      edge,
      p;
    for (i = 0, len = points.length; i < len; i++) {
      points[i]._code = _getBitCode(points[i], bounds);
    }

    // for each edge (left, bottom, right, top)
    for (k = 0; k < 4; k++) {
      edge = edges[k];
      clippedPoints = [];
      for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
        a = points[i];
        b = points[j];

        // if a is inside the clip window
        if (!(a._code & edge)) {
          // if b is outside the clip window (a->b goes out of screen)
          if (b._code & edge) {
            p = _getEdgeIntersection(b, a, edge, bounds, round);
            p._code = _getBitCode(p, bounds);
            clippedPoints.push(p);
          }
          clippedPoints.push(a);

          // else if b is inside the clip window (a->b enters the screen)
        } else if (!(b._code & edge)) {
          p = _getEdgeIntersection(b, a, edge, bounds, round);
          p._code = _getBitCode(p, bounds);
          clippedPoints.push(p);
        }
      }
      points = clippedPoints;
    }
    return points;
  }

  /* @function polygonCenter(latlngs: LatLng[], crs: CRS): LatLng
   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polygon.
   */
  function polygonCenter(latlngs, crs) {
    var i, j, p1, p2, f, area, x, y, center;
    if (!latlngs || latlngs.length === 0) {
      throw new Error('latlngs not passed');
    }
    if (!isFlat(latlngs)) {
      console.warn('latlngs are not flat! Only the first ring will be used');
      latlngs = latlngs[0];
    }
    var centroidLatLng = toLatLng([0, 0]);
    var bounds = toLatLngBounds(latlngs);
    var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
    // tests showed that below 1700 rounding errors are happening
    if (areaBounds < 1700) {
      // getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors
      centroidLatLng = centroid(latlngs);
    }
    var len = latlngs.length;
    var points = [];
    for (i = 0; i < len; i++) {
      var latlng = toLatLng(latlngs[i]);
      points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
    }
    area = x = y = 0;

    // polygon centroid algorithm;
    for (i = 0, j = len - 1; i < len; j = i++) {
      p1 = points[i];
      p2 = points[j];
      f = p1.y * p2.x - p2.y * p1.x;
      x += (p1.x + p2.x) * f;
      y += (p1.y + p2.y) * f;
      area += f * 3;
    }
    if (area === 0) {
      // Polygon is so small that all points are on same pixel.
      center = points[0];
    } else {
      center = [x / area, y / area];
    }
    var latlngCenter = crs.unproject(toPoint(center));
    return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
  }

  /* @function centroid(latlngs: LatLng[]): LatLng
   * Returns the 'center of mass' of the passed LatLngs.
   */
  function centroid(coords) {
    var latSum = 0;
    var lngSum = 0;
    var len = 0;
    for (var i = 0; i < coords.length; i++) {
      var latlng = toLatLng(coords[i]);
      latSum += latlng.lat;
      lngSum += latlng.lng;
      len++;
    }
    return toLatLng([latSum / len, lngSum / len]);
  }
  var PolyUtil = {
    __proto__: null,
    clipPolygon: clipPolygon,
    polygonCenter: polygonCenter,
    centroid: centroid
  };

  /*
   * @namespace LineUtil
   *
   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
   */

  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.
  // Improves rendering performance dramatically by lessening the number of points to draw.

  // @function simplify(points: Point[], tolerance: Number): Point[]
  // Dramatically reduces the number of points in a polyline while retaining
  // its shape and returns a new array of simplified points, using the
  // [Ramer-Douglas-Peucker algorithm](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm).
  // Used for a huge performance boost when processing/displaying Leaflet polylines for
  // each zoom level and also reducing visual noise. tolerance affects the amount of
  // simplification (lesser value means higher quality but slower and with more points).
  // Also released as a separated micro-library [Simplify.js](https://mourner.github.io/simplify-js/).
  function simplify(points, tolerance) {
    if (!tolerance || !points.length) {
      return points.slice();
    }
    var sqTolerance = tolerance * tolerance;

    // stage 1: vertex reduction
    points = _reducePoints(points, sqTolerance);

    // stage 2: Douglas-Peucker simplification
    points = _simplifyDP(points, sqTolerance);
    return points;
  }

  // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
  // Returns the distance between point `p` and segment `p1` to `p2`.
  function pointToSegmentDistance(p, p1, p2) {
    return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
  }

  // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
  // Returns the closest point from a point `p` on a segment `p1` to `p2`.
  function closestPointOnSegment(p, p1, p2) {
    return _sqClosestPointOnSegment(p, p1, p2);
  }

  // Ramer-Douglas-Peucker simplification, see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
  function _simplifyDP(points, sqTolerance) {
    var len = points.length,
      ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
      markers = new ArrayConstructor(len);
    markers[0] = markers[len - 1] = 1;
    _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
    var i,
      newPoints = [];
    for (i = 0; i < len; i++) {
      if (markers[i]) {
        newPoints.push(points[i]);
      }
    }
    return newPoints;
  }
  function _simplifyDPStep(points, markers, sqTolerance, first, last) {
    var maxSqDist = 0,
      index,
      i,
      sqDist;
    for (i = first + 1; i <= last - 1; i++) {
      sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);
      if (sqDist > maxSqDist) {
        index = i;
        maxSqDist = sqDist;
      }
    }
    if (maxSqDist > sqTolerance) {
      markers[index] = 1;
      _simplifyDPStep(points, markers, sqTolerance, first, index);
      _simplifyDPStep(points, markers, sqTolerance, index, last);
    }
  }

  // reduce points that are too close to each other to a single point
  function _reducePoints(points, sqTolerance) {
    var reducedPoints = [points[0]];
    for (var i = 1, prev = 0, len = points.length; i < len; i++) {
      if (_sqDist(points[i], points[prev]) > sqTolerance) {
        reducedPoints.push(points[i]);
        prev = i;
      }
    }
    if (prev < len - 1) {
      reducedPoints.push(points[len - 1]);
    }
    return reducedPoints;
  }
  var _lastCode;

  // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
  // Clips the segment a to b by rectangular bounds with the
  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
  // (modifying the segment points directly!). Used by Leaflet to only show polyline
  // points that are on the screen or near, increasing performance.
  function clipSegment(a, b, bounds, useLastCode, round) {
    var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
      codeB = _getBitCode(b, bounds),
      codeOut,
      p,
      newCode;

    // save 2nd code to avoid calculating it on the next segment
    _lastCode = codeB;
    while (true) {
      // if a,b is inside the clip window (trivial accept)
      if (!(codeA | codeB)) {
        return [a, b];
      }

      // if a,b is outside the clip window (trivial reject)
      if (codeA & codeB) {
        return false;
      }

      // other cases
      codeOut = codeA || codeB;
      p = _getEdgeIntersection(a, b, codeOut, bounds, round);
      newCode = _getBitCode(p, bounds);
      if (codeOut === codeA) {
        a = p;
        codeA = newCode;
      } else {
        b = p;
        codeB = newCode;
      }
    }
  }
  function _getEdgeIntersection(a, b, code, bounds, round) {
    var dx = b.x - a.x,
      dy = b.y - a.y,
      min = bounds.min,
      max = bounds.max,
      x,
      y;
    if (code & 8) {
      // top
      x = a.x + dx * (max.y - a.y) / dy;
      y = max.y;
    } else if (code & 4) {
      // bottom
      x = a.x + dx * (min.y - a.y) / dy;
      y = min.y;
    } else if (code & 2) {
      // right
      x = max.x;
      y = a.y + dy * (max.x - a.x) / dx;
    } else if (code & 1) {
      // left
      x = min.x;
      y = a.y + dy * (min.x - a.x) / dx;
    }
    return new Point(x, y, round);
  }
  function _getBitCode(p, bounds) {
    var code = 0;
    if (p.x < bounds.min.x) {
      // left
      code |= 1;
    } else if (p.x > bounds.max.x) {
      // right
      code |= 2;
    }
    if (p.y < bounds.min.y) {
      // bottom
      code |= 4;
    } else if (p.y > bounds.max.y) {
      // top
      code |= 8;
    }
    return code;
  }

  // square distance (to avoid unnecessary Math.sqrt calls)
  function _sqDist(p1, p2) {
    var dx = p2.x - p1.x,
      dy = p2.y - p1.y;
    return dx * dx + dy * dy;
  }

  // return closest point on segment or distance to that point
  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
    var x = p1.x,
      y = p1.y,
      dx = p2.x - x,
      dy = p2.y - y,
      dot = dx * dx + dy * dy,
      t;
    if (dot > 0) {
      t = ((p.x - x) * dx + (p.y - y) * dy) / dot;
      if (t > 1) {
        x = p2.x;
        y = p2.y;
      } else if (t > 0) {
        x += dx * t;
        y += dy * t;
      }
    }
    dx = p.x - x;
    dy = p.y - y;
    return sqDist ? dx * dx + dy * dy : new Point(x, y);
  }

  // @function isFlat(latlngs: LatLng[]): Boolean
  // Returns true if `latlngs` is a flat array, false is nested.
  function isFlat(latlngs) {
    return !isArray(latlngs[0]) || typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined';
  }
  function _flat(latlngs) {
    console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
    return isFlat(latlngs);
  }

  /* @function polylineCenter(latlngs: LatLng[], crs: CRS): LatLng
   * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the passed LatLngs (first ring) from a polyline.
   */
  function polylineCenter(latlngs, crs) {
    var i, halfDist, segDist, dist, p1, p2, ratio, center;
    if (!latlngs || latlngs.length === 0) {
      throw new Error('latlngs not passed');
    }
    if (!isFlat(latlngs)) {
      console.warn('latlngs are not flat! Only the first ring will be used');
      latlngs = latlngs[0];
    }
    var centroidLatLng = toLatLng([0, 0]);
    var bounds = toLatLngBounds(latlngs);
    var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
    // tests showed that below 1700 rounding errors are happening
    if (areaBounds < 1700) {
      // getting a inexact center, to move the latlngs near to [0, 0] to prevent rounding errors
      centroidLatLng = centroid(latlngs);
    }
    var len = latlngs.length;
    var points = [];
    for (i = 0; i < len; i++) {
      var latlng = toLatLng(latlngs[i]);
      points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
    }
    for (i = 0, halfDist = 0; i < len - 1; i++) {
      halfDist += points[i].distanceTo(points[i + 1]) / 2;
    }

    // The line is so small in the current view that all points are on the same pixel.
    if (halfDist === 0) {
      center = points[0];
    } else {
      for (i = 0, dist = 0; i < len - 1; i++) {
        p1 = points[i];
        p2 = points[i + 1];
        segDist = p1.distanceTo(p2);
        dist += segDist;
        if (dist > halfDist) {
          ratio = (dist - halfDist) / segDist;
          center = [p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)];
          break;
        }
      }
    }
    var latlngCenter = crs.unproject(toPoint(center));
    return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
  }
  var LineUtil = {
    __proto__: null,
    simplify: simplify,
    pointToSegmentDistance: pointToSegmentDistance,
    closestPointOnSegment: closestPointOnSegment,
    clipSegment: clipSegment,
    _getEdgeIntersection: _getEdgeIntersection,
    _getBitCode: _getBitCode,
    _sqClosestPointOnSegment: _sqClosestPointOnSegment,
    isFlat: isFlat,
    _flat: _flat,
    polylineCenter: polylineCenter
  };

  /*
   * @namespace Projection
   * @section
   * Leaflet comes with a set of already defined Projections out of the box:
   *
   * @projection L.Projection.LonLat
   *
   * Equirectangular, or Plate Carree projection — the most simple projection,
   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
   * `EPSG:4326` and `Simple` CRS.
   */

  var LonLat = {
    project: function (latlng) {
      return new Point(latlng.lng, latlng.lat);
    },
    unproject: function (point) {
      return new LatLng(point.y, point.x);
    },
    bounds: new Bounds([-180, -90], [180, 90])
  };

  /*
   * @namespace Projection
   * @projection L.Projection.Mercator
   *
   * Elliptical Mercator projection — more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.
   */

  var Mercator = {
    R: 6378137,
    R_MINOR: 6356752.314245179,
    bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),
    project: function (latlng) {
      var d = Math.PI / 180,
        r = this.R,
        y = latlng.lat * d,
        tmp = this.R_MINOR / r,
        e = Math.sqrt(1 - tmp * tmp),
        con = e * Math.sin(y);
      var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
      y = -r * Math.log(Math.max(ts, 1E-10));
      return new Point(latlng.lng * d * r, y);
    },
    unproject: function (point) {
      var d = 180 / Math.PI,
        r = this.R,
        tmp = this.R_MINOR / r,
        e = Math.sqrt(1 - tmp * tmp),
        ts = Math.exp(-point.y / r),
        phi = Math.PI / 2 - 2 * Math.atan(ts);
      for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
        con = e * Math.sin(phi);
        con = Math.pow((1 - con) / (1 + con), e / 2);
        dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
        phi += dphi;
      }
      return new LatLng(phi * d, point.x * d / r);
    }
  };

  /*
   * @class Projection
    * An object with methods for projecting geographical coordinates of the world onto
   * a flat surface (and back). See [Map projection](https://en.wikipedia.org/wiki/Map_projection).
    * @property bounds: Bounds
   * The bounds (specified in CRS units) where the projection is valid
    * @method project(latlng: LatLng): Point
   * Projects geographical coordinates into a 2D point.
   * Only accepts actual `L.LatLng` instances, not arrays.
    * @method unproject(point: Point): LatLng
   * The inverse of `project`. Projects a 2D point into a geographical location.
   * Only accepts actual `L.Point` instances, not arrays.
    * Note that the projection instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.
    */

  var index = {
    __proto__: null,
    LonLat: LonLat,
    Mercator: Mercator,
    SphericalMercator: SphericalMercator
  };

  /*
   * @namespace CRS
   * @crs L.CRS.EPSG3395
   *
   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
   */
  var EPSG3395 = extend({}, Earth, {
    code: 'EPSG:3395',
    projection: Mercator,
    transformation: function () {
      var scale = 0.5 / (Math.PI * Mercator.R);
      return toTransformation(scale, 0.5, -scale, 0.5);
    }()
  });

  /*
   * @namespace CRS
   * @crs L.CRS.EPSG4326
   *
   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
   *
   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
   * with this CRS, ensure that there are two 256x256 pixel tiles covering the
   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
   */

  var EPSG4326 = extend({}, Earth, {
    code: 'EPSG:4326',
    projection: LonLat,
    transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
  });

  /*
   * @namespace CRS
   * @crs L.CRS.Simple
   *
   * A simple CRS that maps longitude and latitude into `x` and `y` directly.
   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
   * axis should still be inverted (going from bottom to top). `distance()` returns
   * simple euclidean distance.
   */

  var Simple = extend({}, CRS, {
    projection: LonLat,
    transformation: toTransformation(1, 0, -1, 0),
    scale: function (zoom) {
      return Math.pow(2, zoom);
    },
    zoom: function (scale) {
      return Math.log(scale) / Math.LN2;
    },
    distance: function (latlng1, latlng2) {
      var dx = latlng2.lng - latlng1.lng,
        dy = latlng2.lat - latlng1.lat;
      return Math.sqrt(dx * dx + dy * dy);
    },
    infinite: true
  });
  CRS.Earth = Earth;
  CRS.EPSG3395 = EPSG3395;
  CRS.EPSG3857 = EPSG3857;
  CRS.EPSG900913 = EPSG900913;
  CRS.EPSG4326 = EPSG4326;
  CRS.Simple = Simple;

  /*
   * @class Layer
   * @inherits Evented
   * @aka L.Layer
   * @aka ILayer
   *
   * A set of methods from the Layer base class that all Leaflet layers use.
   * Inherits all methods, options and events from `L.Evented`.
   *
   * @example
   *
   * ```js
   * var layer = L.marker(latlng).addTo(map);
   * layer.addTo(map);
   * layer.remove();
   * ```
   *
   * @event add: Event
   * Fired after the layer is added to a map
   *
   * @event remove: Event
   * Fired after the layer is removed from a map
   */

  var Layer = Evented.extend({
    // Classes extending `L.Layer` will inherit the following options:
    options: {
      // @option pane: String = 'overlayPane'
      // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
      pane: 'overlayPane',
      // @option attribution: String = null
      // String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
      attribution: null,
      bubblingMouseEvents: true
    },
    /* @section
     * Classes extending `L.Layer` will inherit the following methods:
     *
     * @method addTo(map: Map|LayerGroup): this
     * Adds the layer to the given map or layer group.
     */
    addTo: function (map) {
      map.addLayer(this);
      return this;
    },
    // @method remove: this
    // Removes the layer from the map it is currently active on.
    remove: function () {
      return this.removeFrom(this._map || this._mapToAdd);
    },
    // @method removeFrom(map: Map): this
    // Removes the layer from the given map
    //
    // @alternative
    // @method removeFrom(group: LayerGroup): this
    // Removes the layer from the given `LayerGroup`
    removeFrom: function (obj) {
      if (obj) {
        obj.removeLayer(this);
      }
      return this;
    },
    // @method getPane(name? : String): HTMLElement
    // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
    getPane: function (name) {
      return this._map.getPane(name ? this.options[name] || name : this.options.pane);
    },
    addInteractiveTarget: function (targetEl) {
      this._map._targets[stamp(targetEl)] = this;
      return this;
    },
    removeInteractiveTarget: function (targetEl) {
      delete this._map._targets[stamp(targetEl)];
      return this;
    },
    // @method getAttribution: String
    // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
    getAttribution: function () {
      return this.options.attribution;
    },
    _layerAdd: function (e) {
      var map = e.target;

      // check in case layer gets added and then removed before the map is ready
      if (!map.hasLayer(this)) {
        return;
      }
      this._map = map;
      this._zoomAnimated = map._zoomAnimated;
      if (this.getEvents) {
        var events = this.getEvents();
        map.on(events, this);
        this.once('remove', function () {
          map.off(events, this);
        }, this);
      }
      this.onAdd(map);
      this.fire('add');
      map.fire('layeradd', {
        layer: this
      });
    }
  });

  /* @section Extension methods
   * @uninheritable
   *
   * Every layer should extend from `L.Layer` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): this
   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
   *
   * @method onRemove(map: Map): this
   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
   *
   * @method getEvents(): Object
   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
   *
   * @method getAttribution(): String
   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
   *
   * @method beforeAdd(map: Map): this
   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
   */

  /* @namespace Map
   * @section Layer events
   *
   * @event layeradd: LayerEvent
   * Fired when a new layer is added to the map.
   *
   * @event layerremove: LayerEvent
   * Fired when some layer is removed from the map
   *
   * @section Methods for Layers and Controls
   */
  Map.include({
    // @method addLayer(layer: Layer): this
    // Adds the given layer to the map
    addLayer: function (layer) {
      if (!layer._layerAdd) {
        throw new Error('The provided object is not a Layer.');
      }
      var id = stamp(layer);
      if (this._layers[id]) {
        return this;
      }
      this._layers[id] = layer;
      layer._mapToAdd = this;
      if (layer.beforeAdd) {
        layer.beforeAdd(this);
      }
      this.whenReady(layer._layerAdd, layer);
      return this;
    },
    // @method removeLayer(layer: Layer): this
    // Removes the given layer from the map.
    removeLayer: function (layer) {
      var id = stamp(layer);
      if (!this._layers[id]) {
        return this;
      }
      if (this._loaded) {
        layer.onRemove(this);
      }
      delete this._layers[id];
      if (this._loaded) {
        this.fire('layerremove', {
          layer: layer
        });
        layer.fire('remove');
      }
      layer._map = layer._mapToAdd = null;
      return this;
    },
    // @method hasLayer(layer: Layer): Boolean
    // Returns `true` if the given layer is currently added to the map
    hasLayer: function (layer) {
      return stamp(layer) in this._layers;
    },
    /* @method eachLayer(fn: Function, context?: Object): this
     * Iterates over the layers of the map, optionally specifying context of the iterator function.
     * ```
     * map.eachLayer(function(layer){
     *     layer.bindPopup('Hello');
     * });
     * ```
     */
    eachLayer: function (method, context) {
      for (var i in this._layers) {
        method.call(context, this._layers[i]);
      }
      return this;
    },
    _addLayers: function (layers) {
      layers = layers ? isArray(layers) ? layers : [layers] : [];
      for (var i = 0, len = layers.length; i < len; i++) {
        this.addLayer(layers[i]);
      }
    },
    _addZoomLimit: function (layer) {
      if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
        this._zoomBoundLayers[stamp(layer)] = layer;
        this._updateZoomLevels();
      }
    },
    _removeZoomLimit: function (layer) {
      var id = stamp(layer);
      if (this._zoomBoundLayers[id]) {
        delete this._zoomBoundLayers[id];
        this._updateZoomLevels();
      }
    },
    _updateZoomLevels: function () {
      var minZoom = Infinity,
        maxZoom = -Infinity,
        oldZoomSpan = this._getZoomSpan();
      for (var i in this._zoomBoundLayers) {
        var options = this._zoomBoundLayers[i].options;
        minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
        maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
      }
      this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
      this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

      // @section Map state change events
      // @event zoomlevelschange: Event
      // Fired when the number of zoomlevels on the map is changed due
      // to adding or removing a layer.
      if (oldZoomSpan !== this._getZoomSpan()) {
        this.fire('zoomlevelschange');
      }
      if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
        this.setZoom(this._layersMaxZoom);
      }
      if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
        this.setZoom(this._layersMinZoom);
      }
    }
  });

  /*
   * @class LayerGroup
   * @aka L.LayerGroup
   * @inherits Interactive layer
   *
   * Used to group several layers and handle them as one. If you add it to the map,
   * any layers added or removed from the group will be added/removed on the map as
   * well. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.layerGroup([marker1, marker2])
   * 	.addLayer(polyline)
   * 	.addTo(map);
   * ```
   */

  var LayerGroup = Layer.extend({
    initialize: function (layers, options) {
      setOptions(this, options);
      this._layers = {};
      var i, len;
      if (layers) {
        for (i = 0, len = layers.length; i < len; i++) {
          this.addLayer(layers[i]);
        }
      }
    },
    // @method addLayer(layer: Layer): this
    // Adds the given layer to the group.
    addLayer: function (layer) {
      var id = this.getLayerId(layer);
      this._layers[id] = layer;
      if (this._map) {
        this._map.addLayer(layer);
      }
      return this;
    },
    // @method removeLayer(layer: Layer): this
    // Removes the given layer from the group.
    // @alternative
    // @method removeLayer(id: Number): this
    // Removes the layer with the given internal ID from the group.
    removeLayer: function (layer) {
      var id = layer in this._layers ? layer : this.getLayerId(layer);
      if (this._map && this._layers[id]) {
        this._map.removeLayer(this._layers[id]);
      }
      delete this._layers[id];
      return this;
    },
    // @method hasLayer(layer: Layer): Boolean
    // Returns `true` if the given layer is currently added to the group.
    // @alternative
    // @method hasLayer(id: Number): Boolean
    // Returns `true` if the given internal ID is currently added to the group.
    hasLayer: function (layer) {
      var layerId = typeof layer === 'number' ? layer : this.getLayerId(layer);
      return layerId in this._layers;
    },
    // @method clearLayers(): this
    // Removes all the layers from the group.
    clearLayers: function () {
      return this.eachLayer(this.removeLayer, this);
    },
    // @method invoke(methodName: String, …): this
    // Calls `methodName` on every layer contained in this group, passing any
    // additional parameters. Has no effect if the layers contained do not
    // implement `methodName`.
    invoke: function (methodName) {
      var args = Array.prototype.slice.call(arguments, 1),
        i,
        layer;
      for (i in this._layers) {
        layer = this._layers[i];
        if (layer[methodName]) {
          layer[methodName].apply(layer, args);
        }
      }
      return this;
    },
    onAdd: function (map) {
      this.eachLayer(map.addLayer, map);
    },
    onRemove: function (map) {
      this.eachLayer(map.removeLayer, map);
    },
    // @method eachLayer(fn: Function, context?: Object): this
    // Iterates over the layers of the group, optionally specifying context of the iterator function.
    // ```js
    // group.eachLayer(function (layer) {
    // 	layer.bindPopup('Hello');
    // });
    // ```
    eachLayer: function (method, context) {
      for (var i in this._layers) {
        method.call(context, this._layers[i]);
      }
      return this;
    },
    // @method getLayer(id: Number): Layer
    // Returns the layer with the given internal ID.
    getLayer: function (id) {
      return this._layers[id];
    },
    // @method getLayers(): Layer[]
    // Returns an array of all the layers added to the group.
    getLayers: function () {
      var layers = [];
      this.eachLayer(layers.push, layers);
      return layers;
    },
    // @method setZIndex(zIndex: Number): this
    // Calls `setZIndex` on every layer contained in this group, passing the z-index.
    setZIndex: function (zIndex) {
      return this.invoke('setZIndex', zIndex);
    },
    // @method getLayerId(layer: Layer): Number
    // Returns the internal ID for a layer
    getLayerId: function (layer) {
      return stamp(layer);
    }
  });

  // @factory L.layerGroup(layers?: Layer[], options?: Object)
  // Create a layer group, optionally given an initial set of layers and an `options` object.
  var layerGroup = function (layers, options) {
    return new LayerGroup(layers, options);
  };

  /*
   * @class FeatureGroup
   * @aka L.FeatureGroup
   * @inherits LayerGroup
   *
   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
   *  * Events are propagated to the `FeatureGroup`, so if the group has an event
   * handler, it will handle events from any of the layers. This includes mouse events
   * and custom events.
   *  * Has `layeradd` and `layerremove` events
   *
   * @example
   *
   * ```js
   * L.featureGroup([marker1, marker2, polyline])
   * 	.bindPopup('Hello world!')
   * 	.on('click', function() { alert('Clicked on a member of the group!'); })
   * 	.addTo(map);
   * ```
   */

  var FeatureGroup = LayerGroup.extend({
    addLayer: function (layer) {
      if (this.hasLayer(layer)) {
        return this;
      }
      layer.addEventParent(this);
      LayerGroup.prototype.addLayer.call(this, layer);

      // @event layeradd: LayerEvent
      // Fired when a layer is added to this `FeatureGroup`
      return this.fire('layeradd', {
        layer: layer
      });
    },
    removeLayer: function (layer) {
      if (!this.hasLayer(layer)) {
        return this;
      }
      if (layer in this._layers) {
        layer = this._layers[layer];
      }
      layer.removeEventParent(this);
      LayerGroup.prototype.removeLayer.call(this, layer);

      // @event layerremove: LayerEvent
      // Fired when a layer is removed from this `FeatureGroup`
      return this.fire('layerremove', {
        layer: layer
      });
    },
    // @method setStyle(style: Path options): this
    // Sets the given path options to each layer of the group that has a `setStyle` method.
    setStyle: function (style) {
      return this.invoke('setStyle', style);
    },
    // @method bringToFront(): this
    // Brings the layer group to the top of all other layers
    bringToFront: function () {
      return this.invoke('bringToFront');
    },
    // @method bringToBack(): this
    // Brings the layer group to the back of all other layers
    bringToBack: function () {
      return this.invoke('bringToBack');
    },
    // @method getBounds(): LatLngBounds
    // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
    getBounds: function () {
      var bounds = new LatLngBounds();
      for (var id in this._layers) {
        var layer = this._layers[id];
        bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
      }
      return bounds;
    }
  });

  // @factory L.featureGroup(layers?: Layer[], options?: Object)
  // Create a feature group, optionally given an initial set of layers and an `options` object.
  var featureGroup = function (layers, options) {
    return new FeatureGroup(layers, options);
  };

  /*
   * @class Icon
   * @aka L.Icon
   *
   * Represents an icon to provide when creating a marker.
   *
   * @example
   *
   * ```js
   * var myIcon = L.icon({
   *     iconUrl: 'my-icon.png',
   *     iconRetinaUrl: 'my-icon@2x.png',
   *     iconSize: [38, 95],
   *     iconAnchor: [22, 94],
   *     popupAnchor: [-3, -76],
   *     shadowUrl: 'my-icon-shadow.png',
   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
   *     shadowSize: [68, 95],
   *     shadowAnchor: [22, 94]
   * });
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
   *
   */

  var Icon = Class.extend({
    /* @section
     * @aka Icon options
     *
     * @option iconUrl: String = null
     * **(required)** The URL to the icon image (absolute or relative to your script path).
     *
     * @option iconRetinaUrl: String = null
     * The URL to a retina sized version of the icon image (absolute or relative to your
     * script path). Used for Retina screen devices.
     *
     * @option iconSize: Point = null
     * Size of the icon image in pixels.
     *
     * @option iconAnchor: Point = null
     * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
     * will be aligned so that this point is at the marker's geographical location. Centered
     * by default if size is specified, also can be set in CSS with negative margins.
     *
     * @option popupAnchor: Point = [0, 0]
     * The coordinates of the point from which popups will "open", relative to the icon anchor.
     *
     * @option tooltipAnchor: Point = [0, 0]
     * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
     *
     * @option shadowUrl: String = null
     * The URL to the icon shadow image. If not specified, no shadow image will be created.
     *
     * @option shadowRetinaUrl: String = null
     *
     * @option shadowSize: Point = null
     * Size of the shadow image in pixels.
     *
     * @option shadowAnchor: Point = null
     * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
     * as iconAnchor if not specified).
     *
     * @option className: String = ''
     * A custom class name to assign to both icon and shadow images. Empty by default.
     */

    options: {
      popupAnchor: [0, 0],
      tooltipAnchor: [0, 0],
      // @option crossOrigin: Boolean|String = false
      // Whether the crossOrigin attribute will be added to the tiles.
      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
      crossOrigin: false
    },
    initialize: function (options) {
      setOptions(this, options);
    },
    // @method createIcon(oldIcon?: HTMLElement): HTMLElement
    // Called internally when the icon has to be shown, returns a `<img>` HTML element
    // styled according to the options.
    createIcon: function (oldIcon) {
      return this._createIcon('icon', oldIcon);
    },
    // @method createShadow(oldIcon?: HTMLElement): HTMLElement
    // As `createIcon`, but for the shadow beneath it.
    createShadow: function (oldIcon) {
      return this._createIcon('shadow', oldIcon);
    },
    _createIcon: function (name, oldIcon) {
      var src = this._getIconUrl(name);
      if (!src) {
        if (name === 'icon') {
          throw new Error('iconUrl not set in Icon options (see the docs).');
        }
        return null;
      }
      var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
      this._setIconStyles(img, name);
      if (this.options.crossOrigin || this.options.crossOrigin === '') {
        img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
      }
      return img;
    },
    _setIconStyles: function (img, name) {
      var options = this.options;
      var sizeOption = options[name + 'Size'];
      if (typeof sizeOption === 'number') {
        sizeOption = [sizeOption, sizeOption];
      }
      var size = toPoint(sizeOption),
        anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
      img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');
      if (anchor) {
        img.style.marginLeft = -anchor.x + 'px';
        img.style.marginTop = -anchor.y + 'px';
      }
      if (size) {
        img.style.width = size.x + 'px';
        img.style.height = size.y + 'px';
      }
    },
    _createImg: function (src, el) {
      el = el || document.createElement('img');
      el.src = src;
      return el;
    },
    _getIconUrl: function (name) {
      return Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
    }
  });

  // @factory L.icon(options: Icon options)
  // Creates an icon instance with the given options.
  function icon(options) {
    return new Icon(options);
  }

  /*
   * @miniclass Icon.Default (Icon)
   * @aka L.Icon.Default
   * @section
   *
   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
   * no icon is specified. Points to the blue marker image distributed with Leaflet
   * releases.
   *
   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
   * (which is a set of `Icon options`).
   *
   * If you want to _completely_ replace the default icon, override the
   * `L.Marker.prototype.options.icon` with your own icon instead.
   */

  var IconDefault = Icon.extend({
    options: {
      iconUrl: 'marker-icon.png',
      iconRetinaUrl: 'marker-icon-2x.png',
      shadowUrl: 'marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      tooltipAnchor: [16, -28],
      shadowSize: [41, 41]
    },
    _getIconUrl: function (name) {
      if (typeof IconDefault.imagePath !== 'string') {
        // Deprecated, backwards-compatibility only
        IconDefault.imagePath = this._detectIconPath();
      }

      // @option imagePath: String
      // `Icon.Default` will try to auto-detect the location of the
      // blue icon images. If you are placing these images in a non-standard
      // way, set this option to point to the right path.
      return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
    },
    _stripUrl: function (path) {
      // separate function to use in tests
      var strip = function (str, re, idx) {
        var match = re.exec(str);
        return match && match[idx];
      };
      path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
      return path && strip(path, /^(.*)marker-icon\.png$/, 1);
    },
    _detectIconPath: function () {
      var el = create$1('div', 'leaflet-default-icon-path', document.body);
      var path = getStyle(el, 'background-image') || getStyle(el, 'backgroundImage'); // IE8

      document.body.removeChild(el);
      path = this._stripUrl(path);
      if (path) {
        return path;
      }
      var link = document.querySelector('link[href$="leaflet.css"]');
      if (!link) {
        return '';
      }
      return link.href.substring(0, link.href.length - 'leaflet.css'.length - 1);
    }
  });

  /*
   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
   */

  /* @namespace Marker
   * @section Interaction handlers
   *
   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
   *
   * ```js
   * marker.dragging.disable();
   * ```
   *
   * @property dragging: Handler
   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
   */

  var MarkerDrag = Handler.extend({
    initialize: function (marker) {
      this._marker = marker;
    },
    addHooks: function () {
      var icon = this._marker._icon;
      if (!this._draggable) {
        this._draggable = new Draggable(icon, icon, true);
      }
      this._draggable.on({
        dragstart: this._onDragStart,
        predrag: this._onPreDrag,
        drag: this._onDrag,
        dragend: this._onDragEnd
      }, this).enable();
      addClass(icon, 'leaflet-marker-draggable');
    },
    removeHooks: function () {
      this._draggable.off({
        dragstart: this._onDragStart,
        predrag: this._onPreDrag,
        drag: this._onDrag,
        dragend: this._onDragEnd
      }, this).disable();
      if (this._marker._icon) {
        removeClass(this._marker._icon, 'leaflet-marker-draggable');
      }
    },
    moved: function () {
      return this._draggable && this._draggable._moved;
    },
    _adjustPan: function (e) {
      var marker = this._marker,
        map = marker._map,
        speed = this._marker.options.autoPanSpeed,
        padding = this._marker.options.autoPanPadding,
        iconPos = getPosition(marker._icon),
        bounds = map.getPixelBounds(),
        origin = map.getPixelOrigin();
      var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));
      if (!panBounds.contains(iconPos)) {
        // Compute incremental movement
        var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);
        map.panBy(movement, {
          animate: false
        });
        this._draggable._newPos._add(movement);
        this._draggable._startPos._add(movement);
        setPosition(marker._icon, this._draggable._newPos);
        this._onDrag(e);
        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
      }
    },
    _onDragStart: function () {
      // @section Dragging events
      // @event dragstart: Event
      // Fired when the user starts dragging the marker.

      // @event movestart: Event
      // Fired when the marker starts moving (because of dragging).

      this._oldLatLng = this._marker.getLatLng();

      // When using ES6 imports it could not be set when `Popup` was not imported as well
      this._marker.closePopup && this._marker.closePopup();
      this._marker.fire('movestart').fire('dragstart');
    },
    _onPreDrag: function (e) {
      if (this._marker.options.autoPan) {
        cancelAnimFrame(this._panRequest);
        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
      }
    },
    _onDrag: function (e) {
      var marker = this._marker,
        shadow = marker._shadow,
        iconPos = getPosition(marker._icon),
        latlng = marker._map.layerPointToLatLng(iconPos);

      // update shadow position
      if (shadow) {
        setPosition(shadow, iconPos);
      }
      marker._latlng = latlng;
      e.latlng = latlng;
      e.oldLatLng = this._oldLatLng;

      // @event drag: Event
      // Fired repeatedly while the user drags the marker.
      marker.fire('move', e).fire('drag', e);
    },
    _onDragEnd: function (e) {
      // @event dragend: DragEndEvent
      // Fired when the user stops dragging the marker.

      cancelAnimFrame(this._panRequest);

      // @event moveend: Event
      // Fired when the marker stops moving (because of dragging).
      delete this._oldLatLng;
      this._marker.fire('moveend').fire('dragend', e);
    }
  });

  /*
   * @class Marker
   * @inherits Interactive layer
   * @aka L.Marker
   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.marker([50.5, 30.5]).addTo(map);
   * ```
   */

  var Marker = Layer.extend({
    // @section
    // @aka Marker options
    options: {
      // @option icon: Icon = *
      // Icon instance to use for rendering the marker.
      // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
      // If not specified, a common instance of `L.Icon.Default` is used.
      icon: new IconDefault(),
      // Option inherited from "Interactive layer" abstract class
      interactive: true,
      // @option keyboard: Boolean = true
      // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
      keyboard: true,
      // @option title: String = ''
      // Text for the browser tooltip that appear on marker hover (no tooltip by default).
      // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
      title: '',
      // @option alt: String = 'Marker'
      // Text for the `alt` attribute of the icon image.
      // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
      alt: 'Marker',
      // @option zIndexOffset: Number = 0
      // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
      zIndexOffset: 0,
      // @option opacity: Number = 1.0
      // The opacity of the marker.
      opacity: 1,
      // @option riseOnHover: Boolean = false
      // If `true`, the marker will get on top of others when you hover the mouse over it.
      riseOnHover: false,
      // @option riseOffset: Number = 250
      // The z-index offset used for the `riseOnHover` feature.
      riseOffset: 250,
      // @option pane: String = 'markerPane'
      // `Map pane` where the markers icon will be added.
      pane: 'markerPane',
      // @option shadowPane: String = 'shadowPane'
      // `Map pane` where the markers shadow will be added.
      shadowPane: 'shadowPane',
      // @option bubblingMouseEvents: Boolean = false
      // When `true`, a mouse event on this marker will trigger the same event on the map
      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
      bubblingMouseEvents: false,
      // @option autoPanOnFocus: Boolean = true
      // When `true`, the map will pan whenever the marker is focused (via
      // e.g. pressing `tab` on the keyboard) to ensure the marker is
      // visible within the map's bounds
      autoPanOnFocus: true,
      // @section Draggable marker options
      // @option draggable: Boolean = false
      // Whether the marker is draggable with mouse/touch or not.
      draggable: false,
      // @option autoPan: Boolean = false
      // Whether to pan the map when dragging this marker near its edge or not.
      autoPan: false,
      // @option autoPanPadding: Point = Point(50, 50)
      // Distance (in pixels to the left/right and to the top/bottom) of the
      // map edge to start panning the map.
      autoPanPadding: [50, 50],
      // @option autoPanSpeed: Number = 10
      // Number of pixels the map should pan by.
      autoPanSpeed: 10
    },
    /* @section
     *
     * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
     */

    initialize: function (latlng, options) {
      setOptions(this, options);
      this._latlng = toLatLng(latlng);
    },
    onAdd: function (map) {
      this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;
      if (this._zoomAnimated) {
        map.on('zoomanim', this._animateZoom, this);
      }
      this._initIcon();
      this.update();
    },
    onRemove: function (map) {
      if (this.dragging && this.dragging.enabled()) {
        this.options.draggable = true;
        this.dragging.removeHooks();
      }
      delete this.dragging;
      if (this._zoomAnimated) {
        map.off('zoomanim', this._animateZoom, this);
      }
      this._removeIcon();
      this._removeShadow();
    },
    getEvents: function () {
      return {
        zoom: this.update,
        viewreset: this.update
      };
    },
    // @method getLatLng: LatLng
    // Returns the current geographical position of the marker.
    getLatLng: function () {
      return this._latlng;
    },
    // @method setLatLng(latlng: LatLng): this
    // Changes the marker position to the given point.
    setLatLng: function (latlng) {
      var oldLatLng = this._latlng;
      this._latlng = toLatLng(latlng);
      this.update();

      // @event move: Event
      // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
      return this.fire('move', {
        oldLatLng: oldLatLng,
        latlng: this._latlng
      });
    },
    // @method setZIndexOffset(offset: Number): this
    // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
    setZIndexOffset: function (offset) {
      this.options.zIndexOffset = offset;
      return this.update();
    },
    // @method getIcon: Icon
    // Returns the current icon used by the marker
    getIcon: function () {
      return this.options.icon;
    },
    // @method setIcon(icon: Icon): this
    // Changes the marker icon.
    setIcon: function (icon) {
      this.options.icon = icon;
      if (this._map) {
        this._initIcon();
        this.update();
      }
      if (this._popup) {
        this.bindPopup(this._popup, this._popup.options);
      }
      return this;
    },
    getElement: function () {
      return this._icon;
    },
    update: function () {
      if (this._icon && this._map) {
        var pos = this._map.latLngToLayerPoint(this._latlng).round();
        this._setPos(pos);
      }
      return this;
    },
    _initIcon: function () {
      var options = this.options,
        classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');
      var icon = options.icon.createIcon(this._icon),
        addIcon = false;

      // if we're not reusing the icon, remove the old one and init new one
      if (icon !== this._icon) {
        if (this._icon) {
          this._removeIcon();
        }
        addIcon = true;
        if (options.title) {
          icon.title = options.title;
        }
        if (icon.tagName === 'IMG') {
          icon.alt = options.alt || '';
        }
      }
      addClass(icon, classToAdd);
      if (options.keyboard) {
        icon.tabIndex = '0';
        icon.setAttribute('role', 'button');
      }
      this._icon = icon;
      if (options.riseOnHover) {
        this.on({
          mouseover: this._bringToFront,
          mouseout: this._resetZIndex
        });
      }
      if (this.options.autoPanOnFocus) {
        on(icon, 'focus', this._panOnFocus, this);
      }
      var newShadow = options.icon.createShadow(this._shadow),
        addShadow = false;
      if (newShadow !== this._shadow) {
        this._removeShadow();
        addShadow = true;
      }
      if (newShadow) {
        addClass(newShadow, classToAdd);
        newShadow.alt = '';
      }
      this._shadow = newShadow;
      if (options.opacity < 1) {
        this._updateOpacity();
      }
      if (addIcon) {
        this.getPane().appendChild(this._icon);
      }
      this._initInteraction();
      if (newShadow && addShadow) {
        this.getPane(options.shadowPane).appendChild(this._shadow);
      }
    },
    _removeIcon: function () {
      if (this.options.riseOnHover) {
        this.off({
          mouseover: this._bringToFront,
          mouseout: this._resetZIndex
        });
      }
      if (this.options.autoPanOnFocus) {
        off(this._icon, 'focus', this._panOnFocus, this);
      }
      remove(this._icon);
      this.removeInteractiveTarget(this._icon);
      this._icon = null;
    },
    _removeShadow: function () {
      if (this._shadow) {
        remove(this._shadow);
      }
      this._shadow = null;
    },
    _setPos: function (pos) {
      if (this._icon) {
        setPosition(this._icon, pos);
      }
      if (this._shadow) {
        setPosition(this._shadow, pos);
      }
      this._zIndex = pos.y + this.options.zIndexOffset;
      this._resetZIndex();
    },
    _updateZIndex: function (offset) {
      if (this._icon) {
        this._icon.style.zIndex = this._zIndex + offset;
      }
    },
    _animateZoom: function (opt) {
      var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
      this._setPos(pos);
    },
    _initInteraction: function () {
      if (!this.options.interactive) {
        return;
      }
      addClass(this._icon, 'leaflet-interactive');
      this.addInteractiveTarget(this._icon);
      if (MarkerDrag) {
        var draggable = this.options.draggable;
        if (this.dragging) {
          draggable = this.dragging.enabled();
          this.dragging.disable();
        }
        this.dragging = new MarkerDrag(this);
        if (draggable) {
          this.dragging.enable();
        }
      }
    },
    // @method setOpacity(opacity: Number): this
    // Changes the opacity of the marker.
    setOpacity: function (opacity) {
      this.options.opacity = opacity;
      if (this._map) {
        this._updateOpacity();
      }
      return this;
    },
    _updateOpacity: function () {
      var opacity = this.options.opacity;
      if (this._icon) {
        setOpacity(this._icon, opacity);
      }
      if (this._shadow) {
        setOpacity(this._shadow, opacity);
      }
    },
    _bringToFront: function () {
      this._updateZIndex(this.options.riseOffset);
    },
    _resetZIndex: function () {
      this._updateZIndex(0);
    },
    _panOnFocus: function () {
      var map = this._map;
      if (!map) {
        return;
      }
      var iconOpts = this.options.icon.options;
      var size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0);
      var anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
      map.panInside(this._latlng, {
        paddingTopLeft: anchor,
        paddingBottomRight: size.subtract(anchor)
      });
    },
    _getPopupAnchor: function () {
      return this.options.icon.options.popupAnchor;
    },
    _getTooltipAnchor: function () {
      return this.options.icon.options.tooltipAnchor;
    }
  });

  // factory L.marker(latlng: LatLng, options? : Marker options)

  // @factory L.marker(latlng: LatLng, options? : Marker options)
  // Instantiates a Marker object given a geographical point and optionally an options object.
  function marker(latlng, options) {
    return new Marker(latlng, options);
  }

  /*
   * @class Path
   * @aka L.Path
   * @inherits Interactive layer
   *
   * An abstract class that contains options and constants shared between vector
   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
   */

  var Path = Layer.extend({
    // @section
    // @aka Path options
    options: {
      // @option stroke: Boolean = true
      // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
      stroke: true,
      // @option color: String = '#3388ff'
      // Stroke color
      color: '#3388ff',
      // @option weight: Number = 3
      // Stroke width in pixels
      weight: 3,
      // @option opacity: Number = 1.0
      // Stroke opacity
      opacity: 1,
      // @option lineCap: String= 'round'
      // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
      lineCap: 'round',
      // @option lineJoin: String = 'round'
      // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
      lineJoin: 'round',
      // @option dashArray: String = null
      // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
      dashArray: null,
      // @option dashOffset: String = null
      // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
      dashOffset: null,
      // @option fill: Boolean = depends
      // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
      fill: false,
      // @option fillColor: String = *
      // Fill color. Defaults to the value of the [`color`](#path-color) option
      fillColor: null,
      // @option fillOpacity: Number = 0.2
      // Fill opacity.
      fillOpacity: 0.2,
      // @option fillRule: String = 'evenodd'
      // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
      fillRule: 'evenodd',
      // className: '',

      // Option inherited from "Interactive layer" abstract class
      interactive: true,
      // @option bubblingMouseEvents: Boolean = true
      // When `true`, a mouse event on this path will trigger the same event on the map
      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
      bubblingMouseEvents: true
    },
    beforeAdd: function (map) {
      // Renderer is set here because we need to call renderer.getEvents
      // before this.getEvents.
      this._renderer = map.getRenderer(this);
    },
    onAdd: function () {
      this._renderer._initPath(this);
      this._reset();
      this._renderer._addPath(this);
    },
    onRemove: function () {
      this._renderer._removePath(this);
    },
    // @method redraw(): this
    // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
    redraw: function () {
      if (this._map) {
        this._renderer._updatePath(this);
      }
      return this;
    },
    // @method setStyle(style: Path options): this
    // Changes the appearance of a Path based on the options in the `Path options` object.
    setStyle: function (style) {
      setOptions(this, style);
      if (this._renderer) {
        this._renderer._updateStyle(this);
        if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, 'weight')) {
          this._updateBounds();
        }
      }
      return this;
    },
    // @method bringToFront(): this
    // Brings the layer to the top of all path layers.
    bringToFront: function () {
      if (this._renderer) {
        this._renderer._bringToFront(this);
      }
      return this;
    },
    // @method bringToBack(): this
    // Brings the layer to the bottom of all path layers.
    bringToBack: function () {
      if (this._renderer) {
        this._renderer._bringToBack(this);
      }
      return this;
    },
    getElement: function () {
      return this._path;
    },
    _reset: function () {
      // defined in child classes
      this._project();
      this._update();
    },
    _clickTolerance: function () {
      // used when doing hit detection for Canvas layers
      return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
    }
  });

  /*
   * @class CircleMarker
   * @aka L.CircleMarker
   * @inherits Path
   *
   * A circle of a fixed size with radius specified in pixels. Extends `Path`.
   */

  var CircleMarker = Path.extend({
    // @section
    // @aka CircleMarker options
    options: {
      fill: true,
      // @option radius: Number = 10
      // Radius of the circle marker, in pixels
      radius: 10
    },
    initialize: function (latlng, options) {
      setOptions(this, options);
      this._latlng = toLatLng(latlng);
      this._radius = this.options.radius;
    },
    // @method setLatLng(latLng: LatLng): this
    // Sets the position of a circle marker to a new location.
    setLatLng: function (latlng) {
      var oldLatLng = this._latlng;
      this._latlng = toLatLng(latlng);
      this.redraw();

      // @event move: Event
      // Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
      return this.fire('move', {
        oldLatLng: oldLatLng,
        latlng: this._latlng
      });
    },
    // @method getLatLng(): LatLng
    // Returns the current geographical position of the circle marker
    getLatLng: function () {
      return this._latlng;
    },
    // @method setRadius(radius: Number): this
    // Sets the radius of a circle marker. Units are in pixels.
    setRadius: function (radius) {
      this.options.radius = this._radius = radius;
      return this.redraw();
    },
    // @method getRadius(): Number
    // Returns the current radius of the circle
    getRadius: function () {
      return this._radius;
    },
    setStyle: function (options) {
      var radius = options && options.radius || this._radius;
      Path.prototype.setStyle.call(this, options);
      this.setRadius(radius);
      return this;
    },
    _project: function () {
      this._point = this._map.latLngToLayerPoint(this._latlng);
      this._updateBounds();
    },
    _updateBounds: function () {
      var r = this._radius,
        r2 = this._radiusY || r,
        w = this._clickTolerance(),
        p = [r + w, r2 + w];
      this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
    },
    _update: function () {
      if (this._map) {
        this._updatePath();
      }
    },
    _updatePath: function () {
      this._renderer._updateCircle(this);
    },
    _empty: function () {
      return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
    },
    // Needed by the `Canvas` renderer for interactivity
    _containsPoint: function (p) {
      return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
    }
  });

  // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
  // Instantiates a circle marker object given a geographical point, and an optional options object.
  function circleMarker(latlng, options) {
    return new CircleMarker(latlng, options);
  }

  /*
   * @class Circle
   * @aka L.Circle
   * @inherits CircleMarker
   *
   * A class for drawing circle overlays on a map. Extends `CircleMarker`.
   *
   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
   *
   * @example
   *
   * ```js
   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
   * ```
   */

  var Circle = CircleMarker.extend({
    initialize: function (latlng, options, legacyOptions) {
      if (typeof options === 'number') {
        // Backwards compatibility with 0.7.x factory (latlng, radius, options?)
        options = extend({}, legacyOptions, {
          radius: options
        });
      }
      setOptions(this, options);
      this._latlng = toLatLng(latlng);
      if (isNaN(this.options.radius)) {
        throw new Error('Circle radius cannot be NaN');
      }

      // @section
      // @aka Circle options
      // @option radius: Number; Radius of the circle, in meters.
      this._mRadius = this.options.radius;
    },
    // @method setRadius(radius: Number): this
    // Sets the radius of a circle. Units are in meters.
    setRadius: function (radius) {
      this._mRadius = radius;
      return this.redraw();
    },
    // @method getRadius(): Number
    // Returns the current radius of a circle. Units are in meters.
    getRadius: function () {
      return this._mRadius;
    },
    // @method getBounds(): LatLngBounds
    // Returns the `LatLngBounds` of the path.
    getBounds: function () {
      var half = [this._radius, this._radiusY || this._radius];
      return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));
    },
    setStyle: Path.prototype.setStyle,
    _project: function () {
      var lng = this._latlng.lng,
        lat = this._latlng.lat,
        map = this._map,
        crs = map.options.crs;
      if (crs.distance === Earth.distance) {
        var d = Math.PI / 180,
          latR = this._mRadius / Earth.R / d,
          top = map.project([lat + latR, lng]),
          bottom = map.project([lat - latR, lng]),
          p = top.add(bottom).divideBy(2),
          lat2 = map.unproject(p).lat,
          lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;
        if (isNaN(lngR) || lngR === 0) {
          lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
        }

        this._point = p.subtract(map.getPixelOrigin());
        this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
        this._radiusY = p.y - top.y;
      } else {
        var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
        this._point = map.latLngToLayerPoint(this._latlng);
        this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
      }
      this._updateBounds();
    }
  });

  // @factory L.circle(latlng: LatLng, options?: Circle options)
  // Instantiates a circle object given a geographical point, and an options object
  // which contains the circle radius.
  // @alternative
  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
  // Do not use in new applications or plugins.
  function circle(latlng, options, legacyOptions) {
    return new Circle(latlng, options, legacyOptions);
  }

  /*
   * @class Polyline
   * @aka L.Polyline
   * @inherits Path
   *
   * A class for drawing polyline overlays on a map. Extends `Path`.
   *
   * @example
   *
   * ```js
   * // create a red polyline from an array of LatLng points
   * var latlngs = [
   * 	[45.51, -122.68],
   * 	[37.77, -122.43],
   * 	[34.04, -118.2]
   * ];
   *
   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polyline
   * map.fitBounds(polyline.getBounds());
   * ```
   *
   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
   *
   * ```js
   * // create a red polyline from an array of arrays of LatLng points
   * var latlngs = [
   * 	[[45.51, -122.68],
   * 	 [37.77, -122.43],
   * 	 [34.04, -118.2]],
   * 	[[40.78, -73.91],
   * 	 [41.83, -87.62],
   * 	 [32.76, -96.72]]
   * ];
   * ```
   */

  var Polyline = Path.extend({
    // @section
    // @aka Polyline options
    options: {
      // @option smoothFactor: Number = 1.0
      // How much to simplify the polyline on each zoom level. More means
      // better performance and smoother look, and less means more accurate representation.
      smoothFactor: 1.0,
      // @option noClip: Boolean = false
      // Disable polyline clipping.
      noClip: false
    },
    initialize: function (latlngs, options) {
      setOptions(this, options);
      this._setLatLngs(latlngs);
    },
    // @method getLatLngs(): LatLng[]
    // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
    getLatLngs: function () {
      return this._latlngs;
    },
    // @method setLatLngs(latlngs: LatLng[]): this
    // Replaces all the points in the polyline with the given array of geographical points.
    setLatLngs: function (latlngs) {
      this._setLatLngs(latlngs);
      return this.redraw();
    },
    // @method isEmpty(): Boolean
    // Returns `true` if the Polyline has no LatLngs.
    isEmpty: function () {
      return !this._latlngs.length;
    },
    // @method closestLayerPoint(p: Point): Point
    // Returns the point closest to `p` on the Polyline.
    closestLayerPoint: function (p) {
      var minDistance = Infinity,
        minPoint = null,
        closest = _sqClosestPointOnSegment,
        p1,
        p2;
      for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
        var points = this._parts[j];
        for (var i = 1, len = points.length; i < len; i++) {
          p1 = points[i - 1];
          p2 = points[i];
          var sqDist = closest(p, p1, p2, true);
          if (sqDist < minDistance) {
            minDistance = sqDist;
            minPoint = closest(p, p1, p2);
          }
        }
      }
      if (minPoint) {
        minPoint.distance = Math.sqrt(minDistance);
      }
      return minPoint;
    },
    // @method getCenter(): LatLng
    // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
    getCenter: function () {
      // throws error when not yet added to map as this center calculation requires projected coordinates
      if (!this._map) {
        throw new Error('Must add layer to map before using getCenter()');
      }
      return polylineCenter(this._defaultShape(), this._map.options.crs);
    },
    // @method getBounds(): LatLngBounds
    // Returns the `LatLngBounds` of the path.
    getBounds: function () {
      return this._bounds;
    },
    // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
    // Adds a given point to the polyline. By default, adds to the first ring of
    // the polyline in case of a multi-polyline, but can be overridden by passing
    // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
    addLatLng: function (latlng, latlngs) {
      latlngs = latlngs || this._defaultShape();
      latlng = toLatLng(latlng);
      latlngs.push(latlng);
      this._bounds.extend(latlng);
      return this.redraw();
    },
    _setLatLngs: function (latlngs) {
      this._bounds = new LatLngBounds();
      this._latlngs = this._convertLatLngs(latlngs);
    },
    _defaultShape: function () {
      return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
    },
    // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
    _convertLatLngs: function (latlngs) {
      var result = [],
        flat = isFlat(latlngs);
      for (var i = 0, len = latlngs.length; i < len; i++) {
        if (flat) {
          result[i] = toLatLng(latlngs[i]);
          this._bounds.extend(result[i]);
        } else {
          result[i] = this._convertLatLngs(latlngs[i]);
        }
      }
      return result;
    },
    _project: function () {
      var pxBounds = new Bounds();
      this._rings = [];
      this._projectLatlngs(this._latlngs, this._rings, pxBounds);
      if (this._bounds.isValid() && pxBounds.isValid()) {
        this._rawPxBounds = pxBounds;
        this._updateBounds();
      }
    },
    _updateBounds: function () {
      var w = this._clickTolerance(),
        p = new Point(w, w);
      if (!this._rawPxBounds) {
        return;
      }
      this._pxBounds = new Bounds([this._rawPxBounds.min.subtract(p), this._rawPxBounds.max.add(p)]);
    },
    // recursively turns latlngs into a set of rings with projected coordinates
    _projectLatlngs: function (latlngs, result, projectedBounds) {
      var flat = latlngs[0] instanceof LatLng,
        len = latlngs.length,
        i,
        ring;
      if (flat) {
        ring = [];
        for (i = 0; i < len; i++) {
          ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
          projectedBounds.extend(ring[i]);
        }
        result.push(ring);
      } else {
        for (i = 0; i < len; i++) {
          this._projectLatlngs(latlngs[i], result, projectedBounds);
        }
      }
    },
    // clip polyline by renderer bounds so that we have less to render for performance
    _clipPoints: function () {
      var bounds = this._renderer._bounds;
      this._parts = [];
      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
        return;
      }
      if (this.options.noClip) {
        this._parts = this._rings;
        return;
      }
      var parts = this._parts,
        i,
        j,
        k,
        len,
        len2,
        segment,
        points;
      for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
        points = this._rings[i];
        for (j = 0, len2 = points.length; j < len2 - 1; j++) {
          segment = clipSegment(points[j], points[j + 1], bounds, j, true);
          if (!segment) {
            continue;
          }
          parts[k] = parts[k] || [];
          parts[k].push(segment[0]);

          // if segment goes out of screen, or it's the last one, it's the end of the line part
          if (segment[1] !== points[j + 1] || j === len2 - 2) {
            parts[k].push(segment[1]);
            k++;
          }
        }
      }
    },
    // simplify each clipped part of the polyline for performance
    _simplifyPoints: function () {
      var parts = this._parts,
        tolerance = this.options.smoothFactor;
      for (var i = 0, len = parts.length; i < len; i++) {
        parts[i] = simplify(parts[i], tolerance);
      }
    },
    _update: function () {
      if (!this._map) {
        return;
      }
      this._clipPoints();
      this._simplifyPoints();
      this._updatePath();
    },
    _updatePath: function () {
      this._renderer._updatePoly(this);
    },
    // Needed by the `Canvas` renderer for interactivity
    _containsPoint: function (p, closed) {
      var i,
        j,
        k,
        len,
        len2,
        part,
        w = this._clickTolerance();
      if (!this._pxBounds || !this._pxBounds.contains(p)) {
        return false;
      }

      // hit detection for polylines
      for (i = 0, len = this._parts.length; i < len; i++) {
        part = this._parts[i];
        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
          if (!closed && j === 0) {
            continue;
          }
          if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
            return true;
          }
        }
      }
      return false;
    }
  });

  // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
  // Instantiates a polyline object given an array of geographical points and
  // optionally an options object. You can create a `Polyline` object with
  // multiple separate lines (`MultiPolyline`) by passing an array of arrays
  // of geographic points.
  function polyline(latlngs, options) {
    return new Polyline(latlngs, options);
  }

  // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.
  Polyline._flat = _flat;

  /*
   * @class Polygon
   * @aka L.Polygon
   * @inherits Polyline
   *
   * A class for drawing polygon overlays on a map. Extends `Polyline`.
   *
   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
   *
   *
   * @example
   *
   * ```js
   * // create a red polygon from an array of LatLng points
   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
   *
   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polygon
   * map.fitBounds(polygon.getBounds());
   * ```
   *
   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
   *
   * ```js
   * var latlngs = [
   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   * ];
   * ```
   *
   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
   *
   * ```js
   * var latlngs = [
   *   [ // first polygon
   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   *   ],
   *   [ // second polygon
   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
   *   ]
   * ];
   * ```
   */

  var Polygon = Polyline.extend({
    options: {
      fill: true
    },
    isEmpty: function () {
      return !this._latlngs.length || !this._latlngs[0].length;
    },
    // @method getCenter(): LatLng
    // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
    getCenter: function () {
      // throws error when not yet added to map as this center calculation requires projected coordinates
      if (!this._map) {
        throw new Error('Must add layer to map before using getCenter()');
      }
      return polygonCenter(this._defaultShape(), this._map.options.crs);
    },
    _convertLatLngs: function (latlngs) {
      var result = Polyline.prototype._convertLatLngs.call(this, latlngs),
        len = result.length;

      // remove last point if it equals first one
      if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
        result.pop();
      }
      return result;
    },
    _setLatLngs: function (latlngs) {
      Polyline.prototype._setLatLngs.call(this, latlngs);
      if (isFlat(this._latlngs)) {
        this._latlngs = [this._latlngs];
      }
    },
    _defaultShape: function () {
      return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
    },
    _clipPoints: function () {
      // polygons need a different clipping algorithm so we redefine that

      var bounds = this._renderer._bounds,
        w = this.options.weight,
        p = new Point(w, w);

      // increase clip padding by stroke width to avoid stroke on clip edges
      bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));
      this._parts = [];
      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
        return;
      }
      if (this.options.noClip) {
        this._parts = this._rings;
        return;
      }
      for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
        clipped = clipPolygon(this._rings[i], bounds, true);
        if (clipped.length) {
          this._parts.push(clipped);
        }
      }
    },
    _updatePath: function () {
      this._renderer._updatePoly(this, true);
    },
    // Needed by the `Canvas` renderer for interactivity
    _containsPoint: function (p) {
      var inside = false,
        part,
        p1,
        p2,
        i,
        j,
        k,
        len,
        len2;
      if (!this._pxBounds || !this._pxBounds.contains(p)) {
        return false;
      }

      // ray casting algorithm for detecting if point is in polygon
      for (i = 0, len = this._parts.length; i < len; i++) {
        part = this._parts[i];
        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
          p1 = part[j];
          p2 = part[k];
          if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
            inside = !inside;
          }
        }
      }

      // also check if it's on polygon stroke
      return inside || Polyline.prototype._containsPoint.call(this, p, true);
    }
  });

  // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
  function polygon(latlngs, options) {
    return new Polygon(latlngs, options);
  }

  /*
   * @class GeoJSON
   * @aka L.GeoJSON
   * @inherits FeatureGroup
   *
   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
   * GeoJSON data and display it on the map. Extends `FeatureGroup`.
   *
   * @example
   *
   * ```js
   * L.geoJSON(data, {
   * 	style: function (feature) {
   * 		return {color: feature.properties.color};
   * 	}
   * }).bindPopup(function (layer) {
   * 	return layer.feature.properties.description;
   * }).addTo(map);
   * ```
   */

  var GeoJSON = FeatureGroup.extend({
    /* @section
     * @aka GeoJSON options
     *
     * @option pointToLayer: Function = *
     * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
     * called when data is added, passing the GeoJSON point feature and its `LatLng`.
     * The default is to spawn a default `Marker`:
     * ```js
     * function(geoJsonPoint, latlng) {
     * 	return L.marker(latlng);
     * }
     * ```
     *
     * @option style: Function = *
     * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
     * called internally when data is added.
     * The default value is to not override any defaults:
     * ```js
     * function (geoJsonFeature) {
     * 	return {}
     * }
     * ```
     *
     * @option onEachFeature: Function = *
     * A `Function` that will be called once for each created `Feature`, after it has
     * been created and styled. Useful for attaching events and popups to features.
     * The default is to do nothing with the newly created layers:
     * ```js
     * function (feature, layer) {}
     * ```
     *
     * @option filter: Function = *
     * A `Function` that will be used to decide whether to include a feature or not.
     * The default is to include all features:
     * ```js
     * function (geoJsonFeature) {
     * 	return true;
     * }
     * ```
     * Note: dynamically changing the `filter` option will have effect only on newly
     * added data. It will _not_ re-evaluate already included features.
     *
     * @option coordsToLatLng: Function = *
     * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
     * The default is the `coordsToLatLng` static method.
     *
     * @option markersInheritOptions: Boolean = false
     * Whether default Markers for "Point" type Features inherit from group options.
     */

    initialize: function (geojson, options) {
      setOptions(this, options);
      this._layers = {};
      if (geojson) {
        this.addData(geojson);
      }
    },
    // @method addData( <GeoJSON> data ): this
    // Adds a GeoJSON object to the layer.
    addData: function (geojson) {
      var features = isArray(geojson) ? geojson : geojson.features,
        i,
        len,
        feature;
      if (features) {
        for (i = 0, len = features.length; i < len; i++) {
          // only add this if geometry or geometries are set and not null
          feature = features[i];
          if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
            this.addData(feature);
          }
        }
        return this;
      }
      var options = this.options;
      if (options.filter && !options.filter(geojson)) {
        return this;
      }
      var layer = geometryToLayer(geojson, options);
      if (!layer) {
        return this;
      }
      layer.feature = asFeature(geojson);
      layer.defaultOptions = layer.options;
      this.resetStyle(layer);
      if (options.onEachFeature) {
        options.onEachFeature(geojson, layer);
      }
      return this.addLayer(layer);
    },
    // @method resetStyle( <Path> layer? ): this
    // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
    // If `layer` is omitted, the style of all features in the current layer is reset.
    resetStyle: function (layer) {
      if (layer === undefined) {
        return this.eachLayer(this.resetStyle, this);
      }
      // reset any custom styles
      layer.options = extend({}, layer.defaultOptions);
      this._setLayerStyle(layer, this.options.style);
      return this;
    },
    // @method setStyle( <Function> style ): this
    // Changes styles of GeoJSON vector layers with the given style function.
    setStyle: function (style) {
      return this.eachLayer(function (layer) {
        this._setLayerStyle(layer, style);
      }, this);
    },
    _setLayerStyle: function (layer, style) {
      if (layer.setStyle) {
        if (typeof style === 'function') {
          style = style(layer.feature);
        }
        layer.setStyle(style);
      }
    }
  });

  // @section
  // There are several static functions which can be called without instantiating L.GeoJSON:

  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
  // Creates a `Layer` from a given GeoJSON feature. Can use a custom
  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
  // functions if provided as options.
  function geometryToLayer(geojson, options) {
    var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
      coords = geometry ? geometry.coordinates : null,
      layers = [],
      pointToLayer = options && options.pointToLayer,
      _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
      latlng,
      latlngs,
      i,
      len;
    if (!coords && !geometry) {
      return null;
    }
    switch (geometry.type) {
      case 'Point':
        latlng = _coordsToLatLng(coords);
        return _pointToLayer(pointToLayer, geojson, latlng, options);
      case 'MultiPoint':
        for (i = 0, len = coords.length; i < len; i++) {
          latlng = _coordsToLatLng(coords[i]);
          layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));
        }
        return new FeatureGroup(layers);
      case 'LineString':
      case 'MultiLineString':
        latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
        return new Polyline(latlngs, options);
      case 'Polygon':
      case 'MultiPolygon':
        latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
        return new Polygon(latlngs, options);
      case 'GeometryCollection':
        for (i = 0, len = geometry.geometries.length; i < len; i++) {
          var geoLayer = geometryToLayer({
            geometry: geometry.geometries[i],
            type: 'Feature',
            properties: geojson.properties
          }, options);
          if (geoLayer) {
            layers.push(geoLayer);
          }
        }
        return new FeatureGroup(layers);
      case 'FeatureCollection':
        for (i = 0, len = geometry.features.length; i < len; i++) {
          var featureLayer = geometryToLayer(geometry.features[i], options);
          if (featureLayer) {
            layers.push(featureLayer);
          }
        }
        return new FeatureGroup(layers);
      default:
        throw new Error('Invalid GeoJSON object.');
    }
  }
  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
    return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
  }

  // @function coordsToLatLng(coords: Array): LatLng
  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
  function coordsToLatLng(coords) {
    return new LatLng(coords[1], coords[0], coords[2]);
  }

  // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
    var latlngs = [];
    for (var i = 0, len = coords.length, latlng; i < len; i++) {
      latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
      latlngs.push(latlng);
    }
    return latlngs;
  }

  // @function latLngToCoords(latlng: LatLng, precision?: Number|false): Array
  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.
  function latLngToCoords(latlng, precision) {
    latlng = toLatLng(latlng);
    return latlng.alt !== undefined ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
  }

  // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean, precision?: Number|false): Array
  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function.
  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
    var coords = [];
    for (var i = 0, len = latlngs.length; i < len; i++) {
      // Check for flat arrays required to ensure unbalanced arrays are correctly converted in recursion
      coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
    }
    if (!levelsDeep && closed && coords.length > 0) {
      coords.push(coords[0].slice());
    }
    return coords;
  }
  function getFeature(layer, newGeometry) {
    return layer.feature ? extend({}, layer.feature, {
      geometry: newGeometry
    }) : asFeature(newGeometry);
  }

  // @function asFeature(geojson: Object): Object
  // Normalize GeoJSON geometries/features into GeoJSON features.
  function asFeature(geojson) {
    if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
      return geojson;
    }
    return {
      type: 'Feature',
      properties: {},
      geometry: geojson
    };
  }
  var PointToGeoJSON = {
    toGeoJSON: function (precision) {
      return getFeature(this, {
        type: 'Point',
        coordinates: latLngToCoords(this.getLatLng(), precision)
      });
    }
  };

  // @namespace Marker
  // @section Other methods
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
  Marker.include(PointToGeoJSON);

  // @namespace CircleMarker
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
  Circle.include(PointToGeoJSON);
  CircleMarker.include(PointToGeoJSON);

  // @namespace Polyline
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
  Polyline.include({
    toGeoJSON: function (precision) {
      var multi = !isFlat(this._latlngs);
      var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
      return getFeature(this, {
        type: (multi ? 'Multi' : '') + 'LineString',
        coordinates: coords
      });
    }
  });

  // @namespace Polygon
  // @method toGeoJSON(precision?: Number|false): Object
  // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
  // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
  Polygon.include({
    toGeoJSON: function (precision) {
      var holes = !isFlat(this._latlngs),
        multi = holes && !isFlat(this._latlngs[0]);
      var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
      if (!holes) {
        coords = [coords];
      }
      return getFeature(this, {
        type: (multi ? 'Multi' : '') + 'Polygon',
        coordinates: coords
      });
    }
  });

  // @namespace LayerGroup
  LayerGroup.include({
    toMultiPoint: function (precision) {
      var coords = [];
      this.eachLayer(function (layer) {
        coords.push(layer.toGeoJSON(precision).geometry.coordinates);
      });
      return getFeature(this, {
        type: 'MultiPoint',
        coordinates: coords
      });
    },
    // @method toGeoJSON(precision?: Number|false): Object
    // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
    // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
    toGeoJSON: function (precision) {
      var type = this.feature && this.feature.geometry && this.feature.geometry.type;
      if (type === 'MultiPoint') {
        return this.toMultiPoint(precision);
      }
      var isGeometryCollection = type === 'GeometryCollection',
        jsons = [];
      this.eachLayer(function (layer) {
        if (layer.toGeoJSON) {
          var json = layer.toGeoJSON(precision);
          if (isGeometryCollection) {
            jsons.push(json.geometry);
          } else {
            var feature = asFeature(json);
            // Squash nested feature collections
            if (feature.type === 'FeatureCollection') {
              jsons.push.apply(jsons, feature.features);
            } else {
              jsons.push(feature);
            }
          }
        }
      });
      if (isGeometryCollection) {
        return getFeature(this, {
          geometries: jsons,
          type: 'GeometryCollection'
        });
      }
      return {
        type: 'FeatureCollection',
        features: jsons
      };
    }
  });

  // @namespace GeoJSON
  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
  // Creates a GeoJSON layer. Optionally accepts an object in
  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map
  // (you can alternatively add it later with `addData` method) and an `options` object.
  function geoJSON(geojson, options) {
    return new GeoJSON(geojson, options);
  }

  // Backward compatibility.
  var geoJson = geoJSON;

  /*
   * @class ImageOverlay
   * @aka L.ImageOverlay
   * @inherits Interactive layer
   *
   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * var imageUrl = 'https://maps.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
   * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
   * L.imageOverlay(imageUrl, imageBounds).addTo(map);
   * ```
   */

  var ImageOverlay = Layer.extend({
    // @section
    // @aka ImageOverlay options
    options: {
      // @option opacity: Number = 1.0
      // The opacity of the image overlay.
      opacity: 1,
      // @option alt: String = ''
      // Text for the `alt` attribute of the image (useful for accessibility).
      alt: '',
      // @option interactive: Boolean = false
      // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
      interactive: false,
      // @option crossOrigin: Boolean|String = false
      // Whether the crossOrigin attribute will be added to the image.
      // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
      crossOrigin: false,
      // @option errorOverlayUrl: String = ''
      // URL to the overlay image to show in place of the overlay that failed to load.
      errorOverlayUrl: '',
      // @option zIndex: Number = 1
      // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
      zIndex: 1,
      // @option className: String = ''
      // A custom class name to assign to the image. Empty by default.
      className: ''
    },
    initialize: function (url, bounds, options) {
      // (String, LatLngBounds, Object)
      this._url = url;
      this._bounds = toLatLngBounds(bounds);
      setOptions(this, options);
    },
    onAdd: function () {
      if (!this._image) {
        this._initImage();
        if (this.options.opacity < 1) {
          this._updateOpacity();
        }
      }
      if (this.options.interactive) {
        addClass(this._image, 'leaflet-interactive');
        this.addInteractiveTarget(this._image);
      }
      this.getPane().appendChild(this._image);
      this._reset();
    },
    onRemove: function () {
      remove(this._image);
      if (this.options.interactive) {
        this.removeInteractiveTarget(this._image);
      }
    },
    // @method setOpacity(opacity: Number): this
    // Sets the opacity of the overlay.
    setOpacity: function (opacity) {
      this.options.opacity = opacity;
      if (this._image) {
        this._updateOpacity();
      }
      return this;
    },
    setStyle: function (styleOpts) {
      if (styleOpts.opacity) {
        this.setOpacity(styleOpts.opacity);
      }
      return this;
    },
    // @method bringToFront(): this
    // Brings the layer to the top of all overlays.
    bringToFront: function () {
      if (this._map) {
        toFront(this._image);
      }
      return this;
    },
    // @method bringToBack(): this
    // Brings the layer to the bottom of all overlays.
    bringToBack: function () {
      if (this._map) {
        toBack(this._image);
      }
      return this;
    },
    // @method setUrl(url: String): this
    // Changes the URL of the image.
    setUrl: function (url) {
      this._url = url;
      if (this._image) {
        this._image.src = url;
      }
      return this;
    },
    // @method setBounds(bounds: LatLngBounds): this
    // Update the bounds that this ImageOverlay covers
    setBounds: function (bounds) {
      this._bounds = toLatLngBounds(bounds);
      if (this._map) {
        this._reset();
      }
      return this;
    },
    getEvents: function () {
      var events = {
        zoom: this._reset,
        viewreset: this._reset
      };
      if (this._zoomAnimated) {
        events.zoomanim = this._animateZoom;
      }
      return events;
    },
    // @method setZIndex(value: Number): this
    // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
    setZIndex: function (value) {
      this.options.zIndex = value;
      this._updateZIndex();
      return this;
    },
    // @method getBounds(): LatLngBounds
    // Get the bounds that this ImageOverlay covers
    getBounds: function () {
      return this._bounds;
    },
    // @method getElement(): HTMLElement
    // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
    // used by this overlay.
    getElement: function () {
      return this._image;
    },
    _initImage: function () {
      var wasElementSupplied = this._url.tagName === 'IMG';
      var img = this._image = wasElementSupplied ? this._url : create$1('img');
      addClass(img, 'leaflet-image-layer');
      if (this._zoomAnimated) {
        addClass(img, 'leaflet-zoom-animated');
      }
      if (this.options.className) {
        addClass(img, this.options.className);
      }
      img.onselectstart = falseFn;
      img.onmousemove = falseFn;

      // @event load: Event
      // Fired when the ImageOverlay layer has loaded its image
      img.onload = bind(this.fire, this, 'load');
      img.onerror = bind(this._overlayOnError, this, 'error');
      if (this.options.crossOrigin || this.options.crossOrigin === '') {
        img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
      }
      if (this.options.zIndex) {
        this._updateZIndex();
      }
      if (wasElementSupplied) {
        this._url = img.src;
        return;
      }
      img.src = this._url;
      img.alt = this.options.alt;
    },
    _animateZoom: function (e) {
      var scale = this._map.getZoomScale(e.zoom),
        offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;
      setTransform(this._image, offset, scale);
    },
    _reset: function () {
      var image = this._image,
        bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
        size = bounds.getSize();
      setPosition(image, bounds.min);
      image.style.width = size.x + 'px';
      image.style.height = size.y + 'px';
    },
    _updateOpacity: function () {
      setOpacity(this._image, this.options.opacity);
    },
    _updateZIndex: function () {
      if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
        this._image.style.zIndex = this.options.zIndex;
      }
    },
    _overlayOnError: function () {
      // @event error: Event
      // Fired when the ImageOverlay layer fails to load its image
      this.fire('error');
      var errorUrl = this.options.errorOverlayUrl;
      if (errorUrl && this._url !== errorUrl) {
        this._url = errorUrl;
        this._image.src = errorUrl;
      }
    },
    // @method getCenter(): LatLng
    // Returns the center of the ImageOverlay.
    getCenter: function () {
      return this._bounds.getCenter();
    }
  });

  // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
  // Instantiates an image overlay object given the URL of the image and the
  // geographical bounds it is tied to.
  var imageOverlay = function (url, bounds, options) {
    return new ImageOverlay(url, bounds, options);
  };

  /*
   * @class VideoOverlay
   * @aka L.VideoOverlay
   * @inherits ImageOverlay
   *
   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
   *
   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
   * HTML5 element.
   *
   * @example
   *
   * ```js
   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
   * 	videoBounds = [[ 32, -130], [ 13, -100]];
   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);
   * ```
   */

  var VideoOverlay = ImageOverlay.extend({
    // @section
    // @aka VideoOverlay options
    options: {
      // @option autoplay: Boolean = true
      // Whether the video starts playing automatically when loaded.
      // On some browsers autoplay will only work with `muted: true`
      autoplay: true,
      // @option loop: Boolean = true
      // Whether the video will loop back to the beginning when played.
      loop: true,
      // @option keepAspectRatio: Boolean = true
      // Whether the video will save aspect ratio after the projection.
      // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
      keepAspectRatio: true,
      // @option muted: Boolean = false
      // Whether the video starts on mute when loaded.
      muted: false,
      // @option playsInline: Boolean = true
      // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
      playsInline: true
    },
    _initImage: function () {
      var wasElementSupplied = this._url.tagName === 'VIDEO';
      var vid = this._image = wasElementSupplied ? this._url : create$1('video');
      addClass(vid, 'leaflet-image-layer');
      if (this._zoomAnimated) {
        addClass(vid, 'leaflet-zoom-animated');
      }
      if (this.options.className) {
        addClass(vid, this.options.className);
      }
      vid.onselectstart = falseFn;
      vid.onmousemove = falseFn;

      // @event load: Event
      // Fired when the video has finished loading the first frame
      vid.onloadeddata = bind(this.fire, this, 'load');
      if (wasElementSupplied) {
        var sourceElements = vid.getElementsByTagName('source');
        var sources = [];
        for (var j = 0; j < sourceElements.length; j++) {
          sources.push(sourceElements[j].src);
        }
        this._url = sourceElements.length > 0 ? sources : [vid.src];
        return;
      }
      if (!isArray(this._url)) {
        this._url = [this._url];
      }
      if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, 'objectFit')) {
        vid.style['objectFit'] = 'fill';
      }
      vid.autoplay = !!this.options.autoplay;
      vid.loop = !!this.options.loop;
      vid.muted = !!this.options.muted;
      vid.playsInline = !!this.options.playsInline;
      for (var i = 0; i < this._url.length; i++) {
        var source = create$1('source');
        source.src = this._url[i];
        vid.appendChild(source);
      }
    }

    // @method getElement(): HTMLVideoElement
    // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
    // used by this overlay.
  });

  // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
  // geographical bounds it is tied to.

  function videoOverlay(video, bounds, options) {
    return new VideoOverlay(video, bounds, options);
  }

  /*
   * @class SVGOverlay
   * @aka L.SVGOverlay
   * @inherits ImageOverlay
   *
   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.
   *
   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.
   *
   * @example
   *
   * ```js
   * var svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
   * svgElement.setAttribute('xmlns', "http://www.w3.org/2000/svg");
   * svgElement.setAttribute('viewBox', "0 0 200 200");
   * svgElement.innerHTML = '<rect width="200" height="200"/><rect x="75" y="23" width="50" height="50" style="fill:red"/><rect x="75" y="123" width="50" height="50" style="fill:#0013ff"/>';
   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];
   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);
   * ```
   */

  var SVGOverlay = ImageOverlay.extend({
    _initImage: function () {
      var el = this._image = this._url;
      addClass(el, 'leaflet-image-layer');
      if (this._zoomAnimated) {
        addClass(el, 'leaflet-zoom-animated');
      }
      if (this.options.className) {
        addClass(el, this.options.className);
      }
      el.onselectstart = falseFn;
      el.onmousemove = falseFn;
    }

    // @method getElement(): SVGElement
    // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
    // used by this overlay.
  });

  // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)
  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.
  // A viewBox attribute is required on the SVG element to zoom in and out properly.

  function svgOverlay(el, bounds, options) {
    return new SVGOverlay(el, bounds, options);
  }

  /*
   * @class DivOverlay
   * @inherits Interactive layer
   * @aka L.DivOverlay
   * Base model for L.Popup and L.Tooltip. Inherit from it for custom overlays like plugins.
   */

  // @namespace DivOverlay
  var DivOverlay = Layer.extend({
    // @section
    // @aka DivOverlay options
    options: {
      // @option interactive: Boolean = false
      // If true, the popup/tooltip will listen to the mouse events.
      interactive: false,
      // @option offset: Point = Point(0, 0)
      // The offset of the overlay position.
      offset: [0, 0],
      // @option className: String = ''
      // A custom CSS class name to assign to the overlay.
      className: '',
      // @option pane: String = undefined
      // `Map pane` where the overlay will be added.
      pane: undefined,
      // @option content: String|HTMLElement|Function = ''
      // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
      // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
      content: ''
    },
    initialize: function (options, source) {
      if (options && (options instanceof LatLng || isArray(options))) {
        this._latlng = toLatLng(options);
        setOptions(this, source);
      } else {
        setOptions(this, options);
        this._source = source;
      }
      if (this.options.content) {
        this._content = this.options.content;
      }
    },
    // @method openOn(map: Map): this
    // Adds the overlay to the map.
    // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
    openOn: function (map) {
      map = arguments.length ? map : this._source._map; // experimental, not the part of public api
      if (!map.hasLayer(this)) {
        map.addLayer(this);
      }
      return this;
    },
    // @method close(): this
    // Closes the overlay.
    // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
    // and `layer.closePopup()`/`.closeTooltip()`.
    close: function () {
      if (this._map) {
        this._map.removeLayer(this);
      }
      return this;
    },
    // @method toggle(layer?: Layer): this
    // Opens or closes the overlay bound to layer depending on its current state.
    // Argument may be omitted only for overlay bound to layer.
    // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
    toggle: function (layer) {
      if (this._map) {
        this.close();
      } else {
        if (arguments.length) {
          this._source = layer;
        } else {
          layer = this._source;
        }
        this._prepareOpen();

        // open the overlay on the map
        this.openOn(layer._map);
      }
      return this;
    },
    onAdd: function (map) {
      this._zoomAnimated = map._zoomAnimated;
      if (!this._container) {
        this._initLayout();
      }
      if (map._fadeAnimated) {
        setOpacity(this._container, 0);
      }
      clearTimeout(this._removeTimeout);
      this.getPane().appendChild(this._container);
      this.update();
      if (map._fadeAnimated) {
        setOpacity(this._container, 1);
      }
      this.bringToFront();
      if (this.options.interactive) {
        addClass(this._container, 'leaflet-interactive');
        this.addInteractiveTarget(this._container);
      }
    },
    onRemove: function (map) {
      if (map._fadeAnimated) {
        setOpacity(this._container, 0);
        this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);
      } else {
        remove(this._container);
      }
      if (this.options.interactive) {
        removeClass(this._container, 'leaflet-interactive');
        this.removeInteractiveTarget(this._container);
      }
    },
    // @namespace DivOverlay
    // @method getLatLng: LatLng
    // Returns the geographical point of the overlay.
    getLatLng: function () {
      return this._latlng;
    },
    // @method setLatLng(latlng: LatLng): this
    // Sets the geographical point where the overlay will open.
    setLatLng: function (latlng) {
      this._latlng = toLatLng(latlng);
      if (this._map) {
        this._updatePosition();
        this._adjustPan();
      }
      return this;
    },
    // @method getContent: String|HTMLElement
    // Returns the content of the overlay.
    getContent: function () {
      return this._content;
    },
    // @method setContent(htmlContent: String|HTMLElement|Function): this
    // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
    // The function should return a `String` or `HTMLElement` to be used in the overlay.
    setContent: function (content) {
      this._content = content;
      this.update();
      return this;
    },
    // @method getElement: String|HTMLElement
    // Returns the HTML container of the overlay.
    getElement: function () {
      return this._container;
    },
    // @method update: null
    // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
    update: function () {
      if (!this._map) {
        return;
      }
      this._container.style.visibility = 'hidden';
      this._updateContent();
      this._updateLayout();
      this._updatePosition();
      this._container.style.visibility = '';
      this._adjustPan();
    },
    getEvents: function () {
      var events = {
        zoom: this._updatePosition,
        viewreset: this._updatePosition
      };
      if (this._zoomAnimated) {
        events.zoomanim = this._animateZoom;
      }
      return events;
    },
    // @method isOpen: Boolean
    // Returns `true` when the overlay is visible on the map.
    isOpen: function () {
      return !!this._map && this._map.hasLayer(this);
    },
    // @method bringToFront: this
    // Brings this overlay in front of other overlays (in the same map pane).
    bringToFront: function () {
      if (this._map) {
        toFront(this._container);
      }
      return this;
    },
    // @method bringToBack: this
    // Brings this overlay to the back of other overlays (in the same map pane).
    bringToBack: function () {
      if (this._map) {
        toBack(this._container);
      }
      return this;
    },
    // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
    _prepareOpen: function (latlng) {
      var source = this._source;
      if (!source._map) {
        return false;
      }
      if (source instanceof FeatureGroup) {
        source = null;
        var layers = this._source._layers;
        for (var id in layers) {
          if (layers[id]._map) {
            source = layers[id];
            break;
          }
        }
        if (!source) {
          return false;
        } // Unable to get source layer.

        // set overlay source to this layer
        this._source = source;
      }
      if (!latlng) {
        if (source.getCenter) {
          latlng = source.getCenter();
        } else if (source.getLatLng) {
          latlng = source.getLatLng();
        } else if (source.getBounds) {
          latlng = source.getBounds().getCenter();
        } else {
          throw new Error('Unable to get source layer LatLng.');
        }
      }
      this.setLatLng(latlng);
      if (this._map) {
        // update the overlay (content, layout, etc...)
        this.update();
      }
      return true;
    },
    _updateContent: function () {
      if (!this._content) {
        return;
      }
      var node = this._contentNode;
      var content = typeof this._content === 'function' ? this._content(this._source || this) : this._content;
      if (typeof content === 'string') {
        node.innerHTML = content;
      } else {
        while (node.hasChildNodes()) {
          node.removeChild(node.firstChild);
        }
        node.appendChild(content);
      }

      // @namespace DivOverlay
      // @section DivOverlay events
      // @event contentupdate: Event
      // Fired when the content of the overlay is updated
      this.fire('contentupdate');
    },
    _updatePosition: function () {
      if (!this._map) {
        return;
      }
      var pos = this._map.latLngToLayerPoint(this._latlng),
        offset = toPoint(this.options.offset),
        anchor = this._getAnchor();
      if (this._zoomAnimated) {
        setPosition(this._container, pos.add(anchor));
      } else {
        offset = offset.add(pos).add(anchor);
      }
      var bottom = this._containerBottom = -offset.y,
        left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

      // bottom position the overlay in case the height of the overlay changes (images loading etc)
      this._container.style.bottom = bottom + 'px';
      this._container.style.left = left + 'px';
    },
    _getAnchor: function () {
      return [0, 0];
    }
  });
  Map.include({
    _initOverlay: function (OverlayClass, content, latlng, options) {
      var overlay = content;
      if (!(overlay instanceof OverlayClass)) {
        overlay = new OverlayClass(options).setContent(content);
      }
      if (latlng) {
        overlay.setLatLng(latlng);
      }
      return overlay;
    }
  });
  Layer.include({
    _initOverlay: function (OverlayClass, old, content, options) {
      var overlay = content;
      if (overlay instanceof OverlayClass) {
        setOptions(overlay, options);
        overlay._source = this;
      } else {
        overlay = old && !options ? old : new OverlayClass(options, this);
        overlay.setContent(content);
      }
      return overlay;
    }
  });

  /*
   * @class Popup
   * @inherits DivOverlay
   * @aka L.Popup
   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
   * open popups while making sure that only one popup is open at one time
   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
   *
   * @example
   *
   * If you want to just bind a popup to marker click and then open it, it's really easy:
   *
   * ```js
   * marker.bindPopup(popupContent).openPopup();
   * ```
   * Path overlays like polylines also have a `bindPopup` method.
   *
   * A popup can be also standalone:
   *
   * ```js
   * var popup = L.popup()
   * 	.setLatLng(latlng)
   * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
   * 	.openOn(map);
   * ```
   * or
   * ```js
   * var popup = L.popup(latlng, {content: '<p>Hello world!<br />This is a nice popup.</p>')
   * 	.openOn(map);
   * ```
   */

  // @namespace Popup
  var Popup = DivOverlay.extend({
    // @section
    // @aka Popup options
    options: {
      // @option pane: String = 'popupPane'
      // `Map pane` where the popup will be added.
      pane: 'popupPane',
      // @option offset: Point = Point(0, 7)
      // The offset of the popup position.
      offset: [0, 7],
      // @option maxWidth: Number = 300
      // Max width of the popup, in pixels.
      maxWidth: 300,
      // @option minWidth: Number = 50
      // Min width of the popup, in pixels.
      minWidth: 50,
      // @option maxHeight: Number = null
      // If set, creates a scrollable container of the given height
      // inside a popup if its content exceeds it.
      // The scrollable container can be styled using the
      // `leaflet-popup-scrolled` CSS class selector.
      maxHeight: null,
      // @option autoPan: Boolean = true
      // Set it to `false` if you don't want the map to do panning animation
      // to fit the opened popup.
      autoPan: true,
      // @option autoPanPaddingTopLeft: Point = null
      // The margin between the popup and the top left corner of the map
      // view after autopanning was performed.
      autoPanPaddingTopLeft: null,
      // @option autoPanPaddingBottomRight: Point = null
      // The margin between the popup and the bottom right corner of the map
      // view after autopanning was performed.
      autoPanPaddingBottomRight: null,
      // @option autoPanPadding: Point = Point(5, 5)
      // Equivalent of setting both top left and bottom right autopan padding to the same value.
      autoPanPadding: [5, 5],
      // @option keepInView: Boolean = false
      // Set it to `true` if you want to prevent users from panning the popup
      // off of the screen while it is open.
      keepInView: false,
      // @option closeButton: Boolean = true
      // Controls the presence of a close button in the popup.
      closeButton: true,
      // @option autoClose: Boolean = true
      // Set it to `false` if you want to override the default behavior of
      // the popup closing when another popup is opened.
      autoClose: true,
      // @option closeOnEscapeKey: Boolean = true
      // Set it to `false` if you want to override the default behavior of
      // the ESC key for closing of the popup.
      closeOnEscapeKey: true,
      // @option closeOnClick: Boolean = *
      // Set it if you want to override the default behavior of the popup closing when user clicks
      // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.

      // @option className: String = ''
      // A custom CSS class name to assign to the popup.
      className: ''
    },
    // @namespace Popup
    // @method openOn(map: Map): this
    // Alternative to `map.openPopup(popup)`.
    // Adds the popup to the map and closes the previous one.
    openOn: function (map) {
      map = arguments.length ? map : this._source._map; // experimental, not the part of public api

      if (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {
        map.removeLayer(map._popup);
      }
      map._popup = this;
      return DivOverlay.prototype.openOn.call(this, map);
    },
    onAdd: function (map) {
      DivOverlay.prototype.onAdd.call(this, map);

      // @namespace Map
      // @section Popup events
      // @event popupopen: PopupEvent
      // Fired when a popup is opened in the map
      map.fire('popupopen', {
        popup: this
      });
      if (this._source) {
        // @namespace Layer
        // @section Popup events
        // @event popupopen: PopupEvent
        // Fired when a popup bound to this layer is opened
        this._source.fire('popupopen', {
          popup: this
        }, true);
        // For non-path layers, we toggle the popup when clicking
        // again the layer, so prevent the map to reopen it.
        if (!(this._source instanceof Path)) {
          this._source.on('preclick', stopPropagation);
        }
      }
    },
    onRemove: function (map) {
      DivOverlay.prototype.onRemove.call(this, map);

      // @namespace Map
      // @section Popup events
      // @event popupclose: PopupEvent
      // Fired when a popup in the map is closed
      map.fire('popupclose', {
        popup: this
      });
      if (this._source) {
        // @namespace Layer
        // @section Popup events
        // @event popupclose: PopupEvent
        // Fired when a popup bound to this layer is closed
        this._source.fire('popupclose', {
          popup: this
        }, true);
        if (!(this._source instanceof Path)) {
          this._source.off('preclick', stopPropagation);
        }
      }
    },
    getEvents: function () {
      var events = DivOverlay.prototype.getEvents.call(this);
      if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
        events.preclick = this.close;
      }
      if (this.options.keepInView) {
        events.moveend = this._adjustPan;
      }
      return events;
    },
    _initLayout: function () {
      var prefix = 'leaflet-popup',
        container = this._container = create$1('div', prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-animated');
      var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);
      this._contentNode = create$1('div', prefix + '-content', wrapper);
      disableClickPropagation(container);
      disableScrollPropagation(this._contentNode);
      on(container, 'contextmenu', stopPropagation);
      this._tipContainer = create$1('div', prefix + '-tip-container', container);
      this._tip = create$1('div', prefix + '-tip', this._tipContainer);
      if (this.options.closeButton) {
        var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);
        closeButton.setAttribute('role', 'button'); // overrides the implicit role=link of <a> elements #7399
        closeButton.setAttribute('aria-label', 'Close popup');
        closeButton.href = '#close';
        closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';
        on(closeButton, 'click', function (ev) {
          preventDefault(ev);
          this.close();
        }, this);
      }
    },
    _updateLayout: function () {
      var container = this._contentNode,
        style = container.style;
      style.width = '';
      style.whiteSpace = 'nowrap';
      var width = container.offsetWidth;
      width = Math.min(width, this.options.maxWidth);
      width = Math.max(width, this.options.minWidth);
      style.width = width + 1 + 'px';
      style.whiteSpace = '';
      style.height = '';
      var height = container.offsetHeight,
        maxHeight = this.options.maxHeight,
        scrolledClass = 'leaflet-popup-scrolled';
      if (maxHeight && height > maxHeight) {
        style.height = maxHeight + 'px';
        addClass(container, scrolledClass);
      } else {
        removeClass(container, scrolledClass);
      }
      this._containerWidth = this._container.offsetWidth;
    },
    _animateZoom: function (e) {
      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
        anchor = this._getAnchor();
      setPosition(this._container, pos.add(anchor));
    },
    _adjustPan: function () {
      if (!this.options.autoPan) {
        return;
      }
      if (this._map._panAnim) {
        this._map._panAnim.stop();
      }

      // We can endlessly recurse if keepInView is set and the view resets.
      // Let's guard against that by exiting early if we're responding to our own autopan.
      if (this._autopanning) {
        this._autopanning = false;
        return;
      }
      var map = this._map,
        marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,
        containerHeight = this._container.offsetHeight + marginBottom,
        containerWidth = this._containerWidth,
        layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
      layerPos._add(getPosition(this._container));
      var containerPos = map.layerPointToContainerPoint(layerPos),
        padding = toPoint(this.options.autoPanPadding),
        paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),
        paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),
        size = map.getSize(),
        dx = 0,
        dy = 0;
      if (containerPos.x + containerWidth + paddingBR.x > size.x) {
        // right
        dx = containerPos.x + containerWidth - size.x + paddingBR.x;
      }
      if (containerPos.x - dx - paddingTL.x < 0) {
        // left
        dx = containerPos.x - paddingTL.x;
      }
      if (containerPos.y + containerHeight + paddingBR.y > size.y) {
        // bottom
        dy = containerPos.y + containerHeight - size.y + paddingBR.y;
      }
      if (containerPos.y - dy - paddingTL.y < 0) {
        // top
        dy = containerPos.y - paddingTL.y;
      }

      // @namespace Map
      // @section Popup events
      // @event autopanstart: Event
      // Fired when the map starts autopanning when opening a popup.
      if (dx || dy) {
        // Track that we're autopanning, as this function will be re-ran on moveend
        if (this.options.keepInView) {
          this._autopanning = true;
        }
        map.fire('autopanstart').panBy([dx, dy]);
      }
    },
    _getAnchor: function () {
      // Where should we anchor the popup on the source layer?
      return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
    }
  });

  // @namespace Popup
  // @factory L.popup(options?: Popup options, source?: Layer)
  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
  // @alternative
  // @factory L.popup(latlng: LatLng, options?: Popup options)
  // Instantiates a `Popup` object given `latlng` where the popup will open and an optional `options` object that describes its appearance and location.
  var popup = function (options, source) {
    return new Popup(options, source);
  };

  /* @namespace Map
   * @section Interaction Options
   * @option closePopupOnClick: Boolean = true
   * Set it to `false` if you don't want popups to close when user clicks the map.
   */
  Map.mergeOptions({
    closePopupOnClick: true
  });

  // @namespace Map
  // @section Methods for Layers and Controls
  Map.include({
    // @method openPopup(popup: Popup): this
    // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
    // @alternative
    // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
    // Creates a popup with the specified content and options and opens it in the given point on a map.
    openPopup: function (popup, latlng, options) {
      this._initOverlay(Popup, popup, latlng, options).openOn(this);
      return this;
    },
    // @method closePopup(popup?: Popup): this
    // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
    closePopup: function (popup) {
      popup = arguments.length ? popup : this._popup;
      if (popup) {
        popup.close();
      }
      return this;
    }
  });

  /*
   * @namespace Layer
   * @section Popup methods example
   *
   * All layers share a set of methods convenient for binding popups to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
   * layer.openPopup();
   * layer.closePopup();
   * ```
   *
   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
   */

  // @section Popup methods
  Layer.include({
    // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
    // Binds a popup to the layer with the passed `content` and sets up the
    // necessary event listeners. If a `Function` is passed it will receive
    // the layer as the first argument and should return a `String` or `HTMLElement`.
    bindPopup: function (content, options) {
      this._popup = this._initOverlay(Popup, this._popup, content, options);
      if (!this._popupHandlersAdded) {
        this.on({
          click: this._openPopup,
          keypress: this._onKeyPress,
          remove: this.closePopup,
          move: this._movePopup
        });
        this._popupHandlersAdded = true;
      }
      return this;
    },
    // @method unbindPopup(): this
    // Removes the popup previously bound with `bindPopup`.
    unbindPopup: function () {
      if (this._popup) {
        this.off({
          click: this._openPopup,
          keypress: this._onKeyPress,
          remove: this.closePopup,
          move: this._movePopup
        });
        this._popupHandlersAdded = false;
        this._popup = null;
      }
      return this;
    },
    // @method openPopup(latlng?: LatLng): this
    // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
    openPopup: function (latlng) {
      if (this._popup) {
        if (!(this instanceof FeatureGroup)) {
          this._popup._source = this;
        }
        if (this._popup._prepareOpen(latlng || this._latlng)) {
          // open the popup on the map
          this._popup.openOn(this._map);
        }
      }
      return this;
    },
    // @method closePopup(): this
    // Closes the popup bound to this layer if it is open.
    closePopup: function () {
      if (this._popup) {
        this._popup.close();
      }
      return this;
    },
    // @method togglePopup(): this
    // Opens or closes the popup bound to this layer depending on its current state.
    togglePopup: function () {
      if (this._popup) {
        this._popup.toggle(this);
      }
      return this;
    },
    // @method isPopupOpen(): boolean
    // Returns `true` if the popup bound to this layer is currently open.
    isPopupOpen: function () {
      return this._popup ? this._popup.isOpen() : false;
    },
    // @method setPopupContent(content: String|HTMLElement|Popup): this
    // Sets the content of the popup bound to this layer.
    setPopupContent: function (content) {
      if (this._popup) {
        this._popup.setContent(content);
      }
      return this;
    },
    // @method getPopup(): Popup
    // Returns the popup bound to this layer.
    getPopup: function () {
      return this._popup;
    },
    _openPopup: function (e) {
      if (!this._popup || !this._map) {
        return;
      }
      // prevent map click
      stop(e);
      var target = e.layer || e.target;
      if (this._popup._source === target && !(target instanceof Path)) {
        // treat it like a marker and figure out
        // if we should toggle it open/closed
        if (this._map.hasLayer(this._popup)) {
          this.closePopup();
        } else {
          this.openPopup(e.latlng);
        }
        return;
      }
      this._popup._source = target;
      this.openPopup(e.latlng);
    },
    _movePopup: function (e) {
      this._popup.setLatLng(e.latlng);
    },
    _onKeyPress: function (e) {
      if (e.originalEvent.keyCode === 13) {
        this._openPopup(e);
      }
    }
  });

  /*
   * @class Tooltip
   * @inherits DivOverlay
   * @aka L.Tooltip
   * Used to display small texts on top of map layers.
   *
   * @example
   * If you want to just bind a tooltip to marker:
   *
   * ```js
   * marker.bindTooltip("my tooltip text").openTooltip();
   * ```
   * Path overlays like polylines also have a `bindTooltip` method.
   *
   * A tooltip can be also standalone:
   *
   * ```js
   * var tooltip = L.tooltip()
   * 	.setLatLng(latlng)
   * 	.setContent('Hello world!<br />This is a nice tooltip.')
   * 	.addTo(map);
   * ```
   * or
   * ```js
   * var tooltip = L.tooltip(latlng, {content: 'Hello world!<br />This is a nice tooltip.'})
   * 	.addTo(map);
   * ```
   *
   *
   * Note about tooltip offset. Leaflet takes two options in consideration
   * for computing tooltip offsetting:
   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
   *   move it to the bottom. Negatives will move to the left and top.
   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
   *   should adapt this value if you use a custom icon.
   */

  // @namespace Tooltip
  var Tooltip = DivOverlay.extend({
    // @section
    // @aka Tooltip options
    options: {
      // @option pane: String = 'tooltipPane'
      // `Map pane` where the tooltip will be added.
      pane: 'tooltipPane',
      // @option offset: Point = Point(0, 0)
      // Optional offset of the tooltip position.
      offset: [0, 0],
      // @option direction: String = 'auto'
      // Direction where to open the tooltip. Possible values are: `right`, `left`,
      // `top`, `bottom`, `center`, `auto`.
      // `auto` will dynamically switch between `right` and `left` according to the tooltip
      // position on the map.
      direction: 'auto',
      // @option permanent: Boolean = false
      // Whether to open the tooltip permanently or only on mouseover.
      permanent: false,
      // @option sticky: Boolean = false
      // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
      sticky: false,
      // @option opacity: Number = 0.9
      // Tooltip container opacity.
      opacity: 0.9
    },
    onAdd: function (map) {
      DivOverlay.prototype.onAdd.call(this, map);
      this.setOpacity(this.options.opacity);

      // @namespace Map
      // @section Tooltip events
      // @event tooltipopen: TooltipEvent
      // Fired when a tooltip is opened in the map.
      map.fire('tooltipopen', {
        tooltip: this
      });
      if (this._source) {
        this.addEventParent(this._source);

        // @namespace Layer
        // @section Tooltip events
        // @event tooltipopen: TooltipEvent
        // Fired when a tooltip bound to this layer is opened.
        this._source.fire('tooltipopen', {
          tooltip: this
        }, true);
      }
    },
    onRemove: function (map) {
      DivOverlay.prototype.onRemove.call(this, map);

      // @namespace Map
      // @section Tooltip events
      // @event tooltipclose: TooltipEvent
      // Fired when a tooltip in the map is closed.
      map.fire('tooltipclose', {
        tooltip: this
      });
      if (this._source) {
        this.removeEventParent(this._source);

        // @namespace Layer
        // @section Tooltip events
        // @event tooltipclose: TooltipEvent
        // Fired when a tooltip bound to this layer is closed.
        this._source.fire('tooltipclose', {
          tooltip: this
        }, true);
      }
    },
    getEvents: function () {
      var events = DivOverlay.prototype.getEvents.call(this);
      if (!this.options.permanent) {
        events.preclick = this.close;
      }
      return events;
    },
    _initLayout: function () {
      var prefix = 'leaflet-tooltip',
        className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');
      this._contentNode = this._container = create$1('div', className);
      this._container.setAttribute('role', 'tooltip');
      this._container.setAttribute('id', 'leaflet-tooltip-' + stamp(this));
    },
    _updateLayout: function () {},
    _adjustPan: function () {},
    _setPosition: function (pos) {
      var subX,
        subY,
        map = this._map,
        container = this._container,
        centerPoint = map.latLngToContainerPoint(map.getCenter()),
        tooltipPoint = map.layerPointToContainerPoint(pos),
        direction = this.options.direction,
        tooltipWidth = container.offsetWidth,
        tooltipHeight = container.offsetHeight,
        offset = toPoint(this.options.offset),
        anchor = this._getAnchor();
      if (direction === 'top') {
        subX = tooltipWidth / 2;
        subY = tooltipHeight;
      } else if (direction === 'bottom') {
        subX = tooltipWidth / 2;
        subY = 0;
      } else if (direction === 'center') {
        subX = tooltipWidth / 2;
        subY = tooltipHeight / 2;
      } else if (direction === 'right') {
        subX = 0;
        subY = tooltipHeight / 2;
      } else if (direction === 'left') {
        subX = tooltipWidth;
        subY = tooltipHeight / 2;
      } else if (tooltipPoint.x < centerPoint.x) {
        direction = 'right';
        subX = 0;
        subY = tooltipHeight / 2;
      } else {
        direction = 'left';
        subX = tooltipWidth + (offset.x + anchor.x) * 2;
        subY = tooltipHeight / 2;
      }
      pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
      removeClass(container, 'leaflet-tooltip-right');
      removeClass(container, 'leaflet-tooltip-left');
      removeClass(container, 'leaflet-tooltip-top');
      removeClass(container, 'leaflet-tooltip-bottom');
      addClass(container, 'leaflet-tooltip-' + direction);
      setPosition(container, pos);
    },
    _updatePosition: function () {
      var pos = this._map.latLngToLayerPoint(this._latlng);
      this._setPosition(pos);
    },
    setOpacity: function (opacity) {
      this.options.opacity = opacity;
      if (this._container) {
        setOpacity(this._container, opacity);
      }
    },
    _animateZoom: function (e) {
      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
      this._setPosition(pos);
    },
    _getAnchor: function () {
      // Where should we anchor the tooltip on the source layer?
      return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
    }
  });

  // @namespace Tooltip
  // @factory L.tooltip(options?: Tooltip options, source?: Layer)
  // Instantiates a `Tooltip` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
  // @alternative
  // @factory L.tooltip(latlng: LatLng, options?: Tooltip options)
  // Instantiates a `Tooltip` object given `latlng` where the tooltip will open and an optional `options` object that describes its appearance and location.
  var tooltip = function (options, source) {
    return new Tooltip(options, source);
  };

  // @namespace Map
  // @section Methods for Layers and Controls
  Map.include({
    // @method openTooltip(tooltip: Tooltip): this
    // Opens the specified tooltip.
    // @alternative
    // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
    // Creates a tooltip with the specified content and options and open it.
    openTooltip: function (tooltip, latlng, options) {
      this._initOverlay(Tooltip, tooltip, latlng, options).openOn(this);
      return this;
    },
    // @method closeTooltip(tooltip: Tooltip): this
    // Closes the tooltip given as parameter.
    closeTooltip: function (tooltip) {
      tooltip.close();
      return this;
    }
  });

  /*
   * @namespace Layer
   * @section Tooltip methods example
   *
   * All layers share a set of methods convenient for binding tooltips to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
   * layer.openTooltip();
   * layer.closeTooltip();
   * ```
   */

  // @section Tooltip methods
  Layer.include({
    // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
    // Binds a tooltip to the layer with the passed `content` and sets up the
    // necessary event listeners. If a `Function` is passed it will receive
    // the layer as the first argument and should return a `String` or `HTMLElement`.
    bindTooltip: function (content, options) {
      if (this._tooltip && this.isTooltipOpen()) {
        this.unbindTooltip();
      }
      this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);
      this._initTooltipInteractions();
      if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
        this.openTooltip();
      }
      return this;
    },
    // @method unbindTooltip(): this
    // Removes the tooltip previously bound with `bindTooltip`.
    unbindTooltip: function () {
      if (this._tooltip) {
        this._initTooltipInteractions(true);
        this.closeTooltip();
        this._tooltip = null;
      }
      return this;
    },
    _initTooltipInteractions: function (remove) {
      if (!remove && this._tooltipHandlersAdded) {
        return;
      }
      var onOff = remove ? 'off' : 'on',
        events = {
          remove: this.closeTooltip,
          move: this._moveTooltip
        };
      if (!this._tooltip.options.permanent) {
        events.mouseover = this._openTooltip;
        events.mouseout = this.closeTooltip;
        events.click = this._openTooltip;
        if (this._map) {
          this._addFocusListeners();
        } else {
          events.add = this._addFocusListeners;
        }
      } else {
        events.add = this._openTooltip;
      }
      if (this._tooltip.options.sticky) {
        events.mousemove = this._moveTooltip;
      }
      this[onOff](events);
      this._tooltipHandlersAdded = !remove;
    },
    // @method openTooltip(latlng?: LatLng): this
    // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
    openTooltip: function (latlng) {
      if (this._tooltip) {
        if (!(this instanceof FeatureGroup)) {
          this._tooltip._source = this;
        }
        if (this._tooltip._prepareOpen(latlng)) {
          // open the tooltip on the map
          this._tooltip.openOn(this._map);
          if (this.getElement) {
            this._setAriaDescribedByOnLayer(this);
          } else if (this.eachLayer) {
            this.eachLayer(this._setAriaDescribedByOnLayer, this);
          }
        }
      }
      return this;
    },
    // @method closeTooltip(): this
    // Closes the tooltip bound to this layer if it is open.
    closeTooltip: function () {
      if (this._tooltip) {
        return this._tooltip.close();
      }
    },
    // @method toggleTooltip(): this
    // Opens or closes the tooltip bound to this layer depending on its current state.
    toggleTooltip: function () {
      if (this._tooltip) {
        this._tooltip.toggle(this);
      }
      return this;
    },
    // @method isTooltipOpen(): boolean
    // Returns `true` if the tooltip bound to this layer is currently open.
    isTooltipOpen: function () {
      return this._tooltip.isOpen();
    },
    // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
    // Sets the content of the tooltip bound to this layer.
    setTooltipContent: function (content) {
      if (this._tooltip) {
        this._tooltip.setContent(content);
      }
      return this;
    },
    // @method getTooltip(): Tooltip
    // Returns the tooltip bound to this layer.
    getTooltip: function () {
      return this._tooltip;
    },
    _addFocusListeners: function () {
      if (this.getElement) {
        this._addFocusListenersOnLayer(this);
      } else if (this.eachLayer) {
        this.eachLayer(this._addFocusListenersOnLayer, this);
      }
    },
    _addFocusListenersOnLayer: function (layer) {
      var el = typeof layer.getElement === 'function' && layer.getElement();
      if (el) {
        on(el, 'focus', function () {
          this._tooltip._source = layer;
          this.openTooltip();
        }, this);
        on(el, 'blur', this.closeTooltip, this);
      }
    },
    _setAriaDescribedByOnLayer: function (layer) {
      var el = typeof layer.getElement === 'function' && layer.getElement();
      if (el) {
        el.setAttribute('aria-describedby', this._tooltip._container.id);
      }
    },
    _openTooltip: function (e) {
      if (!this._tooltip || !this._map) {
        return;
      }

      // If the map is moving, we will show the tooltip after it's done.
      if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
        this._openOnceFlag = true;
        var that = this;
        this._map.once('moveend', function () {
          that._openOnceFlag = false;
          that._openTooltip(e);
        });
        return;
      }
      this._tooltip._source = e.layer || e.target;
      this.openTooltip(this._tooltip.options.sticky ? e.latlng : undefined);
    },
    _moveTooltip: function (e) {
      var latlng = e.latlng,
        containerPoint,
        layerPoint;
      if (this._tooltip.options.sticky && e.originalEvent) {
        containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
        layerPoint = this._map.containerPointToLayerPoint(containerPoint);
        latlng = this._map.layerPointToLatLng(layerPoint);
      }
      this._tooltip.setLatLng(latlng);
    }
  });

  /*
   * @class DivIcon
   * @aka L.DivIcon
   * @inherits Icon
   *
   * Represents a lightweight icon for markers that uses a simple `<div>`
   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
   *
   * @example
   * ```js
   * var myIcon = L.divIcon({className: 'my-div-icon'});
   * // you can set .my-div-icon styles in CSS
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
   */

  var DivIcon = Icon.extend({
    options: {
      // @section
      // @aka DivIcon options
      iconSize: [12, 12],
      // also can be set through CSS

      // iconAnchor: (Point),
      // popupAnchor: (Point),

      // @option html: String|HTMLElement = ''
      // Custom HTML code to put inside the div element, empty by default. Alternatively,
      // an instance of `HTMLElement`.
      html: false,
      // @option bgPos: Point = [0, 0]
      // Optional relative position of the background, in pixels
      bgPos: null,
      className: 'leaflet-div-icon'
    },
    createIcon: function (oldIcon) {
      var div = oldIcon && oldIcon.tagName === 'DIV' ? oldIcon : document.createElement('div'),
        options = this.options;
      if (options.html instanceof Element) {
        empty(div);
        div.appendChild(options.html);
      } else {
        div.innerHTML = options.html !== false ? options.html : '';
      }
      if (options.bgPos) {
        var bgPos = toPoint(options.bgPos);
        div.style.backgroundPosition = -bgPos.x + 'px ' + -bgPos.y + 'px';
      }
      this._setIconStyles(div, 'icon');
      return div;
    },
    createShadow: function () {
      return null;
    }
  });

  // @factory L.divIcon(options: DivIcon options)
  // Creates a `DivIcon` instance with the given options.
  function divIcon(options) {
    return new DivIcon(options);
  }
  Icon.Default = IconDefault;

  /*
   * @class GridLayer
   * @inherits Layer
   * @aka L.GridLayer
   *
   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
   *
   *
   * @section Synchronous usage
   * @example
   *
   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords){
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
   *         var ctx = tile.getContext('2d');
   *
   *         // return the tile so it can be rendered on screen
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section Asynchronous usage
   * @example
   *
   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords, done){
   *         var error;
   *
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // draw something asynchronously and pass the tile to the done() callback
   *         setTimeout(function() {
   *             done(error, tile);
   *         }, 1000);
   *
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section
   */

  var GridLayer = Layer.extend({
    // @section
    // @aka GridLayer options
    options: {
      // @option tileSize: Number|Point = 256
      // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
      tileSize: 256,
      // @option opacity: Number = 1.0
      // Opacity of the tiles. Can be used in the `createTile()` function.
      opacity: 1,
      // @option updateWhenIdle: Boolean = (depends)
      // Load new tiles only when panning ends.
      // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
      // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
      // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
      updateWhenIdle: Browser.mobile,
      // @option updateWhenZooming: Boolean = true
      // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
      updateWhenZooming: true,
      // @option updateInterval: Number = 200
      // Tiles will not update more than once every `updateInterval` milliseconds when panning.
      updateInterval: 200,
      // @option zIndex: Number = 1
      // The explicit zIndex of the tile layer.
      zIndex: 1,
      // @option bounds: LatLngBounds = undefined
      // If set, tiles will only be loaded inside the set `LatLngBounds`.
      bounds: null,
      // @option minZoom: Number = 0
      // The minimum zoom level down to which this layer will be displayed (inclusive).
      minZoom: 0,
      // @option maxZoom: Number = undefined
      // The maximum zoom level up to which this layer will be displayed (inclusive).
      maxZoom: undefined,
      // @option maxNativeZoom: Number = undefined
      // Maximum zoom number the tile source has available. If it is specified,
      // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
      // from `maxNativeZoom` level and auto-scaled.
      maxNativeZoom: undefined,
      // @option minNativeZoom: Number = undefined
      // Minimum zoom number the tile source has available. If it is specified,
      // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
      // from `minNativeZoom` level and auto-scaled.
      minNativeZoom: undefined,
      // @option noWrap: Boolean = false
      // Whether the layer is wrapped around the antimeridian. If `true`, the
      // GridLayer will only be displayed once at low zoom levels. Has no
      // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
      // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
      // tiles outside the CRS limits.
      noWrap: false,
      // @option pane: String = 'tilePane'
      // `Map pane` where the grid layer will be added.
      pane: 'tilePane',
      // @option className: String = ''
      // A custom class name to assign to the tile layer. Empty by default.
      className: '',
      // @option keepBuffer: Number = 2
      // When panning the map, keep this many rows and columns of tiles before unloading them.
      keepBuffer: 2
    },
    initialize: function (options) {
      setOptions(this, options);
    },
    onAdd: function () {
      this._initContainer();
      this._levels = {};
      this._tiles = {};
      this._resetView(); // implicit _update() call
    },

    beforeAdd: function (map) {
      map._addZoomLimit(this);
    },
    onRemove: function (map) {
      this._removeAllTiles();
      remove(this._container);
      map._removeZoomLimit(this);
      this._container = null;
      this._tileZoom = undefined;
    },
    // @method bringToFront: this
    // Brings the tile layer to the top of all tile layers.
    bringToFront: function () {
      if (this._map) {
        toFront(this._container);
        this._setAutoZIndex(Math.max);
      }
      return this;
    },
    // @method bringToBack: this
    // Brings the tile layer to the bottom of all tile layers.
    bringToBack: function () {
      if (this._map) {
        toBack(this._container);
        this._setAutoZIndex(Math.min);
      }
      return this;
    },
    // @method getContainer: HTMLElement
    // Returns the HTML element that contains the tiles for this layer.
    getContainer: function () {
      return this._container;
    },
    // @method setOpacity(opacity: Number): this
    // Changes the [opacity](#gridlayer-opacity) of the grid layer.
    setOpacity: function (opacity) {
      this.options.opacity = opacity;
      this._updateOpacity();
      return this;
    },
    // @method setZIndex(zIndex: Number): this
    // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
    setZIndex: function (zIndex) {
      this.options.zIndex = zIndex;
      this._updateZIndex();
      return this;
    },
    // @method isLoading: Boolean
    // Returns `true` if any tile in the grid layer has not finished loading.
    isLoading: function () {
      return this._loading;
    },
    // @method redraw: this
    // Causes the layer to clear all the tiles and request them again.
    redraw: function () {
      if (this._map) {
        this._removeAllTiles();
        var tileZoom = this._clampZoom(this._map.getZoom());
        if (tileZoom !== this._tileZoom) {
          this._tileZoom = tileZoom;
          this._updateLevels();
        }
        this._update();
      }
      return this;
    },
    getEvents: function () {
      var events = {
        viewprereset: this._invalidateAll,
        viewreset: this._resetView,
        zoom: this._resetView,
        moveend: this._onMoveEnd
      };
      if (!this.options.updateWhenIdle) {
        // update tiles on move, but not more often than once per given interval
        if (!this._onMove) {
          this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
        }
        events.move = this._onMove;
      }
      if (this._zoomAnimated) {
        events.zoomanim = this._animateZoom;
      }
      return events;
    },
    // @section Extension methods
    // Layers extending `GridLayer` shall reimplement the following method.
    // @method createTile(coords: Object, done?: Function): HTMLElement
    // Called only internally, must be overridden by classes extending `GridLayer`.
    // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
    // is specified, it must be called when the tile has finished loading and drawing.
    createTile: function () {
      return document.createElement('div');
    },
    // @section
    // @method getTileSize: Point
    // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
    getTileSize: function () {
      var s = this.options.tileSize;
      return s instanceof Point ? s : new Point(s, s);
    },
    _updateZIndex: function () {
      if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
        this._container.style.zIndex = this.options.zIndex;
      }
    },
    _setAutoZIndex: function (compare) {
      // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

      var layers = this.getPane().children,
        edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

      for (var i = 0, len = layers.length, zIndex; i < len; i++) {
        zIndex = layers[i].style.zIndex;
        if (layers[i] !== this._container && zIndex) {
          edgeZIndex = compare(edgeZIndex, +zIndex);
        }
      }
      if (isFinite(edgeZIndex)) {
        this.options.zIndex = edgeZIndex + compare(-1, 1);
        this._updateZIndex();
      }
    },
    _updateOpacity: function () {
      if (!this._map) {
        return;
      }

      // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
      if (Browser.ielt9) {
        return;
      }
      setOpacity(this._container, this.options.opacity);
      var now = +new Date(),
        nextFrame = false,
        willPrune = false;
      for (var key in this._tiles) {
        var tile = this._tiles[key];
        if (!tile.current || !tile.loaded) {
          continue;
        }
        var fade = Math.min(1, (now - tile.loaded) / 200);
        setOpacity(tile.el, fade);
        if (fade < 1) {
          nextFrame = true;
        } else {
          if (tile.active) {
            willPrune = true;
          } else {
            this._onOpaqueTile(tile);
          }
          tile.active = true;
        }
      }
      if (willPrune && !this._noPrune) {
        this._pruneTiles();
      }
      if (nextFrame) {
        cancelAnimFrame(this._fadeFrame);
        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
      }
    },
    _onOpaqueTile: falseFn,
    _initContainer: function () {
      if (this._container) {
        return;
      }
      this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));
      this._updateZIndex();
      if (this.options.opacity < 1) {
        this._updateOpacity();
      }
      this.getPane().appendChild(this._container);
    },
    _updateLevels: function () {
      var zoom = this._tileZoom,
        maxZoom = this.options.maxZoom;
      if (zoom === undefined) {
        return undefined;
      }
      for (var z in this._levels) {
        z = Number(z);
        if (this._levels[z].el.children.length || z === zoom) {
          this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
          this._onUpdateLevel(z);
        } else {
          remove(this._levels[z].el);
          this._removeTilesAtZoom(z);
          this._onRemoveLevel(z);
          delete this._levels[z];
        }
      }
      var level = this._levels[zoom],
        map = this._map;
      if (!level) {
        level = this._levels[zoom] = {};
        level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
        level.el.style.zIndex = maxZoom;
        level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
        level.zoom = zoom;
        this._setZoomTransform(level, map.getCenter(), map.getZoom());

        // force the browser to consider the newly added element for transition
        falseFn(level.el.offsetWidth);
        this._onCreateLevel(level);
      }
      this._level = level;
      return level;
    },
    _onUpdateLevel: falseFn,
    _onRemoveLevel: falseFn,
    _onCreateLevel: falseFn,
    _pruneTiles: function () {
      if (!this._map) {
        return;
      }
      var key, tile;
      var zoom = this._map.getZoom();
      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
        this._removeAllTiles();
        return;
      }
      for (key in this._tiles) {
        tile = this._tiles[key];
        tile.retain = tile.current;
      }
      for (key in this._tiles) {
        tile = this._tiles[key];
        if (tile.current && !tile.active) {
          var coords = tile.coords;
          if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
            this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
          }
        }
      }
      for (key in this._tiles) {
        if (!this._tiles[key].retain) {
          this._removeTile(key);
        }
      }
    },
    _removeTilesAtZoom: function (zoom) {
      for (var key in this._tiles) {
        if (this._tiles[key].coords.z !== zoom) {
          continue;
        }
        this._removeTile(key);
      }
    },
    _removeAllTiles: function () {
      for (var key in this._tiles) {
        this._removeTile(key);
      }
    },
    _invalidateAll: function () {
      for (var z in this._levels) {
        remove(this._levels[z].el);
        this._onRemoveLevel(Number(z));
        delete this._levels[z];
      }
      this._removeAllTiles();
      this._tileZoom = undefined;
    },
    _retainParent: function (x, y, z, minZoom) {
      var x2 = Math.floor(x / 2),
        y2 = Math.floor(y / 2),
        z2 = z - 1,
        coords2 = new Point(+x2, +y2);
      coords2.z = +z2;
      var key = this._tileCoordsToKey(coords2),
        tile = this._tiles[key];
      if (tile && tile.active) {
        tile.retain = true;
        return true;
      } else if (tile && tile.loaded) {
        tile.retain = true;
      }
      if (z2 > minZoom) {
        return this._retainParent(x2, y2, z2, minZoom);
      }
      return false;
    },
    _retainChildren: function (x, y, z, maxZoom) {
      for (var i = 2 * x; i < 2 * x + 2; i++) {
        for (var j = 2 * y; j < 2 * y + 2; j++) {
          var coords = new Point(i, j);
          coords.z = z + 1;
          var key = this._tileCoordsToKey(coords),
            tile = this._tiles[key];
          if (tile && tile.active) {
            tile.retain = true;
            continue;
          } else if (tile && tile.loaded) {
            tile.retain = true;
          }
          if (z + 1 < maxZoom) {
            this._retainChildren(i, j, z + 1, maxZoom);
          }
        }
      }
    },
    _resetView: function (e) {
      var animating = e && (e.pinch || e.flyTo);
      this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
    },
    _animateZoom: function (e) {
      this._setView(e.center, e.zoom, true, e.noUpdate);
    },
    _clampZoom: function (zoom) {
      var options = this.options;
      if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
        return options.minNativeZoom;
      }
      if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
        return options.maxNativeZoom;
      }
      return zoom;
    },
    _setView: function (center, zoom, noPrune, noUpdate) {
      var tileZoom = Math.round(zoom);
      if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {
        tileZoom = undefined;
      } else {
        tileZoom = this._clampZoom(tileZoom);
      }
      var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
      if (!noUpdate || tileZoomChanged) {
        this._tileZoom = tileZoom;
        if (this._abortLoading) {
          this._abortLoading();
        }
        this._updateLevels();
        this._resetGrid();
        if (tileZoom !== undefined) {
          this._update(center);
        }
        if (!noPrune) {
          this._pruneTiles();
        }

        // Flag to prevent _updateOpacity from pruning tiles during
        // a zoom anim or a pinch gesture
        this._noPrune = !!noPrune;
      }
      this._setZoomTransforms(center, zoom);
    },
    _setZoomTransforms: function (center, zoom) {
      for (var i in this._levels) {
        this._setZoomTransform(this._levels[i], center, zoom);
      }
    },
    _setZoomTransform: function (level, center, zoom) {
      var scale = this._map.getZoomScale(zoom, level.zoom),
        translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();
      if (Browser.any3d) {
        setTransform(level.el, translate, scale);
      } else {
        setPosition(level.el, translate);
      }
    },
    _resetGrid: function () {
      var map = this._map,
        crs = map.options.crs,
        tileSize = this._tileSize = this.getTileSize(),
        tileZoom = this._tileZoom;
      var bounds = this._map.getPixelWorldBounds(this._tileZoom);
      if (bounds) {
        this._globalTileRange = this._pxBoundsToTileRange(bounds);
      }
      this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];
      this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];
    },
    _onMoveEnd: function () {
      if (!this._map || this._map._animatingZoom) {
        return;
      }
      this._update();
    },
    _getTiledPixelBounds: function (center) {
      var map = this._map,
        mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
        scale = map.getZoomScale(mapZoom, this._tileZoom),
        pixelCenter = map.project(center, this._tileZoom).floor(),
        halfSize = map.getSize().divideBy(scale * 2);
      return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
    },
    // Private method to load tiles in the grid's active zoom level according to map bounds
    _update: function (center) {
      var map = this._map;
      if (!map) {
        return;
      }
      var zoom = this._clampZoom(map.getZoom());
      if (center === undefined) {
        center = map.getCenter();
      }
      if (this._tileZoom === undefined) {
        return;
      } // if out of minzoom/maxzoom

      var pixelBounds = this._getTiledPixelBounds(center),
        tileRange = this._pxBoundsToTileRange(pixelBounds),
        tileCenter = tileRange.getCenter(),
        queue = [],
        margin = this.options.keepBuffer,
        noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin]));

      // Sanity check: panic if the tile range contains Infinity somewhere.
      if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
        throw new Error('Attempted to load an infinite number of tiles');
      }
      for (var key in this._tiles) {
        var c = this._tiles[key].coords;
        if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
          this._tiles[key].current = false;
        }
      }

      // _update just loads more tiles. If the tile zoom level differs too much
      // from the map's, let _setView reset levels and prune old tiles.
      if (Math.abs(zoom - this._tileZoom) > 1) {
        this._setView(center, zoom);
        return;
      }

      // create a queue of coordinates to load tiles from
      for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
        for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
          var coords = new Point(i, j);
          coords.z = this._tileZoom;
          if (!this._isValidTile(coords)) {
            continue;
          }
          var tile = this._tiles[this._tileCoordsToKey(coords)];
          if (tile) {
            tile.current = true;
          } else {
            queue.push(coords);
          }
        }
      }

      // sort tile queue to load tiles in order of their distance to center
      queue.sort(function (a, b) {
        return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
      });
      if (queue.length !== 0) {
        // if it's the first batch of tiles to load
        if (!this._loading) {
          this._loading = true;
          // @event loading: Event
          // Fired when the grid layer starts loading tiles.
          this.fire('loading');
        }

        // create DOM fragment to append tiles in one batch
        var fragment = document.createDocumentFragment();
        for (i = 0; i < queue.length; i++) {
          this._addTile(queue[i], fragment);
        }
        this._level.el.appendChild(fragment);
      }
    },
    _isValidTile: function (coords) {
      var crs = this._map.options.crs;
      if (!crs.infinite) {
        // don't load tile if it's out of bounds and not wrapped
        var bounds = this._globalTileRange;
        if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
          return false;
        }
      }
      if (!this.options.bounds) {
        return true;
      }

      // don't load tile if it doesn't intersect the bounds in options
      var tileBounds = this._tileCoordsToBounds(coords);
      return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
    },
    _keyToBounds: function (key) {
      return this._tileCoordsToBounds(this._keyToTileCoords(key));
    },
    _tileCoordsToNwSe: function (coords) {
      var map = this._map,
        tileSize = this.getTileSize(),
        nwPoint = coords.scaleBy(tileSize),
        sePoint = nwPoint.add(tileSize),
        nw = map.unproject(nwPoint, coords.z),
        se = map.unproject(sePoint, coords.z);
      return [nw, se];
    },
    // converts tile coordinates to its geographical bounds
    _tileCoordsToBounds: function (coords) {
      var bp = this._tileCoordsToNwSe(coords),
        bounds = new LatLngBounds(bp[0], bp[1]);
      if (!this.options.noWrap) {
        bounds = this._map.wrapLatLngBounds(bounds);
      }
      return bounds;
    },
    // converts tile coordinates to key for the tile cache
    _tileCoordsToKey: function (coords) {
      return coords.x + ':' + coords.y + ':' + coords.z;
    },
    // converts tile cache key to coordinates
    _keyToTileCoords: function (key) {
      var k = key.split(':'),
        coords = new Point(+k[0], +k[1]);
      coords.z = +k[2];
      return coords;
    },
    _removeTile: function (key) {
      var tile = this._tiles[key];
      if (!tile) {
        return;
      }
      remove(tile.el);
      delete this._tiles[key];

      // @event tileunload: TileEvent
      // Fired when a tile is removed (e.g. when a tile goes off the screen).
      this.fire('tileunload', {
        tile: tile.el,
        coords: this._keyToTileCoords(key)
      });
    },
    _initTile: function (tile) {
      addClass(tile, 'leaflet-tile');
      var tileSize = this.getTileSize();
      tile.style.width = tileSize.x + 'px';
      tile.style.height = tileSize.y + 'px';
      tile.onselectstart = falseFn;
      tile.onmousemove = falseFn;

      // update opacity on tiles in IE7-8 because of filter inheritance problems
      if (Browser.ielt9 && this.options.opacity < 1) {
        setOpacity(tile, this.options.opacity);
      }
    },
    _addTile: function (coords, container) {
      var tilePos = this._getTilePos(coords),
        key = this._tileCoordsToKey(coords);
      var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));
      this._initTile(tile);

      // if createTile is defined with a second argument ("done" callback),
      // we know that tile is async and will be ready later; otherwise
      if (this.createTile.length < 2) {
        // mark tile as ready, but delay one frame for opacity animation to happen
        requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
      }
      setPosition(tile, tilePos);

      // save tile in cache
      this._tiles[key] = {
        el: tile,
        coords: coords,
        current: true
      };
      container.appendChild(tile);
      // @event tileloadstart: TileEvent
      // Fired when a tile is requested and starts loading.
      this.fire('tileloadstart', {
        tile: tile,
        coords: coords
      });
    },
    _tileReady: function (coords, err, tile) {
      if (err) {
        // @event tileerror: TileErrorEvent
        // Fired when there is an error loading a tile.
        this.fire('tileerror', {
          error: err,
          tile: tile,
          coords: coords
        });
      }
      var key = this._tileCoordsToKey(coords);
      tile = this._tiles[key];
      if (!tile) {
        return;
      }
      tile.loaded = +new Date();
      if (this._map._fadeAnimated) {
        setOpacity(tile.el, 0);
        cancelAnimFrame(this._fadeFrame);
        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
      } else {
        tile.active = true;
        this._pruneTiles();
      }
      if (!err) {
        addClass(tile.el, 'leaflet-tile-loaded');

        // @event tileload: TileEvent
        // Fired when a tile loads.
        this.fire('tileload', {
          tile: tile.el,
          coords: coords
        });
      }
      if (this._noTilesToLoad()) {
        this._loading = false;
        // @event load: Event
        // Fired when the grid layer loaded all visible tiles.
        this.fire('load');
        if (Browser.ielt9 || !this._map._fadeAnimated) {
          requestAnimFrame(this._pruneTiles, this);
        } else {
          // Wait a bit more than 0.2 secs (the duration of the tile fade-in)
          // to trigger a pruning.
          setTimeout(bind(this._pruneTiles, this), 250);
        }
      }
    },
    _getTilePos: function (coords) {
      return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
    },
    _wrapCoords: function (coords) {
      var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
      newCoords.z = coords.z;
      return newCoords;
    },
    _pxBoundsToTileRange: function (bounds) {
      var tileSize = this.getTileSize();
      return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
    },
    _noTilesToLoad: function () {
      for (var key in this._tiles) {
        if (!this._tiles[key].loaded) {
          return false;
        }
      }
      return true;
    }
  });

  // @factory L.gridLayer(options?: GridLayer options)
  // Creates a new instance of GridLayer with the supplied options.
  function gridLayer(options) {
    return new GridLayer(options);
  }

  /*
   * @class TileLayer
   * @inherits GridLayer
   * @aka L.TileLayer
   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.
   *
   * @example
   *
   * ```js
   * L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'}).addTo(map);
   * ```
   *
   * @section URL template
   * @example
   *
   * A string of the following form:
   *
   * ```
   * 'https://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
   * ```
   *
   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
   *
   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
   *
   * ```
   * L.tileLayer('https://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
   * ```
   */

  var TileLayer = GridLayer.extend({
    // @section
    // @aka TileLayer options
    options: {
      // @option minZoom: Number = 0
      // The minimum zoom level down to which this layer will be displayed (inclusive).
      minZoom: 0,
      // @option maxZoom: Number = 18
      // The maximum zoom level up to which this layer will be displayed (inclusive).
      maxZoom: 18,
      // @option subdomains: String|String[] = 'abc'
      // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
      subdomains: 'abc',
      // @option errorTileUrl: String = ''
      // URL to the tile image to show in place of the tile that failed to load.
      errorTileUrl: '',
      // @option zoomOffset: Number = 0
      // The zoom number used in tile URLs will be offset with this value.
      zoomOffset: 0,
      // @option tms: Boolean = false
      // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
      tms: false,
      // @option zoomReverse: Boolean = false
      // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
      zoomReverse: false,
      // @option detectRetina: Boolean = false
      // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
      detectRetina: false,
      // @option crossOrigin: Boolean|String = false
      // Whether the crossOrigin attribute will be added to the tiles.
      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
      crossOrigin: false,
      // @option referrerPolicy: Boolean|String = false
      // Whether the referrerPolicy attribute will be added to the tiles.
      // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
      // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
      // (e.g. to validate an API token).
      // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
      referrerPolicy: false
    },
    initialize: function (url, options) {
      this._url = url;
      options = setOptions(this, options);

      // detecting retina displays, adjusting tileSize and zoom levels
      if (options.detectRetina && Browser.retina && options.maxZoom > 0) {
        options.tileSize = Math.floor(options.tileSize / 2);
        if (!options.zoomReverse) {
          options.zoomOffset++;
          options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);
        } else {
          options.zoomOffset--;
          options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);
        }
        options.minZoom = Math.max(0, options.minZoom);
      } else if (!options.zoomReverse) {
        // make sure maxZoom is gte minZoom
        options.maxZoom = Math.max(options.minZoom, options.maxZoom);
      } else {
        // make sure minZoom is lte maxZoom
        options.minZoom = Math.min(options.maxZoom, options.minZoom);
      }
      if (typeof options.subdomains === 'string') {
        options.subdomains = options.subdomains.split('');
      }
      this.on('tileunload', this._onTileRemove);
    },
    // @method setUrl(url: String, noRedraw?: Boolean): this
    // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
    // If the URL does not change, the layer will not be redrawn unless
    // the noRedraw parameter is set to false.
    setUrl: function (url, noRedraw) {
      if (this._url === url && noRedraw === undefined) {
        noRedraw = true;
      }
      this._url = url;
      if (!noRedraw) {
        this.redraw();
      }
      return this;
    },
    // @method createTile(coords: Object, done?: Function): HTMLElement
    // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
    // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
    // callback is called when the tile has been loaded.
    createTile: function (coords, done) {
      var tile = document.createElement('img');
      on(tile, 'load', bind(this._tileOnLoad, this, done, tile));
      on(tile, 'error', bind(this._tileOnError, this, done, tile));
      if (this.options.crossOrigin || this.options.crossOrigin === '') {
        tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
      }

      // for this new option we follow the documented behavior
      // more closely by only setting the property when string
      if (typeof this.options.referrerPolicy === 'string') {
        tile.referrerPolicy = this.options.referrerPolicy;
      }

      // The alt attribute is set to the empty string,
      // allowing screen readers to ignore the decorative image tiles.
      // https://www.w3.org/WAI/tutorials/images/decorative/
      // https://www.w3.org/TR/html-aria/#el-img-empty-alt
      tile.alt = '';
      tile.src = this.getTileUrl(coords);
      return tile;
    },
    // @section Extension methods
    // @uninheritable
    // Layers extending `TileLayer` might reimplement the following method.
    // @method getTileUrl(coords: Object): String
    // Called only internally, returns the URL for a tile given its coordinates.
    // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
    getTileUrl: function (coords) {
      var data = {
        r: Browser.retina ? '@2x' : '',
        s: this._getSubdomain(coords),
        x: coords.x,
        y: coords.y,
        z: this._getZoomForUrl()
      };
      if (this._map && !this._map.options.crs.infinite) {
        var invertedY = this._globalTileRange.max.y - coords.y;
        if (this.options.tms) {
          data['y'] = invertedY;
        }
        data['-y'] = invertedY;
      }
      return template(this._url, extend(data, this.options));
    },
    _tileOnLoad: function (done, tile) {
      // For https://github.com/Leaflet/Leaflet/issues/3332
      if (Browser.ielt9) {
        setTimeout(bind(done, this, null, tile), 0);
      } else {
        done(null, tile);
      }
    },
    _tileOnError: function (done, tile, e) {
      var errorUrl = this.options.errorTileUrl;
      if (errorUrl && tile.getAttribute('src') !== errorUrl) {
        tile.src = errorUrl;
      }
      done(e, tile);
    },
    _onTileRemove: function (e) {
      e.tile.onload = null;
    },
    _getZoomForUrl: function () {
      var zoom = this._tileZoom,
        maxZoom = this.options.maxZoom,
        zoomReverse = this.options.zoomReverse,
        zoomOffset = this.options.zoomOffset;
      if (zoomReverse) {
        zoom = maxZoom - zoom;
      }
      return zoom + zoomOffset;
    },
    _getSubdomain: function (tilePoint) {
      var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
      return this.options.subdomains[index];
    },
    // stops loading all tiles in the background layer
    _abortLoading: function () {
      var i, tile;
      for (i in this._tiles) {
        if (this._tiles[i].coords.z !== this._tileZoom) {
          tile = this._tiles[i].el;
          tile.onload = falseFn;
          tile.onerror = falseFn;
          if (!tile.complete) {
            tile.src = emptyImageUrl;
            var coords = this._tiles[i].coords;
            remove(tile);
            delete this._tiles[i];
            // @event tileabort: TileEvent
            // Fired when a tile was loading but is now not wanted.
            this.fire('tileabort', {
              tile: tile,
              coords: coords
            });
          }
        }
      }
    },
    _removeTile: function (key) {
      var tile = this._tiles[key];
      if (!tile) {
        return;
      }

      // Cancels any pending http requests associated with the tile
      tile.el.setAttribute('src', emptyImageUrl);
      return GridLayer.prototype._removeTile.call(this, key);
    },
    _tileReady: function (coords, err, tile) {
      if (!this._map || tile && tile.getAttribute('src') === emptyImageUrl) {
        return;
      }
      return GridLayer.prototype._tileReady.call(this, coords, err, tile);
    }
  });

  // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
  // Instantiates a tile layer object given a `URL template` and optionally an options object.

  function tileLayer(url, options) {
    return new TileLayer(url, options);
  }

  /*
   * @class TileLayer.WMS
   * @inherits TileLayer
   * @aka L.TileLayer.WMS
   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
   *
   * @example
   *
   * ```js
   * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
   * 	layers: 'nexrad-n0r-900913',
   * 	format: 'image/png',
   * 	transparent: true,
   * 	attribution: "Weather data © 2012 IEM Nexrad"
   * });
   * ```
   */

  var TileLayerWMS = TileLayer.extend({
    // @section
    // @aka TileLayer.WMS options
    // If any custom options not documented here are used, they will be sent to the
    // WMS server as extra parameters in each request URL. This can be useful for
    // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
    defaultWmsParams: {
      service: 'WMS',
      request: 'GetMap',
      // @option layers: String = ''
      // **(required)** Comma-separated list of WMS layers to show.
      layers: '',
      // @option styles: String = ''
      // Comma-separated list of WMS styles.
      styles: '',
      // @option format: String = 'image/jpeg'
      // WMS image format (use `'image/png'` for layers with transparency).
      format: 'image/jpeg',
      // @option transparent: Boolean = false
      // If `true`, the WMS service will return images with transparency.
      transparent: false,
      // @option version: String = '1.1.1'
      // Version of the WMS service to use
      version: '1.1.1'
    },
    options: {
      // @option crs: CRS = null
      // Coordinate Reference System to use for the WMS requests, defaults to
      // map CRS. Don't change this if you're not sure what it means.
      crs: null,
      // @option uppercase: Boolean = false
      // If `true`, WMS request parameter keys will be uppercase.
      uppercase: false
    },
    initialize: function (url, options) {
      this._url = url;
      var wmsParams = extend({}, this.defaultWmsParams);

      // all keys that are not TileLayer options go to WMS params
      for (var i in options) {
        if (!(i in this.options)) {
          wmsParams[i] = options[i];
        }
      }
      options = setOptions(this, options);
      var realRetina = options.detectRetina && Browser.retina ? 2 : 1;
      var tileSize = this.getTileSize();
      wmsParams.width = tileSize.x * realRetina;
      wmsParams.height = tileSize.y * realRetina;
      this.wmsParams = wmsParams;
    },
    onAdd: function (map) {
      this._crs = this.options.crs || map.options.crs;
      this._wmsVersion = parseFloat(this.wmsParams.version);
      var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
      this.wmsParams[projectionKey] = this._crs.code;
      TileLayer.prototype.onAdd.call(this, map);
    },
    getTileUrl: function (coords) {
      var tileBounds = this._tileCoordsToNwSe(coords),
        crs = this._crs,
        bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),
        min = bounds.min,
        max = bounds.max,
        bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(','),
        url = TileLayer.prototype.getTileUrl.call(this, coords);
      return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
    },
    // @method setParams(params: Object, noRedraw?: Boolean): this
    // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
    setParams: function (params, noRedraw) {
      extend(this.wmsParams, params);
      if (!noRedraw) {
        this.redraw();
      }
      return this;
    }
  });

  // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
  function tileLayerWMS(url, options) {
    return new TileLayerWMS(url, options);
  }
  TileLayer.WMS = TileLayerWMS;
  tileLayer.wms = tileLayerWMS;

  /*
   * @class Renderer
   * @inherits Layer
   * @aka L.Renderer
   *
   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
   * DOM container of the renderer, its bounds, and its zoom animation.
   *
   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
   * itself can be added or removed to the map. All paths use a renderer, which can
   * be implicit (the map will decide the type of renderer and use it automatically)
   * or explicit (using the [`renderer`](#path-renderer) option of the path).
   *
   * Do not use this class directly, use `SVG` and `Canvas` instead.
   *
   * @event update: Event
   * Fired when the renderer updates its bounds, center and zoom, for example when
   * its map has moved
   */

  var Renderer = Layer.extend({
    // @section
    // @aka Renderer options
    options: {
      // @option padding: Number = 0.1
      // How much to extend the clip area around the map view (relative to its size)
      // e.g. 0.1 would be 10% of map view in each direction
      padding: 0.1
    },
    initialize: function (options) {
      setOptions(this, options);
      stamp(this);
      this._layers = this._layers || {};
    },
    onAdd: function () {
      if (!this._container) {
        this._initContainer(); // defined by renderer implementations

        // always keep transform-origin as 0 0
        addClass(this._container, 'leaflet-zoom-animated');
      }
      this.getPane().appendChild(this._container);
      this._update();
      this.on('update', this._updatePaths, this);
    },
    onRemove: function () {
      this.off('update', this._updatePaths, this);
      this._destroyContainer();
    },
    getEvents: function () {
      var events = {
        viewreset: this._reset,
        zoom: this._onZoom,
        moveend: this._update,
        zoomend: this._onZoomEnd
      };
      if (this._zoomAnimated) {
        events.zoomanim = this._onAnimZoom;
      }
      return events;
    },
    _onAnimZoom: function (ev) {
      this._updateTransform(ev.center, ev.zoom);
    },
    _onZoom: function () {
      this._updateTransform(this._map.getCenter(), this._map.getZoom());
    },
    _updateTransform: function (center, zoom) {
      var scale = this._map.getZoomScale(zoom, this._zoom),
        viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
        currentCenterPoint = this._map.project(this._center, zoom),
        topLeftOffset = viewHalf.multiplyBy(-scale).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom));
      if (Browser.any3d) {
        setTransform(this._container, topLeftOffset, scale);
      } else {
        setPosition(this._container, topLeftOffset);
      }
    },
    _reset: function () {
      this._update();
      this._updateTransform(this._center, this._zoom);
      for (var id in this._layers) {
        this._layers[id]._reset();
      }
    },
    _onZoomEnd: function () {
      for (var id in this._layers) {
        this._layers[id]._project();
      }
    },
    _updatePaths: function () {
      for (var id in this._layers) {
        this._layers[id]._update();
      }
    },
    _update: function () {
      // Update pixel bounds of renderer container (for positioning/sizing/clipping later)
      // Subclasses are responsible of firing the 'update' event.
      var p = this.options.padding,
        size = this._map.getSize(),
        min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();
      this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());
      this._center = this._map.getCenter();
      this._zoom = this._map.getZoom();
    }
  });

  /*
   * @class Canvas
   * @inherits Renderer
   * @aka L.Canvas
   *
   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](https://caniuse.com/canvas), Canvas is not
   * available in all web browsers, notably IE8, and overlapping geometries might
   * not display properly in some edge cases.
   *
   * @example
   *
   * Use Canvas by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.canvas()
   * });
   * ```
   *
   * Use a Canvas renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.canvas({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */

  var Canvas = Renderer.extend({
    // @section
    // @aka Canvas options
    options: {
      // @option tolerance: Number = 0
      // How much to extend the click tolerance around a path/object on the map.
      tolerance: 0
    },
    getEvents: function () {
      var events = Renderer.prototype.getEvents.call(this);
      events.viewprereset = this._onViewPreReset;
      return events;
    },
    _onViewPreReset: function () {
      // Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
      this._postponeUpdatePaths = true;
    },
    onAdd: function () {
      Renderer.prototype.onAdd.call(this);

      // Redraw vectors since canvas is cleared upon removal,
      // in case of removing the renderer itself from the map.
      this._draw();
    },
    _initContainer: function () {
      var container = this._container = document.createElement('canvas');
      on(container, 'mousemove', this._onMouseMove, this);
      on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
      on(container, 'mouseout', this._handleMouseOut, this);
      container['_leaflet_disable_events'] = true;
      this._ctx = container.getContext('2d');
    },
    _destroyContainer: function () {
      cancelAnimFrame(this._redrawRequest);
      delete this._ctx;
      remove(this._container);
      off(this._container);
      delete this._container;
    },
    _updatePaths: function () {
      if (this._postponeUpdatePaths) {
        return;
      }
      var layer;
      this._redrawBounds = null;
      for (var id in this._layers) {
        layer = this._layers[id];
        layer._update();
      }
      this._redraw();
    },
    _update: function () {
      if (this._map._animatingZoom && this._bounds) {
        return;
      }
      Renderer.prototype._update.call(this);
      var b = this._bounds,
        container = this._container,
        size = b.getSize(),
        m = Browser.retina ? 2 : 1;
      setPosition(container, b.min);

      // set canvas size (also clearing it); use double size on retina
      container.width = m * size.x;
      container.height = m * size.y;
      container.style.width = size.x + 'px';
      container.style.height = size.y + 'px';
      if (Browser.retina) {
        this._ctx.scale(2, 2);
      }

      // translate so we use the same path coordinates after canvas element moves
      this._ctx.translate(-b.min.x, -b.min.y);

      // Tell paths to redraw themselves
      this.fire('update');
    },
    _reset: function () {
      Renderer.prototype._reset.call(this);
      if (this._postponeUpdatePaths) {
        this._postponeUpdatePaths = false;
        this._updatePaths();
      }
    },
    _initPath: function (layer) {
      this._updateDashArray(layer);
      this._layers[stamp(layer)] = layer;
      var order = layer._order = {
        layer: layer,
        prev: this._drawLast,
        next: null
      };
      if (this._drawLast) {
        this._drawLast.next = order;
      }
      this._drawLast = order;
      this._drawFirst = this._drawFirst || this._drawLast;
    },
    _addPath: function (layer) {
      this._requestRedraw(layer);
    },
    _removePath: function (layer) {
      var order = layer._order;
      var next = order.next;
      var prev = order.prev;
      if (next) {
        next.prev = prev;
      } else {
        this._drawLast = prev;
      }
      if (prev) {
        prev.next = next;
      } else {
        this._drawFirst = next;
      }
      delete layer._order;
      delete this._layers[stamp(layer)];
      this._requestRedraw(layer);
    },
    _updatePath: function (layer) {
      // Redraw the union of the layer's old pixel
      // bounds and the new pixel bounds.
      this._extendRedrawBounds(layer);
      layer._project();
      layer._update();
      // The redraw will extend the redraw bounds
      // with the new pixel bounds.
      this._requestRedraw(layer);
    },
    _updateStyle: function (layer) {
      this._updateDashArray(layer);
      this._requestRedraw(layer);
    },
    _updateDashArray: function (layer) {
      if (typeof layer.options.dashArray === 'string') {
        var parts = layer.options.dashArray.split(/[, ]+/),
          dashArray = [],
          dashValue,
          i;
        for (i = 0; i < parts.length; i++) {
          dashValue = Number(parts[i]);
          // Ignore dash array containing invalid lengths
          if (isNaN(dashValue)) {
            return;
          }
          dashArray.push(dashValue);
        }
        layer.options._dashArray = dashArray;
      } else {
        layer.options._dashArray = layer.options.dashArray;
      }
    },
    _requestRedraw: function (layer) {
      if (!this._map) {
        return;
      }
      this._extendRedrawBounds(layer);
      this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
    },
    _extendRedrawBounds: function (layer) {
      if (layer._pxBounds) {
        var padding = (layer.options.weight || 0) + 1;
        this._redrawBounds = this._redrawBounds || new Bounds();
        this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
        this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
      }
    },
    _redraw: function () {
      this._redrawRequest = null;
      if (this._redrawBounds) {
        this._redrawBounds.min._floor();
        this._redrawBounds.max._ceil();
      }
      this._clear(); // clear layers in redraw bounds
      this._draw(); // draw layers

      this._redrawBounds = null;
    },
    _clear: function () {
      var bounds = this._redrawBounds;
      if (bounds) {
        var size = bounds.getSize();
        this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
      } else {
        this._ctx.save();
        this._ctx.setTransform(1, 0, 0, 1, 0, 0);
        this._ctx.clearRect(0, 0, this._container.width, this._container.height);
        this._ctx.restore();
      }
    },
    _draw: function () {
      var layer,
        bounds = this._redrawBounds;
      this._ctx.save();
      if (bounds) {
        var size = bounds.getSize();
        this._ctx.beginPath();
        this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
        this._ctx.clip();
      }
      this._drawing = true;
      for (var order = this._drawFirst; order; order = order.next) {
        layer = order.layer;
        if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
          layer._updatePath();
        }
      }
      this._drawing = false;
      this._ctx.restore(); // Restore state before clipping.
    },

    _updatePoly: function (layer, closed) {
      if (!this._drawing) {
        return;
      }
      var i,
        j,
        len2,
        p,
        parts = layer._parts,
        len = parts.length,
        ctx = this._ctx;
      if (!len) {
        return;
      }
      ctx.beginPath();
      for (i = 0; i < len; i++) {
        for (j = 0, len2 = parts[i].length; j < len2; j++) {
          p = parts[i][j];
          ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
        }
        if (closed) {
          ctx.closePath();
        }
      }
      this._fillStroke(ctx, layer);

      // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
    },

    _updateCircle: function (layer) {
      if (!this._drawing || layer._empty()) {
        return;
      }
      var p = layer._point,
        ctx = this._ctx,
        r = Math.max(Math.round(layer._radius), 1),
        s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;
      if (s !== 1) {
        ctx.save();
        ctx.scale(1, s);
      }
      ctx.beginPath();
      ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);
      if (s !== 1) {
        ctx.restore();
      }
      this._fillStroke(ctx, layer);
    },
    _fillStroke: function (ctx, layer) {
      var options = layer.options;
      if (options.fill) {
        ctx.globalAlpha = options.fillOpacity;
        ctx.fillStyle = options.fillColor || options.color;
        ctx.fill(options.fillRule || 'evenodd');
      }
      if (options.stroke && options.weight !== 0) {
        if (ctx.setLineDash) {
          ctx.setLineDash(layer.options && layer.options._dashArray || []);
        }
        ctx.globalAlpha = options.opacity;
        ctx.lineWidth = options.weight;
        ctx.strokeStyle = options.color;
        ctx.lineCap = options.lineCap;
        ctx.lineJoin = options.lineJoin;
        ctx.stroke();
      }
    },
    // Canvas obviously doesn't have mouse events for individual drawn objects,
    // so we emulate that by calculating what's under the mouse on mousemove/click manually

    _onClick: function (e) {
      var point = this._map.mouseEventToLayerPoint(e),
        layer,
        clickedLayer;
      for (var order = this._drawFirst; order; order = order.next) {
        layer = order.layer;
        if (layer.options.interactive && layer._containsPoint(point)) {
          if (!(e.type === 'click' || e.type === 'preclick') || !this._map._draggableMoved(layer)) {
            clickedLayer = layer;
          }
        }
      }
      this._fireEvent(clickedLayer ? [clickedLayer] : false, e);
    },
    _onMouseMove: function (e) {
      if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
        return;
      }
      var point = this._map.mouseEventToLayerPoint(e);
      this._handleMouseHover(e, point);
    },
    _handleMouseOut: function (e) {
      var layer = this._hoveredLayer;
      if (layer) {
        // if we're leaving the layer, fire mouseout
        removeClass(this._container, 'leaflet-interactive');
        this._fireEvent([layer], e, 'mouseout');
        this._hoveredLayer = null;
        this._mouseHoverThrottled = false;
      }
    },
    _handleMouseHover: function (e, point) {
      if (this._mouseHoverThrottled) {
        return;
      }
      var layer, candidateHoveredLayer;
      for (var order = this._drawFirst; order; order = order.next) {
        layer = order.layer;
        if (layer.options.interactive && layer._containsPoint(point)) {
          candidateHoveredLayer = layer;
        }
      }
      if (candidateHoveredLayer !== this._hoveredLayer) {
        this._handleMouseOut(e);
        if (candidateHoveredLayer) {
          addClass(this._container, 'leaflet-interactive'); // change cursor
          this._fireEvent([candidateHoveredLayer], e, 'mouseover');
          this._hoveredLayer = candidateHoveredLayer;
        }
      }
      this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);
      this._mouseHoverThrottled = true;
      setTimeout(bind(function () {
        this._mouseHoverThrottled = false;
      }, this), 32);
    },
    _fireEvent: function (layers, e, type) {
      this._map._fireDOMEvent(e, type || e.type, layers);
    },
    _bringToFront: function (layer) {
      var order = layer._order;
      if (!order) {
        return;
      }
      var next = order.next;
      var prev = order.prev;
      if (next) {
        next.prev = prev;
      } else {
        // Already last
        return;
      }
      if (prev) {
        prev.next = next;
      } else if (next) {
        // Update first entry unless this is the
        // single entry
        this._drawFirst = next;
      }
      order.prev = this._drawLast;
      this._drawLast.next = order;
      order.next = null;
      this._drawLast = order;
      this._requestRedraw(layer);
    },
    _bringToBack: function (layer) {
      var order = layer._order;
      if (!order) {
        return;
      }
      var next = order.next;
      var prev = order.prev;
      if (prev) {
        prev.next = next;
      } else {
        // Already first
        return;
      }
      if (next) {
        next.prev = prev;
      } else if (prev) {
        // Update last entry unless this is the
        // single entry
        this._drawLast = prev;
      }
      order.prev = null;
      order.next = this._drawFirst;
      this._drawFirst.prev = order;
      this._drawFirst = order;
      this._requestRedraw(layer);
    }
  });

  // @factory L.canvas(options?: Renderer options)
  // Creates a Canvas renderer with the given options.
  function canvas(options) {
    return Browser.canvas ? new Canvas(options) : null;
  }

  /*
   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
   */

  var vmlCreate = function () {
    try {
      document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
      return function (name) {
        return document.createElement('<lvml:' + name + ' class="lvml">');
      };
    } catch (e) {
      // Do not return fn from catch block so `e` can be garbage collected
      // See https://github.com/Leaflet/Leaflet/pull/7279
    }
    return function (name) {
      return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
    };
  }();

  /*
   * @class SVG
   *
   *
   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
   * with old versions of Internet Explorer.
   */

  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences
  var vmlMixin = {
    _initContainer: function () {
      this._container = create$1('div', 'leaflet-vml-container');
    },
    _update: function () {
      if (this._map._animatingZoom) {
        return;
      }
      Renderer.prototype._update.call(this);
      this.fire('update');
    },
    _initPath: function (layer) {
      var container = layer._container = vmlCreate('shape');
      addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));
      container.coordsize = '1 1';
      layer._path = vmlCreate('path');
      container.appendChild(layer._path);
      this._updateStyle(layer);
      this._layers[stamp(layer)] = layer;
    },
    _addPath: function (layer) {
      var container = layer._container;
      this._container.appendChild(container);
      if (layer.options.interactive) {
        layer.addInteractiveTarget(container);
      }
    },
    _removePath: function (layer) {
      var container = layer._container;
      remove(container);
      layer.removeInteractiveTarget(container);
      delete this._layers[stamp(layer)];
    },
    _updateStyle: function (layer) {
      var stroke = layer._stroke,
        fill = layer._fill,
        options = layer.options,
        container = layer._container;
      container.stroked = !!options.stroke;
      container.filled = !!options.fill;
      if (options.stroke) {
        if (!stroke) {
          stroke = layer._stroke = vmlCreate('stroke');
        }
        container.appendChild(stroke);
        stroke.weight = options.weight + 'px';
        stroke.color = options.color;
        stroke.opacity = options.opacity;
        if (options.dashArray) {
          stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');
        } else {
          stroke.dashStyle = '';
        }
        stroke.endcap = options.lineCap.replace('butt', 'flat');
        stroke.joinstyle = options.lineJoin;
      } else if (stroke) {
        container.removeChild(stroke);
        layer._stroke = null;
      }
      if (options.fill) {
        if (!fill) {
          fill = layer._fill = vmlCreate('fill');
        }
        container.appendChild(fill);
        fill.color = options.fillColor || options.color;
        fill.opacity = options.fillOpacity;
      } else if (fill) {
        container.removeChild(fill);
        layer._fill = null;
      }
    },
    _updateCircle: function (layer) {
      var p = layer._point.round(),
        r = Math.round(layer._radius),
        r2 = Math.round(layer._radiusY || r);
      this._setPath(layer, layer._empty() ? 'M0 0' : 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + 65535 * 360);
    },
    _setPath: function (layer, path) {
      layer._path.v = path;
    },
    _bringToFront: function (layer) {
      toFront(layer._container);
    },
    _bringToBack: function (layer) {
      toBack(layer._container);
    }
  };
  var create = Browser.vml ? vmlCreate : svgCreate;

  /*
   * @class SVG
   * @inherits Renderer
   * @aka L.SVG
   *
   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](https://caniuse.com/svg), SVG is not
   * available in all web browsers, notably Android 2.x and 3.x.
   *
   * Although SVG is not available on IE7 and IE8, these browsers support
   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
   * (a now deprecated technology), and the SVG renderer will fall back to VML in
   * this case.
   *
   * @example
   *
   * Use SVG by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.svg()
   * });
   * ```
   *
   * Use a SVG renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.svg({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */

  var SVG = Renderer.extend({
    _initContainer: function () {
      this._container = create('svg');

      // makes it possible to click through svg root; we'll reset it back in individual paths
      this._container.setAttribute('pointer-events', 'none');
      this._rootGroup = create('g');
      this._container.appendChild(this._rootGroup);
    },
    _destroyContainer: function () {
      remove(this._container);
      off(this._container);
      delete this._container;
      delete this._rootGroup;
      delete this._svgSize;
    },
    _update: function () {
      if (this._map._animatingZoom && this._bounds) {
        return;
      }
      Renderer.prototype._update.call(this);
      var b = this._bounds,
        size = b.getSize(),
        container = this._container;

      // set size of svg-container if changed
      if (!this._svgSize || !this._svgSize.equals(size)) {
        this._svgSize = size;
        container.setAttribute('width', size.x);
        container.setAttribute('height', size.y);
      }

      // movement: update container viewBox so that we don't have to change coordinates of individual layers
      setPosition(container, b.min);
      container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));
      this.fire('update');
    },
    // methods below are called by vector layers implementations

    _initPath: function (layer) {
      var path = layer._path = create('path');

      // @namespace Path
      // @option className: String = null
      // Custom class name set on an element. Only for SVG renderer.
      if (layer.options.className) {
        addClass(path, layer.options.className);
      }
      if (layer.options.interactive) {
        addClass(path, 'leaflet-interactive');
      }
      this._updateStyle(layer);
      this._layers[stamp(layer)] = layer;
    },
    _addPath: function (layer) {
      if (!this._rootGroup) {
        this._initContainer();
      }
      this._rootGroup.appendChild(layer._path);
      layer.addInteractiveTarget(layer._path);
    },
    _removePath: function (layer) {
      remove(layer._path);
      layer.removeInteractiveTarget(layer._path);
      delete this._layers[stamp(layer)];
    },
    _updatePath: function (layer) {
      layer._project();
      layer._update();
    },
    _updateStyle: function (layer) {
      var path = layer._path,
        options = layer.options;
      if (!path) {
        return;
      }
      if (options.stroke) {
        path.setAttribute('stroke', options.color);
        path.setAttribute('stroke-opacity', options.opacity);
        path.setAttribute('stroke-width', options.weight);
        path.setAttribute('stroke-linecap', options.lineCap);
        path.setAttribute('stroke-linejoin', options.lineJoin);
        if (options.dashArray) {
          path.setAttribute('stroke-dasharray', options.dashArray);
        } else {
          path.removeAttribute('stroke-dasharray');
        }
        if (options.dashOffset) {
          path.setAttribute('stroke-dashoffset', options.dashOffset);
        } else {
          path.removeAttribute('stroke-dashoffset');
        }
      } else {
        path.setAttribute('stroke', 'none');
      }
      if (options.fill) {
        path.setAttribute('fill', options.fillColor || options.color);
        path.setAttribute('fill-opacity', options.fillOpacity);
        path.setAttribute('fill-rule', options.fillRule || 'evenodd');
      } else {
        path.setAttribute('fill', 'none');
      }
    },
    _updatePoly: function (layer, closed) {
      this._setPath(layer, pointsToPath(layer._parts, closed));
    },
    _updateCircle: function (layer) {
      var p = layer._point,
        r = Math.max(Math.round(layer._radius), 1),
        r2 = Math.max(Math.round(layer._radiusY), 1) || r,
        arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

      // drawing a circle with two half-arcs
      var d = layer._empty() ? 'M0 0' : 'M' + (p.x - r) + ',' + p.y + arc + r * 2 + ',0 ' + arc + -r * 2 + ',0 ';
      this._setPath(layer, d);
    },
    _setPath: function (layer, path) {
      layer._path.setAttribute('d', path);
    },
    // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
    _bringToFront: function (layer) {
      toFront(layer._path);
    },
    _bringToBack: function (layer) {
      toBack(layer._path);
    }
  });
  if (Browser.vml) {
    SVG.include(vmlMixin);
  }

  // @namespace SVG
  // @factory L.svg(options?: Renderer options)
  // Creates a SVG renderer with the given options.
  function svg(options) {
    return Browser.svg || Browser.vml ? new SVG(options) : null;
  }
  Map.include({
    // @namespace Map; @method getRenderer(layer: Path): Renderer
    // Returns the instance of `Renderer` that should be used to render the given
    // `Path`. It will ensure that the `renderer` options of the map and paths
    // are respected, and that the renderers do exist on the map.
    getRenderer: function (layer) {
      // @namespace Path; @option renderer: Renderer
      // Use this specific instance of `Renderer` for this path. Takes
      // precedence over the map's [default renderer](#map-renderer).
      var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
      if (!renderer) {
        renderer = this._renderer = this._createRenderer();
      }
      if (!this.hasLayer(renderer)) {
        this.addLayer(renderer);
      }
      return renderer;
    },
    _getPaneRenderer: function (name) {
      if (name === 'overlayPane' || name === undefined) {
        return false;
      }
      var renderer = this._paneRenderers[name];
      if (renderer === undefined) {
        renderer = this._createRenderer({
          pane: name
        });
        this._paneRenderers[name] = renderer;
      }
      return renderer;
    },
    _createRenderer: function (options) {
      // @namespace Map; @option preferCanvas: Boolean = false
      // Whether `Path`s should be rendered on a `Canvas` renderer.
      // By default, all `Path`s are rendered in a `SVG` renderer.
      return this.options.preferCanvas && canvas(options) || svg(options);
    }
  });

  /*
   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
   */

  /*
   * @class Rectangle
   * @aka L.Rectangle
   * @inherits Polygon
   *
   * A class for drawing rectangle overlays on a map. Extends `Polygon`.
   *
   * @example
   *
   * ```js
   * // define rectangle geographical bounds
   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
   *
   * // create an orange rectangle
   * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
   *
   * // zoom the map to the rectangle bounds
   * map.fitBounds(bounds);
   * ```
   *
   */

  var Rectangle = Polygon.extend({
    initialize: function (latLngBounds, options) {
      Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
    },
    // @method setBounds(latLngBounds: LatLngBounds): this
    // Redraws the rectangle with the passed bounds.
    setBounds: function (latLngBounds) {
      return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
    },
    _boundsToLatLngs: function (latLngBounds) {
      latLngBounds = toLatLngBounds(latLngBounds);
      return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];
    }
  });

  // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
  function rectangle(latLngBounds, options) {
    return new Rectangle(latLngBounds, options);
  }
  SVG.create = create;
  SVG.pointsToPath = pointsToPath;
  GeoJSON.geometryToLayer = geometryToLayer;
  GeoJSON.coordsToLatLng = coordsToLatLng;
  GeoJSON.coordsToLatLngs = coordsToLatLngs;
  GeoJSON.latLngToCoords = latLngToCoords;
  GeoJSON.latLngsToCoords = latLngsToCoords;
  GeoJSON.getFeature = getFeature;
  GeoJSON.asFeature = asFeature;

  /*
   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
   * (zoom to a selected bounding box), enabled by default.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
    // @option boxZoom: Boolean = true
    // Whether the map can be zoomed to a rectangular area specified by
    // dragging the mouse while pressing the shift key.
    boxZoom: true
  });
  var BoxZoom = Handler.extend({
    initialize: function (map) {
      this._map = map;
      this._container = map._container;
      this._pane = map._panes.overlayPane;
      this._resetStateTimeout = 0;
      map.on('unload', this._destroy, this);
    },
    addHooks: function () {
      on(this._container, 'mousedown', this._onMouseDown, this);
    },
    removeHooks: function () {
      off(this._container, 'mousedown', this._onMouseDown, this);
    },
    moved: function () {
      return this._moved;
    },
    _destroy: function () {
      remove(this._pane);
      delete this._pane;
    },
    _resetState: function () {
      this._resetStateTimeout = 0;
      this._moved = false;
    },
    _clearDeferredResetState: function () {
      if (this._resetStateTimeout !== 0) {
        clearTimeout(this._resetStateTimeout);
        this._resetStateTimeout = 0;
      }
    },
    _onMouseDown: function (e) {
      if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
        return false;
      }

      // Clear the deferred resetState if it hasn't executed yet, otherwise it
      // will interrupt the interaction and orphan a box element in the container.
      this._clearDeferredResetState();
      this._resetState();
      disableTextSelection();
      disableImageDrag();
      this._startPoint = this._map.mouseEventToContainerPoint(e);
      on(document, {
        contextmenu: stop,
        mousemove: this._onMouseMove,
        mouseup: this._onMouseUp,
        keydown: this._onKeyDown
      }, this);
    },
    _onMouseMove: function (e) {
      if (!this._moved) {
        this._moved = true;
        this._box = create$1('div', 'leaflet-zoom-box', this._container);
        addClass(this._container, 'leaflet-crosshair');
        this._map.fire('boxzoomstart');
      }
      this._point = this._map.mouseEventToContainerPoint(e);
      var bounds = new Bounds(this._point, this._startPoint),
        size = bounds.getSize();
      setPosition(this._box, bounds.min);
      this._box.style.width = size.x + 'px';
      this._box.style.height = size.y + 'px';
    },
    _finish: function () {
      if (this._moved) {
        remove(this._box);
        removeClass(this._container, 'leaflet-crosshair');
      }
      enableTextSelection();
      enableImageDrag();
      off(document, {
        contextmenu: stop,
        mousemove: this._onMouseMove,
        mouseup: this._onMouseUp,
        keydown: this._onKeyDown
      }, this);
    },
    _onMouseUp: function (e) {
      if (e.which !== 1 && e.button !== 1) {
        return;
      }
      this._finish();
      if (!this._moved) {
        return;
      }
      // Postpone to next JS tick so internal click event handling
      // still see it as "moved".
      this._clearDeferredResetState();
      this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
      var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));
      this._map.fitBounds(bounds).fire('boxzoomend', {
        boxZoomBounds: bounds
      });
    },
    _onKeyDown: function (e) {
      if (e.keyCode === 27) {
        this._finish();
        this._clearDeferredResetState();
        this._resetState();
      }
    }
  });

  // @section Handlers
  // @property boxZoom: Handler
  // Box (shift-drag with mouse) zoom handler.
  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);

  /*
   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
   */

  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
    // @option doubleClickZoom: Boolean|String = true
    // Whether the map can be zoomed in by double clicking on it and
    // zoomed out by double clicking while holding shift. If passed
    // `'center'`, double-click zoom will zoom to the center of the
    //  view regardless of where the mouse was.
    doubleClickZoom: true
  });
  var DoubleClickZoom = Handler.extend({
    addHooks: function () {
      this._map.on('dblclick', this._onDoubleClick, this);
    },
    removeHooks: function () {
      this._map.off('dblclick', this._onDoubleClick, this);
    },
    _onDoubleClick: function (e) {
      var map = this._map,
        oldZoom = map.getZoom(),
        delta = map.options.zoomDelta,
        zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
      if (map.options.doubleClickZoom === 'center') {
        map.setZoom(zoom);
      } else {
        map.setZoomAround(e.containerPoint, zoom);
      }
    }
  });

  // @section Handlers
  //
  // Map properties include interaction handlers that allow you to control
  // interaction behavior in runtime, enabling or disabling certain features such
  // as dragging or touch zoom (see `Handler` methods). For example:
  //
  // ```js
  // map.doubleClickZoom.disable();
  // ```
  //
  // @property doubleClickZoom: Handler
  // Double click zoom handler.
  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);

  /*
   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
    // @option dragging: Boolean = true
    // Whether the map is draggable with mouse/touch or not.
    dragging: true,
    // @section Panning Inertia Options
    // @option inertia: Boolean = *
    // If enabled, panning of the map will have an inertia effect where
    // the map builds momentum while dragging and continues moving in
    // the same direction for some time. Feels especially nice on touch
    // devices. Enabled by default.
    inertia: true,
    // @option inertiaDeceleration: Number = 3000
    // The rate with which the inertial movement slows down, in pixels/second².
    inertiaDeceleration: 3400,
    // px/s^2

    // @option inertiaMaxSpeed: Number = Infinity
    // Max speed of the inertial movement, in pixels/second.
    inertiaMaxSpeed: Infinity,
    // px/s

    // @option easeLinearity: Number = 0.2
    easeLinearity: 0.2,
    // TODO refactor, move to CRS
    // @option worldCopyJump: Boolean = false
    // With this option enabled, the map tracks when you pan to another "copy"
    // of the world and seamlessly jumps to the original one so that all overlays
    // like markers and vector layers are still visible.
    worldCopyJump: false,
    // @option maxBoundsViscosity: Number = 0.0
    // If `maxBounds` is set, this option will control how solid the bounds
    // are when dragging the map around. The default value of `0.0` allows the
    // user to drag outside the bounds at normal speed, higher values will
    // slow down map dragging outside bounds, and `1.0` makes the bounds fully
    // solid, preventing the user from dragging outside the bounds.
    maxBoundsViscosity: 0.0
  });
  var Drag = Handler.extend({
    addHooks: function () {
      if (!this._draggable) {
        var map = this._map;
        this._draggable = new Draggable(map._mapPane, map._container);
        this._draggable.on({
          dragstart: this._onDragStart,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this);
        this._draggable.on('predrag', this._onPreDragLimit, this);
        if (map.options.worldCopyJump) {
          this._draggable.on('predrag', this._onPreDragWrap, this);
          map.on('zoomend', this._onZoomEnd, this);
          map.whenReady(this._onZoomEnd, this);
        }
      }
      addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
      this._draggable.enable();
      this._positions = [];
      this._times = [];
    },
    removeHooks: function () {
      removeClass(this._map._container, 'leaflet-grab');
      removeClass(this._map._container, 'leaflet-touch-drag');
      this._draggable.disable();
    },
    moved: function () {
      return this._draggable && this._draggable._moved;
    },
    moving: function () {
      return this._draggable && this._draggable._moving;
    },
    _onDragStart: function () {
      var map = this._map;
      map._stop();
      if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
        var bounds = toLatLngBounds(this._map.options.maxBounds);
        this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));
        this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
      } else {
        this._offsetLimit = null;
      }
      map.fire('movestart').fire('dragstart');
      if (map.options.inertia) {
        this._positions = [];
        this._times = [];
      }
    },
    _onDrag: function (e) {
      if (this._map.options.inertia) {
        var time = this._lastTime = +new Date(),
          pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
        this._positions.push(pos);
        this._times.push(time);
        this._prunePositions(time);
      }
      this._map.fire('move', e).fire('drag', e);
    },
    _prunePositions: function (time) {
      while (this._positions.length > 1 && time - this._times[0] > 50) {
        this._positions.shift();
        this._times.shift();
      }
    },
    _onZoomEnd: function () {
      var pxCenter = this._map.getSize().divideBy(2),
        pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
      this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
      this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
    },
    _viscousLimit: function (value, threshold) {
      return value - (value - threshold) * this._viscosity;
    },
    _onPreDragLimit: function () {
      if (!this._viscosity || !this._offsetLimit) {
        return;
      }
      var offset = this._draggable._newPos.subtract(this._draggable._startPos);
      var limit = this._offsetLimit;
      if (offset.x < limit.min.x) {
        offset.x = this._viscousLimit(offset.x, limit.min.x);
      }
      if (offset.y < limit.min.y) {
        offset.y = this._viscousLimit(offset.y, limit.min.y);
      }
      if (offset.x > limit.max.x) {
        offset.x = this._viscousLimit(offset.x, limit.max.x);
      }
      if (offset.y > limit.max.y) {
        offset.y = this._viscousLimit(offset.y, limit.max.y);
      }
      this._draggable._newPos = this._draggable._startPos.add(offset);
    },
    _onPreDragWrap: function () {
      // TODO refactor to be able to adjust map pane position after zoom
      var worldWidth = this._worldWidth,
        halfWidth = Math.round(worldWidth / 2),
        dx = this._initialWorldOffset,
        x = this._draggable._newPos.x,
        newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
        newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
        newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
      this._draggable._absPos = this._draggable._newPos.clone();
      this._draggable._newPos.x = newX;
    },
    _onDragEnd: function (e) {
      var map = this._map,
        options = map.options,
        noInertia = !options.inertia || e.noInertia || this._times.length < 2;
      map.fire('dragend', e);
      if (noInertia) {
        map.fire('moveend');
      } else {
        this._prunePositions(+new Date());
        var direction = this._lastPos.subtract(this._positions[0]),
          duration = (this._lastTime - this._times[0]) / 1000,
          ease = options.easeLinearity,
          speedVector = direction.multiplyBy(ease / duration),
          speed = speedVector.distanceTo([0, 0]),
          limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
          limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),
          decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
          offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
        if (!offset.x && !offset.y) {
          map.fire('moveend');
        } else {
          offset = map._limitOffset(offset, map.options.maxBounds);
          requestAnimFrame(function () {
            map.panBy(offset, {
              duration: decelerationDuration,
              easeLinearity: ease,
              noMoveStart: true,
              animate: true
            });
          });
        }
      }
    }
  });

  // @section Handlers
  // @property dragging: Handler
  // Map dragging handler (by both mouse and touch).
  Map.addInitHook('addHandler', 'dragging', Drag);

  /*
   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
   */

  // @namespace Map
  // @section Keyboard Navigation Options
  Map.mergeOptions({
    // @option keyboard: Boolean = true
    // Makes the map focusable and allows users to navigate the map with keyboard
    // arrows and `+`/`-` keys.
    keyboard: true,
    // @option keyboardPanDelta: Number = 80
    // Amount of pixels to pan when pressing an arrow key.
    keyboardPanDelta: 80
  });
  var Keyboard = Handler.extend({
    keyCodes: {
      left: [37],
      right: [39],
      down: [40],
      up: [38],
      zoomIn: [187, 107, 61, 171],
      zoomOut: [189, 109, 54, 173]
    },
    initialize: function (map) {
      this._map = map;
      this._setPanDelta(map.options.keyboardPanDelta);
      this._setZoomDelta(map.options.zoomDelta);
    },
    addHooks: function () {
      var container = this._map._container;

      // make the container focusable by tabbing
      if (container.tabIndex <= 0) {
        container.tabIndex = '0';
      }
      on(container, {
        focus: this._onFocus,
        blur: this._onBlur,
        mousedown: this._onMouseDown
      }, this);
      this._map.on({
        focus: this._addHooks,
        blur: this._removeHooks
      }, this);
    },
    removeHooks: function () {
      this._removeHooks();
      off(this._map._container, {
        focus: this._onFocus,
        blur: this._onBlur,
        mousedown: this._onMouseDown
      }, this);
      this._map.off({
        focus: this._addHooks,
        blur: this._removeHooks
      }, this);
    },
    _onMouseDown: function () {
      if (this._focused) {
        return;
      }
      var body = document.body,
        docEl = document.documentElement,
        top = body.scrollTop || docEl.scrollTop,
        left = body.scrollLeft || docEl.scrollLeft;
      this._map._container.focus();
      window.scrollTo(left, top);
    },
    _onFocus: function () {
      this._focused = true;
      this._map.fire('focus');
    },
    _onBlur: function () {
      this._focused = false;
      this._map.fire('blur');
    },
    _setPanDelta: function (panDelta) {
      var keys = this._panKeys = {},
        codes = this.keyCodes,
        i,
        len;
      for (i = 0, len = codes.left.length; i < len; i++) {
        keys[codes.left[i]] = [-1 * panDelta, 0];
      }
      for (i = 0, len = codes.right.length; i < len; i++) {
        keys[codes.right[i]] = [panDelta, 0];
      }
      for (i = 0, len = codes.down.length; i < len; i++) {
        keys[codes.down[i]] = [0, panDelta];
      }
      for (i = 0, len = codes.up.length; i < len; i++) {
        keys[codes.up[i]] = [0, -1 * panDelta];
      }
    },
    _setZoomDelta: function (zoomDelta) {
      var keys = this._zoomKeys = {},
        codes = this.keyCodes,
        i,
        len;
      for (i = 0, len = codes.zoomIn.length; i < len; i++) {
        keys[codes.zoomIn[i]] = zoomDelta;
      }
      for (i = 0, len = codes.zoomOut.length; i < len; i++) {
        keys[codes.zoomOut[i]] = -zoomDelta;
      }
    },
    _addHooks: function () {
      on(document, 'keydown', this._onKeyDown, this);
    },
    _removeHooks: function () {
      off(document, 'keydown', this._onKeyDown, this);
    },
    _onKeyDown: function (e) {
      if (e.altKey || e.ctrlKey || e.metaKey) {
        return;
      }
      var key = e.keyCode,
        map = this._map,
        offset;
      if (key in this._panKeys) {
        if (!map._panAnim || !map._panAnim._inProgress) {
          offset = this._panKeys[key];
          if (e.shiftKey) {
            offset = toPoint(offset).multiplyBy(3);
          }
          if (map.options.maxBounds) {
            offset = map._limitOffset(toPoint(offset), map.options.maxBounds);
          }
          if (map.options.worldCopyJump) {
            var newLatLng = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(offset)));
            map.panTo(newLatLng);
          } else {
            map.panBy(offset);
          }
        }
      } else if (key in this._zoomKeys) {
        map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
      } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
        map.closePopup();
      } else {
        return;
      }
      stop(e);
    }
  });

  // @section Handlers
  // @section Handlers
  // @property keyboard: Handler
  // Keyboard navigation handler.
  Map.addInitHook('addHandler', 'keyboard', Keyboard);

  /*
   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
    // @section Mouse wheel options
    // @option scrollWheelZoom: Boolean|String = true
    // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
    // it will zoom to the center of the view regardless of where the mouse was.
    scrollWheelZoom: true,
    // @option wheelDebounceTime: Number = 40
    // Limits the rate at which a wheel can fire (in milliseconds). By default
    // user can't zoom via wheel more often than once per 40 ms.
    wheelDebounceTime: 40,
    // @option wheelPxPerZoomLevel: Number = 60
    // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
    // mean a change of one full zoom level. Smaller values will make wheel-zooming
    // faster (and vice versa).
    wheelPxPerZoomLevel: 60
  });
  var ScrollWheelZoom = Handler.extend({
    addHooks: function () {
      on(this._map._container, 'wheel', this._onWheelScroll, this);
      this._delta = 0;
    },
    removeHooks: function () {
      off(this._map._container, 'wheel', this._onWheelScroll, this);
    },
    _onWheelScroll: function (e) {
      var delta = getWheelDelta(e);
      var debounce = this._map.options.wheelDebounceTime;
      this._delta += delta;
      this._lastMousePos = this._map.mouseEventToContainerPoint(e);
      if (!this._startTime) {
        this._startTime = +new Date();
      }
      var left = Math.max(debounce - (+new Date() - this._startTime), 0);
      clearTimeout(this._timer);
      this._timer = setTimeout(bind(this._performZoom, this), left);
      stop(e);
    },
    _performZoom: function () {
      var map = this._map,
        zoom = map.getZoom(),
        snap = this._map.options.zoomSnap || 0;
      map._stop(); // stop panning and fly animations if any

      // map the delta with a sigmoid function to -4..4 range leaning on -1..1
      var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
        d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
        d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
        delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;
      this._delta = 0;
      this._startTime = null;
      if (!delta) {
        return;
      }
      if (map.options.scrollWheelZoom === 'center') {
        map.setZoom(zoom + delta);
      } else {
        map.setZoomAround(this._lastMousePos, zoom + delta);
      }
    }
  });

  // @section Handlers
  // @property scrollWheelZoom: Handler
  // Scroll wheel zoom handler.
  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);

  /*
   * L.Map.TapHold is used to simulate `contextmenu` event on long hold,
   * which otherwise is not fired by mobile Safari.
   */

  var tapHoldDelay = 600;

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
    // @section Touch interaction options
    // @option tapHold: Boolean
    // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
    tapHold: Browser.touchNative && Browser.safari && Browser.mobile,
    // @option tapTolerance: Number = 15
    // The max number of pixels a user can shift his finger during touch
    // for it to be considered a valid tap.
    tapTolerance: 15
  });
  var TapHold = Handler.extend({
    addHooks: function () {
      on(this._map._container, 'touchstart', this._onDown, this);
    },
    removeHooks: function () {
      off(this._map._container, 'touchstart', this._onDown, this);
    },
    _onDown: function (e) {
      clearTimeout(this._holdTimeout);
      if (e.touches.length !== 1) {
        return;
      }
      var first = e.touches[0];
      this._startPos = this._newPos = new Point(first.clientX, first.clientY);
      this._holdTimeout = setTimeout(bind(function () {
        this._cancel();
        if (!this._isTapValid()) {
          return;
        }

        // prevent simulated mouse events https://w3c.github.io/touch-events/#mouse-events
        on(document, 'touchend', preventDefault);
        on(document, 'touchend touchcancel', this._cancelClickPrevent);
        this._simulateEvent('contextmenu', first);
      }, this), tapHoldDelay);
      on(document, 'touchend touchcancel contextmenu', this._cancel, this);
      on(document, 'touchmove', this._onMove, this);
    },
    _cancelClickPrevent: function cancelClickPrevent() {
      off(document, 'touchend', preventDefault);
      off(document, 'touchend touchcancel', cancelClickPrevent);
    },
    _cancel: function () {
      clearTimeout(this._holdTimeout);
      off(document, 'touchend touchcancel contextmenu', this._cancel, this);
      off(document, 'touchmove', this._onMove, this);
    },
    _onMove: function (e) {
      var first = e.touches[0];
      this._newPos = new Point(first.clientX, first.clientY);
    },
    _isTapValid: function () {
      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
    },
    _simulateEvent: function (type, e) {
      var simulatedEvent = new MouseEvent(type, {
        bubbles: true,
        cancelable: true,
        view: window,
        // detail: 1,
        screenX: e.screenX,
        screenY: e.screenY,
        clientX: e.clientX,
        clientY: e.clientY
        // button: 2,
        // buttons: 2
      });

      simulatedEvent._simulated = true;
      e.target.dispatchEvent(simulatedEvent);
    }
  });

  // @section Handlers
  // @property tapHold: Handler
  // Long tap handler to simulate `contextmenu` event (useful in mobile Safari).
  Map.addInitHook('addHandler', 'tapHold', TapHold);

  /*
   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
   */

  // @namespace Map
  // @section Interaction Options
  Map.mergeOptions({
    // @section Touch interaction options
    // @option touchZoom: Boolean|String = *
    // Whether the map can be zoomed by touch-dragging with two fingers. If
    // passed `'center'`, it will zoom to the center of the view regardless of
    // where the touch events (fingers) were. Enabled for touch-capable web
    // browsers.
    touchZoom: Browser.touch,
    // @option bounceAtZoomLimits: Boolean = true
    // Set it to false if you don't want the map to zoom beyond min/max zoom
    // and then bounce back when pinch-zooming.
    bounceAtZoomLimits: true
  });
  var TouchZoom = Handler.extend({
    addHooks: function () {
      addClass(this._map._container, 'leaflet-touch-zoom');
      on(this._map._container, 'touchstart', this._onTouchStart, this);
    },
    removeHooks: function () {
      removeClass(this._map._container, 'leaflet-touch-zoom');
      off(this._map._container, 'touchstart', this._onTouchStart, this);
    },
    _onTouchStart: function (e) {
      var map = this._map;
      if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
        return;
      }
      var p1 = map.mouseEventToContainerPoint(e.touches[0]),
        p2 = map.mouseEventToContainerPoint(e.touches[1]);
      this._centerPoint = map.getSize()._divideBy(2);
      this._startLatLng = map.containerPointToLatLng(this._centerPoint);
      if (map.options.touchZoom !== 'center') {
        this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
      }
      this._startDist = p1.distanceTo(p2);
      this._startZoom = map.getZoom();
      this._moved = false;
      this._zooming = true;
      map._stop();
      on(document, 'touchmove', this._onTouchMove, this);
      on(document, 'touchend touchcancel', this._onTouchEnd, this);
      preventDefault(e);
    },
    _onTouchMove: function (e) {
      if (!e.touches || e.touches.length !== 2 || !this._zooming) {
        return;
      }
      var map = this._map,
        p1 = map.mouseEventToContainerPoint(e.touches[0]),
        p2 = map.mouseEventToContainerPoint(e.touches[1]),
        scale = p1.distanceTo(p2) / this._startDist;
      this._zoom = map.getScaleZoom(scale, this._startZoom);
      if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {
        this._zoom = map._limitZoom(this._zoom);
      }
      if (map.options.touchZoom === 'center') {
        this._center = this._startLatLng;
        if (scale === 1) {
          return;
        }
      } else {
        // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
        var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
        if (scale === 1 && delta.x === 0 && delta.y === 0) {
          return;
        }
        this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
      }
      if (!this._moved) {
        map._moveStart(true, false);
        this._moved = true;
      }
      cancelAnimFrame(this._animRequest);
      var moveFn = bind(map._move, map, this._center, this._zoom, {
        pinch: true,
        round: false
      }, undefined);
      this._animRequest = requestAnimFrame(moveFn, this, true);
      preventDefault(e);
    },
    _onTouchEnd: function () {
      if (!this._moved || !this._zooming) {
        this._zooming = false;
        return;
      }
      this._zooming = false;
      cancelAnimFrame(this._animRequest);
      off(document, 'touchmove', this._onTouchMove, this);
      off(document, 'touchend touchcancel', this._onTouchEnd, this);

      // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
      if (this._map.options.zoomAnimation) {
        this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
      } else {
        this._map._resetView(this._center, this._map._limitZoom(this._zoom));
      }
    }
  });

  // @section Handlers
  // @property touchZoom: Handler
  // Touch zoom handler.
  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);
  Map.BoxZoom = BoxZoom;
  Map.DoubleClickZoom = DoubleClickZoom;
  Map.Drag = Drag;
  Map.Keyboard = Keyboard;
  Map.ScrollWheelZoom = ScrollWheelZoom;
  Map.TapHold = TapHold;
  Map.TouchZoom = TouchZoom;
  exports.Bounds = Bounds;
  exports.Browser = Browser;
  exports.CRS = CRS;
  exports.Canvas = Canvas;
  exports.Circle = Circle;
  exports.CircleMarker = CircleMarker;
  exports.Class = Class;
  exports.Control = Control;
  exports.DivIcon = DivIcon;
  exports.DivOverlay = DivOverlay;
  exports.DomEvent = DomEvent;
  exports.DomUtil = DomUtil;
  exports.Draggable = Draggable;
  exports.Evented = Evented;
  exports.FeatureGroup = FeatureGroup;
  exports.GeoJSON = GeoJSON;
  exports.GridLayer = GridLayer;
  exports.Handler = Handler;
  exports.Icon = Icon;
  exports.ImageOverlay = ImageOverlay;
  exports.LatLng = LatLng;
  exports.LatLngBounds = LatLngBounds;
  exports.Layer = Layer;
  exports.LayerGroup = LayerGroup;
  exports.LineUtil = LineUtil;
  exports.Map = Map;
  exports.Marker = Marker;
  exports.Mixin = Mixin;
  exports.Path = Path;
  exports.Point = Point;
  exports.PolyUtil = PolyUtil;
  exports.Polygon = Polygon;
  exports.Polyline = Polyline;
  exports.Popup = Popup;
  exports.PosAnimation = PosAnimation;
  exports.Projection = index;
  exports.Rectangle = Rectangle;
  exports.Renderer = Renderer;
  exports.SVG = SVG;
  exports.SVGOverlay = SVGOverlay;
  exports.TileLayer = TileLayer;
  exports.Tooltip = Tooltip;
  exports.Transformation = Transformation;
  exports.Util = Util;
  exports.VideoOverlay = VideoOverlay;
  exports.bind = bind;
  exports.bounds = toBounds;
  exports.canvas = canvas;
  exports.circle = circle;
  exports.circleMarker = circleMarker;
  exports.control = control;
  exports.divIcon = divIcon;
  exports.extend = extend;
  exports.featureGroup = featureGroup;
  exports.geoJSON = geoJSON;
  exports.geoJson = geoJson;
  exports.gridLayer = gridLayer;
  exports.icon = icon;
  exports.imageOverlay = imageOverlay;
  exports.latLng = toLatLng;
  exports.latLngBounds = toLatLngBounds;
  exports.layerGroup = layerGroup;
  exports.map = createMap;
  exports.marker = marker;
  exports.point = toPoint;
  exports.polygon = polygon;
  exports.polyline = polyline;
  exports.popup = popup;
  exports.rectangle = rectangle;
  exports.setOptions = setOptions;
  exports.stamp = stamp;
  exports.svg = svg;
  exports.svgOverlay = svgOverlay;
  exports.tileLayer = tileLayer;
  exports.tooltip = tooltip;
  exports.transformation = toTransformation;
  exports.version = version;
  exports.videoOverlay = videoOverlay;
  var oldL = window.L;
  exports.noConflict = function () {
    window.L = oldL;
    return this;
  };
  // Always export us to window global (see #2364)
  window.L = exports;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJleHRlbmQiLCJkZXN0IiwiaSIsImoiLCJsZW4iLCJzcmMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJjcmVhdGUkMiIsIk9iamVjdCIsImNyZWF0ZSIsIkYiLCJwcm90byIsInByb3RvdHlwZSIsImJpbmQiLCJmbiIsIm9iaiIsInNsaWNlIiwiQXJyYXkiLCJhcHBseSIsImNhbGwiLCJhcmdzIiwiY29uY2F0IiwibGFzdElkIiwic3RhbXAiLCJfbGVhZmxldF9pZCIsInRocm90dGxlIiwidGltZSIsImNvbnRleHQiLCJsb2NrIiwid3JhcHBlckZuIiwibGF0ZXIiLCJzZXRUaW1lb3V0Iiwid3JhcE51bSIsIngiLCJyYW5nZSIsImluY2x1ZGVNYXgiLCJtYXgiLCJtaW4iLCJkIiwiZmFsc2VGbiIsImZvcm1hdE51bSIsIm51bSIsInByZWNpc2lvbiIsInBvdyIsIk1hdGgiLCJ1bmRlZmluZWQiLCJyb3VuZCIsInRyaW0iLCJzdHIiLCJyZXBsYWNlIiwic3BsaXRXb3JkcyIsInNwbGl0Iiwic2V0T3B0aW9ucyIsIm9wdGlvbnMiLCJoYXNPd25Qcm9wZXJ0eSIsImdldFBhcmFtU3RyaW5nIiwiZXhpc3RpbmdVcmwiLCJ1cHBlcmNhc2UiLCJwYXJhbXMiLCJwdXNoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidG9VcHBlckNhc2UiLCJpbmRleE9mIiwiam9pbiIsInRlbXBsYXRlUmUiLCJ0ZW1wbGF0ZSIsImRhdGEiLCJrZXkiLCJ2YWx1ZSIsIkVycm9yIiwiaXNBcnJheSIsInRvU3RyaW5nIiwiYXJyYXkiLCJlbCIsImVtcHR5SW1hZ2VVcmwiLCJnZXRQcmVmaXhlZCIsIm5hbWUiLCJ3aW5kb3ciLCJsYXN0VGltZSIsInRpbWVvdXREZWZlciIsIkRhdGUiLCJ0aW1lVG9DYWxsIiwicmVxdWVzdEZuIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsRm4iLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImlkIiwiY2xlYXJUaW1lb3V0IiwicmVxdWVzdEFuaW1GcmFtZSIsImltbWVkaWF0ZSIsImNhbmNlbEFuaW1GcmFtZSIsIkNsYXNzIiwicHJvcHMiLCJOZXdDbGFzcyIsImluaXRpYWxpemUiLCJjYWxsSW5pdEhvb2tzIiwicGFyZW50UHJvdG8iLCJfX3N1cGVyX18iLCJjb25zdHJ1Y3RvciIsInN0YXRpY3MiLCJpbmNsdWRlcyIsImNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzIiwiX2luaXRIb29rcyIsIl9pbml0SG9va3NDYWxsZWQiLCJpbmNsdWRlIiwicGFyZW50T3B0aW9ucyIsIm1lcmdlT3B0aW9ucyIsImFkZEluaXRIb29rIiwiaW5pdCIsIkwiLCJNaXhpbiIsIkV2ZW50cyIsImNvbnNvbGUiLCJ3YXJuIiwic3RhY2siLCJvbiIsInR5cGVzIiwidHlwZSIsIl9vbiIsIm9mZiIsIl9ldmVudHMiLCJfb2ZmIiwicmVtb3ZlQWxsIiwiX29uY2UiLCJfbGlzdGVucyIsIm5ld0xpc3RlbmVyIiwiY3R4Iiwib25jZSIsImxpc3RlbmVycyIsIl9maXJpbmdDb3VudCIsImluZGV4IiwibGlzdGVuZXIiLCJzcGxpY2UiLCJmaXJlIiwicHJvcGFnYXRlIiwibGlzdGVucyIsImV2ZW50IiwidGFyZ2V0Iiwic291cmNlVGFyZ2V0IiwibCIsIl9wcm9wYWdhdGVFdmVudCIsIl9mbiIsIl9ldmVudFBhcmVudHMiLCJhZGRFdmVudFBhcmVudCIsInJlbW92ZUV2ZW50UGFyZW50IiwiZSIsImxheWVyIiwicHJvcGFnYXRlZEZyb20iLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMiLCJhZGRPbmVUaW1lRXZlbnRMaXN0ZW5lciIsImZpcmVFdmVudCIsImhhc0V2ZW50TGlzdGVuZXJzIiwiRXZlbnRlZCIsIlBvaW50IiwieSIsInRydW5jIiwidiIsImZsb29yIiwiY2VpbCIsImNsb25lIiwiYWRkIiwicG9pbnQiLCJfYWRkIiwidG9Qb2ludCIsInN1YnRyYWN0IiwiX3N1YnRyYWN0IiwiZGl2aWRlQnkiLCJfZGl2aWRlQnkiLCJtdWx0aXBseUJ5IiwiX211bHRpcGx5QnkiLCJzY2FsZUJ5IiwidW5zY2FsZUJ5IiwiX3JvdW5kIiwiX2Zsb29yIiwiX2NlaWwiLCJfdHJ1bmMiLCJkaXN0YW5jZVRvIiwic3FydCIsImVxdWFscyIsImNvbnRhaW5zIiwiYWJzIiwiQm91bmRzIiwiYSIsImIiLCJwb2ludHMiLCJtaW4yIiwibWF4MiIsInRvQm91bmRzIiwiZ2V0Q2VudGVyIiwiZ2V0Qm90dG9tTGVmdCIsImdldFRvcFJpZ2h0IiwiZ2V0VG9wTGVmdCIsImdldEJvdHRvbVJpZ2h0IiwiZ2V0U2l6ZSIsImludGVyc2VjdHMiLCJib3VuZHMiLCJ4SW50ZXJzZWN0cyIsInlJbnRlcnNlY3RzIiwib3ZlcmxhcHMiLCJ4T3ZlcmxhcHMiLCJ5T3ZlcmxhcHMiLCJpc1ZhbGlkIiwicGFkIiwiYnVmZmVyUmF0aW8iLCJoZWlnaHRCdWZmZXIiLCJ3aWR0aEJ1ZmZlciIsIkxhdExuZ0JvdW5kcyIsImNvcm5lcjEiLCJjb3JuZXIyIiwibGF0bG5ncyIsInN3IiwiX3NvdXRoV2VzdCIsIm5lIiwiX25vcnRoRWFzdCIsInN3MiIsIm5lMiIsIkxhdExuZyIsInRvTGF0TG5nIiwidG9MYXRMbmdCb3VuZHMiLCJsYXQiLCJsbmciLCJnZXRTb3V0aFdlc3QiLCJnZXROb3J0aEVhc3QiLCJnZXROb3J0aFdlc3QiLCJnZXROb3J0aCIsImdldFdlc3QiLCJnZXRTb3V0aEVhc3QiLCJnZXRTb3V0aCIsImdldEVhc3QiLCJsYXRJbnRlcnNlY3RzIiwibG5nSW50ZXJzZWN0cyIsImxhdE92ZXJsYXBzIiwibG5nT3ZlcmxhcHMiLCJ0b0JCb3hTdHJpbmciLCJtYXhNYXJnaW4iLCJhbHQiLCJpc05hTiIsIm1hcmdpbiIsIm90aGVyIiwiRWFydGgiLCJkaXN0YW5jZSIsIndyYXAiLCJ3cmFwTGF0TG5nIiwic2l6ZUluTWV0ZXJzIiwibGF0QWNjdXJhY3kiLCJsbmdBY2N1cmFjeSIsImNvcyIsIlBJIiwiYyIsImxvbiIsIkNSUyIsImxhdExuZ1RvUG9pbnQiLCJsYXRsbmciLCJ6b29tIiwicHJvamVjdGVkUG9pbnQiLCJwcm9qZWN0aW9uIiwicHJvamVjdCIsInNjYWxlIiwidHJhbnNmb3JtYXRpb24iLCJfdHJhbnNmb3JtIiwicG9pbnRUb0xhdExuZyIsInVudHJhbnNmb3JtZWRQb2ludCIsInVudHJhbnNmb3JtIiwidW5wcm9qZWN0IiwibG9nIiwiTE4yIiwiZ2V0UHJvamVjdGVkQm91bmRzIiwiaW5maW5pdGUiLCJzIiwidHJhbnNmb3JtIiwid3JhcExuZyIsIndyYXBMYXQiLCJ3cmFwTGF0TG5nQm91bmRzIiwiY2VudGVyIiwibmV3Q2VudGVyIiwibGF0U2hpZnQiLCJsbmdTaGlmdCIsIm5ld1N3IiwibmV3TmUiLCJSIiwibGF0bG5nMSIsImxhdGxuZzIiLCJyYWQiLCJsYXQxIiwibGF0MiIsInNpbkRMYXQiLCJzaW4iLCJzaW5ETG9uIiwiYXRhbjIiLCJlYXJ0aFJhZGl1cyIsIlNwaGVyaWNhbE1lcmNhdG9yIiwiTUFYX0xBVElUVURFIiwiYXRhbiIsImV4cCIsIlRyYW5zZm9ybWF0aW9uIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJ0b1RyYW5zZm9ybWF0aW9uIiwiRVBTRzM4NTciLCJjb2RlIiwiRVBTRzkwMDkxMyIsInN2Z0NyZWF0ZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudE5TIiwicG9pbnRzVG9QYXRoIiwicmluZ3MiLCJjbG9zZWQiLCJsZW4yIiwicCIsIkJyb3dzZXIiLCJzdmciLCJzdHlsZSIsImRvY3VtZW50RWxlbWVudCIsImllIiwiaWVsdDkiLCJlZGdlIiwibmF2aWdhdG9yIiwid2Via2l0IiwidXNlckFnZW50Q29udGFpbnMiLCJhbmRyb2lkIiwiYW5kcm9pZDIzIiwid2Via2l0VmVyIiwicGFyc2VJbnQiLCJleGVjIiwidXNlckFnZW50IiwiYW5kcm9pZFN0b2NrIiwib3BlcmEiLCJjaHJvbWUiLCJnZWNrbyIsInNhZmFyaSIsInBoYW50b20iLCJvcGVyYTEyIiwid2luIiwicGxhdGZvcm0iLCJpZTNkIiwid2Via2l0M2QiLCJXZWJLaXRDU1NNYXRyaXgiLCJnZWNrbzNkIiwiYW55M2QiLCJMX0RJU0FCTEVfM0QiLCJtb2JpbGUiLCJvcmllbnRhdGlvbiIsIm1vYmlsZVdlYmtpdCIsIm1vYmlsZVdlYmtpdDNkIiwibXNQb2ludGVyIiwiUG9pbnRlckV2ZW50IiwiTVNQb2ludGVyRXZlbnQiLCJwb2ludGVyIiwidG91Y2hOYXRpdmUiLCJUb3VjaEV2ZW50IiwidG91Y2giLCJMX05PX1RPVUNIIiwibW9iaWxlT3BlcmEiLCJtb2JpbGVHZWNrbyIsInJldGluYSIsImRldmljZVBpeGVsUmF0aW8iLCJzY3JlZW4iLCJkZXZpY2VYRFBJIiwibG9naWNhbFhEUEkiLCJwYXNzaXZlRXZlbnRzIiwic3VwcG9ydHNQYXNzaXZlT3B0aW9uIiwib3B0cyIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiY2FudmFzJDEiLCJjcmVhdGVFbGVtZW50IiwiZ2V0Q29udGV4dCIsInN2ZyQxIiwiY3JlYXRlU1ZHUmVjdCIsImlubGluZVN2ZyIsImRpdiIsImlubmVySFRNTCIsImZpcnN0Q2hpbGQiLCJuYW1lc3BhY2VVUkkiLCJ2bWwiLCJzaGFwZSIsImJlaGF2aW9yIiwiYWRqIiwibWFjIiwibGludXgiLCJ0b0xvd2VyQ2FzZSIsImNhbnZhcyIsIlBPSU5URVJfRE9XTiIsIlBPSU5URVJfTU9WRSIsIlBPSU5URVJfVVAiLCJQT0lOVEVSX0NBTkNFTCIsInBFdmVudCIsInRvdWNoc3RhcnQiLCJ0b3VjaG1vdmUiLCJ0b3VjaGVuZCIsInRvdWNoY2FuY2VsIiwiaGFuZGxlIiwiX29uUG9pbnRlclN0YXJ0IiwiX2hhbmRsZVBvaW50ZXIiLCJfcG9pbnRlcnMiLCJfcG9pbnRlckRvY0xpc3RlbmVyIiwiYWRkUG9pbnRlckxpc3RlbmVyIiwiaGFuZGxlciIsIl9hZGRQb2ludGVyRG9jTGlzdGVuZXIiLCJyZW1vdmVQb2ludGVyTGlzdGVuZXIiLCJfZ2xvYmFsUG9pbnRlckRvd24iLCJwb2ludGVySWQiLCJfZ2xvYmFsUG9pbnRlck1vdmUiLCJfZ2xvYmFsUG9pbnRlclVwIiwicG9pbnRlclR5cGUiLCJNU1BPSU5URVJfVFlQRV9NT1VTRSIsInRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsIk1TUE9JTlRFUl9UWVBFX1RPVUNIIiwicHJldmVudERlZmF1bHQiLCJtYWtlRGJsY2xpY2siLCJuZXdFdmVudCIsInByb3AiLCJkZXRhaWwiLCJpc1RydXN0ZWQiLCJfc2ltdWxhdGVkIiwiZGVsYXkiLCJhZGREb3VibGVUYXBMaXN0ZW5lciIsImxhc3QiLCJzaW1EYmxjbGljayIsInNvdXJjZUNhcGFiaWxpdGllcyIsImZpcmVzVG91Y2hFdmVudHMiLCJwYXRoIiwiZ2V0UHJvcGFnYXRpb25QYXRoIiwic29tZSIsIkhUTUxMYWJlbEVsZW1lbnQiLCJhdHRyaWJ1dGVzIiwiZm9yIiwiSFRNTElucHV0RWxlbWVudCIsIkhUTUxTZWxlY3RFbGVtZW50Iiwibm93IiwiZGJsY2xpY2siLCJyZW1vdmVEb3VibGVUYXBMaXN0ZW5lciIsImhhbmRsZXJzIiwiVFJBTlNGT1JNIiwidGVzdFByb3AiLCJUUkFOU0lUSU9OIiwiVFJBTlNJVElPTl9FTkQiLCJnZXRFbGVtZW50QnlJZCIsImdldFN0eWxlIiwiY3VycmVudFN0eWxlIiwiZGVmYXVsdFZpZXciLCJjc3MiLCJnZXRDb21wdXRlZFN0eWxlIiwiY3JlYXRlJDEiLCJ0YWdOYW1lIiwiY2xhc3NOYW1lIiwiY29udGFpbmVyIiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmUiLCJwYXJlbnQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJlbXB0eSIsInRvRnJvbnQiLCJsYXN0Q2hpbGQiLCJ0b0JhY2siLCJpbnNlcnRCZWZvcmUiLCJoYXNDbGFzcyIsImNsYXNzTGlzdCIsImdldENsYXNzIiwiUmVnRXhwIiwidGVzdCIsImFkZENsYXNzIiwiY2xhc3NlcyIsInNldENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJiYXNlVmFsIiwiY29ycmVzcG9uZGluZ0VsZW1lbnQiLCJzZXRPcGFjaXR5Iiwib3BhY2l0eSIsIl9zZXRPcGFjaXR5SUUiLCJmaWx0ZXIiLCJmaWx0ZXJOYW1lIiwiZmlsdGVycyIsIml0ZW0iLCJFbmFibGVkIiwiT3BhY2l0eSIsInNldFRyYW5zZm9ybSIsIm9mZnNldCIsInBvcyIsInNldFBvc2l0aW9uIiwiX2xlYWZsZXRfcG9zIiwibGVmdCIsInRvcCIsImdldFBvc2l0aW9uIiwiZGlzYWJsZVRleHRTZWxlY3Rpb24iLCJlbmFibGVUZXh0U2VsZWN0aW9uIiwiX3VzZXJTZWxlY3QiLCJ1c2VyU2VsZWN0UHJvcGVydHkiLCJkaXNhYmxlSW1hZ2VEcmFnIiwiZW5hYmxlSW1hZ2VEcmFnIiwiX291dGxpbmVFbGVtZW50IiwiX291dGxpbmVTdHlsZSIsInByZXZlbnRPdXRsaW5lIiwiZWxlbWVudCIsInRhYkluZGV4IiwicmVzdG9yZU91dGxpbmUiLCJvdXRsaW5lU3R5bGUiLCJnZXRTaXplZFBhcmVudE5vZGUiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImJvZHkiLCJnZXRTY2FsZSIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsImhlaWdodCIsImJvdW5kaW5nQ2xpZW50UmVjdCIsImFkZE9uZSIsImV2ZW50c0tleSIsImJhdGNoUmVtb3ZlIiwicmVtb3ZlT25lIiwiZmlsdGVyRm4iLCJtb3VzZVN1YnN0IiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJ3aGVlbCIsIm9yaWdpbmFsSGFuZGxlciIsInBhc3NpdmUiLCJpc0V4dGVybmFsVGFyZ2V0IiwiYXR0YWNoRXZlbnQiLCJkZXRhY2hFdmVudCIsInN0b3BQcm9wYWdhdGlvbiIsIm9yaWdpbmFsRXZlbnQiLCJfc3RvcHBlZCIsImNhbmNlbEJ1YmJsZSIsImRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbiIsImRpc2FibGVDbGlja1Byb3BhZ2F0aW9uIiwicmV0dXJuVmFsdWUiLCJzdG9wIiwiZXYiLCJjb21wb3NlZFBhdGgiLCJnZXRNb3VzZVBvc2l0aW9uIiwiY2xpZW50WCIsImNsaWVudFkiLCJjbGllbnRMZWZ0IiwiY2xpZW50VG9wIiwid2hlZWxQeEZhY3RvciIsImdldFdoZWVsRGVsdGEiLCJ3aGVlbERlbHRhWSIsImRlbHRhWSIsImRlbHRhTW9kZSIsImRlbHRhWCIsImRlbHRhWiIsIndoZWVsRGVsdGEiLCJyZWxhdGVkIiwicmVsYXRlZFRhcmdldCIsImVyciIsIlBvc0FuaW1hdGlvbiIsInJ1biIsIm5ld1BvcyIsImR1cmF0aW9uIiwiZWFzZUxpbmVhcml0eSIsIl9lbCIsIl9pblByb2dyZXNzIiwiX2R1cmF0aW9uIiwiX2Vhc2VPdXRQb3dlciIsIl9zdGFydFBvcyIsIl9vZmZzZXQiLCJfc3RhcnRUaW1lIiwiX2FuaW1hdGUiLCJfc3RlcCIsIl9jb21wbGV0ZSIsIl9hbmltSWQiLCJlbGFwc2VkIiwiX3J1bkZyYW1lIiwiX2Vhc2VPdXQiLCJwcm9ncmVzcyIsInQiLCJNYXAiLCJjcnMiLCJtaW5ab29tIiwibWF4Wm9vbSIsImxheWVycyIsIm1heEJvdW5kcyIsInJlbmRlcmVyIiwiem9vbUFuaW1hdGlvbiIsInpvb21BbmltYXRpb25UaHJlc2hvbGQiLCJmYWRlQW5pbWF0aW9uIiwibWFya2VyWm9vbUFuaW1hdGlvbiIsInRyYW5zZm9ybTNETGltaXQiLCJ6b29tU25hcCIsInpvb21EZWx0YSIsInRyYWNrUmVzaXplIiwiX2hhbmRsZXJzIiwiX2xheWVycyIsIl96b29tQm91bmRMYXllcnMiLCJfc2l6ZUNoYW5nZWQiLCJfaW5pdENvbnRhaW5lciIsIl9pbml0TGF5b3V0IiwiX29uUmVzaXplIiwiX2luaXRFdmVudHMiLCJzZXRNYXhCb3VuZHMiLCJfem9vbSIsIl9saW1pdFpvb20iLCJzZXRWaWV3IiwicmVzZXQiLCJfem9vbUFuaW1hdGVkIiwiX2NyZWF0ZUFuaW1Qcm94eSIsIl9wcm94eSIsIl9jYXRjaFRyYW5zaXRpb25FbmQiLCJfYWRkTGF5ZXJzIiwiX2xpbWl0Q2VudGVyIiwiX3N0b3AiLCJfbG9hZGVkIiwiYW5pbWF0ZSIsInBhbiIsIm1vdmVkIiwiX3RyeUFuaW1hdGVkWm9vbSIsIl90cnlBbmltYXRlZFBhbiIsIl9zaXplVGltZXIiLCJfcmVzZXRWaWV3Iiwibm9Nb3ZlU3RhcnQiLCJzZXRab29tIiwiem9vbUluIiwiZGVsdGEiLCJ6b29tT3V0Iiwic2V0Wm9vbUFyb3VuZCIsImdldFpvb21TY2FsZSIsInZpZXdIYWxmIiwiY29udGFpbmVyUG9pbnQiLCJsYXRMbmdUb0NvbnRhaW5lclBvaW50IiwiY2VudGVyT2Zmc2V0IiwiY29udGFpbmVyUG9pbnRUb0xhdExuZyIsIl9nZXRCb3VuZHNDZW50ZXJab29tIiwiZ2V0Qm91bmRzIiwicGFkZGluZ1RMIiwicGFkZGluZ1RvcExlZnQiLCJwYWRkaW5nIiwicGFkZGluZ0JSIiwicGFkZGluZ0JvdHRvbVJpZ2h0IiwiZ2V0Qm91bmRzWm9vbSIsIkluZmluaXR5IiwicGFkZGluZ09mZnNldCIsInN3UG9pbnQiLCJuZVBvaW50IiwiZml0Qm91bmRzIiwiZml0V29ybGQiLCJwYW5UbyIsInBhbkJ5IiwiZ2V0Wm9vbSIsIl9wYW5BbmltIiwiX29uUGFuVHJhbnNpdGlvblN0ZXAiLCJfb25QYW5UcmFuc2l0aW9uRW5kIiwiX21hcFBhbmUiLCJfZ2V0TWFwUGFuZVBvcyIsIl9yYXdQYW5CeSIsImZseVRvIiwidGFyZ2V0Q2VudGVyIiwidGFyZ2V0Wm9vbSIsImZyb20iLCJ0byIsInNpemUiLCJzdGFydFpvb20iLCJ3MCIsIncxIiwidTEiLCJyaG8iLCJyaG8yIiwiciIsInMxIiwiczIiLCJ0MSIsImIxIiwic3EiLCJzaW5oIiwibiIsImNvc2giLCJ0YW5oIiwicjAiLCJ3IiwidSIsImVhc2VPdXQiLCJzdGFydCIsIlMiLCJmcmFtZSIsIl9mbHlUb0ZyYW1lIiwiX21vdmUiLCJnZXRTY2FsZVpvb20iLCJfbW92ZUVuZCIsIl9tb3ZlU3RhcnQiLCJmbHlUb0JvdW5kcyIsIl9wYW5JbnNpZGVNYXhCb3VuZHMiLCJzZXRNaW5ab29tIiwib2xkWm9vbSIsInNldE1heFpvb20iLCJwYW5JbnNpZGVCb3VuZHMiLCJfZW5mb3JjaW5nQm91bmRzIiwicGFuSW5zaWRlIiwicGl4ZWxDZW50ZXIiLCJwaXhlbFBvaW50IiwicGl4ZWxCb3VuZHMiLCJnZXRQaXhlbEJvdW5kcyIsInBhZGRlZEJvdW5kcyIsInBhZGRlZFNpemUiLCJpbnZhbGlkYXRlU2l6ZSIsIm9sZFNpemUiLCJfbGFzdENlbnRlciIsIm5ld1NpemUiLCJvbGRDZW50ZXIiLCJkZWJvdW5jZU1vdmVlbmQiLCJsb2NhdGUiLCJfbG9jYXRlT3B0aW9ucyIsInRpbWVvdXQiLCJ3YXRjaCIsIl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yIiwibWVzc2FnZSIsIm9uUmVzcG9uc2UiLCJfaGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSIsIm9uRXJyb3IiLCJfbG9jYXRpb25XYXRjaElkIiwiZ2VvbG9jYXRpb24iLCJ3YXRjaFBvc2l0aW9uIiwiZ2V0Q3VycmVudFBvc2l0aW9uIiwic3RvcExvY2F0ZSIsImNsZWFyV2F0Y2giLCJlcnJvciIsIl9jb250YWluZXIiLCJjb29yZHMiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsImFjY3VyYWN5IiwidGltZXN0YW1wIiwiYWRkSGFuZGxlciIsIkhhbmRsZXJDbGFzcyIsImVuYWJsZSIsIl9jb250YWluZXJJZCIsIl9jbGVhckNvbnRyb2xQb3MiLCJfcmVzaXplUmVxdWVzdCIsIl9jbGVhckhhbmRsZXJzIiwiX3BhbmVzIiwiX3JlbmRlcmVyIiwiY3JlYXRlUGFuZSIsInBhbmUiLCJfY2hlY2tJZkxvYWRlZCIsIl9tb3ZlZCIsImxheWVyUG9pbnRUb0xhdExuZyIsIl9nZXRDZW50ZXJMYXllclBvaW50IiwiZ2V0TWluWm9vbSIsIl9sYXllcnNNaW5ab29tIiwiZ2V0TWF4Wm9vbSIsIl9sYXllcnNNYXhab29tIiwiaW5zaWRlIiwibnciLCJzZSIsImJvdW5kc1NpemUiLCJzbmFwIiwic2NhbGV4Iiwic2NhbGV5IiwiX3NpemUiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsInRvcExlZnRQb2ludCIsIl9nZXRUb3BMZWZ0UG9pbnQiLCJnZXRQaXhlbE9yaWdpbiIsIl9waXhlbE9yaWdpbiIsImdldFBpeGVsV29ybGRCb3VuZHMiLCJnZXRQYW5lIiwiZ2V0UGFuZXMiLCJnZXRDb250YWluZXIiLCJ0b1pvb20iLCJmcm9tWm9vbSIsImxhdExuZ1RvTGF5ZXJQb2ludCIsImNvbnRhaW5lclBvaW50VG9MYXllclBvaW50IiwibGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQiLCJsYXllclBvaW50IiwibW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQiLCJtb3VzZUV2ZW50VG9MYXllclBvaW50IiwibW91c2VFdmVudFRvTGF0TG5nIiwiX29uU2Nyb2xsIiwiX2ZhZGVBbmltYXRlZCIsInBvc2l0aW9uIiwiX2luaXRQYW5lcyIsIl9pbml0Q29udHJvbFBvcyIsInBhbmVzIiwiX3BhbmVSZW5kZXJlcnMiLCJtYXJrZXJQYW5lIiwic2hhZG93UGFuZSIsImxvYWRpbmciLCJ6b29tQ2hhbmdlZCIsInN1cHJlc3NFdmVudCIsIl9nZXROZXdQaXhlbE9yaWdpbiIsInBpbmNoIiwiX2dldFpvb21TcGFuIiwiX3RhcmdldHMiLCJvbk9mZiIsIl9oYW5kbGVET01FdmVudCIsIl9vbk1vdmVFbmQiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0IiwiX2ZpbmRFdmVudFRhcmdldHMiLCJ0YXJnZXRzIiwiaXNIb3ZlciIsInNyY0VsZW1lbnQiLCJkcmFnZ2luZyIsIl9kcmFnZ2FibGVNb3ZlZCIsIl9pc0NsaWNrRGlzYWJsZWQiLCJfZmlyZURPTUV2ZW50IiwiX21vdXNlRXZlbnRzIiwiY2FudmFzVGFyZ2V0cyIsInN5bnRoIiwiZmlsdGVyZWQiLCJpc01hcmtlciIsImdldExhdExuZyIsIl9yYWRpdXMiLCJidWJibGluZ01vdXNlRXZlbnRzIiwiZW5hYmxlZCIsImJveFpvb20iLCJkaXNhYmxlIiwid2hlblJlYWR5IiwiY2FsbGJhY2siLCJwaXhlbE9yaWdpbiIsIl9sYXRMbmdUb05ld0xheWVyUG9pbnQiLCJ0b3BMZWZ0IiwiX2xhdExuZ0JvdW5kc1RvTmV3TGF5ZXJCb3VuZHMiLCJsYXRMbmdCb3VuZHMiLCJfZ2V0Q2VudGVyT2Zmc2V0IiwiY2VudGVyUG9pbnQiLCJ2aWV3Qm91bmRzIiwiX2dldEJvdW5kc09mZnNldCIsIl9saW1pdE9mZnNldCIsIm5ld0JvdW5kcyIsInB4Qm91bmRzIiwicHJvamVjdGVkTWF4Qm91bmRzIiwibWluT2Zmc2V0IiwibWF4T2Zmc2V0IiwiZHgiLCJfcmVib3VuZCIsImR5IiwicmlnaHQiLCJwcm94eSIsIm1hcFBhbmUiLCJfYW5pbWF0aW5nWm9vbSIsIl9vblpvb21UcmFuc2l0aW9uRW5kIiwiX2FuaW1Nb3ZlRW5kIiwiX2Rlc3Ryb3lBbmltUHJveHkiLCJ6IiwicHJvcGVydHlOYW1lIiwiX25vdGhpbmdUb0FuaW1hdGUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiX2FuaW1hdGVab29tIiwic3RhcnRBbmltIiwibm9VcGRhdGUiLCJfYW5pbWF0ZVRvQ2VudGVyIiwiX2FuaW1hdGVUb1pvb20iLCJfdGVtcEZpcmVab29tRXZlbnQiLCJjcmVhdGVNYXAiLCJDb250cm9sIiwibWFwIiwiX21hcCIsInJlbW92ZUNvbnRyb2wiLCJhZGRDb250cm9sIiwiYWRkVG8iLCJvbkFkZCIsImNvcm5lciIsIl9jb250cm9sQ29ybmVycyIsIm9uUmVtb3ZlIiwiX3JlZm9jdXNPbk1hcCIsInNjcmVlblgiLCJzY3JlZW5ZIiwiZm9jdXMiLCJjb250cm9sIiwiY29ybmVycyIsIl9jb250cm9sQ29udGFpbmVyIiwiY3JlYXRlQ29ybmVyIiwidlNpZGUiLCJoU2lkZSIsIkxheWVycyIsImNvbGxhcHNlZCIsImF1dG9aSW5kZXgiLCJoaWRlU2luZ2xlQmFzZSIsInNvcnRMYXllcnMiLCJzb3J0RnVuY3Rpb24iLCJsYXllckEiLCJsYXllckIiLCJuYW1lQSIsIm5hbWVCIiwiYmFzZUxheWVycyIsIm92ZXJsYXlzIiwiX2xheWVyQ29udHJvbElucHV0cyIsIl9sYXN0WkluZGV4IiwiX2hhbmRsaW5nQ2xpY2siLCJfcHJldmVudENsaWNrIiwiX2FkZExheWVyIiwiX3VwZGF0ZSIsIl9jaGVja0Rpc2FibGVkTGF5ZXJzIiwiX29uTGF5ZXJDaGFuZ2UiLCJfZXhwYW5kSWZOb3RDb2xsYXBzZWQiLCJhZGRCYXNlTGF5ZXIiLCJhZGRPdmVybGF5IiwicmVtb3ZlTGF5ZXIiLCJfZ2V0TGF5ZXIiLCJleHBhbmQiLCJfc2VjdGlvbiIsImFjY2VwdGFibGVIZWlnaHQiLCJvZmZzZXRUb3AiLCJjb2xsYXBzZSIsInNldEF0dHJpYnV0ZSIsInNlY3Rpb24iLCJfZXhwYW5kU2FmZWx5IiwibGluayIsIl9sYXllcnNMaW5rIiwiaHJlZiIsInRpdGxlIiwia2V5ZG93biIsImtleUNvZGUiLCJjbGljayIsIl9iYXNlTGF5ZXJzTGlzdCIsIl9zZXBhcmF0b3IiLCJfb3ZlcmxheXNMaXN0Iiwib3ZlcmxheSIsInNvcnQiLCJzZXRaSW5kZXgiLCJiYXNlTGF5ZXJzUHJlc2VudCIsIm92ZXJsYXlzUHJlc2VudCIsImJhc2VMYXllcnNDb3VudCIsIl9hZGRJdGVtIiwiZGlzcGxheSIsIl9jcmVhdGVSYWRpb0VsZW1lbnQiLCJjaGVja2VkIiwicmFkaW9IdG1sIiwicmFkaW9GcmFnbWVudCIsImxhYmVsIiwiaGFzTGF5ZXIiLCJpbnB1dCIsImRlZmF1bHRDaGVja2VkIiwibGF5ZXJJZCIsIl9vbklucHV0Q2xpY2siLCJob2xkZXIiLCJpbnB1dHMiLCJhZGRlZExheWVycyIsInJlbW92ZWRMYXllcnMiLCJhZGRMYXllciIsImRpc2FibGVkIiwidGhhdCIsIlpvb20iLCJ6b29tSW5UZXh0Iiwiem9vbUluVGl0bGUiLCJ6b29tT3V0VGV4dCIsInpvb21PdXRUaXRsZSIsInpvb21OYW1lIiwiX3pvb21JbkJ1dHRvbiIsIl9jcmVhdGVCdXR0b24iLCJfem9vbUluIiwiX3pvb21PdXRCdXR0b24iLCJfem9vbU91dCIsIl91cGRhdGVEaXNhYmxlZCIsIl9kaXNhYmxlZCIsInNoaWZ0S2V5IiwiaHRtbCIsInpvb21Db250cm9sIiwiU2NhbGUiLCJtYXhXaWR0aCIsIm1ldHJpYyIsImltcGVyaWFsIiwiX2FkZFNjYWxlcyIsInVwZGF0ZVdoZW5JZGxlIiwiX21TY2FsZSIsIl9pU2NhbGUiLCJtYXhNZXRlcnMiLCJfdXBkYXRlU2NhbGVzIiwiX3VwZGF0ZU1ldHJpYyIsIl91cGRhdGVJbXBlcmlhbCIsIm1ldGVycyIsIl9nZXRSb3VuZE51bSIsIl91cGRhdGVTY2FsZSIsIm1heEZlZXQiLCJtYXhNaWxlcyIsIm1pbGVzIiwiZmVldCIsInRleHQiLCJyYXRpbyIsInBvdzEwIiwidWtyYWluaWFuRmxhZyIsIkF0dHJpYnV0aW9uIiwicHJlZml4IiwiX2F0dHJpYnV0aW9ucyIsImF0dHJpYnV0aW9uQ29udHJvbCIsImdldEF0dHJpYnV0aW9uIiwiYWRkQXR0cmlidXRpb24iLCJfYWRkQXR0cmlidXRpb24iLCJyZW1vdmVBdHRyaWJ1dGlvbiIsInNldFByZWZpeCIsImF0dHJpYnMiLCJwcmVmaXhBbmRBdHRyaWJzIiwiYXR0cmlidXRpb24iLCJIYW5kbGVyIiwiX2VuYWJsZWQiLCJhZGRIb29rcyIsInJlbW92ZUhvb2tzIiwiU1RBUlQiLCJEcmFnZ2FibGUiLCJjbGlja1RvbGVyYW5jZSIsImRyYWdTdGFydFRhcmdldCIsIl9lbGVtZW50IiwiX2RyYWdTdGFydFRhcmdldCIsIl9wcmV2ZW50T3V0bGluZSIsIl9vbkRvd24iLCJfZHJhZ2dpbmciLCJmaW5pc2hEcmFnIiwid2hpY2giLCJidXR0b24iLCJfbW92aW5nIiwiZmlyc3QiLCJzaXplZFBhcmVudCIsIl9zdGFydFBvaW50IiwiX3BhcmVudFNjYWxlIiwibW91c2VldmVudCIsIl9vbk1vdmUiLCJfb25VcCIsIl9sYXN0VGFyZ2V0IiwiU1ZHRWxlbWVudEluc3RhbmNlIiwiY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQiLCJfbmV3UG9zIiwiX2xhc3RFdmVudCIsIl91cGRhdGVQb3NpdGlvbiIsIm5vSW5lcnRpYSIsImZpcmVEcmFnZW5kIiwiY2xpcFBvbHlnb24iLCJjbGlwcGVkUG9pbnRzIiwiZWRnZXMiLCJrIiwiX2NvZGUiLCJfZ2V0Qml0Q29kZSIsIl9nZXRFZGdlSW50ZXJzZWN0aW9uIiwicG9seWdvbkNlbnRlciIsInAxIiwicDIiLCJmIiwiYXJlYSIsImlzRmxhdCIsImNlbnRyb2lkTGF0TG5nIiwiYXJlYUJvdW5kcyIsImNlbnRyb2lkIiwibGF0bG5nQ2VudGVyIiwibGF0U3VtIiwibG5nU3VtIiwic2ltcGxpZnkiLCJ0b2xlcmFuY2UiLCJzcVRvbGVyYW5jZSIsIl9yZWR1Y2VQb2ludHMiLCJfc2ltcGxpZnlEUCIsInBvaW50VG9TZWdtZW50RGlzdGFuY2UiLCJfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQiLCJjbG9zZXN0UG9pbnRPblNlZ21lbnQiLCJBcnJheUNvbnN0cnVjdG9yIiwiVWludDhBcnJheSIsIm1hcmtlcnMiLCJfc2ltcGxpZnlEUFN0ZXAiLCJuZXdQb2ludHMiLCJtYXhTcURpc3QiLCJzcURpc3QiLCJyZWR1Y2VkUG9pbnRzIiwicHJldiIsIl9zcURpc3QiLCJfbGFzdENvZGUiLCJjbGlwU2VnbWVudCIsInVzZUxhc3RDb2RlIiwiY29kZUEiLCJjb2RlQiIsImNvZGVPdXQiLCJuZXdDb2RlIiwiZG90IiwiX2ZsYXQiLCJwb2x5bGluZUNlbnRlciIsImhhbGZEaXN0Iiwic2VnRGlzdCIsImRpc3QiLCJMb25MYXQiLCJNZXJjYXRvciIsIlJfTUlOT1IiLCJ0bXAiLCJjb24iLCJ0cyIsInRhbiIsInBoaSIsImRwaGkiLCJFUFNHMzM5NSIsIkVQU0c0MzI2IiwiU2ltcGxlIiwiTGF5ZXIiLCJyZW1vdmVGcm9tIiwiX21hcFRvQWRkIiwiYWRkSW50ZXJhY3RpdmVUYXJnZXQiLCJ0YXJnZXRFbCIsInJlbW92ZUludGVyYWN0aXZlVGFyZ2V0IiwiX2xheWVyQWRkIiwiZ2V0RXZlbnRzIiwiZXZlbnRzIiwiYmVmb3JlQWRkIiwiZWFjaExheWVyIiwibWV0aG9kIiwiX2FkZFpvb21MaW1pdCIsIl91cGRhdGVab29tTGV2ZWxzIiwiX3JlbW92ZVpvb21MaW1pdCIsIm9sZFpvb21TcGFuIiwiTGF5ZXJHcm91cCIsImdldExheWVySWQiLCJjbGVhckxheWVycyIsImludm9rZSIsIm1ldGhvZE5hbWUiLCJnZXRMYXllciIsImdldExheWVycyIsInpJbmRleCIsImxheWVyR3JvdXAiLCJGZWF0dXJlR3JvdXAiLCJzZXRTdHlsZSIsImJyaW5nVG9Gcm9udCIsImJyaW5nVG9CYWNrIiwiZmVhdHVyZUdyb3VwIiwiSWNvbiIsInBvcHVwQW5jaG9yIiwidG9vbHRpcEFuY2hvciIsImNyb3NzT3JpZ2luIiwiY3JlYXRlSWNvbiIsIm9sZEljb24iLCJfY3JlYXRlSWNvbiIsImNyZWF0ZVNoYWRvdyIsIl9nZXRJY29uVXJsIiwiaW1nIiwiX2NyZWF0ZUltZyIsIl9zZXRJY29uU3R5bGVzIiwic2l6ZU9wdGlvbiIsImFuY2hvciIsInNoYWRvd0FuY2hvciIsImljb25BbmNob3IiLCJtYXJnaW5MZWZ0IiwibWFyZ2luVG9wIiwiaWNvbiIsIkljb25EZWZhdWx0IiwiaWNvblVybCIsImljb25SZXRpbmFVcmwiLCJzaGFkb3dVcmwiLCJpY29uU2l6ZSIsInNoYWRvd1NpemUiLCJpbWFnZVBhdGgiLCJfZGV0ZWN0SWNvblBhdGgiLCJfc3RyaXBVcmwiLCJzdHJpcCIsInJlIiwiaWR4IiwibWF0Y2giLCJxdWVyeVNlbGVjdG9yIiwic3Vic3RyaW5nIiwiTWFya2VyRHJhZyIsIm1hcmtlciIsIl9tYXJrZXIiLCJfaWNvbiIsIl9kcmFnZ2FibGUiLCJkcmFnc3RhcnQiLCJfb25EcmFnU3RhcnQiLCJwcmVkcmFnIiwiX29uUHJlRHJhZyIsImRyYWciLCJfb25EcmFnIiwiZHJhZ2VuZCIsIl9vbkRyYWdFbmQiLCJfYWRqdXN0UGFuIiwic3BlZWQiLCJhdXRvUGFuU3BlZWQiLCJhdXRvUGFuUGFkZGluZyIsImljb25Qb3MiLCJvcmlnaW4iLCJwYW5Cb3VuZHMiLCJtb3ZlbWVudCIsIl9wYW5SZXF1ZXN0IiwiX29sZExhdExuZyIsImNsb3NlUG9wdXAiLCJhdXRvUGFuIiwic2hhZG93IiwiX3NoYWRvdyIsIl9sYXRsbmciLCJvbGRMYXRMbmciLCJNYXJrZXIiLCJpbnRlcmFjdGl2ZSIsImtleWJvYXJkIiwiekluZGV4T2Zmc2V0IiwicmlzZU9uSG92ZXIiLCJyaXNlT2Zmc2V0IiwiYXV0b1Bhbk9uRm9jdXMiLCJkcmFnZ2FibGUiLCJfaW5pdEljb24iLCJ1cGRhdGUiLCJfcmVtb3ZlSWNvbiIsIl9yZW1vdmVTaGFkb3ciLCJ2aWV3cmVzZXQiLCJzZXRMYXRMbmciLCJzZXRaSW5kZXhPZmZzZXQiLCJnZXRJY29uIiwic2V0SWNvbiIsIl9wb3B1cCIsImJpbmRQb3B1cCIsImdldEVsZW1lbnQiLCJfc2V0UG9zIiwiY2xhc3NUb0FkZCIsImFkZEljb24iLCJtb3VzZW92ZXIiLCJfYnJpbmdUb0Zyb250IiwibW91c2VvdXQiLCJfcmVzZXRaSW5kZXgiLCJfcGFuT25Gb2N1cyIsIm5ld1NoYWRvdyIsImFkZFNoYWRvdyIsIl91cGRhdGVPcGFjaXR5IiwiX2luaXRJbnRlcmFjdGlvbiIsIl96SW5kZXgiLCJfdXBkYXRlWkluZGV4Iiwib3B0IiwiaWNvbk9wdHMiLCJfZ2V0UG9wdXBBbmNob3IiLCJfZ2V0VG9vbHRpcEFuY2hvciIsIlBhdGgiLCJzdHJva2UiLCJjb2xvciIsIndlaWdodCIsImxpbmVDYXAiLCJsaW5lSm9pbiIsImRhc2hBcnJheSIsImRhc2hPZmZzZXQiLCJmaWxsIiwiZmlsbENvbG9yIiwiZmlsbE9wYWNpdHkiLCJmaWxsUnVsZSIsImdldFJlbmRlcmVyIiwiX2luaXRQYXRoIiwiX3Jlc2V0IiwiX2FkZFBhdGgiLCJfcmVtb3ZlUGF0aCIsInJlZHJhdyIsIl91cGRhdGVQYXRoIiwiX3VwZGF0ZVN0eWxlIiwiX3VwZGF0ZUJvdW5kcyIsIl9icmluZ1RvQmFjayIsIl9wYXRoIiwiX3Byb2plY3QiLCJfY2xpY2tUb2xlcmFuY2UiLCJDaXJjbGVNYXJrZXIiLCJyYWRpdXMiLCJzZXRSYWRpdXMiLCJnZXRSYWRpdXMiLCJfcG9pbnQiLCJyMiIsIl9yYWRpdXNZIiwiX3B4Qm91bmRzIiwiX3VwZGF0ZUNpcmNsZSIsIl9lbXB0eSIsIl9ib3VuZHMiLCJfY29udGFpbnNQb2ludCIsImNpcmNsZU1hcmtlciIsIkNpcmNsZSIsImxlZ2FjeU9wdGlvbnMiLCJfbVJhZGl1cyIsImhhbGYiLCJsYXRSIiwiYm90dG9tIiwibG5nUiIsImFjb3MiLCJjaXJjbGUiLCJQb2x5bGluZSIsInNtb290aEZhY3RvciIsIm5vQ2xpcCIsIl9zZXRMYXRMbmdzIiwiZ2V0TGF0TG5ncyIsIl9sYXRsbmdzIiwic2V0TGF0TG5ncyIsImlzRW1wdHkiLCJjbG9zZXN0TGF5ZXJQb2ludCIsIm1pbkRpc3RhbmNlIiwibWluUG9pbnQiLCJjbG9zZXN0IiwiakxlbiIsIl9wYXJ0cyIsIl9kZWZhdWx0U2hhcGUiLCJhZGRMYXRMbmciLCJfY29udmVydExhdExuZ3MiLCJyZXN1bHQiLCJmbGF0IiwiX3JpbmdzIiwiX3Byb2plY3RMYXRsbmdzIiwiX3Jhd1B4Qm91bmRzIiwicHJvamVjdGVkQm91bmRzIiwicmluZyIsIl9jbGlwUG9pbnRzIiwicGFydHMiLCJzZWdtZW50IiwiX3NpbXBsaWZ5UG9pbnRzIiwiX3VwZGF0ZVBvbHkiLCJwYXJ0IiwicG9seWxpbmUiLCJQb2x5Z29uIiwicG9wIiwiY2xpcHBlZCIsInBvbHlnb24iLCJHZW9KU09OIiwiZ2VvanNvbiIsImFkZERhdGEiLCJmZWF0dXJlcyIsImZlYXR1cmUiLCJnZW9tZXRyaWVzIiwiZ2VvbWV0cnkiLCJjb29yZGluYXRlcyIsImdlb21ldHJ5VG9MYXllciIsImFzRmVhdHVyZSIsImRlZmF1bHRPcHRpb25zIiwicmVzZXRTdHlsZSIsIm9uRWFjaEZlYXR1cmUiLCJfc2V0TGF5ZXJTdHlsZSIsInBvaW50VG9MYXllciIsIl9jb29yZHNUb0xhdExuZyIsImNvb3Jkc1RvTGF0TG5nIiwiX3BvaW50VG9MYXllciIsImNvb3Jkc1RvTGF0TG5ncyIsImdlb0xheWVyIiwicHJvcGVydGllcyIsImZlYXR1cmVMYXllciIsInBvaW50VG9MYXllckZuIiwibWFya2Vyc0luaGVyaXRPcHRpb25zIiwibGV2ZWxzRGVlcCIsImxhdExuZ1RvQ29vcmRzIiwibGF0TG5nc1RvQ29vcmRzIiwiZ2V0RmVhdHVyZSIsIm5ld0dlb21ldHJ5IiwiUG9pbnRUb0dlb0pTT04iLCJ0b0dlb0pTT04iLCJtdWx0aSIsImhvbGVzIiwidG9NdWx0aVBvaW50IiwiaXNHZW9tZXRyeUNvbGxlY3Rpb24iLCJqc29ucyIsImpzb24iLCJnZW9KU09OIiwiZ2VvSnNvbiIsIkltYWdlT3ZlcmxheSIsImVycm9yT3ZlcmxheVVybCIsInVybCIsIl91cmwiLCJfaW1hZ2UiLCJfaW5pdEltYWdlIiwic3R5bGVPcHRzIiwic2V0VXJsIiwic2V0Qm91bmRzIiwiem9vbWFuaW0iLCJ3YXNFbGVtZW50U3VwcGxpZWQiLCJvbnNlbGVjdHN0YXJ0Iiwib25tb3VzZW1vdmUiLCJvbmxvYWQiLCJvbmVycm9yIiwiX292ZXJsYXlPbkVycm9yIiwiaW1hZ2UiLCJlcnJvclVybCIsImltYWdlT3ZlcmxheSIsIlZpZGVvT3ZlcmxheSIsImF1dG9wbGF5IiwibG9vcCIsImtlZXBBc3BlY3RSYXRpbyIsIm11dGVkIiwicGxheXNJbmxpbmUiLCJ2aWQiLCJvbmxvYWRlZGRhdGEiLCJzb3VyY2VFbGVtZW50cyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwic291cmNlcyIsInNvdXJjZSIsInZpZGVvT3ZlcmxheSIsInZpZGVvIiwiU1ZHT3ZlcmxheSIsInN2Z092ZXJsYXkiLCJEaXZPdmVybGF5IiwiY29udGVudCIsIl9zb3VyY2UiLCJfY29udGVudCIsIm9wZW5PbiIsImNsb3NlIiwidG9nZ2xlIiwiX3ByZXBhcmVPcGVuIiwiX3JlbW92ZVRpbWVvdXQiLCJnZXRDb250ZW50Iiwic2V0Q29udGVudCIsInZpc2liaWxpdHkiLCJfdXBkYXRlQ29udGVudCIsIl91cGRhdGVMYXlvdXQiLCJpc09wZW4iLCJub2RlIiwiX2NvbnRlbnROb2RlIiwiaGFzQ2hpbGROb2RlcyIsIl9nZXRBbmNob3IiLCJfY29udGFpbmVyQm90dG9tIiwiX2NvbnRhaW5lckxlZnQiLCJfY29udGFpbmVyV2lkdGgiLCJfaW5pdE92ZXJsYXkiLCJPdmVybGF5Q2xhc3MiLCJvbGQiLCJQb3B1cCIsIm1pbldpZHRoIiwibWF4SGVpZ2h0IiwiYXV0b1BhblBhZGRpbmdUb3BMZWZ0IiwiYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCIsImtlZXBJblZpZXciLCJjbG9zZUJ1dHRvbiIsImF1dG9DbG9zZSIsImNsb3NlT25Fc2NhcGVLZXkiLCJwb3B1cCIsImNsb3NlT25DbGljayIsImNsb3NlUG9wdXBPbkNsaWNrIiwicHJlY2xpY2siLCJtb3ZlZW5kIiwid3JhcHBlciIsIl93cmFwcGVyIiwiX3RpcENvbnRhaW5lciIsIl90aXAiLCJfY2xvc2VCdXR0b24iLCJ3aGl0ZVNwYWNlIiwic2Nyb2xsZWRDbGFzcyIsIl9hdXRvcGFubmluZyIsIm1hcmdpbkJvdHRvbSIsImNvbnRhaW5lckhlaWdodCIsImNvbnRhaW5lcldpZHRoIiwibGF5ZXJQb3MiLCJjb250YWluZXJQb3MiLCJvcGVuUG9wdXAiLCJfcG9wdXBIYW5kbGVyc0FkZGVkIiwiX29wZW5Qb3B1cCIsImtleXByZXNzIiwiX29uS2V5UHJlc3MiLCJtb3ZlIiwiX21vdmVQb3B1cCIsInVuYmluZFBvcHVwIiwidG9nZ2xlUG9wdXAiLCJpc1BvcHVwT3BlbiIsInNldFBvcHVwQ29udGVudCIsImdldFBvcHVwIiwiVG9vbHRpcCIsImRpcmVjdGlvbiIsInBlcm1hbmVudCIsInN0aWNreSIsInRvb2x0aXAiLCJfc2V0UG9zaXRpb24iLCJzdWJYIiwic3ViWSIsInRvb2x0aXBQb2ludCIsInRvb2x0aXBXaWR0aCIsInRvb2x0aXBIZWlnaHQiLCJvcGVuVG9vbHRpcCIsImNsb3NlVG9vbHRpcCIsImJpbmRUb29sdGlwIiwiX3Rvb2x0aXAiLCJpc1Rvb2x0aXBPcGVuIiwidW5iaW5kVG9vbHRpcCIsIl9pbml0VG9vbHRpcEludGVyYWN0aW9ucyIsIl90b29sdGlwSGFuZGxlcnNBZGRlZCIsIl9tb3ZlVG9vbHRpcCIsIl9vcGVuVG9vbHRpcCIsIl9hZGRGb2N1c0xpc3RlbmVycyIsIm1vdXNlbW92ZSIsIl9zZXRBcmlhRGVzY3JpYmVkQnlPbkxheWVyIiwidG9nZ2xlVG9vbHRpcCIsInNldFRvb2x0aXBDb250ZW50IiwiZ2V0VG9vbHRpcCIsIl9hZGRGb2N1c0xpc3RlbmVyc09uTGF5ZXIiLCJtb3ZpbmciLCJfb3Blbk9uY2VGbGFnIiwiRGl2SWNvbiIsImJnUG9zIiwiRWxlbWVudCIsImJhY2tncm91bmRQb3NpdGlvbiIsImRpdkljb24iLCJEZWZhdWx0IiwiR3JpZExheWVyIiwidGlsZVNpemUiLCJ1cGRhdGVXaGVuWm9vbWluZyIsInVwZGF0ZUludGVydmFsIiwibWF4TmF0aXZlWm9vbSIsIm1pbk5hdGl2ZVpvb20iLCJub1dyYXAiLCJrZWVwQnVmZmVyIiwiX2xldmVscyIsIl90aWxlcyIsIl9yZW1vdmVBbGxUaWxlcyIsIl90aWxlWm9vbSIsIl9zZXRBdXRvWkluZGV4IiwiaXNMb2FkaW5nIiwiX2xvYWRpbmciLCJ0aWxlWm9vbSIsIl9jbGFtcFpvb20iLCJfdXBkYXRlTGV2ZWxzIiwidmlld3ByZXJlc2V0IiwiX2ludmFsaWRhdGVBbGwiLCJjcmVhdGVUaWxlIiwiZ2V0VGlsZVNpemUiLCJjb21wYXJlIiwiY2hpbGRyZW4iLCJlZGdlWkluZGV4IiwiaXNGaW5pdGUiLCJuZXh0RnJhbWUiLCJ3aWxsUHJ1bmUiLCJ0aWxlIiwiY3VycmVudCIsImxvYWRlZCIsImZhZGUiLCJhY3RpdmUiLCJfb25PcGFxdWVUaWxlIiwiX25vUHJ1bmUiLCJfcHJ1bmVUaWxlcyIsIl9mYWRlRnJhbWUiLCJOdW1iZXIiLCJfb25VcGRhdGVMZXZlbCIsIl9yZW1vdmVUaWxlc0F0Wm9vbSIsIl9vblJlbW92ZUxldmVsIiwibGV2ZWwiLCJfc2V0Wm9vbVRyYW5zZm9ybSIsIl9vbkNyZWF0ZUxldmVsIiwiX2xldmVsIiwicmV0YWluIiwiX3JldGFpblBhcmVudCIsIl9yZXRhaW5DaGlsZHJlbiIsIl9yZW1vdmVUaWxlIiwieDIiLCJ5MiIsInoyIiwiY29vcmRzMiIsIl90aWxlQ29vcmRzVG9LZXkiLCJhbmltYXRpbmciLCJfc2V0VmlldyIsIm5vUHJ1bmUiLCJ0aWxlWm9vbUNoYW5nZWQiLCJfYWJvcnRMb2FkaW5nIiwiX3Jlc2V0R3JpZCIsIl9zZXRab29tVHJhbnNmb3JtcyIsInRyYW5zbGF0ZSIsIl90aWxlU2l6ZSIsIl9nbG9iYWxUaWxlUmFuZ2UiLCJfcHhCb3VuZHNUb1RpbGVSYW5nZSIsIl93cmFwWCIsIl93cmFwWSIsIl9nZXRUaWxlZFBpeGVsQm91bmRzIiwibWFwWm9vbSIsImhhbGZTaXplIiwidGlsZVJhbmdlIiwidGlsZUNlbnRlciIsInF1ZXVlIiwibm9QcnVuZVJhbmdlIiwiX2lzVmFsaWRUaWxlIiwiZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiX2FkZFRpbGUiLCJ0aWxlQm91bmRzIiwiX3RpbGVDb29yZHNUb0JvdW5kcyIsIl9rZXlUb0JvdW5kcyIsIl9rZXlUb1RpbGVDb29yZHMiLCJfdGlsZUNvb3Jkc1RvTndTZSIsIm53UG9pbnQiLCJzZVBvaW50IiwiYnAiLCJfaW5pdFRpbGUiLCJ0aWxlUG9zIiwiX2dldFRpbGVQb3MiLCJfd3JhcENvb3JkcyIsIl90aWxlUmVhZHkiLCJfbm9UaWxlc1RvTG9hZCIsIm5ld0Nvb3JkcyIsImdyaWRMYXllciIsIlRpbGVMYXllciIsInN1YmRvbWFpbnMiLCJlcnJvclRpbGVVcmwiLCJ6b29tT2Zmc2V0IiwidG1zIiwiem9vbVJldmVyc2UiLCJkZXRlY3RSZXRpbmEiLCJyZWZlcnJlclBvbGljeSIsIl9vblRpbGVSZW1vdmUiLCJub1JlZHJhdyIsImRvbmUiLCJfdGlsZU9uTG9hZCIsIl90aWxlT25FcnJvciIsImdldFRpbGVVcmwiLCJfZ2V0U3ViZG9tYWluIiwiX2dldFpvb21Gb3JVcmwiLCJpbnZlcnRlZFkiLCJnZXRBdHRyaWJ1dGUiLCJ0aWxlUG9pbnQiLCJjb21wbGV0ZSIsInRpbGVMYXllciIsIlRpbGVMYXllcldNUyIsImRlZmF1bHRXbXNQYXJhbXMiLCJzZXJ2aWNlIiwicmVxdWVzdCIsInN0eWxlcyIsImZvcm1hdCIsInRyYW5zcGFyZW50IiwidmVyc2lvbiIsIndtc1BhcmFtcyIsInJlYWxSZXRpbmEiLCJfY3JzIiwiX3dtc1ZlcnNpb24iLCJwYXJzZUZsb2F0IiwicHJvamVjdGlvbktleSIsImJib3giLCJzZXRQYXJhbXMiLCJ0aWxlTGF5ZXJXTVMiLCJXTVMiLCJ3bXMiLCJSZW5kZXJlciIsIl91cGRhdGVQYXRocyIsIl9kZXN0cm95Q29udGFpbmVyIiwiX29uWm9vbSIsInpvb21lbmQiLCJfb25ab29tRW5kIiwiX29uQW5pbVpvb20iLCJfdXBkYXRlVHJhbnNmb3JtIiwiY3VycmVudENlbnRlclBvaW50IiwiX2NlbnRlciIsInRvcExlZnRPZmZzZXQiLCJDYW52YXMiLCJfb25WaWV3UHJlUmVzZXQiLCJfcG9zdHBvbmVVcGRhdGVQYXRocyIsIl9kcmF3IiwiX29uTW91c2VNb3ZlIiwiX29uQ2xpY2siLCJfaGFuZGxlTW91c2VPdXQiLCJfY3R4IiwiX3JlZHJhd1JlcXVlc3QiLCJfcmVkcmF3Qm91bmRzIiwiX3JlZHJhdyIsIm0iLCJfdXBkYXRlRGFzaEFycmF5Iiwib3JkZXIiLCJfb3JkZXIiLCJfZHJhd0xhc3QiLCJuZXh0IiwiX2RyYXdGaXJzdCIsIl9yZXF1ZXN0UmVkcmF3IiwiX2V4dGVuZFJlZHJhd0JvdW5kcyIsImRhc2hWYWx1ZSIsIl9kYXNoQXJyYXkiLCJfY2xlYXIiLCJjbGVhclJlY3QiLCJzYXZlIiwicmVzdG9yZSIsImJlZ2luUGF0aCIsImNsaXAiLCJfZHJhd2luZyIsImNsb3NlUGF0aCIsIl9maWxsU3Ryb2tlIiwiYXJjIiwiZ2xvYmFsQWxwaGEiLCJmaWxsU3R5bGUiLCJzZXRMaW5lRGFzaCIsImxpbmVXaWR0aCIsInN0cm9rZVN0eWxlIiwiY2xpY2tlZExheWVyIiwiX2ZpcmVFdmVudCIsIl9oYW5kbGVNb3VzZUhvdmVyIiwiX2hvdmVyZWRMYXllciIsIl9tb3VzZUhvdmVyVGhyb3R0bGVkIiwiY2FuZGlkYXRlSG92ZXJlZExheWVyIiwidm1sQ3JlYXRlIiwibmFtZXNwYWNlcyIsInZtbE1peGluIiwiY29vcmRzaXplIiwiX3N0cm9rZSIsIl9maWxsIiwic3Ryb2tlZCIsImZpbGxlZCIsImRhc2hTdHlsZSIsImVuZGNhcCIsImpvaW5zdHlsZSIsIl9zZXRQYXRoIiwiU1ZHIiwiX3Jvb3RHcm91cCIsIl9zdmdTaXplIiwicmVtb3ZlQXR0cmlidXRlIiwiX2dldFBhbmVSZW5kZXJlciIsIl9jcmVhdGVSZW5kZXJlciIsInByZWZlckNhbnZhcyIsIlJlY3RhbmdsZSIsIl9ib3VuZHNUb0xhdExuZ3MiLCJyZWN0YW5nbGUiLCJCb3hab29tIiwiX3BhbmUiLCJvdmVybGF5UGFuZSIsIl9yZXNldFN0YXRlVGltZW91dCIsIl9kZXN0cm95IiwiX29uTW91c2VEb3duIiwiX3Jlc2V0U3RhdGUiLCJfY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUiLCJjb250ZXh0bWVudSIsIm1vdXNldXAiLCJfb25Nb3VzZVVwIiwiX29uS2V5RG93biIsIl9ib3giLCJfZmluaXNoIiwiYm94Wm9vbUJvdW5kcyIsImRvdWJsZUNsaWNrWm9vbSIsIkRvdWJsZUNsaWNrWm9vbSIsIl9vbkRvdWJsZUNsaWNrIiwiaW5lcnRpYSIsImluZXJ0aWFEZWNlbGVyYXRpb24iLCJpbmVydGlhTWF4U3BlZWQiLCJ3b3JsZENvcHlKdW1wIiwibWF4Qm91bmRzVmlzY29zaXR5IiwiRHJhZyIsIl9vblByZURyYWdMaW1pdCIsIl9vblByZURyYWdXcmFwIiwiX3Bvc2l0aW9ucyIsIl90aW1lcyIsIl9vZmZzZXRMaW1pdCIsIl92aXNjb3NpdHkiLCJfbGFzdFRpbWUiLCJfbGFzdFBvcyIsIl9hYnNQb3MiLCJfcHJ1bmVQb3NpdGlvbnMiLCJzaGlmdCIsInB4Q2VudGVyIiwicHhXb3JsZENlbnRlciIsIl9pbml0aWFsV29ybGRPZmZzZXQiLCJfd29ybGRXaWR0aCIsIl92aXNjb3VzTGltaXQiLCJ0aHJlc2hvbGQiLCJsaW1pdCIsIndvcmxkV2lkdGgiLCJoYWxmV2lkdGgiLCJuZXdYMSIsIm5ld1gyIiwibmV3WCIsImVhc2UiLCJzcGVlZFZlY3RvciIsImxpbWl0ZWRTcGVlZCIsImxpbWl0ZWRTcGVlZFZlY3RvciIsImRlY2VsZXJhdGlvbkR1cmF0aW9uIiwia2V5Ym9hcmRQYW5EZWx0YSIsIktleWJvYXJkIiwia2V5Q29kZXMiLCJkb3duIiwidXAiLCJfc2V0UGFuRGVsdGEiLCJfc2V0Wm9vbURlbHRhIiwiX29uRm9jdXMiLCJibHVyIiwiX29uQmx1ciIsIm1vdXNlZG93biIsIl9hZGRIb29rcyIsIl9yZW1vdmVIb29rcyIsIl9mb2N1c2VkIiwiZG9jRWwiLCJzY3JvbGxUbyIsInBhbkRlbHRhIiwia2V5cyIsIl9wYW5LZXlzIiwiY29kZXMiLCJfem9vbUtleXMiLCJhbHRLZXkiLCJjdHJsS2V5IiwibWV0YUtleSIsIm5ld0xhdExuZyIsInNjcm9sbFdoZWVsWm9vbSIsIndoZWVsRGVib3VuY2VUaW1lIiwid2hlZWxQeFBlclpvb21MZXZlbCIsIlNjcm9sbFdoZWVsWm9vbSIsIl9vbldoZWVsU2Nyb2xsIiwiX2RlbHRhIiwiZGVib3VuY2UiLCJfbGFzdE1vdXNlUG9zIiwiX3RpbWVyIiwiX3BlcmZvcm1ab29tIiwiZDIiLCJkMyIsImQ0IiwidGFwSG9sZERlbGF5IiwidGFwSG9sZCIsInRhcFRvbGVyYW5jZSIsIlRhcEhvbGQiLCJfaG9sZFRpbWVvdXQiLCJfY2FuY2VsIiwiX2lzVGFwVmFsaWQiLCJfY2FuY2VsQ2xpY2tQcmV2ZW50IiwiX3NpbXVsYXRlRXZlbnQiLCJjYW5jZWxDbGlja1ByZXZlbnQiLCJzaW11bGF0ZWRFdmVudCIsIk1vdXNlRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInZpZXciLCJkaXNwYXRjaEV2ZW50IiwidG91Y2hab29tIiwiYm91bmNlQXRab29tTGltaXRzIiwiVG91Y2hab29tIiwiX29uVG91Y2hTdGFydCIsIl96b29taW5nIiwiX2NlbnRlclBvaW50IiwiX3N0YXJ0TGF0TG5nIiwiX3BpbmNoU3RhcnRMYXRMbmciLCJfc3RhcnREaXN0IiwiX3N0YXJ0Wm9vbSIsIl9vblRvdWNoTW92ZSIsIl9vblRvdWNoRW5kIiwiX2FuaW1SZXF1ZXN0IiwibW92ZUZuIl0sInNvdXJjZXMiOlsiLi4vc3JjL2NvcmUvVXRpbC5qcyIsIi4uL3NyYy9jb3JlL0NsYXNzLmpzIiwiLi4vc3JjL2NvcmUvRXZlbnRzLmpzIiwiLi4vc3JjL2dlb21ldHJ5L1BvaW50LmpzIiwiLi4vc3JjL2dlb21ldHJ5L0JvdW5kcy5qcyIsIi4uL3NyYy9nZW8vTGF0TG5nQm91bmRzLmpzIiwiLi4vc3JjL2dlby9MYXRMbmcuanMiLCIuLi9zcmMvZ2VvL2Nycy9DUlMuanMiLCIuLi9zcmMvZ2VvL2Nycy9DUlMuRWFydGguanMiLCIuLi9zcmMvZ2VvL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvci5qcyIsIi4uL3NyYy9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbi5qcyIsIi4uL3NyYy9nZW8vY3JzL0NSUy5FUFNHMzg1Ny5qcyIsIi4uL3NyYy9sYXllci92ZWN0b3IvU1ZHLlV0aWwuanMiLCIuLi9zcmMvY29yZS9Ccm93c2VyLmpzIiwiLi4vc3JjL2RvbS9Eb21FdmVudC5Qb2ludGVyLmpzIiwiLi4vc3JjL2RvbS9Eb21FdmVudC5Eb3VibGVUYXAuanMiLCIuLi9zcmMvZG9tL0RvbVV0aWwuanMiLCIuLi9zcmMvZG9tL0RvbUV2ZW50LmpzIiwiLi4vc3JjL2RvbS9Qb3NBbmltYXRpb24uanMiLCIuLi9zcmMvbWFwL01hcC5qcyIsIi4uL3NyYy9jb250cm9sL0NvbnRyb2wuanMiLCIuLi9zcmMvY29udHJvbC9Db250cm9sLkxheWVycy5qcyIsIi4uL3NyYy9jb250cm9sL0NvbnRyb2wuWm9vbS5qcyIsIi4uL3NyYy9jb250cm9sL0NvbnRyb2wuU2NhbGUuanMiLCIuLi9zcmMvY29udHJvbC9Db250cm9sLkF0dHJpYnV0aW9uLmpzIiwiLi4vc3JjL2NvbnRyb2wvaW5kZXguanMiLCIuLi9zcmMvY29yZS9IYW5kbGVyLmpzIiwiLi4vc3JjL2NvcmUvaW5kZXguanMiLCIuLi9zcmMvZG9tL0RyYWdnYWJsZS5qcyIsIi4uL3NyYy9nZW9tZXRyeS9Qb2x5VXRpbC5qcyIsIi4uL3NyYy9nZW9tZXRyeS9MaW5lVXRpbC5qcyIsIi4uL3NyYy9nZW8vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdC5qcyIsIi4uL3NyYy9nZW8vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLk1lcmNhdG9yLmpzIiwiLi4vc3JjL2dlby9wcm9qZWN0aW9uL2luZGV4LmpzIiwiLi4vc3JjL2dlby9jcnMvQ1JTLkVQU0czMzk1LmpzIiwiLi4vc3JjL2dlby9jcnMvQ1JTLkVQU0c0MzI2LmpzIiwiLi4vc3JjL2dlby9jcnMvQ1JTLlNpbXBsZS5qcyIsIi4uL3NyYy9nZW8vY3JzL2luZGV4LmpzIiwiLi4vc3JjL2xheWVyL0xheWVyLmpzIiwiLi4vc3JjL2xheWVyL0xheWVyR3JvdXAuanMiLCIuLi9zcmMvbGF5ZXIvRmVhdHVyZUdyb3VwLmpzIiwiLi4vc3JjL2xheWVyL21hcmtlci9JY29uLmpzIiwiLi4vc3JjL2xheWVyL21hcmtlci9JY29uLkRlZmF1bHQuanMiLCIuLi9zcmMvbGF5ZXIvbWFya2VyL01hcmtlci5EcmFnLmpzIiwiLi4vc3JjL2xheWVyL21hcmtlci9NYXJrZXIuanMiLCIuLi9zcmMvbGF5ZXIvdmVjdG9yL1BhdGguanMiLCIuLi9zcmMvbGF5ZXIvdmVjdG9yL0NpcmNsZU1hcmtlci5qcyIsIi4uL3NyYy9sYXllci92ZWN0b3IvQ2lyY2xlLmpzIiwiLi4vc3JjL2xheWVyL3ZlY3Rvci9Qb2x5bGluZS5qcyIsIi4uL3NyYy9sYXllci92ZWN0b3IvUG9seWdvbi5qcyIsIi4uL3NyYy9sYXllci9HZW9KU09OLmpzIiwiLi4vc3JjL2xheWVyL0ltYWdlT3ZlcmxheS5qcyIsIi4uL3NyYy9sYXllci9WaWRlb092ZXJsYXkuanMiLCIuLi9zcmMvbGF5ZXIvU1ZHT3ZlcmxheS5qcyIsIi4uL3NyYy9sYXllci9EaXZPdmVybGF5LmpzIiwiLi4vc3JjL2xheWVyL1BvcHVwLmpzIiwiLi4vc3JjL2xheWVyL1Rvb2x0aXAuanMiLCIuLi9zcmMvbGF5ZXIvbWFya2VyL0Rpdkljb24uanMiLCIuLi9zcmMvbGF5ZXIvbWFya2VyL2luZGV4LmpzIiwiLi4vc3JjL2xheWVyL3RpbGUvR3JpZExheWVyLmpzIiwiLi4vc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLmpzIiwiLi4vc3JjL2xheWVyL3RpbGUvVGlsZUxheWVyLldNUy5qcyIsIi4uL3NyYy9sYXllci90aWxlL2luZGV4LmpzIiwiLi4vc3JjL2xheWVyL3ZlY3Rvci9SZW5kZXJlci5qcyIsIi4uL3NyYy9sYXllci92ZWN0b3IvQ2FudmFzLmpzIiwiLi4vc3JjL2xheWVyL3ZlY3Rvci9TVkcuVk1MLmpzIiwiLi4vc3JjL2xheWVyL3ZlY3Rvci9TVkcuanMiLCIuLi9zcmMvbGF5ZXIvdmVjdG9yL1JlbmRlcmVyLmdldFJlbmRlcmVyLmpzIiwiLi4vc3JjL2xheWVyL3ZlY3Rvci9SZWN0YW5nbGUuanMiLCIuLi9zcmMvbGF5ZXIvdmVjdG9yL2luZGV4LmpzIiwiLi4vc3JjL2xheWVyL2luZGV4LmpzIiwiLi4vc3JjL21hcC9oYW5kbGVyL01hcC5Cb3hab29tLmpzIiwiLi4vc3JjL21hcC9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20uanMiLCIuLi9zcmMvbWFwL2hhbmRsZXIvTWFwLkRyYWcuanMiLCIuLi9zcmMvbWFwL2hhbmRsZXIvTWFwLktleWJvYXJkLmpzIiwiLi4vc3JjL21hcC9oYW5kbGVyL01hcC5TY3JvbGxXaGVlbFpvb20uanMiLCIuLi9zcmMvbWFwL2hhbmRsZXIvTWFwLlRhcEhvbGQuanMiLCIuLi9zcmMvbWFwL2hhbmRsZXIvTWFwLlRvdWNoWm9vbS5qcyIsIi4uL3NyYy9tYXAvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQG5hbWVzcGFjZSBVdGlsXHJcbiAqXHJcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5LlxyXG4gKi9cclxuXHJcbi8vIEBmdW5jdGlvbiBleHRlbmQoZGVzdDogT2JqZWN0LCBzcmM/OiBPYmplY3QpOiBPYmplY3RcclxuLy8gTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBgc3JjYCBvYmplY3QgKG9yIG11bHRpcGxlIG9iamVjdHMpIGludG8gYGRlc3RgIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgbGF0dGVyLiBIYXMgYW4gYEwuZXh0ZW5kYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChkZXN0KSB7XHJcblx0dmFyIGksIGosIGxlbiwgc3JjO1xyXG5cclxuXHRmb3IgKGogPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcclxuXHRcdHNyYyA9IGFyZ3VtZW50c1tqXTtcclxuXHRcdGZvciAoaSBpbiBzcmMpIHtcclxuXHRcdFx0ZGVzdFtpXSA9IHNyY1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGRlc3Q7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjcmVhdGUocHJvdG86IE9iamVjdCwgcHJvcGVydGllcz86IE9iamVjdCk6IE9iamVjdFxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbT2JqZWN0LmNyZWF0ZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZSlcclxuZXhwb3J0IHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XHJcblx0ZnVuY3Rpb24gRigpIHt9XHJcblx0cmV0dXJuIGZ1bmN0aW9uIChwcm90bykge1xyXG5cdFx0Ri5wcm90b3R5cGUgPSBwcm90bztcclxuXHRcdHJldHVybiBuZXcgRigpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxyXG4vLyBAZnVuY3Rpb24gYmluZChmbjogRnVuY3Rpb24sIOKApik6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gYm91bmQgdG8gdGhlIGFyZ3VtZW50cyBwYXNzZWQsIGxpa2UgW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cclxuLy8gSGFzIGEgYEwuYmluZCgpYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIGJpbmQoZm4sIG9iaikge1xyXG5cdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcclxuXHJcblx0aWYgKGZuLmJpbmQpIHtcclxuXHRcdHJldHVybiBmbi5iaW5kLmFwcGx5KGZuLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG5cdH1cclxuXHJcblx0dmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmxlbmd0aCA/IGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBhcmd1bWVudHMpO1xyXG5cdH07XHJcbn1cclxuXHJcbi8vIEBwcm9wZXJ0eSBsYXN0SWQ6IE51bWJlclxyXG4vLyBMYXN0IHVuaXF1ZSBJRCB1c2VkIGJ5IFtgc3RhbXAoKWBdKCN1dGlsLXN0YW1wKVxyXG5leHBvcnQgdmFyIGxhc3RJZCA9IDA7XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RhbXAob2JqOiBPYmplY3QpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgdW5pcXVlIElEIG9mIGFuIG9iamVjdCwgYXNzaWduaW5nIGl0IG9uZSBpZiBpdCBkb2Vzbid0IGhhdmUgaXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdGFtcChvYmopIHtcclxuXHRpZiAoISgnX2xlYWZsZXRfaWQnIGluIG9iaikpIHtcclxuXHRcdG9ialsnX2xlYWZsZXRfaWQnXSA9ICsrbGFzdElkO1xyXG5cdH1cclxuXHRyZXR1cm4gb2JqLl9sZWFmbGV0X2lkO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdGhyb3R0bGUoZm46IEZ1bmN0aW9uLCB0aW1lOiBOdW1iZXIsIGNvbnRleHQ6IE9iamVjdCk6IEZ1bmN0aW9uXHJcbi8vIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBmdW5jdGlvbiBgZm5gIHdpdGggdGhlIGdpdmVuIHNjb3BlIGBjb250ZXh0YFxyXG4vLyAoc28gdGhhdCB0aGUgYHRoaXNgIGtleXdvcmQgcmVmZXJzIHRvIGBjb250ZXh0YCBpbnNpZGUgYGZuYCdzIGNvZGUpLiBUaGUgZnVuY3Rpb25cclxuLy8gYGZuYCB3aWxsIGJlIGNhbGxlZCBubyBtb3JlIHRoYW4gb25lIHRpbWUgcGVyIGdpdmVuIGFtb3VudCBvZiBgdGltZWAuIFRoZSBhcmd1bWVudHNcclxuLy8gcmVjZWl2ZWQgYnkgdGhlIGJvdW5kIGZ1bmN0aW9uIHdpbGwgYmUgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBiaW5kaW5nIHRoZVxyXG4vLyBmdW5jdGlvbiwgZm9sbG93ZWQgYnkgYW55IGFyZ3VtZW50cyBwYXNzZWQgd2hlbiBpbnZva2luZyB0aGUgYm91bmQgZnVuY3Rpb24uXHJcbi8vIEhhcyBhbiBgTC50aHJvdHRsZWAgc2hvcnRjdXQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZShmbiwgdGltZSwgY29udGV4dCkge1xyXG5cdHZhciBsb2NrLCBhcmdzLCB3cmFwcGVyRm4sIGxhdGVyO1xyXG5cclxuXHRsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIHJlc2V0IGxvY2sgYW5kIGNhbGwgaWYgcXVldWVkXHJcblx0XHRsb2NrID0gZmFsc2U7XHJcblx0XHRpZiAoYXJncykge1xyXG5cdFx0XHR3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblx0XHRcdGFyZ3MgPSBmYWxzZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHR3cmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAobG9jaykge1xyXG5cdFx0XHQvLyBjYWxsZWQgdG9vIHNvb24sIHF1ZXVlIHRvIGNhbGwgbGF0ZXJcclxuXHRcdFx0YXJncyA9IGFyZ3VtZW50cztcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBjYWxsIGFuZCBsb2NrIHVudGlsIGxhdGVyXHJcblx0XHRcdGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHNldFRpbWVvdXQobGF0ZXIsIHRpbWUpO1xyXG5cdFx0XHRsb2NrID0gdHJ1ZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gd3JhcHBlckZuO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gd3JhcE51bShudW06IE51bWJlciwgcmFuZ2U6IE51bWJlcltdLCBpbmNsdWRlTWF4PzogQm9vbGVhbik6IE51bWJlclxyXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgYG51bWAgbW9kdWxvIGByYW5nZWAgaW4gc3VjaCBhIHdheSBzbyBpdCBsaWVzIHdpdGhpblxyXG4vLyBgcmFuZ2VbMF1gIGFuZCBgcmFuZ2VbMV1gLiBUaGUgcmV0dXJuZWQgdmFsdWUgd2lsbCBiZSBhbHdheXMgc21hbGxlciB0aGFuXHJcbi8vIGByYW5nZVsxXWAgdW5sZXNzIGBpbmNsdWRlTWF4YCBpcyBzZXQgdG8gYHRydWVgLlxyXG5leHBvcnQgZnVuY3Rpb24gd3JhcE51bSh4LCByYW5nZSwgaW5jbHVkZU1heCkge1xyXG5cdHZhciBtYXggPSByYW5nZVsxXSxcclxuXHQgICAgbWluID0gcmFuZ2VbMF0sXHJcblx0ICAgIGQgPSBtYXggLSBtaW47XHJcblx0cmV0dXJuIHggPT09IG1heCAmJiBpbmNsdWRlTWF4ID8geCA6ICgoeCAtIG1pbikgJSBkICsgZCkgJSBkICsgbWluO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZmFsc2VGbigpOiBGdW5jdGlvblxyXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cclxuZXhwb3J0IGZ1bmN0aW9uIGZhbHNlRm4oKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuLy8gQGZ1bmN0aW9uIGZvcm1hdE51bShudW06IE51bWJlciwgcHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogTnVtYmVyXHJcbi8vIFJldHVybnMgdGhlIG51bWJlciBgbnVtYCByb3VuZGVkIHdpdGggc3BlY2lmaWVkIGBwcmVjaXNpb25gLlxyXG4vLyBUaGUgZGVmYXVsdCBgcHJlY2lzaW9uYCB2YWx1ZSBpcyA2IGRlY2ltYWwgcGxhY2VzLlxyXG4vLyBgZmFsc2VgIGNhbiBiZSBwYXNzZWQgdG8gc2tpcCBhbnkgcHJvY2Vzc2luZyAoY2FuIGJlIHVzZWZ1bCB0byBhdm9pZCByb3VuZC1vZmYgZXJyb3JzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE51bShudW0sIHByZWNpc2lvbikge1xyXG5cdGlmIChwcmVjaXNpb24gPT09IGZhbHNlKSB7IHJldHVybiBudW07IH1cclxuXHR2YXIgcG93ID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gNiA6IHByZWNpc2lvbik7XHJcblx0cmV0dXJuIE1hdGgucm91bmQobnVtICogcG93KSAvIHBvdztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHRyaW0oc3RyOiBTdHJpbmcpOiBTdHJpbmdcclxuLy8gQ29tcGF0aWJpbGl0eSBwb2x5ZmlsbCBmb3IgW1N0cmluZy5wcm90b3R5cGUudHJpbV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL1RyaW0pXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmltKHN0cikge1xyXG5cdHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3BsaXRXb3JkcyhzdHI6IFN0cmluZyk6IFN0cmluZ1tdXHJcbi8vIFRyaW1zIGFuZCBzcGxpdHMgdGhlIHN0cmluZyBvbiB3aGl0ZXNwYWNlIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiBwYXJ0cy5cclxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0V29yZHMoc3RyKSB7XHJcblx0cmV0dXJuIHRyaW0oc3RyKS5zcGxpdCgvXFxzKy8pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0T3B0aW9ucyhvYmo6IE9iamVjdCwgb3B0aW9uczogT2JqZWN0KTogT2JqZWN0XHJcbi8vIE1lcmdlcyB0aGUgZ2l2ZW4gcHJvcGVydGllcyB0byB0aGUgYG9wdGlvbnNgIG9mIHRoZSBgb2JqYCBvYmplY3QsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIG9wdGlvbnMuIFNlZSBgQ2xhc3Mgb3B0aW9uc2AuIEhhcyBhbiBgTC5zZXRPcHRpb25zYCBzaG9ydGN1dC5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldE9wdGlvbnMob2JqLCBvcHRpb25zKSB7XHJcblx0aWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCAnb3B0aW9ucycpKSB7XHJcblx0XHRvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gY3JlYXRlKG9iai5vcHRpb25zKSA6IHt9O1xyXG5cdH1cclxuXHRmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcclxuXHRcdG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcclxuXHR9XHJcblx0cmV0dXJuIG9iai5vcHRpb25zO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0UGFyYW1TdHJpbmcob2JqOiBPYmplY3QsIGV4aXN0aW5nVXJsPzogU3RyaW5nLCB1cHBlcmNhc2U/OiBCb29sZWFuKTogU3RyaW5nXHJcbi8vIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgcGFyYW1ldGVyIFVSTCBzdHJpbmcsIGUuZy4gYHthOiBcImZvb1wiLCBiOiBcImJhclwifWBcclxuLy8gdHJhbnNsYXRlcyB0byBgJz9hPWZvbyZiPWJhcidgLiBJZiBgZXhpc3RpbmdVcmxgIGlzIHNldCwgdGhlIHBhcmFtZXRlcnMgd2lsbFxyXG4vLyBiZSBhcHBlbmRlZCBhdCB0aGUgZW5kLiBJZiBgdXBwZXJjYXNlYCBpcyBgdHJ1ZWAsIHRoZSBwYXJhbWV0ZXIgbmFtZXMgd2lsbFxyXG4vLyBiZSB1cHBlcmNhc2VkIChlLmcuIGAnP0E9Zm9vJkI9YmFyJ2ApXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmosIGV4aXN0aW5nVXJsLCB1cHBlcmNhc2UpIHtcclxuXHR2YXIgcGFyYW1zID0gW107XHJcblx0Zm9yICh2YXIgaSBpbiBvYmopIHtcclxuXHRcdHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1cHBlcmNhc2UgPyBpLnRvVXBwZXJDYXNlKCkgOiBpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pKTtcclxuXHR9XHJcblx0cmV0dXJuICgoIWV4aXN0aW5nVXJsIHx8IGV4aXN0aW5nVXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpID8gJz8nIDogJyYnKSArIHBhcmFtcy5qb2luKCcmJyk7XHJcbn1cclxuXHJcbnZhciB0ZW1wbGF0ZVJlID0gL1xceyAqKFtcXHdfIC1dKykgKlxcfS9nO1xyXG5cclxuLy8gQGZ1bmN0aW9uIHRlbXBsYXRlKHN0cjogU3RyaW5nLCBkYXRhOiBPYmplY3QpOiBTdHJpbmdcclxuLy8gU2ltcGxlIHRlbXBsYXRpbmcgZmFjaWxpdHksIGFjY2VwdHMgYSB0ZW1wbGF0ZSBzdHJpbmcgb2YgdGhlIGZvcm0gYCdIZWxsbyB7YX0sIHtifSdgXHJcbi8vIGFuZCBhIGRhdGEgb2JqZWN0IGxpa2UgYHthOiAnZm9vJywgYjogJ2Jhcid9YCwgcmV0dXJucyBldmFsdWF0ZWQgc3RyaW5nXHJcbi8vIGAoJ0hlbGxvIGZvbywgYmFyJylgLiBZb3UgY2FuIGFsc28gc3BlY2lmeSBmdW5jdGlvbnMgaW5zdGVhZCBvZiBzdHJpbmdzIGZvclxyXG4vLyBkYXRhIHZhbHVlcyDigJQgdGhleSB3aWxsIGJlIGV2YWx1YXRlZCBwYXNzaW5nIGBkYXRhYCBhcyBhbiBhcmd1bWVudC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlKHN0ciwgZGF0YSkge1xyXG5cdHJldHVybiBzdHIucmVwbGFjZSh0ZW1wbGF0ZVJlLCBmdW5jdGlvbiAoc3RyLCBrZXkpIHtcclxuXHRcdHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcclxuXHJcblx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbHVlIHByb3ZpZGVkIGZvciB2YXJpYWJsZSAnICsgc3RyKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHR2YWx1ZSA9IHZhbHVlKGRhdGEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gaXNBcnJheShvYmopOiBCb29sZWFuXHJcbi8vIENvbXBhdGliaWxpdHkgcG9seWZpbGwgZm9yIFtBcnJheS5pc0FycmF5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5KVxyXG5leHBvcnQgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcclxuXHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nKTtcclxufTtcclxuXHJcbi8vIEBmdW5jdGlvbiBpbmRleE9mKGFycmF5OiBBcnJheSwgZWw6IE9iamVjdCk6IE51bWJlclxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbQXJyYXkucHJvdG90eXBlLmluZGV4T2ZdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2YpXHJcbmV4cG9ydCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbCkge1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChhcnJheVtpXSA9PT0gZWwpIHsgcmV0dXJuIGk7IH1cclxuXHR9XHJcblx0cmV0dXJuIC0xO1xyXG59XHJcblxyXG4vLyBAcHJvcGVydHkgZW1wdHlJbWFnZVVybDogU3RyaW5nXHJcbi8vIERhdGEgVVJJIHN0cmluZyBjb250YWluaW5nIGEgYmFzZTY0LWVuY29kZWQgZW1wdHkgR0lGIGltYWdlLlxyXG4vLyBVc2VkIGFzIGEgaGFjayB0byBmcmVlIG1lbW9yeSBmcm9tIHVudXNlZCBpbWFnZXMgb24gV2ViS2l0LXBvd2VyZWRcclxuLy8gbW9iaWxlIGRldmljZXMgKGJ5IHNldHRpbmcgaW1hZ2UgYHNyY2AgdG8gdGhpcyBzdHJpbmcpLlxyXG5leHBvcnQgdmFyIGVtcHR5SW1hZ2VVcmwgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBRC9BQ3dBQUFBQUFRQUJBQUFDQURzPSc7XHJcblxyXG4vLyBpbnNwaXJlZCBieSBodHRwczovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuXHJcbmZ1bmN0aW9uIGdldFByZWZpeGVkKG5hbWUpIHtcclxuXHRyZXR1cm4gd2luZG93Wyd3ZWJraXQnICsgbmFtZV0gfHwgd2luZG93Wydtb3onICsgbmFtZV0gfHwgd2luZG93WydtcycgKyBuYW1lXTtcclxufVxyXG5cclxudmFyIGxhc3RUaW1lID0gMDtcclxuXHJcbi8vIGZhbGxiYWNrIGZvciBJRSA3LThcclxuZnVuY3Rpb24gdGltZW91dERlZmVyKGZuKSB7XHJcblx0dmFyIHRpbWUgPSArbmV3IERhdGUoKSxcclxuXHQgICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKHRpbWUgLSBsYXN0VGltZSkpO1xyXG5cclxuXHRsYXN0VGltZSA9IHRpbWUgKyB0aW1lVG9DYWxsO1xyXG5cdHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZVRvQ2FsbCk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgcmVxdWVzdEZuID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBnZXRQcmVmaXhlZCgnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgdGltZW91dERlZmVyO1xyXG5leHBvcnQgdmFyIGNhbmNlbEZuID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGdldFByZWZpeGVkKCdDYW5jZWxBbmltYXRpb25GcmFtZScpIHx8XHJcblx0XHRnZXRQcmVmaXhlZCgnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJykgfHwgZnVuY3Rpb24gKGlkKSB7IHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpOyB9O1xyXG5cclxuLy8gQGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0LCBpbW1lZGlhdGU/OiBCb29sZWFuKTogTnVtYmVyXHJcbi8vIFNjaGVkdWxlcyBgZm5gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGJyb3dzZXIgcmVwYWludHMuIGBmbmAgaXMgYm91bmQgdG9cclxuLy8gYGNvbnRleHRgIGlmIGdpdmVuLiBXaGVuIGBpbW1lZGlhdGVgIGlzIHNldCwgYGZuYCBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgaWZcclxuLy8gdGhlIGJyb3dzZXIgZG9lc24ndCBoYXZlIG5hdGl2ZSBzdXBwb3J0IGZvclxyXG4vLyBbYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvd2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZSksXHJcbi8vIG90aGVyd2lzZSBpdCdzIGRlbGF5ZWQuIFJldHVybnMgYSByZXF1ZXN0IElEIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxyXG5leHBvcnQgZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZShmbiwgY29udGV4dCwgaW1tZWRpYXRlKSB7XHJcblx0aWYgKGltbWVkaWF0ZSAmJiByZXF1ZXN0Rm4gPT09IHRpbWVvdXREZWZlcikge1xyXG5cdFx0Zm4uY2FsbChjb250ZXh0KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIHJlcXVlc3RGbi5jYWxsKHdpbmRvdywgYmluZChmbiwgY29udGV4dCkpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZShpZDogTnVtYmVyKTogdW5kZWZpbmVkXHJcbi8vIENhbmNlbHMgYSBwcmV2aW91cyBgcmVxdWVzdEFuaW1GcmFtZWAuIFNlZSBhbHNvIFt3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS93aW5kb3cvY2FuY2VsQW5pbWF0aW9uRnJhbWUpLlxyXG5leHBvcnQgZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKGlkKSB7XHJcblx0aWYgKGlkKSB7XHJcblx0XHRjYW5jZWxGbi5jYWxsKHdpbmRvdywgaWQpO1xyXG5cdH1cclxufVxyXG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XHJcblxyXG4vLyBAY2xhc3MgQ2xhc3NcclxuLy8gQGFrYSBMLkNsYXNzXHJcblxyXG4vLyBAc2VjdGlvblxyXG4vLyBAdW5pbmhlcml0YWJsZVxyXG5cclxuLy8gVGhhbmtzIHRvIEpvaG4gUmVzaWcgYW5kIERlYW4gRWR3YXJkcyBmb3IgaW5zcGlyYXRpb24hXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ2xhc3MoKSB7fVxyXG5cclxuQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblxyXG5cdC8vIEBmdW5jdGlvbiBleHRlbmQocHJvcHM6IE9iamVjdCk6IEZ1bmN0aW9uXHJcblx0Ly8gW0V4dGVuZHMgdGhlIGN1cnJlbnQgY2xhc3NdKCNjbGFzcy1pbmhlcml0YW5jZSkgZ2l2ZW4gdGhlIHByb3BlcnRpZXMgdG8gYmUgaW5jbHVkZWQuXHJcblx0Ly8gUmV0dXJucyBhIEphdmFzY3JpcHQgZnVuY3Rpb24gdGhhdCBpcyBhIGNsYXNzIGNvbnN0cnVjdG9yICh0byBiZSBjYWxsZWQgd2l0aCBgbmV3YCkuXHJcblx0dmFyIE5ld0NsYXNzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzKTtcclxuXHJcblx0XHQvLyBjYWxsIHRoZSBjb25zdHJ1Y3RvclxyXG5cdFx0aWYgKHRoaXMuaW5pdGlhbGl6ZSkge1xyXG5cdFx0XHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjYWxsIGFsbCBjb25zdHJ1Y3RvciBob29rc1xyXG5cdFx0dGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcblx0fTtcclxuXHJcblx0dmFyIHBhcmVudFByb3RvID0gTmV3Q2xhc3MuX19zdXBlcl9fID0gdGhpcy5wcm90b3R5cGU7XHJcblxyXG5cdHZhciBwcm90byA9IFV0aWwuY3JlYXRlKHBhcmVudFByb3RvKTtcclxuXHRwcm90by5jb25zdHJ1Y3RvciA9IE5ld0NsYXNzO1xyXG5cclxuXHROZXdDbGFzcy5wcm90b3R5cGUgPSBwcm90bztcclxuXHJcblx0Ly8gaW5oZXJpdCBwYXJlbnQncyBzdGF0aWNzXHJcblx0Zm9yICh2YXIgaSBpbiB0aGlzKSB7XHJcblx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIGkpICYmIGkgIT09ICdwcm90b3R5cGUnICYmIGkgIT09ICdfX3N1cGVyX18nKSB7XHJcblx0XHRcdE5ld0NsYXNzW2ldID0gdGhpc1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIG1peCBzdGF0aWMgcHJvcGVydGllcyBpbnRvIHRoZSBjbGFzc1xyXG5cdGlmIChwcm9wcy5zdGF0aWNzKSB7XHJcblx0XHRVdGlsLmV4dGVuZChOZXdDbGFzcywgcHJvcHMuc3RhdGljcyk7XHJcblx0fVxyXG5cclxuXHQvLyBtaXggaW5jbHVkZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0aWYgKHByb3BzLmluY2x1ZGVzKSB7XHJcblx0XHRjaGVja0RlcHJlY2F0ZWRNaXhpbkV2ZW50cyhwcm9wcy5pbmNsdWRlcyk7XHJcblx0XHRVdGlsLmV4dGVuZC5hcHBseShudWxsLCBbcHJvdG9dLmNvbmNhdChwcm9wcy5pbmNsdWRlcykpO1xyXG5cdH1cclxuXHJcblx0Ly8gbWl4IGdpdmVuIHByb3BlcnRpZXMgaW50byB0aGUgcHJvdG90eXBlXHJcblx0VXRpbC5leHRlbmQocHJvdG8sIHByb3BzKTtcclxuXHRkZWxldGUgcHJvdG8uc3RhdGljcztcclxuXHRkZWxldGUgcHJvdG8uaW5jbHVkZXM7XHJcblxyXG5cdC8vIG1lcmdlIG9wdGlvbnNcclxuXHRpZiAocHJvdG8ub3B0aW9ucykge1xyXG5cdFx0cHJvdG8ub3B0aW9ucyA9IHBhcmVudFByb3RvLm9wdGlvbnMgPyBVdGlsLmNyZWF0ZShwYXJlbnRQcm90by5vcHRpb25zKSA6IHt9O1xyXG5cdFx0VXRpbC5leHRlbmQocHJvdG8ub3B0aW9ucywgcHJvcHMub3B0aW9ucyk7XHJcblx0fVxyXG5cclxuXHRwcm90by5faW5pdEhvb2tzID0gW107XHJcblxyXG5cdC8vIGFkZCBtZXRob2QgZm9yIGNhbGxpbmcgYWxsIGhvb2tzXHJcblx0cHJvdG8uY2FsbEluaXRIb29rcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdEhvb2tzQ2FsbGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmIChwYXJlbnRQcm90by5jYWxsSW5pdEhvb2tzKSB7XHJcblx0XHRcdHBhcmVudFByb3RvLmNhbGxJbml0SG9va3MuY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0SG9va3NDYWxsZWQgPSB0cnVlO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm90by5faW5pdEhvb2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHByb3RvLl9pbml0SG9va3NbaV0uY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gTmV3Q2xhc3M7XHJcbn07XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGluY2x1ZGUocHJvcGVydGllczogT2JqZWN0KTogdGhpc1xyXG4vLyBbSW5jbHVkZXMgYSBtaXhpbl0oI2NsYXNzLWluY2x1ZGVzKSBpbnRvIHRoZSBjdXJyZW50IGNsYXNzLlxyXG5DbGFzcy5pbmNsdWRlID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblx0dmFyIHBhcmVudE9wdGlvbnMgPSB0aGlzLnByb3RvdHlwZS5vcHRpb25zO1xyXG5cdFV0aWwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLCBwcm9wcyk7XHJcblx0aWYgKHByb3BzLm9wdGlvbnMpIHtcclxuXHRcdHRoaXMucHJvdG90eXBlLm9wdGlvbnMgPSBwYXJlbnRPcHRpb25zO1xyXG5cdFx0dGhpcy5tZXJnZU9wdGlvbnMocHJvcHMub3B0aW9ucyk7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zOiBPYmplY3QpOiB0aGlzXHJcbi8vIFtNZXJnZXMgYG9wdGlvbnNgXSgjY2xhc3Mtb3B0aW9ucykgaW50byB0aGUgZGVmYXVsdHMgb2YgdGhlIGNsYXNzLlxyXG5DbGFzcy5tZXJnZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFV0aWwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZEluaXRIb29rKGZuOiBGdW5jdGlvbik6IHRoaXNcclxuLy8gQWRkcyBhIFtjb25zdHJ1Y3RvciBob29rXSgjY2xhc3MtY29uc3RydWN0b3ItaG9va3MpIHRvIHRoZSBjbGFzcy5cclxuQ2xhc3MuYWRkSW5pdEhvb2sgPSBmdW5jdGlvbiAoZm4pIHsgLy8gKEZ1bmN0aW9uKSB8fCAoU3RyaW5nLCBhcmdzLi4uKVxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcblx0dmFyIGluaXQgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXNbZm5dLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgPSB0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzIHx8IFtdO1xyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MucHVzaChpbml0KTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrRGVwcmVjYXRlZE1peGluRXZlbnRzKGluY2x1ZGVzKSB7XHJcblx0LyogZ2xvYmFsIEw6IHRydWUgKi9cclxuXHRpZiAodHlwZW9mIEwgPT09ICd1bmRlZmluZWQnIHx8ICFMIHx8ICFMLk1peGluKSB7IHJldHVybjsgfVxyXG5cclxuXHRpbmNsdWRlcyA9IFV0aWwuaXNBcnJheShpbmNsdWRlcykgPyBpbmNsdWRlcyA6IFtpbmNsdWRlc107XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgaW5jbHVkZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChpbmNsdWRlc1tpXSA9PT0gTC5NaXhpbi5FdmVudHMpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIGluY2x1ZGUgb2YgTC5NaXhpbi5FdmVudHM6ICcgK1xyXG5cdFx0XHRcdCd0aGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXMsICcgK1xyXG5cdFx0XHRcdCdwbGVhc2UgaW5oZXJpdCBmcm9tIEwuRXZlbnRlZCBpbnN0ZWFkLicsIG5ldyBFcnJvcigpLnN0YWNrKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwiaW1wb3J0IHtDbGFzc30gZnJvbSAnLi9DbGFzcyc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBFdmVudGVkXHJcbiAqIEBha2EgTC5FdmVudGVkXHJcbiAqIEBpbmhlcml0cyBDbGFzc1xyXG4gKlxyXG4gKiBBIHNldCBvZiBtZXRob2RzIHNoYXJlZCBiZXR3ZWVuIGV2ZW50LXBvd2VyZWQgY2xhc3NlcyAobGlrZSBgTWFwYCBhbmQgYE1hcmtlcmApLiBHZW5lcmFsbHksIGV2ZW50cyBhbGxvdyB5b3UgdG8gZXhlY3V0ZSBzb21lIGZ1bmN0aW9uIHdoZW4gc29tZXRoaW5nIGhhcHBlbnMgd2l0aCBhbiBvYmplY3QgKGUuZy4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXAsIGNhdXNpbmcgdGhlIG1hcCB0byBmaXJlIGAnY2xpY2snYCBldmVudCkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAqIFx0YWxlcnQoZS5sYXRsbmcpO1xyXG4gKiB9ICk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBMZWFmbGV0IGRlYWxzIHdpdGggZXZlbnQgbGlzdGVuZXJzIGJ5IHJlZmVyZW5jZSwgc28gaWYgeW91IHdhbnQgdG8gYWRkIGEgbGlzdGVuZXIgYW5kIHRoZW4gcmVtb3ZlIGl0LCBkZWZpbmUgaXQgYXMgYSBmdW5jdGlvbjpcclxuICpcclxuICogYGBganNcclxuICogZnVuY3Rpb24gb25DbGljayhlKSB7IC4uLiB9XHJcbiAqXHJcbiAqIG1hcC5vbignY2xpY2snLCBvbkNsaWNrKTtcclxuICogbWFwLm9mZignY2xpY2snLCBvbkNsaWNrKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBFdmVudHMgPSB7XHJcblx0LyogQG1ldGhvZCBvbih0eXBlOiBTdHJpbmcsIGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBldmVudCB0eXBlIG9mIHRoZSBvYmplY3QuIFlvdSBjYW4gb3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBjb250ZXh0IG9mIHRoZSBsaXN0ZW5lciAob2JqZWN0IHRoZSB0aGlzIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWwgc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblx0ICpcclxuXHQgKiBAYWx0ZXJuYXRpdmVcclxuXHQgKiBAbWV0aG9kIG9uKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cdCAqL1xyXG5cdG9uOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcblx0XHRpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0Ly8gd2UgZG9uJ3QgcHJvY2VzcyBzcGFjZS1zZXBhcmF0ZWQgZXZlbnRzIGhlcmUgZm9yIHBlcmZvcm1hbmNlO1xyXG5cdFx0XHRcdC8vIGl0J3MgYSBob3QgcGF0aCBzaW5jZSBMYXllciB1c2VzIHRoZSBvbihvYmopIHN5bnRheFxyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyB0eXBlcyBjYW4gYmUgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHdvcmRzXHJcblx0XHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX29uKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvKiBAbWV0aG9kIG9mZih0eXBlOiBTdHJpbmcsIGZuPzogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgbGlzdGVuZXIgZnVuY3Rpb24uIElmIG5vIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgaXQgd2lsbCByZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgb2YgdGhhdCBwYXJ0aWN1bGFyIGV2ZW50IGZyb20gdGhlIG9iamVjdC4gTm90ZSB0aGF0IGlmIHlvdSBwYXNzZWQgYSBjdXN0b20gY29udGV4dCB0byBgb25gLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHQgKlxyXG5cdCAqIEBhbHRlcm5hdGl2ZVxyXG5cdCAqIEBtZXRob2Qgb2ZmKGV2ZW50TWFwOiBPYmplY3QpOiB0aGlzXHJcblx0ICogUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLlxyXG5cdCAqXHJcblx0ICogQGFsdGVybmF0aXZlXHJcblx0ICogQG1ldGhvZCBvZmY6IHRoaXNcclxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyBvbiB0aGUgb2JqZWN0LiBUaGlzIGluY2x1ZGVzIGltcGxpY2l0bHkgYXR0YWNoZWQgZXZlbnRzLlxyXG5cdCAqL1xyXG5cdG9mZjogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHQvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGlmIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50c1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIHR5cGVzKSB7XHJcblx0XHRcdFx0dGhpcy5fb2ZmKHR5cGUsIHR5cGVzW3R5cGVdLCBmbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHR2YXIgcmVtb3ZlQWxsID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMTtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKHJlbW92ZUFsbCkge1xyXG5cdFx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5fb2ZmKHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gYXR0YWNoIGxpc3RlbmVyICh3aXRob3V0IHN5bnRhY3RpYyBzdWdhciBub3cpXHJcblx0X29uOiBmdW5jdGlvbiAodHlwZSwgZm4sIGNvbnRleHQsIF9vbmNlKSB7XHJcblx0XHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdGNvbnNvbGUud2Fybignd3JvbmcgbGlzdGVuZXIgdHlwZTogJyArIHR5cGVvZiBmbik7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjaGVjayBpZiBmbiBhbHJlYWR5IHRoZXJlXHJcblx0XHRpZiAodGhpcy5fbGlzdGVucyh0eXBlLCBmbiwgY29udGV4dCkgIT09IGZhbHNlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29udGV4dCA9PT0gdGhpcykge1xyXG5cdFx0XHQvLyBMZXNzIG1lbW9yeSBmb290cHJpbnQuXHJcblx0XHRcdGNvbnRleHQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5ld0xpc3RlbmVyID0ge2ZuOiBmbiwgY3R4OiBjb250ZXh0fTtcclxuXHRcdGlmIChfb25jZSkge1xyXG5cdFx0XHRuZXdMaXN0ZW5lci5vbmNlID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XHJcblx0XHR0aGlzLl9ldmVudHNbdHlwZV0gPSB0aGlzLl9ldmVudHNbdHlwZV0gfHwgW107XHJcblx0XHR0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChuZXdMaXN0ZW5lcik7XHJcblx0fSxcclxuXHJcblx0X29mZjogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzLFxyXG5cdFx0ICAgIGksXHJcblx0XHQgICAgbGVuO1xyXG5cclxuXHRcdGlmICghdGhpcy5fZXZlbnRzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcblx0XHRpZiAoIWxpc3RlbmVycykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHsgLy8gcmVtb3ZlIGFsbFxyXG5cdFx0XHRpZiAodGhpcy5fZmlyaW5nQ291bnQpIHtcclxuXHRcdFx0XHQvLyBTZXQgYWxsIHJlbW92ZWQgbGlzdGVuZXJzIHRvIG5vb3BcclxuXHRcdFx0XHQvLyBzbyB0aGV5IGFyZSBub3QgY2FsbGVkIGlmIHJlbW92ZSBoYXBwZW5zIGluIGZpcmVcclxuXHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdGxpc3RlbmVyc1tpXS5mbiA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gY2xlYXIgYWxsIGxpc3RlbmVycyBmb3IgYSB0eXBlIGlmIGZ1bmN0aW9uIGlzbid0IHNwZWNpZmllZFxyXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGxpc3RlbmVyIHR5cGU6ICcgKyB0eXBlb2YgZm4pO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZmluZCBmbiBhbmQgcmVtb3ZlIGl0XHJcblx0XHR2YXIgaW5kZXggPSB0aGlzLl9saXN0ZW5zKHR5cGUsIGZuLCBjb250ZXh0KTtcclxuXHRcdGlmIChpbmRleCAhPT0gZmFsc2UpIHtcclxuXHRcdFx0dmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2luZGV4XTtcclxuXHRcdFx0aWYgKHRoaXMuX2ZpcmluZ0NvdW50KSB7XHJcblx0XHRcdFx0Ly8gc2V0IHRoZSByZW1vdmVkIGxpc3RlbmVyIHRvIG5vb3Agc28gdGhhdCdzIG5vdCBjYWxsZWQgaWYgcmVtb3ZlIGhhcHBlbnMgaW4gZmlyZVxyXG5cdFx0XHRcdGxpc3RlbmVyLmZuID0gVXRpbC5mYWxzZUZuO1xyXG5cclxuXHRcdFx0XHQvKiBjb3B5IGFycmF5IGluIGNhc2UgZXZlbnRzIGFyZSBiZWluZyBmaXJlZCAqL1xyXG5cdFx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmlyZSh0eXBlOiBTdHJpbmcsIGRhdGE/OiBPYmplY3QsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gRmlyZXMgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLiBZb3UgY2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhIGRhdGFcclxuXHQvLyBvYmplY3Qg4oCUIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gd2lsbCBjb250YWluIGl0c1xyXG5cdC8vIHByb3BlcnRpZXMuIFRoZSBldmVudCBjYW4gb3B0aW9uYWxseSBiZSBwcm9wYWdhdGVkIHRvIGV2ZW50IHBhcmVudHMuXHJcblx0ZmlyZTogZnVuY3Rpb24gKHR5cGUsIGRhdGEsIHByb3BhZ2F0ZSkge1xyXG5cdFx0aWYgKCF0aGlzLmxpc3RlbnModHlwZSwgcHJvcGFnYXRlKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBldmVudCA9IFV0aWwuZXh0ZW5kKHt9LCBkYXRhLCB7XHJcblx0XHRcdHR5cGU6IHR5cGUsXHJcblx0XHRcdHRhcmdldDogdGhpcyxcclxuXHRcdFx0c291cmNlVGFyZ2V0OiBkYXRhICYmIGRhdGEuc291cmNlVGFyZ2V0IHx8IHRoaXNcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9ldmVudHMpIHtcclxuXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdFx0aWYgKGxpc3RlbmVycykge1xyXG5cdFx0XHRcdHRoaXMuX2ZpcmluZ0NvdW50ID0gKHRoaXMuX2ZpcmluZ0NvdW50ICsgMSkgfHwgMTtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgbCA9IGxpc3RlbmVyc1tpXTtcclxuXHRcdFx0XHRcdC8vIG9mZiBvdmVyd3JpdGVzIGwuZm4sIHNvIHdlIG5lZWQgdG8gY29weSBmbiB0byBhIHZhclxyXG5cdFx0XHRcdFx0dmFyIGZuID0gbC5mbjtcclxuXHRcdFx0XHRcdGlmIChsLm9uY2UpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5vZmYodHlwZSwgZm4sIGwuY3R4KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGZuLmNhbGwobC5jdHggfHwgdGhpcywgZXZlbnQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5fZmlyaW5nQ291bnQtLTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChwcm9wYWdhdGUpIHtcclxuXHRcdFx0Ly8gcHJvcGFnYXRlIHRoZSBldmVudCB0byBwYXJlbnRzIChzZXQgd2l0aCBhZGRFdmVudFBhcmVudClcclxuXHRcdFx0dGhpcy5fcHJvcGFnYXRlRXZlbnQoZXZlbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGlzdGVucyh0eXBlOiBTdHJpbmcsIHByb3BhZ2F0ZT86IEJvb2xlYW4pOiBCb29sZWFuXHJcblx0Ly8gQG1ldGhvZCBsaXN0ZW5zKHR5cGU6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0LCBwcm9wYWdhdGU/OiBCb29sZWFuKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIGEgcGFydGljdWxhciBldmVudCB0eXBlIGhhcyBhbnkgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIGl0LlxyXG5cdC8vIFRoZSB2ZXJpZmljYXRpb24gY2FuIG9wdGlvbmFsbHkgYmUgcHJvcGFnYXRlZCwgaXQgd2lsbCByZXR1cm4gYHRydWVgIGlmIHBhcmVudHMgaGF2ZSB0aGUgbGlzdGVuZXIgYXR0YWNoZWQgdG8gaXQuXHJcblx0bGlzdGVuczogZnVuY3Rpb24gKHR5cGUsIGZuLCBjb250ZXh0LCBwcm9wYWdhdGUpIHtcclxuXHRcdGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCdcInN0cmluZ1wiIHR5cGUgYXJndW1lbnQgZXhwZWN0ZWQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyB3ZSBkb24ndCBvdmVyd3JpdGUgdGhlIGlucHV0IGBmbmAgdmFsdWUsIGJlY2F1c2Ugd2UgbmVlZCB0byB1c2UgaXQgZm9yIHByb3BhZ2F0aW9uXHJcblx0XHR2YXIgX2ZuID0gZm47XHJcblx0XHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHByb3BhZ2F0ZSA9ICEhZm47XHJcblx0XHRcdF9mbiA9IHVuZGVmaW5lZDtcclxuXHRcdFx0Y29udGV4dCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuXHRcdGlmIChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzLmxlbmd0aCkge1xyXG5cdFx0XHRpZiAodGhpcy5fbGlzdGVucyh0eXBlLCBfZm4sIGNvbnRleHQpICE9PSBmYWxzZSkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHByb3BhZ2F0ZSkge1xyXG5cdFx0XHQvLyBhbHNvIGNoZWNrIHBhcmVudHMgZm9yIGxpc3RlbmVycyBpZiBldmVudCBwcm9wYWdhdGVzXHJcblx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHRcdGlmICh0aGlzLl9ldmVudFBhcmVudHNbaWRdLmxpc3RlbnModHlwZSwgZm4sIGNvbnRleHQsIHByb3BhZ2F0ZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybnMgdGhlIGluZGV4IChudW1iZXIpIG9yIGZhbHNlXHJcblx0X2xpc3RlbnM6IGZ1bmN0aW9uICh0eXBlLCBmbiwgY29udGV4dCkge1xyXG5cdFx0aWYgKCF0aGlzLl9ldmVudHMpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV0gfHwgW107XHJcblx0XHRpZiAoIWZuKSB7XHJcblx0XHRcdHJldHVybiAhIWxpc3RlbmVycy5sZW5ndGg7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbnRleHQgPT09IHRoaXMpIHtcclxuXHRcdFx0Ly8gTGVzcyBtZW1vcnkgZm9vdHByaW50LlxyXG5cdFx0XHRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0aWYgKGxpc3RlbmVyc1tpXS5mbiA9PT0gZm4gJiYgbGlzdGVuZXJzW2ldLmN0eCA9PT0gY29udGV4dCkge1xyXG5cdFx0XHRcdHJldHVybiBpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb25jZSjigKYpOiB0aGlzXHJcblx0Ly8gQmVoYXZlcyBhcyBbYG9uKOKApilgXSgjZXZlbnRlZC1vbiksIGV4Y2VwdCB0aGUgbGlzdGVuZXIgd2lsbCBvbmx5IGdldCBmaXJlZCBvbmNlIGFuZCB0aGVuIHJlbW92ZWQuXHJcblx0b25jZTogZnVuY3Rpb24gKHR5cGVzLCBmbiwgY29udGV4dCkge1xyXG5cclxuXHRcdC8vIHR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG5cdFx0aWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiB0eXBlcykge1xyXG5cdFx0XHRcdC8vIHdlIGRvbid0IHByb2Nlc3Mgc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBoZXJlIGZvciBwZXJmb3JtYW5jZTtcclxuXHRcdFx0XHQvLyBpdCdzIGEgaG90IHBhdGggc2luY2UgTGF5ZXIgdXNlcyB0aGUgb24ob2JqKSBzeW50YXhcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlLCB0eXBlc1t0eXBlXSwgZm4sIHRydWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gdHlwZXMgY2FuIGJlIGEgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCB3b3Jkc1xyXG5cdFx0XHR0eXBlcyA9IFV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLl9vbih0eXBlc1tpXSwgZm4sIGNvbnRleHQsIHRydWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRFdmVudFBhcmVudChvYmo6IEV2ZW50ZWQpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBldmVudCBwYXJlbnQgLSBhbiBgRXZlbnRlZGAgdGhhdCB3aWxsIHJlY2VpdmUgcHJvcGFnYXRlZCBldmVudHNcclxuXHRhZGRFdmVudFBhcmVudDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dGhpcy5fZXZlbnRQYXJlbnRzID0gdGhpcy5fZXZlbnRQYXJlbnRzIHx8IHt9O1xyXG5cdFx0dGhpcy5fZXZlbnRQYXJlbnRzW1V0aWwuc3RhbXAob2JqKV0gPSBvYmo7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZUV2ZW50UGFyZW50KG9iajogRXZlbnRlZCk6IHRoaXNcclxuXHQvLyBSZW1vdmVzIGFuIGV2ZW50IHBhcmVudCwgc28gaXQgd2lsbCBzdG9wIHJlY2VpdmluZyBwcm9wYWdhdGVkIGV2ZW50c1xyXG5cdHJlbW92ZUV2ZW50UGFyZW50OiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRpZiAodGhpcy5fZXZlbnRQYXJlbnRzKSB7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudFBhcmVudHNbVXRpbC5zdGFtcChvYmopXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9wcm9wYWdhdGVFdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2V2ZW50UGFyZW50cykge1xyXG5cdFx0XHR0aGlzLl9ldmVudFBhcmVudHNbaWRdLmZpcmUoZS50eXBlLCBVdGlsLmV4dGVuZCh7XHJcblx0XHRcdFx0bGF5ZXI6IGUudGFyZ2V0LFxyXG5cdFx0XHRcdHByb3BhZ2F0ZWRGcm9tOiBlLnRhcmdldFxyXG5cdFx0XHR9LCBlKSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuLy8gYWxpYXNlczsgd2Ugc2hvdWxkIGRpdGNoIHRob3NlIGV2ZW50dWFsbHlcclxuXHJcbi8vIEBtZXRob2QgYWRkRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb24o4oCmKWBdKCNldmVudGVkLW9uKVxyXG5FdmVudHMuYWRkRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5vbjtcclxuXHJcbi8vIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgb2ZmKOKApilgXSgjZXZlbnRlZC1vZmYpXHJcblxyXG4vLyBAbWV0aG9kIGNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9mZigpYF0oI2V2ZW50ZWQtb2ZmKVxyXG5FdmVudHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5jbGVhckFsbEV2ZW50TGlzdGVuZXJzID0gRXZlbnRzLm9mZjtcclxuXHJcbi8vIEBtZXRob2QgYWRkT25lVGltZUV2ZW50TGlzdGVuZXIo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYG9uY2Uo4oCmKWBdKCNldmVudGVkLW9uY2UpXHJcbkV2ZW50cy5hZGRPbmVUaW1lRXZlbnRMaXN0ZW5lciA9IEV2ZW50cy5vbmNlO1xyXG5cclxuLy8gQG1ldGhvZCBmaXJlRXZlbnQo4oCmKTogdGhpc1xyXG4vLyBBbGlhcyB0byBbYGZpcmUo4oCmKWBdKCNldmVudGVkLWZpcmUpXHJcbkV2ZW50cy5maXJlRXZlbnQgPSBFdmVudHMuZmlyZTtcclxuXHJcbi8vIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lcnMo4oCmKTogQm9vbGVhblxyXG4vLyBBbGlhcyB0byBbYGxpc3RlbnMo4oCmKWBdKCNldmVudGVkLWxpc3RlbnMpXHJcbkV2ZW50cy5oYXNFdmVudExpc3RlbmVycyA9IEV2ZW50cy5saXN0ZW5zO1xyXG5cclxuZXhwb3J0IHZhciBFdmVudGVkID0gQ2xhc3MuZXh0ZW5kKEV2ZW50cyk7XHJcbiIsImltcG9ydCB7aXNBcnJheSwgZm9ybWF0TnVtfSBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFBvaW50XHJcbiAqIEBha2EgTC5Qb2ludFxyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgcG9pbnQgd2l0aCBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBpbiBwaXhlbHMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwb2ludCA9IEwucG9pbnQoMjAwLCAzMDApO1xyXG4gKiBgYGBcclxuICpcclxuICogQWxsIExlYWZsZXQgbWV0aG9kcyBhbmQgb3B0aW9ucyB0aGF0IGFjY2VwdCBgUG9pbnRgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hcC5wYW5CeShbMjAwLCAzMDBdKTtcclxuICogbWFwLnBhbkJ5KEwucG9pbnQoMjAwLCAzMDApKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgUG9pbnRgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gUG9pbnQoeCwgeSwgcm91bmQpIHtcclxuXHQvLyBAcHJvcGVydHkgeDogTnVtYmVyOyBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XHJcblx0dGhpcy54ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh4KSA6IHgpO1xyXG5cdC8vIEBwcm9wZXJ0eSB5OiBOdW1iZXI7IFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuXHR0aGlzLnkgPSAocm91bmQgPyBNYXRoLnJvdW5kKHkpIDogeSk7XHJcbn1cclxuXHJcbnZhciB0cnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gKHYpIHtcclxuXHRyZXR1cm4gdiA+IDAgPyBNYXRoLmZsb29yKHYpIDogTWF0aC5jZWlsKHYpO1xyXG59O1xyXG5cclxuUG9pbnQucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGNsb25lKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgcG9pbnQuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkKG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYWRkaXRpb24gb2YgdGhlIGN1cnJlbnQgYW5kIHRoZSBnaXZlbiBwb2ludHMuXHJcblx0YWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdC8vIG5vbi1kZXN0cnVjdGl2ZSwgcmV0dXJucyBhIG5ldyBwb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHRvUG9pbnQocG9pbnQpKTtcclxuXHR9LFxyXG5cclxuXHRfYWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdC8vIGRlc3RydWN0aXZlLCB1c2VkIGRpcmVjdGx5IGZvciBwZXJmb3JtYW5jZSBpbiBzaXR1YXRpb25zIHdoZXJlIGl0J3Mgc2FmZSB0byBtb2RpZnkgZXhpc3RpbmcgcG9pbnRcclxuXHRcdHRoaXMueCArPSBwb2ludC54O1xyXG5cdFx0dGhpcy55ICs9IHBvaW50Lnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHN1YnRyYWN0KG90aGVyUG9pbnQ6IFBvaW50KTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2Ygc3VidHJhY3Rpb24gb2YgdGhlIGdpdmVuIHBvaW50IGZyb20gdGhlIGN1cnJlbnQuXHJcblx0c3VidHJhY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fc3VidHJhY3QodG9Qb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdF9zdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR0aGlzLnggLT0gcG9pbnQueDtcclxuXHRcdHRoaXMueSAtPSBwb2ludC55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXZpZGVCeShudW06IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcblx0ZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2RpdmlkZUJ5KG51bSk7XHJcblx0fSxcclxuXHJcblx0X2RpdmlkZUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggLz0gbnVtO1xyXG5cdFx0dGhpcy55IC89IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbXVsdGlwbHlCeShudW06IE51bWJlcik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5IHRoZSBnaXZlbiBudW1iZXIuXHJcblx0bXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fbXVsdGlwbHlCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9tdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggKj0gbnVtO1xyXG5cdFx0dGhpcy55ICo9IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG5cdC8vIE11bHRpcGx5IGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgY3VycmVudCBwb2ludCBieSBlYWNoIGNvb3JkaW5hdGUgb2ZcclxuXHQvLyBgc2NhbGVgLiBJbiBsaW5lYXIgYWxnZWJyYSB0ZXJtcywgbXVsdGlwbHkgdGhlIHBvaW50IGJ5IHRoZVxyXG5cdC8vIFtzY2FsaW5nIG1hdHJpeF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2NhbGluZ18lMjhnZW9tZXRyeSUyOSNNYXRyaXhfcmVwcmVzZW50YXRpb24pXHJcblx0Ly8gZGVmaW5lZCBieSBgc2NhbGVgLlxyXG5cdHNjYWxlQnk6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBwb2ludC54LCB0aGlzLnkgKiBwb2ludC55KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVuc2NhbGVCeShzY2FsZTogUG9pbnQpOiBQb2ludFxyXG5cdC8vIEludmVyc2Ugb2YgYHNjYWxlQnlgLiBEaXZpZGUgZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjdXJyZW50IHBvaW50IGJ5XHJcblx0Ly8gZWFjaCBjb29yZGluYXRlIG9mIGBzY2FsZWAuXHJcblx0dW5zY2FsZUJ5OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByb3VuZCgpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggcm91bmRlZCBjb29yZGluYXRlcy5cclxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfcm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZmxvb3IoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGZsb29yZWQgY29vcmRpbmF0ZXMgKHJvdW5kZWQgZG93bikuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2Zsb29yKCk7XHJcblx0fSxcclxuXHJcblx0X2Zsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNlaWwoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBwb2ludCB3aXRoIGNlaWxlZCBjb29yZGluYXRlcyAocm91bmRlZCB1cCkuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fY2VpbCgpO1xyXG5cdH0sXHJcblxyXG5cdF9jZWlsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcclxuXHRcdHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0cnVuYygpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHBvaW50IHdpdGggdHJ1bmNhdGVkIGNvb3JkaW5hdGVzIChyb3VuZGVkIHRvd2FyZHMgemVybykuXHJcblx0dHJ1bmM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX3RydW5jKCk7XHJcblx0fSxcclxuXHJcblx0X3RydW5jOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSB0cnVuYyh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gdHJ1bmModGhpcy55KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZGlzdGFuY2VUbyhvdGhlclBvaW50OiBQb2ludCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGNhcnRlc2lhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgZ2l2ZW4gcG9pbnRzLlxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHR2YXIgeCA9IHBvaW50LnggLSB0aGlzLngsXHJcblx0XHQgICAgeSA9IHBvaW50LnkgLSB0aGlzLnk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcG9pbnQgaGFzIHRoZSBzYW1lIGNvb3JkaW5hdGVzLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IHRvUG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBwb2ludC54ID09PSB0aGlzLnggJiZcclxuXHRcdCAgICAgICBwb2ludC55ID09PSB0aGlzLnk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWlucyhvdGhlclBvaW50OiBQb2ludCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGNvb3JkaW5hdGVzIG9mIHRoZSBnaXZlbiBwb2ludCBhcmUgbGVzcyB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIGN1cnJlbnQgcG9pbnQgY29vcmRpbmF0ZXMgKGluIGFic29sdXRlIHZhbHVlcykuXHJcblx0Y29udGFpbnM6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cG9pbnQgPSB0b1BvaW50KHBvaW50KTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMocG9pbnQueCkgPD0gTWF0aC5hYnModGhpcy54KSAmJlxyXG5cdFx0ICAgICAgIE1hdGguYWJzKHBvaW50LnkpIDw9IE1hdGguYWJzKHRoaXMueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b1N0cmluZygpOiBTdHJpbmdcclxuXHQvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gJ1BvaW50KCcgK1xyXG5cdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy54KSArICcsICcgK1xyXG5cdFx0ICAgICAgICBmb3JtYXROdW0odGhpcy55KSArICcpJztcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAZmFjdG9yeSBMLnBvaW50KHg6IE51bWJlciwgeTogTnVtYmVyLCByb3VuZD86IEJvb2xlYW4pXHJcbi8vIENyZWF0ZXMgYSBQb2ludCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMuIElmIG9wdGlvbmFsIGByb3VuZGAgaXMgc2V0IHRvIHRydWUsIHJvdW5kcyB0aGUgYHhgIGFuZCBgeWAgdmFsdWVzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBOdW1iZXJbXSlcclxuLy8gRXhwZWN0cyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW3gsIHldYCBpbnN0ZWFkLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwucG9pbnQoY29vcmRzOiBPYmplY3QpXHJcbi8vIEV4cGVjdHMgYSBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHt4OiBOdW1iZXIsIHk6IE51bWJlcn1gIGluc3RlYWQuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1BvaW50KHgsIHksIHJvdW5kKSB7XHJcblx0aWYgKHggaW5zdGFuY2VvZiBQb2ludCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdGlmIChpc0FycmF5KHgpKSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHhbMF0sIHhbMV0pO1xyXG5cdH1cclxuXHRpZiAoeCA9PT0gdW5kZWZpbmVkIHx8IHggPT09IG51bGwpIHtcclxuXHRcdHJldHVybiB4O1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmICd4JyBpbiB4ICYmICd5JyBpbiB4KSB7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KHgueCwgeC55KTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBQb2ludCh4LCB5LCByb3VuZCk7XHJcbn1cclxuIiwiaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQm91bmRzXHJcbiAqIEBha2EgTC5Cb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGFyZWEgaW4gcGl4ZWwgY29vcmRpbmF0ZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBwMSA9IEwucG9pbnQoMTAsIDEwKSxcclxuICogcDIgPSBMLnBvaW50KDQwLCA2MCksXHJcbiAqIGJvdW5kcyA9IEwuYm91bmRzKHAxLCBwMik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IGBCb3VuZHNgIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBvdGhlckJvdW5kcy5pbnRlcnNlY3RzKFtbMTAsIDEwXSwgWzQwLCA2MF1dKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgQm91bmRzYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEJvdW5kcyhhLCBiKSB7XHJcblx0aWYgKCFhKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgcG9pbnRzID0gYiA/IFthLCBiXSA6IGE7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdHRoaXMuZXh0ZW5kKHBvaW50c1tpXSk7XHJcblx0fVxyXG59XHJcblxyXG5Cb3VuZHMucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKHBvaW50OiBQb2ludCk6IHRoaXNcclxuXHQvLyBFeHRlbmRzIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgZXh0ZW5kKG90aGVyQm91bmRzOiBCb3VuZHMpOiB0aGlzXHJcblx0Ly8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbWluMiwgbWF4MjtcclxuXHRcdGlmICghb2JqKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIFBvaW50IHx8IHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8ICd4JyBpbiBvYmopIHtcclxuXHRcdFx0bWluMiA9IG1heDIgPSB0b1BvaW50KG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSB0b0JvdW5kcyhvYmopO1xyXG5cdFx0XHRtaW4yID0gb2JqLm1pbjtcclxuXHRcdFx0bWF4MiA9IG9iai5tYXg7XHJcblxyXG5cdFx0XHRpZiAoIW1pbjIgfHwgIW1heDIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAcHJvcGVydHkgbWluOiBQb2ludFxyXG5cdFx0Ly8gVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cdFx0Ly8gQHByb3BlcnR5IG1heDogUG9pbnRcclxuXHRcdC8vIFRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSByZWN0YW5nbGUuXHJcblx0XHRpZiAoIXRoaXMubWluICYmICF0aGlzLm1heCkge1xyXG5cdFx0XHR0aGlzLm1pbiA9IG1pbjIuY2xvbmUoKTtcclxuXHRcdFx0dGhpcy5tYXggPSBtYXgyLmNsb25lKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm1pbi54ID0gTWF0aC5taW4obWluMi54LCB0aGlzLm1pbi54KTtcclxuXHRcdFx0dGhpcy5tYXgueCA9IE1hdGgubWF4KG1heDIueCwgdGhpcy5tYXgueCk7XHJcblx0XHRcdHRoaXMubWluLnkgPSBNYXRoLm1pbihtaW4yLnksIHRoaXMubWluLnkpO1xyXG5cdFx0XHR0aGlzLm1heC55ID0gTWF0aC5tYXgobWF4Mi55LCB0aGlzLm1heC55KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKHJvdW5kPzogQm9vbGVhbik6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAocm91bmQpIHtcclxuXHRcdHJldHVybiB0b1BvaW50KFxyXG5cdFx0ICAgICAgICAodGhpcy5taW4ueCArIHRoaXMubWF4LngpIC8gMixcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnkgKyB0aGlzLm1heC55KSAvIDIsIHJvdW5kKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdHRvbUxlZnQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tbGVmdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldEJvdHRvbUxlZnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0b1BvaW50KHRoaXMubWluLngsIHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0VG9wUmlnaHQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSB0b3AtcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRUb3BSaWdodDogZnVuY3Rpb24gKCkgeyAvLyAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5tYXgueCwgdGhpcy5taW4ueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRUb3BMZWZ0KCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgdG9wLWxlZnQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWluYF0oI2JvdW5kcy1taW4pKS5cclxuXHRnZXRUb3BMZWZ0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5taW47IC8vIGxlZnQsIHRvcFxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm90dG9tUmlnaHQoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBib3R0b20tcmlnaHQgcG9pbnQgb2YgdGhlIGJvdW5kcyAoaS5lLiBbYHRoaXMubWF4YF0oI2JvdW5kcy1tYXgpKS5cclxuXHRnZXRCb3R0b21SaWdodDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4OyAvLyByaWdodCwgYm90dG9tXHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTaXplKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gYm91bmRzXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4LnN1YnRyYWN0KHRoaXMubWluKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5zKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBjb250YWlucyB0aGUgZ2l2ZW4gb25lLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMocG9pbnQ6IFBvaW50KTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvYmpbMF0gPT09ICdudW1iZXInIHx8IG9iaiBpbnN0YW5jZW9mIFBvaW50KSB7XHJcblx0XHRcdG9iaiA9IHRvUG9pbnQob2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9iaiA9IHRvQm91bmRzKG9iaik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEJvdW5kcykge1xyXG5cdFx0XHRtaW4gPSBvYmoubWluO1xyXG5cdFx0XHRtYXggPSBvYmoubWF4O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWluID0gbWF4ID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAobWluLnggPj0gdGhpcy5taW4ueCkgJiZcclxuXHRcdCAgICAgICAobWF4LnggPD0gdGhpcy5tYXgueCkgJiZcclxuXHRcdCAgICAgICAobWluLnkgPj0gdGhpcy5taW4ueSkgJiZcclxuXHRcdCAgICAgICAobWF4LnkgPD0gdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBpbnRlcnNlY3QgaWYgdGhleSBoYXZlIGF0IGxlYXN0IG9uZSBwb2ludCBpbiBjb21tb24uXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSB0b0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4SW50ZXJzZWN0cyA9IChtYXgyLnggPj0gbWluLngpICYmIChtaW4yLnggPD0gbWF4LngpLFxyXG5cdFx0ICAgIHlJbnRlcnNlY3RzID0gKG1heDIueSA+PSBtaW4ueSkgJiYgKG1pbjIueSA8PSBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhJbnRlcnNlY3RzICYmIHlJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IEJvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHNcclxuXHQvLyBvdmVybGFwIGlmIHRoZWlyIGludGVyc2VjdGlvbiBpcyBhbiBhcmVhLlxyXG5cdG92ZXJsYXBzOiBmdW5jdGlvbiAoYm91bmRzKSB7IC8vIChCb3VuZHMpIC0+IEJvb2xlYW5cclxuXHRcdGJvdW5kcyA9IHRvQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIG1pbiA9IHRoaXMubWluLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMubWF4LFxyXG5cdFx0ICAgIG1pbjIgPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heDIgPSBib3VuZHMubWF4LFxyXG5cdFx0ICAgIHhPdmVybGFwcyA9IChtYXgyLnggPiBtaW4ueCkgJiYgKG1pbjIueCA8IG1heC54KSxcclxuXHRcdCAgICB5T3ZlcmxhcHMgPSAobWF4Mi55ID4gbWluLnkpICYmIChtaW4yLnkgPCBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhPdmVybGFwcyAmJiB5T3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpc1ZhbGlkKCk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYm91bmRzIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZC5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5taW4gJiYgdGhpcy5tYXgpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyBib3VuZHMgY3JlYXRlZCBieSBleHRlbmRpbmcgb3IgcmV0cmFjdGluZyB0aGUgY3VycmVudCBib3VuZHMgYnkgYSBnaXZlbiByYXRpbyBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBGb3IgZXhhbXBsZSwgYSByYXRpbyBvZiAwLjUgZXh0ZW5kcyB0aGUgYm91bmRzIGJ5IDUwJSBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBOZWdhdGl2ZSB2YWx1ZXMgd2lsbCByZXRyYWN0IHRoZSBib3VuZHMuXHJcblx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdG1heCA9IHRoaXMubWF4LFxyXG5cdFx0aGVpZ2h0QnVmZmVyID0gTWF0aC5hYnMobWluLnggLSBtYXgueCkgKiBidWZmZXJSYXRpbyxcclxuXHRcdHdpZHRoQnVmZmVyID0gTWF0aC5hYnMobWluLnkgLSBtYXgueSkgKiBidWZmZXJSYXRpbztcclxuXHJcblxyXG5cdFx0cmV0dXJuIHRvQm91bmRzKFxyXG5cdFx0XHR0b1BvaW50KG1pbi54IC0gaGVpZ2h0QnVmZmVyLCBtaW4ueSAtIHdpZHRoQnVmZmVyKSxcclxuXHRcdFx0dG9Qb2ludChtYXgueCArIGhlaWdodEJ1ZmZlciwgbWF4LnkgKyB3aWR0aEJ1ZmZlcikpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogQm91bmRzKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgaXMgZXF1aXZhbGVudCB0byB0aGUgZ2l2ZW4gYm91bmRzLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ym91bmRzID0gdG9Cb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5taW4uZXF1YWxzKGJvdW5kcy5nZXRUb3BMZWZ0KCkpICYmXHJcblx0XHRcdHRoaXMubWF4LmVxdWFscyhib3VuZHMuZ2V0Qm90dG9tUmlnaHQoKSk7XHJcblx0fSxcclxufTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmJvdW5kcyhjb3JuZXIxOiBQb2ludCwgY29ybmVyMjogUG9pbnQpXHJcbi8vIENyZWF0ZXMgYSBCb3VuZHMgb2JqZWN0IGZyb20gdHdvIGNvcm5lcnMgY29vcmRpbmF0ZSBwYWlycy5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwuYm91bmRzKHBvaW50czogUG9pbnRbXSlcclxuLy8gQ3JlYXRlcyBhIEJvdW5kcyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgb2YgcG9pbnRzLlxyXG5leHBvcnQgZnVuY3Rpb24gdG9Cb3VuZHMoYSwgYikge1xyXG5cdGlmICghYSB8fCBhIGluc3RhbmNlb2YgQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBCb3VuZHMoYSwgYik7XHJcbn1cclxuIiwiaW1wb3J0IHtMYXRMbmcsIHRvTGF0TG5nfSBmcm9tICcuL0xhdExuZyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTGF0TG5nQm91bmRzXHJcbiAqIEBha2EgTC5MYXRMbmdCb3VuZHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGdlb2dyYXBoaWNhbCBhcmVhIG9uIGEgbWFwLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgY29ybmVyMSA9IEwubGF0TG5nKDQwLjcxMiwgLTc0LjIyNyksXHJcbiAqIGNvcm5lcjIgPSBMLmxhdExuZyg0MC43NzQsIC03NC4xMjUpLFxyXG4gKiBib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhjb3JuZXIxLCBjb3JuZXIyKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEFsbCBMZWFmbGV0IG1ldGhvZHMgdGhhdCBhY2NlcHQgTGF0TG5nQm91bmRzIG9iamVjdHMgYWxzbyBhY2NlcHQgdGhlbSBpbiBhIHNpbXBsZSBBcnJheSBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlIGJvdW5kcyBleGFtcGxlIGFib3ZlIGNhbiBiZSBwYXNzZWQgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXAuZml0Qm91bmRzKFtcclxuICogXHRbNDAuNzEyLCAtNzQuMjI3XSxcclxuICogXHRbNDAuNzc0LCAtNzQuMTI1XVxyXG4gKiBdKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIENhdXRpb246IGlmIHRoZSBhcmVhIGNyb3NzZXMgdGhlIGFudGltZXJpZGlhbiAob2Z0ZW4gY29uZnVzZWQgd2l0aCB0aGUgSW50ZXJuYXRpb25hbCBEYXRlIExpbmUpLCB5b3UgbXVzdCBzcGVjaWZ5IGNvcm5lcnMgX291dHNpZGVfIHRoZSBbLTE4MCwgMTgwXSBkZWdyZWVzIGxvbmdpdHVkZSByYW5nZS5cclxuICpcclxuICogTm90ZSB0aGF0IGBMYXRMbmdCb3VuZHNgIGRvZXMgbm90IGluaGVyaXQgZnJvbSBMZWFmbGV0J3MgYENsYXNzYCBvYmplY3QsXHJcbiAqIHdoaWNoIG1lYW5zIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSBpdCwgYW5kIG5ldyBtZXRob2RzXHJcbiAqIGNhbid0IGJlIGFkZGVkIHRvIGl0IHdpdGggdGhlIGBpbmNsdWRlYCBmdW5jdGlvbi5cclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTGF0TG5nQm91bmRzKGNvcm5lcjEsIGNvcm5lcjIpIHsgLy8gKExhdExuZywgTGF0TG5nKSBvciAoTGF0TG5nW10pXHJcblx0aWYgKCFjb3JuZXIxKSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgbGF0bG5ncyA9IGNvcm5lcjIgPyBbY29ybmVyMSwgY29ybmVyMl0gOiBjb3JuZXIxO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dGhpcy5leHRlbmQobGF0bG5nc1tpXSk7XHJcblx0fVxyXG59XHJcblxyXG5MYXRMbmdCb3VuZHMucHJvdG90eXBlID0ge1xyXG5cclxuXHQvLyBAbWV0aG9kIGV4dGVuZChsYXRsbmc6IExhdExuZyk6IHRoaXNcclxuXHQvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludFxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGV4dGVuZChvdGhlckJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIEV4dGVuZCB0aGUgYm91bmRzIHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kc1xyXG5cdGV4dGVuZDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiwgbmUyO1xyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmcpIHtcclxuXHRcdFx0c3cyID0gb2JqO1xyXG5cdFx0XHRuZTIgPSBvYmo7XHJcblxyXG5cdFx0fSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdFx0c3cyID0gb2JqLl9zb3V0aFdlc3Q7XHJcblx0XHRcdG5lMiA9IG9iai5fbm9ydGhFYXN0O1xyXG5cclxuXHRcdFx0aWYgKCFzdzIgfHwgIW5lMikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBvYmogPyB0aGlzLmV4dGVuZCh0b0xhdExuZyhvYmopIHx8IHRvTGF0TG5nQm91bmRzKG9iaikpIDogdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXN3ICYmICFuZSkge1xyXG5cdFx0XHR0aGlzLl9zb3V0aFdlc3QgPSBuZXcgTGF0TG5nKHN3Mi5sYXQsIHN3Mi5sbmcpO1xyXG5cdFx0XHR0aGlzLl9ub3J0aEVhc3QgPSBuZXcgTGF0TG5nKG5lMi5sYXQsIG5lMi5sbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cubGF0ID0gTWF0aC5taW4oc3cyLmxhdCwgc3cubGF0KTtcclxuXHRcdFx0c3cubG5nID0gTWF0aC5taW4oc3cyLmxuZywgc3cubG5nKTtcclxuXHRcdFx0bmUubGF0ID0gTWF0aC5tYXgobmUyLmxhdCwgbmUubGF0KTtcclxuXHRcdFx0bmUubG5nID0gTWF0aC5tYXgobmUyLmxuZywgbmUubG5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhZChidWZmZXJSYXRpbzogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBib3VuZHMgY3JlYXRlZCBieSBleHRlbmRpbmcgb3IgcmV0cmFjdGluZyB0aGUgY3VycmVudCBib3VuZHMgYnkgYSBnaXZlbiByYXRpbyBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBGb3IgZXhhbXBsZSwgYSByYXRpbyBvZiAwLjUgZXh0ZW5kcyB0aGUgYm91bmRzIGJ5IDUwJSBpbiBlYWNoIGRpcmVjdGlvbi5cclxuXHQvLyBOZWdhdGl2ZSB2YWx1ZXMgd2lsbCByZXRyYWN0IHRoZSBib3VuZHMuXHJcblx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHtcclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBoZWlnaHRCdWZmZXIgPSBNYXRoLmFicyhzdy5sYXQgLSBuZS5sYXQpICogYnVmZmVyUmF0aW8sXHJcblx0XHQgICAgd2lkdGhCdWZmZXIgPSBNYXRoLmFicyhzdy5sbmcgLSBuZS5sbmcpICogYnVmZmVyUmF0aW87XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIG5ldyBMYXRMbmcoc3cubGF0IC0gaGVpZ2h0QnVmZmVyLCBzdy5sbmcgLSB3aWR0aEJ1ZmZlciksXHJcblx0XHQgICAgICAgIG5ldyBMYXRMbmcobmUubGF0ICsgaGVpZ2h0QnVmZmVyLCBuZS5sbmcgKyB3aWR0aEJ1ZmZlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcoXHJcblx0XHQgICAgICAgICh0aGlzLl9zb3V0aFdlc3QubGF0ICsgdGhpcy5fbm9ydGhFYXN0LmxhdCkgLyAyLFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxuZyArIHRoaXMuX25vcnRoRWFzdC5sbmcpIC8gMik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aFdlc3QoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgc291dGgtd2VzdCBwb2ludCBvZiB0aGUgYm91bmRzLlxyXG5cdGdldFNvdXRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldE5vcnRoRWFzdCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aC1lYXN0IHBvaW50IG9mIHRoZSBib3VuZHMuXHJcblx0Z2V0Tm9ydGhFYXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbm9ydGhFYXN0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Tm9ydGhXZXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIG5vcnRoLXdlc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXROb3J0aFdlc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0Tm9ydGgoKSwgdGhpcy5nZXRXZXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0U291dGhFYXN0KCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIHNvdXRoLWVhc3QgcG9pbnQgb2YgdGhlIGJvdW5kcy5cclxuXHRnZXRTb3V0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0V2VzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSB3ZXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0V2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRTb3V0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzb3V0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0U291dGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3V0aFdlc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWFzdCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBlYXN0IGxvbmdpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0RWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXROb3J0aCgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBub3J0aCBsYXRpdHVkZSBvZiB0aGUgYm91bmRzXHJcblx0Z2V0Tm9ydGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIGNvbnRhaW5zIHRoZSBnaXZlbiBvbmUuXHJcblxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgY29udGFpbnMgKGxhdGxuZzogTGF0TG5nKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgdGhlIGdpdmVuIHBvaW50LlxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmdCb3VuZHMpIG9yIChMYXRMbmcpIC0+IEJvb2xlYW5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBMYXRMbmcgfHwgJ2xhdCcgaW4gb2JqKSB7XHJcblx0XHRcdG9iaiA9IHRvTGF0TG5nKG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSB0b0xhdExuZ0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdyA9IHRoaXMuX3NvdXRoV2VzdCxcclxuXHRcdCAgICBuZSA9IHRoaXMuX25vcnRoRWFzdCxcclxuXHRcdCAgICBzdzIsIG5lMjtcclxuXHJcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5nZXRTb3V0aFdlc3QoKTtcclxuXHRcdFx0bmUyID0gb2JqLmdldE5vcnRoRWFzdCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cyID0gbmUyID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAoc3cyLmxhdCA+PSBzdy5sYXQpICYmIChuZTIubGF0IDw9IG5lLmxhdCkgJiZcclxuXHRcdCAgICAgICAoc3cyLmxuZyA+PSBzdy5sbmcpICYmIChuZTIubG5nIDw9IG5lLmxuZyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBpbnRlcnNlY3RzKG90aGVyQm91bmRzOiBMYXRMbmdCb3VuZHMpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpbnRlcnNlY3RzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgaW50ZXJzZWN0IGlmIHRoZXkgaGF2ZSBhdCBsZWFzdCBvbmUgcG9pbnQgaW4gY29tbW9uLlxyXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuXHRcdGJvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5fc291dGhXZXN0LFxyXG5cdFx0ICAgIG5lID0gdGhpcy5fbm9ydGhFYXN0LFxyXG5cdFx0ICAgIHN3MiA9IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSxcclxuXHRcdCAgICBuZTIgPSBib3VuZHMuZ2V0Tm9ydGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIGxhdEludGVyc2VjdHMgPSAobmUyLmxhdCA+PSBzdy5sYXQpICYmIChzdzIubGF0IDw9IG5lLmxhdCksXHJcblx0XHQgICAgbG5nSW50ZXJzZWN0cyA9IChuZTIubG5nID49IHN3LmxuZykgJiYgKHN3Mi5sbmcgPD0gbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0SW50ZXJzZWN0cyAmJiBsbmdJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3ZlcmxhcHMob3RoZXJCb3VuZHM6IExhdExuZ0JvdW5kcyk6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVjdGFuZ2xlIG92ZXJsYXBzIHRoZSBnaXZlbiBib3VuZHMuIFR3byBib3VuZHMgb3ZlcmxhcCBpZiB0aGVpciBpbnRlcnNlY3Rpb24gaXMgYW4gYXJlYS5cclxuXHRvdmVybGFwczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0T3ZlcmxhcHMgPSAobmUyLmxhdCA+IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPCBuZS5sYXQpLFxyXG5cdFx0ICAgIGxuZ092ZXJsYXBzID0gKG5lMi5sbmcgPiBzdy5sbmcpICYmIChzdzIubG5nIDwgbmUubG5nKTtcclxuXHJcblx0XHRyZXR1cm4gbGF0T3ZlcmxhcHMgJiYgbG5nT3ZlcmxhcHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB0b0JCb3hTdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyB3aXRoIGJvdW5kaW5nIGJveCBjb29yZGluYXRlcyBpbiBhICdzb3V0aHdlc3RfbG5nLHNvdXRod2VzdF9sYXQsbm9ydGhlYXN0X2xuZyxub3J0aGVhc3RfbGF0JyBmb3JtYXQuIFVzZWZ1bCBmb3Igc2VuZGluZyByZXF1ZXN0cyB0byB3ZWIgc2VydmljZXMgdGhhdCByZXR1cm4gZ2VvIGRhdGEuXHJcblx0dG9CQm94U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gW3RoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldE5vcnRoKCldLmpvaW4oJywnKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVxdWFscyhvdGhlckJvdW5kczogTGF0TG5nQm91bmRzLCBtYXhNYXJnaW4/OiBOdW1iZXIpOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlY3RhbmdsZSBpcyBlcXVpdmFsZW50ICh3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2YgZXJyb3IpIHRvIHRoZSBnaXZlbiBib3VuZHMuIFRoZSBtYXJnaW4gb2YgZXJyb3IgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyBgbWF4TWFyZ2luYCB0byBhIHNtYWxsIG51bWJlci5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChib3VuZHMsIG1heE1hcmdpbikge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmVxdWFscyhib3VuZHMuZ2V0U291dGhXZXN0KCksIG1heE1hcmdpbikgJiZcclxuXHRcdCAgICAgICB0aGlzLl9ub3J0aEVhc3QuZXF1YWxzKGJvdW5kcy5nZXROb3J0aEVhc3QoKSwgbWF4TWFyZ2luKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzVmFsaWQoKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3VuZHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLl9zb3V0aFdlc3QgJiYgdGhpcy5fbm9ydGhFYXN0KTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBUT0RPIEludGVybmF0aW9uYWwgZGF0ZSBsaW5lP1xyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXRMbmdCb3VuZHMoY29ybmVyMTogTGF0TG5nLCBjb3JuZXIyOiBMYXRMbmcpXHJcbi8vIENyZWF0ZXMgYSBgTGF0TG5nQm91bmRzYCBvYmplY3QgYnkgZGVmaW5pbmcgdHdvIGRpYWdvbmFsbHkgb3Bwb3NpdGUgY29ybmVycyBvZiB0aGUgcmVjdGFuZ2xlLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwubGF0TG5nQm91bmRzKGxhdGxuZ3M6IExhdExuZ1tdKVxyXG4vLyBDcmVhdGVzIGEgYExhdExuZ0JvdW5kc2Agb2JqZWN0IGRlZmluZWQgYnkgdGhlIGdlb2dyYXBoaWNhbCBwb2ludHMgaXQgY29udGFpbnMuIFZlcnkgdXNlZnVsIGZvciB6b29taW5nIHRoZSBtYXAgdG8gZml0IGEgcGFydGljdWxhciBzZXQgb2YgbG9jYXRpb25zIHdpdGggW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0xhdExuZ0JvdW5kcyhhLCBiKSB7XHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhhLCBiKTtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7RWFydGh9IGZyb20gJy4vY3JzL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHN9IGZyb20gJy4vTGF0TG5nQm91bmRzJztcclxuXHJcbi8qIEBjbGFzcyBMYXRMbmdcclxuICogQGFrYSBMLkxhdExuZ1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggYSBjZXJ0YWluIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiB2YXIgbGF0bG5nID0gTC5sYXRMbmcoNTAuNSwgMzAuNSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBBbGwgTGVhZmxldCBtZXRob2RzIHRoYXQgYWNjZXB0IExhdExuZyBvYmplY3RzIGFsc28gYWNjZXB0IHRoZW0gaW4gYSBzaW1wbGUgQXJyYXkgZm9ybSBhbmQgc2ltcGxlIG9iamVjdCBmb3JtICh1bmxlc3Mgbm90ZWQgb3RoZXJ3aXNlKSwgc28gdGhlc2UgbGluZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBtYXAucGFuVG8oWzUwLCAzMF0pO1xyXG4gKiBtYXAucGFuVG8oe2xvbjogMzAsIGxhdDogNTB9KTtcclxuICogbWFwLnBhblRvKHtsYXQ6IDUwLCBsbmc6IDMwfSk7XHJcbiAqIG1hcC5wYW5UbyhMLmxhdExuZyg1MCwgMzApKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgTGF0TG5nYCBkb2VzIG5vdCBpbmhlcml0IGZyb20gTGVhZmxldCdzIGBDbGFzc2Agb2JqZWN0LFxyXG4gKiB3aGljaCBtZWFucyBuZXcgY2xhc3NlcyBjYW4ndCBpbmhlcml0IGZyb20gaXQsIGFuZCBuZXcgbWV0aG9kc1xyXG4gKiBjYW4ndCBiZSBhZGRlZCB0byBpdCB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIExhdExuZyhsYXQsIGxuZywgYWx0KSB7XHJcblx0aWYgKGlzTmFOKGxhdCkgfHwgaXNOYU4obG5nKSkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExhdExuZyBvYmplY3Q6ICgnICsgbGF0ICsgJywgJyArIGxuZyArICcpJyk7XHJcblx0fVxyXG5cclxuXHQvLyBAcHJvcGVydHkgbGF0OiBOdW1iZXJcclxuXHQvLyBMYXRpdHVkZSBpbiBkZWdyZWVzXHJcblx0dGhpcy5sYXQgPSArbGF0O1xyXG5cclxuXHQvLyBAcHJvcGVydHkgbG5nOiBOdW1iZXJcclxuXHQvLyBMb25naXR1ZGUgaW4gZGVncmVlc1xyXG5cdHRoaXMubG5nID0gK2xuZztcclxuXHJcblx0Ly8gQHByb3BlcnR5IGFsdDogTnVtYmVyXHJcblx0Ly8gQWx0aXR1ZGUgaW4gbWV0ZXJzIChvcHRpb25hbClcclxuXHRpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMuYWx0ID0gK2FsdDtcclxuXHR9XHJcbn1cclxuXHJcbkxhdExuZy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gQG1ldGhvZCBlcXVhbHMob3RoZXJMYXRMbmc6IExhdExuZywgbWF4TWFyZ2luPzogTnVtYmVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBgTGF0TG5nYCBwb2ludCBpcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiAod2l0aGluIGEgc21hbGwgbWFyZ2luIG9mIGVycm9yKS4gVGhlIG1hcmdpbiBvZiBlcnJvciBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIGBtYXhNYXJnaW5gIHRvIGEgc21hbGwgbnVtYmVyLlxyXG5cdGVxdWFsczogZnVuY3Rpb24gKG9iaiwgbWF4TWFyZ2luKSB7XHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRvYmogPSB0b0xhdExuZyhvYmopO1xyXG5cclxuXHRcdHZhciBtYXJnaW4gPSBNYXRoLm1heChcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sYXQgLSBvYmoubGF0KSxcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sbmcgLSBvYmoubG5nKSk7XHJcblxyXG5cdFx0cmV0dXJuIG1hcmdpbiA8PSAobWF4TWFyZ2luID09PSB1bmRlZmluZWQgPyAxLjBFLTkgOiBtYXhNYXJnaW4pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9TdHJpbmcoKTogU3RyaW5nXHJcblx0Ly8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQgKGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMpLlxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gJ0xhdExuZygnICtcclxuXHRcdCAgICAgICAgVXRpbC5mb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICtcclxuXHRcdCAgICAgICAgVXRpbC5mb3JtYXROdW0odGhpcy5sbmcsIHByZWNpc2lvbikgKyAnKSc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZVRvKG90aGVyTGF0TG5nOiBMYXRMbmcpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSAoaW4gbWV0ZXJzKSB0byB0aGUgZ2l2ZW4gYExhdExuZ2AgY2FsY3VsYXRlZCB1c2luZyB0aGUgW1NwaGVyaWNhbCBMYXcgb2YgQ29zaW5lc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BoZXJpY2FsX2xhd19vZl9jb3NpbmVzKS5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAob3RoZXIpIHtcclxuXHRcdHJldHVybiBFYXJ0aC5kaXN0YW5jZSh0aGlzLCB0b0xhdExuZyhvdGhlcikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcCgpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgbmV3IGBMYXRMbmdgIG9iamVjdCB3aXRoIHRoZSBsb25naXR1ZGUgd3JhcHBlZCBzbyBpdCdzIGFsd2F5cyBiZXR3ZWVuIC0xODAgYW5kICsxODAgZGVncmVlcy5cclxuXHR3cmFwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gRWFydGgud3JhcExhdExuZyh0aGlzKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvQm91bmRzKHNpemVJbk1ldGVyczogTnVtYmVyKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIG5ldyBgTGF0TG5nQm91bmRzYCBvYmplY3QgaW4gd2hpY2ggZWFjaCBib3VuZGFyeSBpcyBgc2l6ZUluTWV0ZXJzLzJgIG1ldGVycyBhcGFydCBmcm9tIHRoZSBgTGF0TG5nYC5cclxuXHR0b0JvdW5kczogZnVuY3Rpb24gKHNpemVJbk1ldGVycykge1xyXG5cdFx0dmFyIGxhdEFjY3VyYWN5ID0gMTgwICogc2l6ZUluTWV0ZXJzIC8gNDAwNzUwMTcsXHJcblx0XHQgICAgbG5nQWNjdXJhY3kgPSBsYXRBY2N1cmFjeSAvIE1hdGguY29zKChNYXRoLlBJIC8gMTgwKSAqIHRoaXMubGF0KTtcclxuXHJcblx0XHRyZXR1cm4gdG9MYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIFt0aGlzLmxhdCAtIGxhdEFjY3VyYWN5LCB0aGlzLmxuZyAtIGxuZ0FjY3VyYWN5XSxcclxuXHRcdCAgICAgICAgW3RoaXMubGF0ICsgbGF0QWNjdXJhY3ksIHRoaXMubG5nICsgbG5nQWNjdXJhY3ldKTtcclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcodGhpcy5sYXQsIHRoaXMubG5nLCB0aGlzLmFsdCk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhsYXRpdHVkZTogTnVtYmVyLCBsb25naXR1ZGU6IE51bWJlciwgYWx0aXR1ZGU/OiBOdW1iZXIpOiBMYXRMbmdcclxuLy8gQ3JlYXRlcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggdGhlIGdpdmVuIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgKGFuZCBvcHRpb25hbGx5IGFsdGl0dWRlKS5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLmxhdExuZyhjb29yZHM6IEFycmF5KTogTGF0TG5nXHJcbi8vIEV4cGVjdHMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFtOdW1iZXIsIE51bWJlcl1gIG9yIGBbTnVtYmVyLCBOdW1iZXIsIE51bWJlcl1gIGluc3RlYWQuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5sYXRMbmcoY29vcmRzOiBPYmplY3QpOiBMYXRMbmdcclxuLy8gRXhwZWN0cyBhbiBwbGFpbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHtsYXQ6IE51bWJlciwgbG5nOiBOdW1iZXJ9YCBvciBge2xhdDogTnVtYmVyLCBsbmc6IE51bWJlciwgYWx0OiBOdW1iZXJ9YCBpbnN0ZWFkLlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvTGF0TG5nKGEsIGIsIGMpIHtcclxuXHRpZiAoYSBpbnN0YW5jZW9mIExhdExuZykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmIChVdGlsLmlzQXJyYXkoYSkgJiYgdHlwZW9mIGFbMF0gIT09ICdvYmplY3QnKSB7XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDMpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSwgYVsyXSk7XHJcblx0XHR9XHJcblx0XHRpZiAoYS5sZW5ndGggPT09IDIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMYXRMbmcoYVswXSwgYVsxXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0aWYgKGEgPT09IHVuZGVmaW5lZCB8fCBhID09PSBudWxsKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAnbGF0JyBpbiBhKSB7XHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhhLmxhdCwgJ2xuZycgaW4gYSA/IGEubG5nIDogYS5sb24sIGEuYWx0KTtcclxuXHR9XHJcblx0aWYgKGIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTGF0TG5nKGEsIGIsIGMpO1xyXG59XHJcbiIsIlxyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL0xhdExuZyc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi9MYXRMbmdCb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkJhc2VcclxuICogT2JqZWN0IHRoYXQgZGVmaW5lcyBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW1zIGZvciBwcm9qZWN0aW5nXHJcbiAqIGdlb2dyYXBoaWNhbCBwb2ludHMgaW50byBwaXhlbCAoc2NyZWVuKSBjb29yZGluYXRlcyBhbmQgYmFjayAoYW5kIHRvXHJcbiAqIGNvb3JkaW5hdGVzIGluIG90aGVyIHVuaXRzIGZvciBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzKS4gU2VlXHJcbiAqIFtzcGF0aWFsIHJlZmVyZW5jZSBzeXN0ZW1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NwYXRpYWxfcmVmZXJlbmNlX3N5c3RlbSkuXHJcbiAqXHJcbiAqIExlYWZsZXQgZGVmaW5lcyB0aGUgbW9zdCB1c3VhbCBDUlNzIGJ5IGRlZmF1bHQuIElmIHlvdSB3YW50IHRvIHVzZSBhXHJcbiAqIENSUyBub3QgZGVmaW5lZCBieSBkZWZhdWx0LCB0YWtlIGEgbG9vayBhdCB0aGVcclxuICogW1Byb2o0TGVhZmxldF0oaHR0cHM6Ly9naXRodWIuY29tL2thcnRlbmEvUHJvajRMZWFmbGV0KSBwbHVnaW4uXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGUgQ1JTIGluc3RhbmNlcyBkbyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcclxuICogYW5kIGNhbid0IGJlIGluc3RhbnRpYXRlZC4gQWxzbywgbmV3IGNsYXNzZXMgY2FuJ3QgaW5oZXJpdCBmcm9tIHRoZW0sXHJcbiAqIGFuZCBtZXRob2RzIGNhbid0IGJlIGFkZGVkIHRvIHRoZW0gd2l0aCB0aGUgYGluY2x1ZGVgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQ1JTID0ge1xyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Qb2ludChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBwaXhlbCBjb29yZGluYXRlcyBmb3IgYSBnaXZlbiB6b29tLlxyXG5cdGxhdExuZ1RvUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgc2NhbGUgPSB0aGlzLnNjYWxlKHpvb20pO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybWF0aW9uLl90cmFuc2Zvcm0ocHJvamVjdGVkUG9pbnQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBvaW50VG9MYXRMbmcocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuXHQvLyBUaGUgaW52ZXJzZSBvZiBgbGF0TG5nVG9Qb2ludGAuIFByb2plY3RzIHBpeGVsIGNvb3JkaW5hdGVzIG9uIGEgZ2l2ZW5cclxuXHQvLyB6b29tIGludG8gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG5cdHBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5zY2FsZSh6b29tKSxcclxuXHRcdCAgICB1bnRyYW5zZm9ybWVkUG9pbnQgPSB0aGlzLnRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKHBvaW50LCBzY2FsZSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi51bnByb2plY3QodW50cmFuc2Zvcm1lZFBvaW50KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHByb2plY3QobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIFByb2plY3RzIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBpbnRvIGNvb3JkaW5hdGVzIGluIHVuaXRzIGFjY2VwdGVkIGZvclxyXG5cdC8vIHRoaXMgQ1JTIChlLmcuIG1ldGVycyBmb3IgRVBTRzozODU3LCBmb3IgcGFzc2luZyBpdCB0byBXTVMgc2VydmljZXMpLlxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24ucHJvamVjdChsYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5wcm9qZWN0KHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcHJvamVjdGVkIGNvb3JkaW5hdGUgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBMYXRMbmcuXHJcblx0Ly8gVGhlIGludmVyc2Ugb2YgYHByb2plY3RgLlxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdChwb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzY2FsZSh6b29tOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBzY2FsZSB1c2VkIHdoZW4gdHJhbnNmb3JtaW5nIHByb2plY3RlZCBjb29yZGluYXRlcyBpbnRvXHJcblx0Ly8gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIGEgcGFydGljdWxhciB6b29tLiBGb3IgZXhhbXBsZSwgaXQgcmV0dXJuc1xyXG5cdC8vIGAyNTYgKiAyXnpvb21gIGZvciBNZXJjYXRvci1iYXNlZCBDUlMuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gMjU2ICogTWF0aC5wb3coMiwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB6b29tKHNjYWxlOiBOdW1iZXIpOiBOdW1iZXJcclxuXHQvLyBJbnZlcnNlIG9mIGBzY2FsZSgpYCwgcmV0dXJucyB0aGUgem9vbSBsZXZlbCBjb3JyZXNwb25kaW5nIHRvIGEgc2NhbGVcclxuXHQvLyBmYWN0b3Igb2YgYHNjYWxlYC5cclxuXHR6b29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcclxuXHRcdHJldHVybiBNYXRoLmxvZyhzY2FsZSAvIDI1NikgLyBNYXRoLkxOMjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFByb2plY3RlZEJvdW5kcyh6b29tOiBOdW1iZXIpOiBCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBwcm9qZWN0aW9uJ3MgYm91bmRzIHNjYWxlZCBhbmQgdHJhbnNmb3JtZWQgZm9yIHRoZSBwcm92aWRlZCBgem9vbWAuXHJcblx0Z2V0UHJvamVjdGVkQm91bmRzOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0aWYgKHRoaXMuaW5maW5pdGUpIHsgcmV0dXJuIG51bGw7IH1cclxuXHJcblx0XHR2YXIgYiA9IHRoaXMucHJvamVjdGlvbi5ib3VuZHMsXHJcblx0XHQgICAgcyA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgbWluID0gdGhpcy50cmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm0oYi5taW4sIHMpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGIubWF4LCBzKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhtaW4sIG1heCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cclxuXHJcblx0Ly8gQHByb3BlcnR5IGNvZGU6IFN0cmluZ1xyXG5cdC8vIFN0YW5kYXJkIGNvZGUgbmFtZSBvZiB0aGUgQ1JTIHBhc3NlZCBpbnRvIFdNUyBzZXJ2aWNlcyAoZS5nLiBgJ0VQU0c6Mzg1NydgKVxyXG5cdC8vXHJcblx0Ly8gQHByb3BlcnR5IHdyYXBMbmc6IE51bWJlcltdXHJcblx0Ly8gQW4gYXJyYXkgb2YgdHdvIG51bWJlcnMgZGVmaW5pbmcgd2hldGhlciB0aGUgbG9uZ2l0dWRlIChob3Jpem9udGFsKSBjb29yZGluYXRlXHJcblx0Ly8gYXhpcyB3cmFwcyBhcm91bmQgYSBnaXZlbiByYW5nZSBhbmQgaG93LiBEZWZhdWx0cyB0byBgWy0xODAsIDE4MF1gIGluIG1vc3RcclxuXHQvLyBnZW9ncmFwaGljYWwgQ1JTcy4gSWYgYHVuZGVmaW5lZGAsIHRoZSBsb25naXR1ZGUgYXhpcyBkb2VzIG5vdCB3cmFwIGFyb3VuZC5cclxuXHQvL1xyXG5cdC8vIEBwcm9wZXJ0eSB3cmFwTGF0OiBOdW1iZXJbXVxyXG5cdC8vIExpa2UgYHdyYXBMbmdgLCBidXQgZm9yIHRoZSBsYXRpdHVkZSAodmVydGljYWwpIGF4aXMuXHJcblxyXG5cdC8vIHdyYXBMbmc6IFttaW4sIG1heF0sXHJcblx0Ly8gd3JhcExhdDogW21pbiwgbWF4XSxcclxuXHJcblx0Ly8gQHByb3BlcnR5IGluZmluaXRlOiBCb29sZWFuXHJcblx0Ly8gSWYgdHJ1ZSwgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugd2lsbCBiZSB1bmJvdW5kZWQgKGluZmluaXRlIGluIGJvdGggYXhlcylcclxuXHRpbmZpbml0ZTogZmFsc2UsXHJcblxyXG5cdC8vIEBtZXRob2Qgd3JhcExhdExuZyhsYXRsbmc6IExhdExuZyk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgYSBgTGF0TG5nYCB3aGVyZSBsYXQgYW5kIGxuZyBoYXMgYmVlbiB3cmFwcGVkIGFjY29yZGluZyB0byB0aGVcclxuXHQvLyBDUlMncyBgd3JhcExhdGAgYW5kIGB3cmFwTG5nYCBwcm9wZXJ0aWVzLCBpZiB0aGV5IGFyZSBvdXRzaWRlIHRoZSBDUlMncyBib3VuZHMuXHJcblx0d3JhcExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGxuZyA9IHRoaXMud3JhcExuZyA/IFV0aWwud3JhcE51bShsYXRsbmcubG5nLCB0aGlzLndyYXBMbmcsIHRydWUpIDogbGF0bG5nLmxuZyxcclxuXHRcdCAgICBsYXQgPSB0aGlzLndyYXBMYXQgPyBVdGlsLndyYXBOdW0obGF0bG5nLmxhdCwgdGhpcy53cmFwTGF0LCB0cnVlKSA6IGxhdGxuZy5sYXQsXHJcblx0XHQgICAgYWx0ID0gbGF0bG5nLmFsdDtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhsYXQsIGxuZywgYWx0KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmdCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ0JvdW5kc2Agd2l0aCB0aGUgc2FtZSBzaXplIGFzIHRoZSBnaXZlbiBvbmUsIGVuc3VyaW5nXHJcblx0Ly8gdGhhdCBpdHMgY2VudGVyIGlzIHdpdGhpbiB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuTGF0TG5nQm91bmRzYCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0d3JhcExhdExuZ0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0dmFyIGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLndyYXBMYXRMbmcoY2VudGVyKSxcclxuXHRcdCAgICBsYXRTaGlmdCA9IGNlbnRlci5sYXQgLSBuZXdDZW50ZXIubGF0LFxyXG5cdFx0ICAgIGxuZ1NoaWZ0ID0gY2VudGVyLmxuZyAtIG5ld0NlbnRlci5sbmc7XHJcblxyXG5cdFx0aWYgKGxhdFNoaWZ0ID09PSAwICYmIGxuZ1NoaWZ0ID09PSAwKSB7XHJcblx0XHRcdHJldHVybiBib3VuZHM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN3ID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lID0gYm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cdFx0ICAgIG5ld1N3ID0gbmV3IExhdExuZyhzdy5sYXQgLSBsYXRTaGlmdCwgc3cubG5nIC0gbG5nU2hpZnQpLFxyXG5cdFx0ICAgIG5ld05lID0gbmV3IExhdExuZyhuZS5sYXQgLSBsYXRTaGlmdCwgbmUubG5nIC0gbG5nU2hpZnQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGF0TG5nQm91bmRzKG5ld1N3LCBuZXdOZSk7XHJcblx0fVxyXG59O1xyXG4iLCJpbXBvcnQge0NSU30gZnJvbSAnLi9DUlMnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogQG5hbWVzcGFjZSBDUlNcbiAqIEBjcnMgTC5DUlMuRWFydGhcbiAqXG4gKiBTZXJ2ZXMgYXMgdGhlIGJhc2UgZm9yIENSUyB0aGF0IGFyZSBnbG9iYWwgc3VjaCB0aGF0IHRoZXkgY292ZXIgdGhlIGVhcnRoLlxuICogQ2FuIG9ubHkgYmUgdXNlZCBhcyB0aGUgYmFzZSBmb3Igb3RoZXIgQ1JTIGFuZCBjYW5ub3QgYmUgdXNlZCBkaXJlY3RseSxcbiAqIHNpbmNlIGl0IGRvZXMgbm90IGhhdmUgYSBgY29kZWAsIGBwcm9qZWN0aW9uYCBvciBgdHJhbnNmb3JtYXRpb25gLiBgZGlzdGFuY2UoKWAgcmV0dXJuc1xuICogbWV0ZXJzLlxuICovXG5cbmV4cG9ydCB2YXIgRWFydGggPSBVdGlsLmV4dGVuZCh7fSwgQ1JTLCB7XG5cdHdyYXBMbmc6IFstMTgwLCAxODBdLFxuXG5cdC8vIE1lYW4gRWFydGggUmFkaXVzLCBhcyByZWNvbW1lbmRlZCBmb3IgdXNlIGJ5XG5cdC8vIHRoZSBJbnRlcm5hdGlvbmFsIFVuaW9uIG9mIEdlb2Rlc3kgYW5kIEdlb3BoeXNpY3MsXG5cdC8vIHNlZSBodHRwczovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXG5cdFI6IDYzNzEwMDAsXG5cblx0Ly8gZGlzdGFuY2UgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpY2FsIHBvaW50cyB1c2luZyBzcGhlcmljYWwgbGF3IG9mIGNvc2luZXMgYXBwcm94aW1hdGlvblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKGxhdGxuZzEsIGxhdGxuZzIpIHtcblx0XHR2YXIgcmFkID0gTWF0aC5QSSAvIDE4MCxcblx0XHQgICAgbGF0MSA9IGxhdGxuZzEubGF0ICogcmFkLFxuXHRcdCAgICBsYXQyID0gbGF0bG5nMi5sYXQgKiByYWQsXG5cdFx0ICAgIHNpbkRMYXQgPSBNYXRoLnNpbigobGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdCkgKiByYWQgLyAyKSxcblx0XHQgICAgc2luRExvbiA9IE1hdGguc2luKChsYXRsbmcyLmxuZyAtIGxhdGxuZzEubG5nKSAqIHJhZCAvIDIpLFxuXHRcdCAgICBhID0gc2luRExhdCAqIHNpbkRMYXQgKyBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpICogc2luRExvbiAqIHNpbkRMb24sXG5cdFx0ICAgIGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xuXHRcdHJldHVybiB0aGlzLlIgKiBjO1xuXHR9XG59KTtcbiIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvclxyXG4gKlxyXG4gKiBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbiDigJQgdGhlIG1vc3QgY29tbW9uIHByb2plY3Rpb24gZm9yIG9ubGluZSBtYXBzLFxyXG4gKiB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbCB0aWxlIHByb3ZpZGVycy4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzXHJcbiAqIGEgc3BoZXJlLiBVc2VkIGJ5IHRoZSBgRVBTRzozODU3YCBDUlMuXHJcbiAqL1xyXG5cclxudmFyIGVhcnRoUmFkaXVzID0gNjM3ODEzNztcclxuXHJcbmV4cG9ydCB2YXIgU3BoZXJpY2FsTWVyY2F0b3IgPSB7XHJcblxyXG5cdFI6IGVhcnRoUmFkaXVzLFxyXG5cdE1BWF9MQVRJVFVERTogODUuMDUxMTI4Nzc5OCxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIGQgPSBNYXRoLlBJIC8gMTgwLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuTUFYX0xBVElUVURFLFxyXG5cdFx0ICAgIGxhdCA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgbGF0bG5nLmxhdCksIC1tYXgpLFxyXG5cdFx0ICAgIHNpbiA9IE1hdGguc2luKGxhdCAqIGQpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHRcdHRoaXMuUiAqIGxhdGxuZy5sbmcgKiBkLFxyXG5cdFx0XHR0aGlzLlIgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpIC8gMik7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZyhcclxuXHRcdFx0KDIgKiBNYXRoLmF0YW4oTWF0aC5leHAocG9pbnQueSAvIHRoaXMuUikpIC0gKE1hdGguUEkgLyAyKSkgKiBkLFxyXG5cdFx0XHRwb2ludC54ICogZCAvIHRoaXMuUik7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGQgPSBlYXJ0aFJhZGl1cyAqIE1hdGguUEk7XHJcblx0XHRyZXR1cm4gbmV3IEJvdW5kcyhbLWQsIC1kXSwgW2QsIGRdKTtcclxuXHR9KSgpXHJcbn07XHJcbiIsImltcG9ydCB7UG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVHJhbnNmb3JtYXRpb25cclxuICogQGFrYSBMLlRyYW5zZm9ybWF0aW9uXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uOiBhIHNldCBvZiBjb2VmZmljaWVudHMgYGFgLCBgYmAsIGBjYCwgYGRgXHJcbiAqIGZvciB0cmFuc2Zvcm1pbmcgYSBwb2ludCBvZiBhIGZvcm0gYCh4LCB5KWAgaW50byBgKGEqeCArIGIsIGMqeSArIGQpYCBhbmQgZG9pbmdcclxuICogdGhlIHJldmVyc2UuIFVzZWQgYnkgTGVhZmxldCBpbiBpdHMgcHJvamVjdGlvbnMgY29kZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIHRyYW5zZm9ybWF0aW9uID0gTC50cmFuc2Zvcm1hdGlvbigyLCA1LCAtMSwgMTApLFxyXG4gKiBcdHAgPSBMLnBvaW50KDEsIDIpLFxyXG4gKiBcdHAyID0gdHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKHApLCAvLyAgTC5wb2ludCg3LCA4KVxyXG4gKiBcdHAzID0gdHJhbnNmb3JtYXRpb24udW50cmFuc2Zvcm0ocDIpOyAvLyAgTC5wb2ludCgxLCAyKVxyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gZmFjdG9yeSBuZXcgTC5UcmFuc2Zvcm1hdGlvbihhOiBOdW1iZXIsIGI6IE51bWJlciwgYzogTnVtYmVyLCBkOiBOdW1iZXIpXHJcbi8vIENyZWF0ZXMgYSBgVHJhbnNmb3JtYXRpb25gIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2VmZmljaWVudHMuXHJcbmV4cG9ydCBmdW5jdGlvbiBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKSB7XHJcblx0aWYgKFV0aWwuaXNBcnJheShhKSkge1xyXG5cdFx0Ly8gdXNlIGFycmF5IHByb3BlcnRpZXNcclxuXHRcdHRoaXMuX2EgPSBhWzBdO1xyXG5cdFx0dGhpcy5fYiA9IGFbMV07XHJcblx0XHR0aGlzLl9jID0gYVsyXTtcclxuXHRcdHRoaXMuX2QgPSBhWzNdO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHR0aGlzLl9hID0gYTtcclxuXHR0aGlzLl9iID0gYjtcclxuXHR0aGlzLl9jID0gYztcclxuXHR0aGlzLl9kID0gZDtcclxufVxyXG5cclxuVHJhbnNmb3JtYXRpb24ucHJvdG90eXBlID0ge1xyXG5cdC8vIEBtZXRob2QgdHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgYSB0cmFuc2Zvcm1lZCBwb2ludCwgb3B0aW9uYWxseSBtdWx0aXBsaWVkIGJ5IHRoZSBnaXZlbiBzY2FsZS5cclxuXHQvLyBPbmx5IGFjY2VwdHMgYWN0dWFsIGBMLlBvaW50YCBpbnN0YW5jZXMsIG5vdCBhcnJheXMuXHJcblx0dHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7IC8vIChQb2ludCwgTnVtYmVyKSAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybShwb2ludC5jbG9uZSgpLCBzY2FsZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gZGVzdHJ1Y3RpdmUgdHJhbnNmb3JtIChmYXN0ZXIpXHJcblx0X3RyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cG9pbnQueCA9IHNjYWxlICogKHRoaXMuX2EgKiBwb2ludC54ICsgdGhpcy5fYik7XHJcblx0XHRwb2ludC55ID0gc2NhbGUgKiAodGhpcy5fYyAqIHBvaW50LnkgKyB0aGlzLl9kKTtcclxuXHRcdHJldHVybiBwb2ludDtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVudHJhbnNmb3JtKHBvaW50OiBQb2ludCwgc2NhbGU/OiBOdW1iZXIpOiBQb2ludFxyXG5cdC8vIFJldHVybnMgdGhlIHJldmVyc2UgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGdpdmVuIHBvaW50LCBvcHRpb25hbGx5IGRpdmlkZWRcclxuXHQvLyBieSB0aGUgZ2l2ZW4gc2NhbGUuIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cclxuXHR1bnRyYW5zZm9ybTogZnVuY3Rpb24gKHBvaW50LCBzY2FsZSkge1xyXG5cdFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChcclxuXHRcdCAgICAgICAgKHBvaW50LnggLyBzY2FsZSAtIHRoaXMuX2IpIC8gdGhpcy5fYSxcclxuXHRcdCAgICAgICAgKHBvaW50LnkgLyBzY2FsZSAtIHRoaXMuX2QpIC8gdGhpcy5fYyk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gZmFjdG9yeSBMLnRyYW5zZm9ybWF0aW9uKGE6IE51bWJlciwgYjogTnVtYmVyLCBjOiBOdW1iZXIsIGQ6IE51bWJlcilcclxuXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBUcmFuc2Zvcm1hdGlvbiBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29lZmZpY2llbnRzLlxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmYWN0b3J5IEwudHJhbnNmb3JtYXRpb24oY29lZmZpY2llbnRzOiBBcnJheSk6IFRyYW5zZm9ybWF0aW9uXHJcbi8vIEV4cGVjdHMgYW4gY29lZmZpY2llbnRzIGFycmF5IG9mIHRoZSBmb3JtXHJcbi8vIGBbYTogTnVtYmVyLCBiOiBOdW1iZXIsIGM6IE51bWJlciwgZDogTnVtYmVyXWAuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG9UcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKSB7XHJcblx0cmV0dXJuIG5ldyBUcmFuc2Zvcm1hdGlvbihhLCBiLCBjLCBkKTtcclxufVxyXG4iLCJpbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XHJcbmltcG9ydCB7U3BoZXJpY2FsTWVyY2F0b3J9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5TcGhlcmljYWxNZXJjYXRvcic7XHJcbmltcG9ydCB7dG9UcmFuc2Zvcm1hdGlvbn0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvVHJhbnNmb3JtYXRpb24nO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIENSU1xyXG4gKiBAY3JzIEwuQ1JTLkVQU0czODU3XHJcbiAqXHJcbiAqIFRoZSBtb3N0IGNvbW1vbiBDUlMgZm9yIG9ubGluZSBtYXBzLCB1c2VkIGJ5IGFsbW9zdCBhbGwgZnJlZSBhbmQgY29tbWVyY2lhbFxyXG4gKiB0aWxlIHByb3ZpZGVycy4gVXNlcyBTcGhlcmljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi4gU2V0IGluIGJ5IGRlZmF1bHQgaW5cclxuICogTWFwJ3MgYGNyc2Agb3B0aW9uLlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRVBTRzM4NTcgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozODU3JyxcclxuXHRwcm9qZWN0aW9uOiBTcGhlcmljYWxNZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIFNwaGVyaWNhbE1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcblxyXG5leHBvcnQgdmFyIEVQU0c5MDA5MTMgPSBVdGlsLmV4dGVuZCh7fSwgRVBTRzM4NTcsIHtcclxuXHRjb2RlOiAnRVBTRzo5MDA5MTMnXHJcbn0pO1xyXG4iLCJpbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuXG4vLyBAbmFtZXNwYWNlIFNWRzsgQHNlY3Rpb25cbi8vIFRoZXJlIGFyZSBzZXZlcmFsIHN0YXRpYyBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5TVkc6XG5cbi8vIEBmdW5jdGlvbiBjcmVhdGUobmFtZTogU3RyaW5nKTogU1ZHRWxlbWVudFxuLy8gUmV0dXJucyBhIGluc3RhbmNlIG9mIFtTVkdFbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHRWxlbWVudCksXG4vLyBjb3JyZXNwb25kaW5nIHRvIHRoZSBjbGFzcyBuYW1lIHBhc3NlZC4gRm9yIGV4YW1wbGUsIHVzaW5nICdsaW5lJyB3aWxsIHJldHVyblxuLy8gYW4gaW5zdGFuY2Ugb2YgW1NWR0xpbmVFbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvU1ZHTGluZUVsZW1lbnQpLlxuZXhwb3J0IGZ1bmN0aW9uIHN2Z0NyZWF0ZShuYW1lKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG59XG5cbi8vIEBmdW5jdGlvbiBwb2ludHNUb1BhdGgocmluZ3M6IFBvaW50W10sIGNsb3NlZDogQm9vbGVhbik6IFN0cmluZ1xuLy8gR2VuZXJhdGVzIGEgU1ZHIHBhdGggc3RyaW5nIGZvciBtdWx0aXBsZSByaW5ncywgd2l0aCBlYWNoIHJpbmcgdHVybmluZ1xuLy8gaW50byBcIk0uLkwuLkwuLlwiIGluc3RydWN0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHBvaW50c1RvUGF0aChyaW5ncywgY2xvc2VkKSB7XG5cdHZhciBzdHIgPSAnJyxcblx0aSwgaiwgbGVuLCBsZW4yLCBwb2ludHMsIHA7XG5cblx0Zm9yIChpID0gMCwgbGVuID0gcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRwb2ludHMgPSByaW5nc1tpXTtcblxuXHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRwID0gcG9pbnRzW2pdO1xuXHRcdFx0c3RyICs9IChqID8gJ0wnIDogJ00nKSArIHAueCArICcgJyArIHAueTtcblx0XHR9XG5cblx0XHQvLyBjbG9zZXMgdGhlIHJpbmcgZm9yIHBvbHlnb25zOyBcInhcIiBpcyBWTUwgc3ludGF4XG5cdFx0c3RyICs9IGNsb3NlZCA/IChCcm93c2VyLnN2ZyA/ICd6JyA6ICd4JykgOiAnJztcblx0fVxuXG5cdC8vIFNWRyBjb21wbGFpbnMgYWJvdXQgZW1wdHkgcGF0aCBzdHJpbmdzXG5cdHJldHVybiBzdHIgfHwgJ00wIDAnO1xufVxuXG5cblxuXG4iLCJpbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4vVXRpbCc7XHJcbmltcG9ydCB7c3ZnQ3JlYXRlfSBmcm9tICcuLi9sYXllci92ZWN0b3IvU1ZHLlV0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBCcm93c2VyXHJcbiAqIEBha2EgTC5Ccm93c2VyXHJcbiAqXHJcbiAqIEEgbmFtZXNwYWNlIHdpdGggc3RhdGljIHByb3BlcnRpZXMgZm9yIGJyb3dzZXIvZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGlmIChMLkJyb3dzZXIuaWVsdDkpIHtcclxuICogICBhbGVydCgnVXBncmFkZSB5b3VyIGJyb3dzZXIsIGR1ZGUhJyk7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5cclxudmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cclxuLy8gQHByb3BlcnR5IGllOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9ucyAobm90IEVkZ2UpLlxyXG52YXIgaWUgPSAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93O1xyXG5cclxuLy8gQHByb3BlcnR5IGllbHQ5OiBCb29sZWFuOyBgdHJ1ZWAgZm9yIEludGVybmV0IEV4cGxvcmVyIHZlcnNpb25zIGxlc3MgdGhhbiA5LlxyXG52YXIgaWVsdDkgPSBpZSAmJiAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHJcbi8vIEBwcm9wZXJ0eSBlZGdlOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBFZGdlIHdlYiBicm93c2VyLlxyXG52YXIgZWRnZSA9ICdtc0xhdW5jaFVyaScgaW4gbmF2aWdhdG9yICYmICEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpO1xyXG5cclxuLy8gQHByb3BlcnR5IHdlYmtpdDogQm9vbGVhbjtcclxuLy8gYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgbGlrZSBDaHJvbWUgYW5kIFNhZmFyaSAoaW5jbHVkaW5nIG1vYmlsZSB2ZXJzaW9ucykuXHJcbnZhciB3ZWJraXQgPSB1c2VyQWdlbnRDb250YWlucygnd2Via2l0Jyk7XHJcblxyXG4vLyBAcHJvcGVydHkgYW5kcm9pZDogQm9vbGVhblxyXG4vLyAqKkRlcHJlY2F0ZWQuKiogYHRydWVgIGZvciBhbnkgYnJvd3NlciBydW5uaW5nIG9uIGFuIEFuZHJvaWQgcGxhdGZvcm0uXHJcbnZhciBhbmRyb2lkID0gdXNlckFnZW50Q29udGFpbnMoJ2FuZHJvaWQnKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBhbmRyb2lkMjM6IEJvb2xlYW47ICoqRGVwcmVjYXRlZC4qKiBgdHJ1ZWAgZm9yIGJyb3dzZXJzIHJ1bm5pbmcgb24gQW5kcm9pZCAyIG9yIEFuZHJvaWQgMy5cclxudmFyIGFuZHJvaWQyMyA9IHVzZXJBZ2VudENvbnRhaW5zKCdhbmRyb2lkIDInKSB8fCB1c2VyQWdlbnRDb250YWlucygnYW5kcm9pZCAzJyk7XHJcblxyXG4vKiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE3OTYxMjY2IGZvciBkZXRhaWxzIG9uIGRldGVjdGluZyBzdG9jayBBbmRyb2lkICovXHJcbnZhciB3ZWJraXRWZXIgPSBwYXJzZUludCgvV2ViS2l0XFwvKFswLTldKyl8JC8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KVsxXSwgMTApOyAvLyBhbHNvIG1hdGNoZXMgQXBwbGVXZWJLaXRcclxuLy8gQHByb3BlcnR5IGFuZHJvaWRTdG9jazogQm9vbGVhbjsgKipEZXByZWNhdGVkLioqIGB0cnVlYCBmb3IgdGhlIEFuZHJvaWQgc3RvY2sgYnJvd3NlciAoaS5lLiBub3QgQ2hyb21lKVxyXG52YXIgYW5kcm9pZFN0b2NrID0gYW5kcm9pZCAmJiB1c2VyQWdlbnRDb250YWlucygnR29vZ2xlJykgJiYgd2Via2l0VmVyIDwgNTM3ICYmICEoJ0F1ZGlvTm9kZScgaW4gd2luZG93KTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBvcGVyYTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgT3BlcmEgYnJvd3NlclxyXG52YXIgb3BlcmEgPSAhIXdpbmRvdy5vcGVyYTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBjaHJvbWU6IEJvb2xlYW47IGB0cnVlYCBmb3IgdGhlIENocm9tZSBicm93c2VyLlxyXG52YXIgY2hyb21lID0gIWVkZ2UgJiYgdXNlckFnZW50Q29udGFpbnMoJ2Nocm9tZScpO1xyXG5cclxuLy8gQHByb3BlcnR5IGdlY2tvOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGdlY2tvLWJhc2VkIGJyb3dzZXJzIGxpa2UgRmlyZWZveC5cclxudmFyIGdlY2tvID0gdXNlckFnZW50Q29udGFpbnMoJ2dlY2tvJykgJiYgIXdlYmtpdCAmJiAhb3BlcmEgJiYgIWllO1xyXG5cclxuLy8gQHByb3BlcnR5IHNhZmFyaTogQm9vbGVhbjsgYHRydWVgIGZvciB0aGUgU2FmYXJpIGJyb3dzZXIuXHJcbnZhciBzYWZhcmkgPSAhY2hyb21lICYmIHVzZXJBZ2VudENvbnRhaW5zKCdzYWZhcmknKTtcclxuXHJcbnZhciBwaGFudG9tID0gdXNlckFnZW50Q29udGFpbnMoJ3BoYW50b20nKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBvcGVyYTEyOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgdGhlIE9wZXJhIGJyb3dzZXIgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3JtcyAodmVyc2lvbiAxMiBvciBsYXRlcikuXHJcbnZhciBvcGVyYTEyID0gJ09UcmFuc2l0aW9uJyBpbiBzdHlsZTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3aW46IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBXaW5kb3dzIHBsYXRmb3JtXHJcbnZhciB3aW4gPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignV2luJykgPT09IDA7XHJcblxyXG4vLyBAcHJvcGVydHkgaWUzZDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIGllM2QgPSBpZSAmJiAoJ3RyYW5zaXRpb24nIGluIHN0eWxlKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB3ZWJraXQzZDogQm9vbGVhbjsgYHRydWVgIGZvciB3ZWJraXQtYmFzZWQgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIHdlYmtpdDNkID0gKCdXZWJLaXRDU1NNYXRyaXgnIGluIHdpbmRvdykgJiYgKCdtMTEnIGluIG5ldyB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KCkpICYmICFhbmRyb2lkMjM7XHJcblxyXG4vLyBAcHJvcGVydHkgZ2Vja28zZDogQm9vbGVhbjsgYHRydWVgIGZvciBnZWNrby1iYXNlZCBicm93c2VycyBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG52YXIgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gc3R5bGU7XHJcblxyXG4vLyBAcHJvcGVydHkgYW55M2Q6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBDU1MgdHJhbnNmb3Jtcy5cclxudmFyIGFueTNkID0gIXdpbmRvdy5MX0RJU0FCTEVfM0QgJiYgKGllM2QgfHwgd2Via2l0M2QgfHwgZ2Vja28zZCkgJiYgIW9wZXJhMTIgJiYgIXBoYW50b207XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBydW5uaW5nIGluIGEgbW9iaWxlIGRldmljZS5cclxudmFyIG1vYmlsZSA9IHR5cGVvZiBvcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgfHwgdXNlckFnZW50Q29udGFpbnMoJ21vYmlsZScpO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZVdlYmtpdDogQm9vbGVhbjsgYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZS5cclxudmFyIG1vYmlsZVdlYmtpdCA9IG1vYmlsZSAmJiB3ZWJraXQ7XHJcblxyXG4vLyBAcHJvcGVydHkgbW9iaWxlV2Via2l0M2Q6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzIGluIGEgbW9iaWxlIGRldmljZSBzdXBwb3J0aW5nIENTUyB0cmFuc2Zvcm1zLlxyXG52YXIgbW9iaWxlV2Via2l0M2QgPSBtb2JpbGUgJiYgd2Via2l0M2Q7XHJcblxyXG4vLyBAcHJvcGVydHkgbXNQb2ludGVyOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgaW1wbGVtZW50aW5nIHRoZSBNaWNyb3NvZnQgdG91Y2ggZXZlbnRzIG1vZGVsIChub3RhYmx5IElFMTApLlxyXG52YXIgbXNQb2ludGVyID0gIXdpbmRvdy5Qb2ludGVyRXZlbnQgJiYgd2luZG93Lk1TUG9pbnRlckV2ZW50O1xyXG5cclxuLy8gQHByb3BlcnR5IHBvaW50ZXI6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBhbGwgYnJvd3NlcnMgc3VwcG9ydGluZyBbcG9pbnRlciBldmVudHNdKGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDQlMjh2PXZzLjg1JTI5LmFzcHgpLlxyXG52YXIgcG9pbnRlciA9ICEhKHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgbXNQb2ludGVyKTtcclxuXHJcbi8vIEBwcm9wZXJ0eSB0b3VjaE5hdGl2ZTogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgZm9yIGFsbCBicm93c2VycyBzdXBwb3J0aW5nIFt0b3VjaCBldmVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Ub3VjaF9ldmVudHMpLlxyXG4vLyAqKlRoaXMgZG9lcyBub3QgbmVjZXNzYXJpbHkgbWVhbioqIHRoYXQgdGhlIGJyb3dzZXIgaXMgcnVubmluZyBpbiBhIGNvbXB1dGVyIHdpdGhcclxuLy8gYSB0b3VjaHNjcmVlbiwgaXQgb25seSBtZWFucyB0aGF0IHRoZSBicm93c2VyIGlzIGNhcGFibGUgb2YgdW5kZXJzdGFuZGluZ1xyXG4vLyB0b3VjaCBldmVudHMuXHJcbnZhciB0b3VjaE5hdGl2ZSA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCAhIXdpbmRvdy5Ub3VjaEV2ZW50O1xyXG5cclxuLy8gQHByb3BlcnR5IHRvdWNoOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYWxsIGJyb3dzZXJzIHN1cHBvcnRpbmcgZWl0aGVyIFt0b3VjaF0oI2Jyb3dzZXItdG91Y2gpIG9yIFtwb2ludGVyXSgjYnJvd3Nlci1wb2ludGVyKSBldmVudHMuXHJcbi8vIE5vdGU6IHBvaW50ZXIgZXZlbnRzIHdpbGwgYmUgcHJlZmVycmVkIChpZiBhdmFpbGFibGUpLCBhbmQgcHJvY2Vzc2VkIGZvciBhbGwgYHRvdWNoKmAgbGlzdGVuZXJzLlxyXG52YXIgdG91Y2ggPSAhd2luZG93LkxfTk9fVE9VQ0ggJiYgKHRvdWNoTmF0aXZlIHx8IHBvaW50ZXIpO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZU9wZXJhOiBCb29sZWFuOyBgdHJ1ZWAgZm9yIHRoZSBPcGVyYSBicm93c2VyIGluIGEgbW9iaWxlIGRldmljZS5cclxudmFyIG1vYmlsZU9wZXJhID0gbW9iaWxlICYmIG9wZXJhO1xyXG5cclxuLy8gQHByb3BlcnR5IG1vYmlsZUdlY2tvOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgZ2Vja28tYmFzZWQgYnJvd3NlcnMgcnVubmluZyBpbiBhIG1vYmlsZSBkZXZpY2UuXHJcbnZhciBtb2JpbGVHZWNrbyA9IG1vYmlsZSAmJiBnZWNrbztcclxuXHJcbi8vIEBwcm9wZXJ0eSByZXRpbmE6IEJvb2xlYW5cclxuLy8gYHRydWVgIGZvciBicm93c2VycyBvbiBhIGhpZ2gtcmVzb2x1dGlvbiBcInJldGluYVwiIHNjcmVlbiBvciBvbiBhbnkgc2NyZWVuIHdoZW4gYnJvd3NlcidzIGRpc3BsYXkgem9vbSBpcyBtb3JlIHRoYW4gMTAwJS5cclxudmFyIHJldGluYSA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAod2luZG93LnNjcmVlbi5kZXZpY2VYRFBJIC8gd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSkpID4gMTtcclxuXHJcbi8vIEBwcm9wZXJ0eSBwYXNzaXZlRXZlbnRzOiBCb29sZWFuXHJcbi8vIGB0cnVlYCBmb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHBhc3NpdmUgZXZlbnRzLlxyXG52YXIgcGFzc2l2ZUV2ZW50cyA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbiA9IGZhbHNlO1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdldHRlci1yZXR1cm5cclxuXHRcdFx0XHRzdXBwb3J0c1Bhc3NpdmVPcHRpb24gPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydCcsIFV0aWwuZmFsc2VGbiwgb3B0cyk7XHJcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBVdGlsLmZhbHNlRm4sIG9wdHMpO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdC8vIEVycm9ycyBjYW4gc2FmZWx5IGJlIGlnbm9yZWQgc2luY2UgdGhpcyBpcyBvbmx5IGEgYnJvd3NlciBzdXBwb3J0IHRlc3QuXHJcblx0fVxyXG5cdHJldHVybiBzdXBwb3J0c1Bhc3NpdmVPcHRpb247XHJcbn0oKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgY2FudmFzOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXHJcbnZhciBjYW52YXMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XHJcbn0oKSk7XHJcblxyXG4vLyBAcHJvcGVydHkgc3ZnOiBCb29sZWFuXHJcbi8vIGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFtTVkddKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRykuXHJcbnZhciBzdmcgPSAhIShkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiYgc3ZnQ3JlYXRlKCdzdmcnKS5jcmVhdGVTVkdSZWN0KTtcclxuXHJcbnZhciBpbmxpbmVTdmcgPSAhIXN2ZyAmJiAoZnVuY3Rpb24gKCkge1xyXG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRkaXYuaW5uZXJIVE1MID0gJzxzdmcvPic7XHJcblx0cmV0dXJuIChkaXYuZmlyc3RDaGlsZCAmJiBkaXYuZmlyc3RDaGlsZC5uYW1lc3BhY2VVUkkpID09PSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xyXG59KSgpO1xyXG5cclxuLy8gQHByb3BlcnR5IHZtbDogQm9vbGVhblxyXG4vLyBgdHJ1ZWAgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSkuXHJcbnZhciB2bWwgPSAhc3ZnICYmIChmdW5jdGlvbiAoKSB7XHJcblx0dHJ5IHtcclxuXHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdGRpdi5pbm5lckhUTUwgPSAnPHY6c2hhcGUgYWRqPVwiMVwiLz4nO1xyXG5cclxuXHRcdHZhciBzaGFwZSA9IGRpdi5maXJzdENoaWxkO1xyXG5cdFx0c2hhcGUuc3R5bGUuYmVoYXZpb3IgPSAndXJsKCNkZWZhdWx0I1ZNTCknO1xyXG5cclxuXHRcdHJldHVybiBzaGFwZSAmJiAodHlwZW9mIHNoYXBlLmFkaiA9PT0gJ29iamVjdCcpO1xyXG5cclxuXHR9IGNhdGNoIChlKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG59KCkpO1xyXG5cclxuXHJcbi8vIEBwcm9wZXJ0eSBtYWM6IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBNYWMgcGxhdGZvcm1cclxudmFyIG1hYyA9IG5hdmlnYXRvci5wbGF0Zm9ybS5pbmRleE9mKCdNYWMnKSA9PT0gMDtcclxuXHJcbi8vIEBwcm9wZXJ0eSBtYWM6IEJvb2xlYW47IGB0cnVlYCB3aGVuIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgaW4gYSBMaW51eCBwbGF0Zm9ybVxyXG52YXIgbGludXggPSBuYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZignTGludXgnKSA9PT0gMDtcclxuXHJcbmZ1bmN0aW9uIHVzZXJBZ2VudENvbnRhaW5zKHN0cikge1xyXG5cdHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzdHIpID49IDA7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aWU6IGllLFxyXG5cdGllbHQ5OiBpZWx0OSxcclxuXHRlZGdlOiBlZGdlLFxyXG5cdHdlYmtpdDogd2Via2l0LFxyXG5cdGFuZHJvaWQ6IGFuZHJvaWQsXHJcblx0YW5kcm9pZDIzOiBhbmRyb2lkMjMsXHJcblx0YW5kcm9pZFN0b2NrOiBhbmRyb2lkU3RvY2ssXHJcblx0b3BlcmE6IG9wZXJhLFxyXG5cdGNocm9tZTogY2hyb21lLFxyXG5cdGdlY2tvOiBnZWNrbyxcclxuXHRzYWZhcmk6IHNhZmFyaSxcclxuXHRwaGFudG9tOiBwaGFudG9tLFxyXG5cdG9wZXJhMTI6IG9wZXJhMTIsXHJcblx0d2luOiB3aW4sXHJcblx0aWUzZDogaWUzZCxcclxuXHR3ZWJraXQzZDogd2Via2l0M2QsXHJcblx0Z2Vja28zZDogZ2Vja28zZCxcclxuXHRhbnkzZDogYW55M2QsXHJcblx0bW9iaWxlOiBtb2JpbGUsXHJcblx0bW9iaWxlV2Via2l0OiBtb2JpbGVXZWJraXQsXHJcblx0bW9iaWxlV2Via2l0M2Q6IG1vYmlsZVdlYmtpdDNkLFxyXG5cdG1zUG9pbnRlcjogbXNQb2ludGVyLFxyXG5cdHBvaW50ZXI6IHBvaW50ZXIsXHJcblx0dG91Y2g6IHRvdWNoLFxyXG5cdHRvdWNoTmF0aXZlOiB0b3VjaE5hdGl2ZSxcclxuXHRtb2JpbGVPcGVyYTogbW9iaWxlT3BlcmEsXHJcblx0bW9iaWxlR2Vja286IG1vYmlsZUdlY2tvLFxyXG5cdHJldGluYTogcmV0aW5hLFxyXG5cdHBhc3NpdmVFdmVudHM6IHBhc3NpdmVFdmVudHMsXHJcblx0Y2FudmFzOiBjYW52YXMsXHJcblx0c3ZnOiBzdmcsXHJcblx0dm1sOiB2bWwsXHJcblx0aW5saW5lU3ZnOiBpbmxpbmVTdmcsXHJcblx0bWFjOiBtYWMsXHJcblx0bGludXg6IGxpbnV4XHJcbn07XHJcbiIsImltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4vRG9tRXZlbnQnO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7ZmFsc2VGbn0gZnJvbSAnLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEV4dGVuZHMgTC5Eb21FdmVudCB0byBwcm92aWRlIHRvdWNoIHN1cHBvcnQgZm9yIEludGVybmV0IEV4cGxvcmVyIGFuZCBXaW5kb3dzLWJhc2VkIGRldmljZXMuXG4gKi9cblxudmFyIFBPSU5URVJfRE9XTiA9ICAgQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgICA6ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9NT1ZFID0gICBCcm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJNb3ZlJyAgIDogJ3BvaW50ZXJtb3ZlJztcbnZhciBQT0lOVEVSX1VQID0gICAgIEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlclVwJyAgICAgOiAncG9pbnRlcnVwJztcbnZhciBQT0lOVEVSX0NBTkNFTCA9IEJyb3dzZXIubXNQb2ludGVyID8gJ01TUG9pbnRlckNhbmNlbCcgOiAncG9pbnRlcmNhbmNlbCc7XG52YXIgcEV2ZW50ID0ge1xuXHR0b3VjaHN0YXJ0ICA6IFBPSU5URVJfRE9XTixcblx0dG91Y2htb3ZlICAgOiBQT0lOVEVSX01PVkUsXG5cdHRvdWNoZW5kICAgIDogUE9JTlRFUl9VUCxcblx0dG91Y2hjYW5jZWwgOiBQT0lOVEVSX0NBTkNFTFxufTtcbnZhciBoYW5kbGUgPSB7XG5cdHRvdWNoc3RhcnQgIDogX29uUG9pbnRlclN0YXJ0LFxuXHR0b3VjaG1vdmUgICA6IF9oYW5kbGVQb2ludGVyLFxuXHR0b3VjaGVuZCAgICA6IF9oYW5kbGVQb2ludGVyLFxuXHR0b3VjaGNhbmNlbCA6IF9oYW5kbGVQb2ludGVyXG59O1xudmFyIF9wb2ludGVycyA9IHt9O1xudmFyIF9wb2ludGVyRG9jTGlzdGVuZXIgPSBmYWxzZTtcblxuLy8gUHJvdmlkZXMgYSB0b3VjaCBldmVudHMgd3JhcHBlciBmb3IgKG1zKXBvaW50ZXIgZXZlbnRzLlxuLy8gcmVmIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyBodHRwczovL3d3dy53My5vcmcvQnVncy9QdWJsaWMvc2hvd19idWcuY2dpP2lkPTIyODkwXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKSB7XG5cdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcblx0XHRfYWRkUG9pbnRlckRvY0xpc3RlbmVyKCk7XG5cdH1cblx0aWYgKCFoYW5kbGVbdHlwZV0pIHtcblx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGV2ZW50IHNwZWNpZmllZDonLCB0eXBlKTtcblx0XHRyZXR1cm4gZmFsc2VGbjtcblx0fVxuXHRoYW5kbGVyID0gaGFuZGxlW3R5cGVdLmJpbmQodGhpcywgaGFuZGxlcik7XG5cdG9iai5hZGRFdmVudExpc3RlbmVyKHBFdmVudFt0eXBlXSwgaGFuZGxlciwgZmFsc2UpO1xuXHRyZXR1cm4gaGFuZGxlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIpIHtcblx0aWYgKCFwRXZlbnRbdHlwZV0pIHtcblx0XHRjb25zb2xlLndhcm4oJ3dyb25nIGV2ZW50IHNwZWNpZmllZDonLCB0eXBlKTtcblx0XHRyZXR1cm47XG5cdH1cblx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIocEV2ZW50W3R5cGVdLCBoYW5kbGVyLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyRG93bihlKSB7XG5cdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xufVxuXG5mdW5jdGlvbiBfZ2xvYmFsUG9pbnRlck1vdmUoZSkge1xuXHRpZiAoX3BvaW50ZXJzW2UucG9pbnRlcklkXSkge1xuXHRcdF9wb2ludGVyc1tlLnBvaW50ZXJJZF0gPSBlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9nbG9iYWxQb2ludGVyVXAoZSkge1xuXHRkZWxldGUgX3BvaW50ZXJzW2UucG9pbnRlcklkXTtcbn1cblxuZnVuY3Rpb24gX2FkZFBvaW50ZXJEb2NMaXN0ZW5lcigpIHtcblx0Ly8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoYXQgcG9pbnRlcnMgYW5kIGhvdyBtYW55IGFyZSBhY3RpdmUgdG8gcHJvdmlkZSBlLnRvdWNoZXMgZW11bGF0aW9uXG5cdGlmICghX3BvaW50ZXJEb2NMaXN0ZW5lcikge1xuXHRcdC8vIHdlIGxpc3RlbiBkb2N1bWVudCBhcyBhbnkgZHJhZ3MgdGhhdCBlbmQgYnkgbW92aW5nIHRoZSB0b3VjaCBvZmYgdGhlIHNjcmVlbiBnZXQgZmlyZWQgdGhlcmVcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfRE9XTiwgX2dsb2JhbFBvaW50ZXJEb3duLCB0cnVlKTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfTU9WRSwgX2dsb2JhbFBvaW50ZXJNb3ZlLCB0cnVlKTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFBPSU5URVJfVVAsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoUE9JTlRFUl9DQU5DRUwsIF9nbG9iYWxQb2ludGVyVXAsIHRydWUpO1xuXG5cdFx0X3BvaW50ZXJEb2NMaXN0ZW5lciA9IHRydWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gX2hhbmRsZVBvaW50ZXIoaGFuZGxlciwgZSkge1xuXHRpZiAoZS5wb2ludGVyVHlwZSA9PT0gKGUuTVNQT0lOVEVSX1RZUEVfTU9VU0UgfHwgJ21vdXNlJykpIHsgcmV0dXJuOyB9XG5cblx0ZS50b3VjaGVzID0gW107XG5cdGZvciAodmFyIGkgaW4gX3BvaW50ZXJzKSB7XG5cdFx0ZS50b3VjaGVzLnB1c2goX3BvaW50ZXJzW2ldKTtcblx0fVxuXHRlLmNoYW5nZWRUb3VjaGVzID0gW2VdO1xuXG5cdGhhbmRsZXIoZSk7XG59XG5cbmZ1bmN0aW9uIF9vblBvaW50ZXJTdGFydChoYW5kbGVyLCBlKSB7XG5cdC8vIElFMTAgc3BlY2lmaWM6IE1zVG91Y2ggbmVlZHMgcHJldmVudERlZmF1bHQuIFNlZSAjMjAwMFxuXHRpZiAoZS5NU1BPSU5URVJfVFlQRV9UT1VDSCAmJiBlLnBvaW50ZXJUeXBlID09PSBlLk1TUE9JTlRFUl9UWVBFX1RPVUNIKSB7XG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH1cblx0X2hhbmRsZVBvaW50ZXIoaGFuZGxlciwgZSk7XG59XG4iLCJpbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcclxuXHJcbi8qXHJcbiAqIEV4dGVuZHMgdGhlIGV2ZW50IGhhbmRsaW5nIGNvZGUgd2l0aCBkb3VibGUgdGFwIHN1cHBvcnQgZm9yIG1vYmlsZSBicm93c2Vycy5cclxuICpcclxuICogTm90ZTogY3VycmVudGx5IG1vc3QgYnJvd3NlcnMgZmlyZSBuYXRpdmUgZGJsY2xpY2ssIHdpdGggb25seSBhIGZldyBleGNlcHRpb25zXHJcbiAqIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvNzAxMiNpc3N1ZWNvbW1lbnQtNTk1MDg3Mzg2KVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1ha2VEYmxjbGljayhldmVudCkge1xyXG5cdC8vIGluIG1vZGVybiBicm93c2VycyBgdHlwZWAgY2Fubm90IGJlIGp1c3Qgb3ZlcnJpZGRlbjpcclxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9FcnJvcnMvR2V0dGVyX29ubHlcclxuXHR2YXIgbmV3RXZlbnQgPSB7fSxcclxuXHQgICAgcHJvcCwgaTtcclxuXHRmb3IgKGkgaW4gZXZlbnQpIHtcclxuXHRcdHByb3AgPSBldmVudFtpXTtcclxuXHRcdG5ld0V2ZW50W2ldID0gcHJvcCAmJiBwcm9wLmJpbmQgPyBwcm9wLmJpbmQoZXZlbnQpIDogcHJvcDtcclxuXHR9XHJcblx0ZXZlbnQgPSBuZXdFdmVudDtcclxuXHRuZXdFdmVudC50eXBlID0gJ2RibGNsaWNrJztcclxuXHRuZXdFdmVudC5kZXRhaWwgPSAyO1xyXG5cdG5ld0V2ZW50LmlzVHJ1c3RlZCA9IGZhbHNlO1xyXG5cdG5ld0V2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlOyAvLyBmb3IgZGVidWcgcHVycG9zZXNcclxuXHRyZXR1cm4gbmV3RXZlbnQ7XHJcbn1cclxuXHJcbnZhciBkZWxheSA9IDIwMDtcclxuZXhwb3J0IGZ1bmN0aW9uIGFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlcikge1xyXG5cdC8vIE1vc3QgYnJvd3NlcnMgaGFuZGxlIGRvdWJsZSB0YXAgbmF0aXZlbHlcclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBoYW5kbGVyKTtcclxuXHJcblx0Ly8gT24gc29tZSBwbGF0Zm9ybXMgdGhlIGJyb3dzZXIgZG9lc24ndCBmaXJlIG5hdGl2ZSBkYmxjbGlja3MgZm9yIHRvdWNoIGV2ZW50cy5cclxuXHQvLyBJdCBzZWVtcyB0aGF0IGluIGFsbCBzdWNoIGNhc2VzIGBkZXRhaWxgIHByb3BlcnR5IG9mIGBjbGlja2AgZXZlbnQgaXMgYWx3YXlzIGAxYC5cclxuXHQvLyBTbyBoZXJlIHdlIHJlbHkgb24gdGhhdCBmYWN0IHRvIGF2b2lkIGV4Y2Vzc2l2ZSAnZGJsY2xpY2snIHNpbXVsYXRpb24gd2hlbiBub3QgbmVlZGVkLlxyXG5cdHZhciBsYXN0ID0gMCxcclxuXHQgICAgZGV0YWlsO1xyXG5cdGZ1bmN0aW9uIHNpbURibGNsaWNrKGUpIHtcclxuXHRcdGlmIChlLmRldGFpbCAhPT0gMSkge1xyXG5cdFx0XHRkZXRhaWwgPSBlLmRldGFpbDsgLy8ga2VlcCBpbiBzeW5jIHRvIGF2b2lkIGZhbHNlIGRibGNsaWNrIGluIHNvbWUgY2FzZXNcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8XHJcblx0XHRcdChlLnNvdXJjZUNhcGFiaWxpdGllcyAmJiAhZS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykpIHtcclxuXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBXaGVuIGNsaWNraW5nIG9uIGFuIDxpbnB1dD4sIHRoZSBicm93c2VyIGdlbmVyYXRlcyBhIGNsaWNrIG9uIGl0c1xyXG5cdFx0Ly8gPGxhYmVsPiAoYW5kIHZpY2UgdmVyc2EpIHRyaWdnZXJpbmcgdHdvIGNsaWNrcyBpbiBxdWljayBzdWNjZXNzaW9uLlxyXG5cdFx0Ly8gVGhpcyBpZ25vcmVzIGNsaWNrcyBvbiBlbGVtZW50cyB3aGljaCBhcmUgYSBsYWJlbCB3aXRoIGEgJ2ZvcidcclxuXHRcdC8vIGF0dHJpYnV0ZSAob3IgY2hpbGRyZW4gb2Ygc3VjaCBhIGxhYmVsKSwgYnV0IG5vdCBjaGlsZHJlbiBvZlxyXG5cdFx0Ly8gYSA8aW5wdXQ+LlxyXG5cdFx0dmFyIHBhdGggPSBEb21FdmVudC5nZXRQcm9wYWdhdGlvblBhdGgoZSk7XHJcblx0XHRpZiAocGF0aC5zb21lKGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0XHRyZXR1cm4gZWwgaW5zdGFuY2VvZiBIVE1MTGFiZWxFbGVtZW50ICYmIGVsLmF0dHJpYnV0ZXMuZm9yO1xyXG5cdFx0fSkgJiZcclxuXHRcdFx0IXBhdGguc29tZShmdW5jdGlvbiAoZWwpIHtcclxuXHRcdFx0XHRyZXR1cm4gKFxyXG5cdFx0XHRcdFx0ZWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50IHx8XHJcblx0XHRcdFx0XHRlbCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50XHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fSlcclxuXHRcdCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5vdyA9IERhdGUubm93KCk7XHJcblx0XHRpZiAobm93IC0gbGFzdCA8PSBkZWxheSkge1xyXG5cdFx0XHRkZXRhaWwrKztcclxuXHRcdFx0aWYgKGRldGFpbCA9PT0gMikge1xyXG5cdFx0XHRcdGhhbmRsZXIobWFrZURibGNsaWNrKGUpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZGV0YWlsID0gMTtcclxuXHRcdH1cclxuXHRcdGxhc3QgPSBub3c7XHJcblx0fVxyXG5cclxuXHRvYmouYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzaW1EYmxjbGljayk7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRkYmxjbGljazogaGFuZGxlcixcclxuXHRcdHNpbURibGNsaWNrOiBzaW1EYmxjbGlja1xyXG5cdH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXJzKSB7XHJcblx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgaGFuZGxlcnMuZGJsY2xpY2spO1xyXG5cdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXJzLnNpbURibGNsaWNrKTtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcblxyXG4vKlxyXG4gKiBAbmFtZXNwYWNlIERvbVV0aWxcclxuICpcclxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRG9jdW1lbnRfT2JqZWN0X01vZGVsKVxyXG4gKiB0cmVlLCB1c2VkIGJ5IExlYWZsZXQgaW50ZXJuYWxseS5cclxuICpcclxuICogTW9zdCBmdW5jdGlvbnMgZXhwZWN0aW5nIG9yIHJldHVybmluZyBhIGBIVE1MRWxlbWVudGAgYWxzbyB3b3JrIGZvclxyXG4gKiBTVkcgZWxlbWVudHMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCBjbGFzc2VzIHJlZmVyIHRvIENTUyBjbGFzc2VzXHJcbiAqIGluIEhUTUwgYW5kIFNWRyBjbGFzc2VzIGluIFNWRy5cclxuICovXHJcblxyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TRk9STTogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2Zvcm0gc3R5bGUgbmFtZSAoZS5nLiBgJ3dlYmtpdFRyYW5zZm9ybSdgIGZvciBXZWJLaXQpLlxyXG5leHBvcnQgdmFyIFRSQU5TRk9STSA9IHRlc3RQcm9wKFxyXG5cdFsndHJhbnNmb3JtJywgJ3dlYmtpdFRyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdtc1RyYW5zZm9ybSddKTtcclxuXHJcbi8vIHdlYmtpdFRyYW5zaXRpb24gY29tZXMgZmlyc3QgYmVjYXVzZSBzb21lIGJyb3dzZXIgdmVyc2lvbnMgdGhhdCBkcm9wIHZlbmRvciBwcmVmaXggZG9uJ3QgZG9cclxuLy8gdGhlIHNhbWUgZm9yIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50LCBpbiBwYXJ0aWN1bGFyIHRoZSBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXHJcblxyXG4vLyBAcHJvcGVydHkgVFJBTlNJVElPTjogU3RyaW5nXHJcbi8vIFZlbmRvci1wcmVmaXhlZCB0cmFuc2l0aW9uIHN0eWxlIG5hbWUuXHJcbmV4cG9ydCB2YXIgVFJBTlNJVElPTiA9IHRlc3RQcm9wKFxyXG5cdFsnd2Via2l0VHJhbnNpdGlvbicsICd0cmFuc2l0aW9uJywgJ09UcmFuc2l0aW9uJywgJ01velRyYW5zaXRpb24nLCAnbXNUcmFuc2l0aW9uJ10pO1xyXG5cclxuLy8gQHByb3BlcnR5IFRSQU5TSVRJT05fRU5EOiBTdHJpbmdcclxuLy8gVmVuZG9yLXByZWZpeGVkIHRyYW5zaXRpb25lbmQgZXZlbnQgbmFtZS5cclxuZXhwb3J0IHZhciBUUkFOU0lUSU9OX0VORCA9XHJcblx0VFJBTlNJVElPTiA9PT0gJ3dlYmtpdFRyYW5zaXRpb24nIHx8IFRSQU5TSVRJT04gPT09ICdPVHJhbnNpdGlvbicgPyBUUkFOU0lUSU9OICsgJ0VuZCcgOiAndHJhbnNpdGlvbmVuZCc7XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldChpZDogU3RyaW5nfEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gUmV0dXJucyBhbiBlbGVtZW50IGdpdmVuIGl0cyBET00gaWQsIG9yIHJldHVybnMgdGhlIGVsZW1lbnQgaXRzZWxmXHJcbi8vIGlmIGl0IHdhcyBwYXNzZWQgZGlyZWN0bHkuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXQoaWQpIHtcclxuXHRyZXR1cm4gdHlwZW9mIGlkID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0U3R5bGUoZWw6IEhUTUxFbGVtZW50LCBzdHlsZUF0dHJpYjogU3RyaW5nKTogU3RyaW5nXHJcbi8vIFJldHVybnMgdGhlIHZhbHVlIGZvciBhIGNlcnRhaW4gc3R5bGUgYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQsXHJcbi8vIGluY2x1ZGluZyBjb21wdXRlZCB2YWx1ZXMgb3IgdmFsdWVzIHNldCB0aHJvdWdoIENTUy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0eWxlKGVsLCBzdHlsZSkge1xyXG5cdHZhciB2YWx1ZSA9IGVsLnN0eWxlW3N0eWxlXSB8fCAoZWwuY3VycmVudFN0eWxlICYmIGVsLmN1cnJlbnRTdHlsZVtzdHlsZV0pO1xyXG5cclxuXHRpZiAoKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gJ2F1dG8nKSAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldykge1xyXG5cdFx0dmFyIGNzcyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xyXG5cdFx0dmFsdWUgPSBjc3MgPyBjc3Nbc3R5bGVdIDogbnVsbDtcclxuXHR9XHJcblx0cmV0dXJuIHZhbHVlID09PSAnYXV0bycgPyBudWxsIDogdmFsdWU7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBjcmVhdGUodGFnTmFtZTogU3RyaW5nLCBjbGFzc05hbWU/OiBTdHJpbmcsIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuLy8gQ3JlYXRlcyBhbiBIVE1MIGVsZW1lbnQgd2l0aCBgdGFnTmFtZWAsIHNldHMgaXRzIGNsYXNzIHRvIGBjbGFzc05hbWVgLCBhbmQgb3B0aW9uYWxseSBhcHBlbmRzIGl0IHRvIGBjb250YWluZXJgIGVsZW1lbnQuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUodGFnTmFtZSwgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcclxuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG5cdGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCAnJztcclxuXHJcblx0aWYgKGNvbnRhaW5lcikge1xyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcclxuXHR9XHJcblx0cmV0dXJuIGVsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcmVtb3ZlKGVsOiBIVE1MRWxlbWVudClcclxuLy8gUmVtb3ZlcyBgZWxgIGZyb20gaXRzIHBhcmVudCBlbGVtZW50XHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUoZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50KSB7XHJcblx0XHRwYXJlbnQucmVtb3ZlQ2hpbGQoZWwpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGVtcHR5KGVsOiBIVE1MRWxlbWVudClcclxuLy8gUmVtb3ZlcyBhbGwgb2YgYGVsYCdzIGNoaWxkcmVuIGVsZW1lbnRzIGZyb20gYGVsYFxyXG5leHBvcnQgZnVuY3Rpb24gZW1wdHkoZWwpIHtcclxuXHR3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xyXG5cdFx0ZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gdG9Gcm9udChlbDogSFRNTEVsZW1lbnQpXHJcbi8vIE1ha2VzIGBlbGAgdGhlIGxhc3QgY2hpbGQgb2YgaXRzIHBhcmVudCwgc28gaXQgcmVuZGVycyBpbiBmcm9udCBvZiB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0Zyb250KGVsKSB7XHJcblx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XHJcblx0aWYgKHBhcmVudCAmJiBwYXJlbnQubGFzdENoaWxkICE9PSBlbCkge1xyXG5cdFx0cGFyZW50LmFwcGVuZENoaWxkKGVsKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0b0JhY2soZWw6IEhUTUxFbGVtZW50KVxyXG4vLyBNYWtlcyBgZWxgIHRoZSBmaXJzdCBjaGlsZCBvZiBpdHMgcGFyZW50LCBzbyBpdCByZW5kZXJzIGJlaGluZCB0aGUgb3RoZXIgY2hpbGRyZW4uXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0JhY2soZWwpIHtcclxuXHR2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcclxuXHRpZiAocGFyZW50ICYmIHBhcmVudC5maXJzdENoaWxkICE9PSBlbCkge1xyXG5cdFx0cGFyZW50Lmluc2VydEJlZm9yZShlbCwgcGFyZW50LmZpcnN0Q2hpbGQpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGhhc0NsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKTogQm9vbGVhblxyXG4vLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZWxlbWVudCdzIGNsYXNzIGF0dHJpYnV0ZSBjb250YWlucyBgbmFtZWAuXHJcbmV4cG9ydCBmdW5jdGlvbiBoYXNDbGFzcyhlbCwgbmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcclxuXHR9XHJcblx0dmFyIGNsYXNzTmFtZSA9IGdldENsYXNzKGVsKTtcclxuXHRyZXR1cm4gY2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIG5hbWUgKyAnKFxcXFxzfCQpJykudGVzdChjbGFzc05hbWUpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gYWRkQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIEFkZHMgYG5hbWVgIHRvIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdHZhciBjbGFzc2VzID0gVXRpbC5zcGxpdFdvcmRzKG5hbWUpO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0ZWwuY2xhc3NMaXN0LmFkZChjbGFzc2VzW2ldKTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYgKCFoYXNDbGFzcyhlbCwgbmFtZSkpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSBnZXRDbGFzcyhlbCk7XHJcblx0XHRzZXRDbGFzcyhlbCwgKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSArICcgJyA6ICcnKSArIG5hbWUpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogU3RyaW5nKVxyXG4vLyBSZW1vdmVzIGBuYW1lYCBmcm9tIHRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlxyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIG5hbWUpIHtcclxuXHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdGVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHNldENsYXNzKGVsLCBVdGlsLnRyaW0oKCcgJyArIGdldENsYXNzKGVsKSArICcgJykucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpKSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc2V0Q2xhc3MoZWw6IEhUTUxFbGVtZW50LCBuYW1lOiBTdHJpbmcpXHJcbi8vIFNldHMgdGhlIGVsZW1lbnQncyBjbGFzcy5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldENsYXNzKGVsLCBuYW1lKSB7XHJcblx0aWYgKGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQpIHtcclxuXHRcdGVsLmNsYXNzTmFtZSA9IG5hbWU7XHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIGluIGNhc2Ugb2YgU1ZHIGVsZW1lbnRcclxuXHRcdGVsLmNsYXNzTmFtZS5iYXNlVmFsID0gbmFtZTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBnZXRDbGFzcyhlbDogSFRNTEVsZW1lbnQpOiBTdHJpbmdcclxuLy8gUmV0dXJucyB0aGUgZWxlbWVudCdzIGNsYXNzLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xhc3MoZWwpIHtcclxuXHQvLyBDaGVjayBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkdFbGVtZW50SW5zdGFuY2UgYW5kIHVzZSB0aGUgY29ycmVzcG9uZGluZ0VsZW1lbnQgaW5zdGVhZFxyXG5cdC8vIChSZXF1aXJlZCBmb3IgbGlua2VkIFNWRyBlbGVtZW50cyBpbiBJRTExLilcclxuXHRpZiAoZWwuY29ycmVzcG9uZGluZ0VsZW1lbnQpIHtcclxuXHRcdGVsID0gZWwuY29ycmVzcG9uZGluZ0VsZW1lbnQ7XHJcblx0fVxyXG5cdHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbCA9PT0gdW5kZWZpbmVkID8gZWwuY2xhc3NOYW1lIDogZWwuY2xhc3NOYW1lLmJhc2VWYWw7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRPcGFjaXR5KGVsOiBIVE1MRWxlbWVudCwgb3BhY2l0eTogTnVtYmVyKVxyXG4vLyBTZXQgdGhlIG9wYWNpdHkgb2YgYW4gZWxlbWVudCAoaW5jbHVkaW5nIG9sZCBJRSBzdXBwb3J0KS5cclxuLy8gYG9wYWNpdHlgIG11c3QgYmUgYSBudW1iZXIgZnJvbSBgMGAgdG8gYDFgLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0T3BhY2l0eShlbCwgdmFsdWUpIHtcclxuXHRpZiAoJ29wYWNpdHknIGluIGVsLnN0eWxlKSB7XHJcblx0XHRlbC5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XHJcblx0fSBlbHNlIGlmICgnZmlsdGVyJyBpbiBlbC5zdHlsZSkge1xyXG5cdFx0X3NldE9wYWNpdHlJRShlbCwgdmFsdWUpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gX3NldE9wYWNpdHlJRShlbCwgdmFsdWUpIHtcclxuXHR2YXIgZmlsdGVyID0gZmFsc2UsXHJcblx0ICAgIGZpbHRlck5hbWUgPSAnRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEnO1xyXG5cclxuXHQvLyBmaWx0ZXJzIGNvbGxlY3Rpb24gdGhyb3dzIGFuIGVycm9yIGlmIHdlIHRyeSB0byByZXRyaWV2ZSBhIGZpbHRlciB0aGF0IGRvZXNuJ3QgZXhpc3RcclxuXHR0cnkge1xyXG5cdFx0ZmlsdGVyID0gZWwuZmlsdGVycy5pdGVtKGZpbHRlck5hbWUpO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdC8vIGRvbid0IHNldCBvcGFjaXR5IHRvIDEgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IHNldCBhbiBvcGFjaXR5LFxyXG5cdFx0Ly8gaXQgaXNuJ3QgbmVlZGVkIGFuZCBicmVha3MgdHJhbnNwYXJlbnQgcG5ncy5cclxuXHRcdGlmICh2YWx1ZSA9PT0gMSkgeyByZXR1cm47IH1cclxuXHR9XHJcblxyXG5cdHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XHJcblxyXG5cdGlmIChmaWx0ZXIpIHtcclxuXHRcdGZpbHRlci5FbmFibGVkID0gKHZhbHVlICE9PSAxMDApO1xyXG5cdFx0ZmlsdGVyLk9wYWNpdHkgPSB2YWx1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZWwuc3R5bGUuZmlsdGVyICs9ICcgcHJvZ2lkOicgKyBmaWx0ZXJOYW1lICsgJyhvcGFjaXR5PScgKyB2YWx1ZSArICcpJztcclxuXHR9XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiB0ZXN0UHJvcChwcm9wczogU3RyaW5nW10pOiBTdHJpbmd8ZmFsc2VcclxuLy8gR29lcyB0aHJvdWdoIHRoZSBhcnJheSBvZiBzdHlsZSBuYW1lcyBhbmQgcmV0dXJucyB0aGUgZmlyc3QgbmFtZVxyXG4vLyB0aGF0IGlzIGEgdmFsaWQgc3R5bGUgbmFtZSBmb3IgYW4gZWxlbWVudC4gSWYgbm8gc3VjaCBuYW1lIGlzIGZvdW5kLFxyXG4vLyBpdCByZXR1cm5zIGZhbHNlLiBVc2VmdWwgZm9yIHZlbmRvci1wcmVmaXhlZCBzdHlsZXMgbGlrZSBgdHJhbnNmb3JtYC5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzKSB7XHJcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAocHJvcHNbaV0gaW4gc3R5bGUpIHtcclxuXHRcdFx0cmV0dXJuIHByb3BzW2ldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oZWw6IEhUTUxFbGVtZW50LCBvZmZzZXQ6IFBvaW50LCBzY2FsZT86IE51bWJlcilcclxuLy8gUmVzZXRzIHRoZSAzRCBDU1MgdHJhbnNmb3JtIG9mIGBlbGAgc28gaXQgaXMgdHJhbnNsYXRlZCBieSBgb2Zmc2V0YCBwaXhlbHNcclxuLy8gYW5kIG9wdGlvbmFsbHkgc2NhbGVkIGJ5IGBzY2FsZWAuIERvZXMgbm90IGhhdmUgYW4gZWZmZWN0IGlmIHRoZVxyXG4vLyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCAzRCBDU1MgdHJhbnNmb3Jtcy5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFRyYW5zZm9ybShlbCwgb2Zmc2V0LCBzY2FsZSkge1xyXG5cdHZhciBwb3MgPSBvZmZzZXQgfHwgbmV3IFBvaW50KDAsIDApO1xyXG5cclxuXHRlbC5zdHlsZVtUUkFOU0ZPUk1dID1cclxuXHRcdChCcm93c2VyLmllM2QgP1xyXG5cdFx0XHQndHJhbnNsYXRlKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgpJyA6XHJcblx0XHRcdCd0cmFuc2xhdGUzZCgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4LDApJykgK1xyXG5cdFx0KHNjYWxlID8gJyBzY2FsZSgnICsgc2NhbGUgKyAnKScgOiAnJyk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBzZXRQb3NpdGlvbihlbDogSFRNTEVsZW1lbnQsIHBvc2l0aW9uOiBQb2ludClcclxuLy8gU2V0cyB0aGUgcG9zaXRpb24gb2YgYGVsYCB0byBjb29yZGluYXRlcyBzcGVjaWZpZWQgYnkgYHBvc2l0aW9uYCxcclxuLy8gdXNpbmcgQ1NTIHRyYW5zbGF0ZSBvciB0b3AvbGVmdCBwb3NpdGlvbmluZyBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXJcclxuLy8gKHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IHRvIHBvc2l0aW9uIGl0cyBsYXllcnMpLlxyXG5leHBvcnQgZnVuY3Rpb24gc2V0UG9zaXRpb24oZWwsIHBvaW50KSB7XHJcblxyXG5cdC8qZXNsaW50LWRpc2FibGUgKi9cclxuXHRlbC5fbGVhZmxldF9wb3MgPSBwb2ludDtcclxuXHQvKiBlc2xpbnQtZW5hYmxlICovXHJcblxyXG5cdGlmIChCcm93c2VyLmFueTNkKSB7XHJcblx0XHRzZXRUcmFuc2Zvcm0oZWwsIHBvaW50KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZWwuc3R5bGUubGVmdCA9IHBvaW50LnggKyAncHgnO1xyXG5cdFx0ZWwuc3R5bGUudG9wID0gcG9pbnQueSArICdweCc7XHJcblx0fVxyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWw6IEhUTUxFbGVtZW50KTogUG9pbnRcclxuLy8gUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgYW4gZWxlbWVudCBwcmV2aW91c2x5IHBvc2l0aW9uZWQgd2l0aCBzZXRQb3NpdGlvbi5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsKSB7XHJcblx0Ly8gdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGZvciBlbGVtZW50cyBwcmV2aW91c2x5IHBvc2l0aW9uZWQgdXNpbmcgc2V0UG9zaXRpb24sXHJcblx0Ly8gc28gaXQncyBzYWZlIHRvIGNhY2hlIHRoZSBwb3NpdGlvbiBmb3IgcGVyZm9ybWFuY2VcclxuXHJcblx0cmV0dXJuIGVsLl9sZWFmbGV0X3BvcyB8fCBuZXcgUG9pbnQoMCwgMCk7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlVGV4dFNlbGVjdGlvbigpXHJcbi8vIFByZXZlbnRzIHRoZSB1c2VyIGZyb20gZ2VuZXJhdGluZyBgc2VsZWN0c3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkXHJcbi8vIHdoZW4gdGhlIHVzZXIgZHJhZ3MgdGhlIG1vdXNlIHRocm91Z2ggYSBwYWdlIHdpdGggdGV4dC4gVXNlZCBpbnRlcm5hbGx5XHJcbi8vIGJ5IExlYWZsZXQgdG8gb3ZlcnJpZGUgdGhlIGJlaGF2aW91ciBvZiBhbnkgY2xpY2stYW5kLWRyYWcgaW50ZXJhY3Rpb24gb25cclxuLy8gdGhlIG1hcC4gQWZmZWN0cyBkcmFnIGludGVyYWN0aW9ucyBvbiB0aGUgd2hvbGUgZG9jdW1lbnQuXHJcblxyXG4vLyBAZnVuY3Rpb24gZW5hYmxlVGV4dFNlbGVjdGlvbigpXHJcbi8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbmBdKCNkb211dGlsLWRpc2FibGV0ZXh0c2VsZWN0aW9uKS5cclxuZXhwb3J0IHZhciBkaXNhYmxlVGV4dFNlbGVjdGlvbjtcclxuZXhwb3J0IHZhciBlbmFibGVUZXh0U2VsZWN0aW9uO1xyXG52YXIgX3VzZXJTZWxlY3Q7XHJcbmlmICgnb25zZWxlY3RzdGFydCcgaW4gZG9jdW1lbnQpIHtcclxuXHRkaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbUV2ZW50Lm9uKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdH07XHJcblx0ZW5hYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbUV2ZW50Lm9mZih3aW5kb3csICdzZWxlY3RzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHR9O1xyXG59IGVsc2Uge1xyXG5cdHZhciB1c2VyU2VsZWN0UHJvcGVydHkgPSB0ZXN0UHJvcChcclxuXHRcdFsndXNlclNlbGVjdCcsICdXZWJraXRVc2VyU2VsZWN0JywgJ09Vc2VyU2VsZWN0JywgJ01velVzZXJTZWxlY3QnLCAnbXNVc2VyU2VsZWN0J10pO1xyXG5cclxuXHRkaXNhYmxlVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuXHRcdFx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xyXG5cdFx0XHRfdXNlclNlbGVjdCA9IHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV07XHJcblx0XHRcdHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV0gPSAnbm9uZSc7XHJcblx0XHR9XHJcblx0fTtcclxuXHRlbmFibGVUZXh0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHVzZXJTZWxlY3RQcm9wZXJ0eSkge1xyXG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9IF91c2VyU2VsZWN0O1xyXG5cdFx0XHRfdXNlclNlbGVjdCA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZGlzYWJsZUltYWdlRHJhZygpXHJcbi8vIEFzIFtgTC5Eb21VdGlsLmRpc2FibGVUZXh0U2VsZWN0aW9uYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLCBidXRcclxuLy8gZm9yIGBkcmFnc3RhcnRgIERPTSBldmVudHMsIHVzdWFsbHkgZ2VuZXJhdGVkIHdoZW4gdGhlIHVzZXIgZHJhZ3MgYW4gaW1hZ2UuXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlSW1hZ2VEcmFnKCkge1xyXG5cdERvbUV2ZW50Lm9uKHdpbmRvdywgJ2RyYWdzdGFydCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGVuYWJsZUltYWdlRHJhZygpXHJcbi8vIENhbmNlbHMgdGhlIGVmZmVjdHMgb2YgYSBwcmV2aW91cyBbYEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnYF0oI2RvbXV0aWwtZGlzYWJsZXRleHRzZWxlY3Rpb24pLlxyXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlSW1hZ2VEcmFnKCkge1xyXG5cdERvbUV2ZW50Lm9mZih3aW5kb3csICdkcmFnc3RhcnQnLCBEb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcbn1cclxuXHJcbnZhciBfb3V0bGluZUVsZW1lbnQsIF9vdXRsaW5lU3R5bGU7XHJcbi8vIEBmdW5jdGlvbiBwcmV2ZW50T3V0bGluZShlbDogSFRNTEVsZW1lbnQpXHJcbi8vIE1ha2VzIHRoZSBbb3V0bGluZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL291dGxpbmUpXHJcbi8vIG9mIHRoZSBlbGVtZW50IGBlbGAgaW52aXNpYmxlLiBVc2VkIGludGVybmFsbHkgYnkgTGVhZmxldCB0byBwcmV2ZW50XHJcbi8vIGZvY3VzYWJsZSBlbGVtZW50cyBmcm9tIGRpc3BsYXlpbmcgYW4gb3V0bGluZSB3aGVuIHRoZSB1c2VyIHBlcmZvcm1zIGFcclxuLy8gZHJhZyBpbnRlcmFjdGlvbiBvbiB0aGVtLlxyXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudE91dGxpbmUoZWxlbWVudCkge1xyXG5cdHdoaWxlIChlbGVtZW50LnRhYkluZGV4ID09PSAtMSkge1xyXG5cdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuXHR9XHJcblx0aWYgKCFlbGVtZW50LnN0eWxlKSB7IHJldHVybjsgfVxyXG5cdHJlc3RvcmVPdXRsaW5lKCk7XHJcblx0X291dGxpbmVFbGVtZW50ID0gZWxlbWVudDtcclxuXHRfb3V0bGluZVN0eWxlID0gZWxlbWVudC5zdHlsZS5vdXRsaW5lU3R5bGU7XHJcblx0ZWxlbWVudC5zdHlsZS5vdXRsaW5lU3R5bGUgPSAnbm9uZSc7XHJcblx0RG9tRXZlbnQub24od2luZG93LCAna2V5ZG93bicsIHJlc3RvcmVPdXRsaW5lKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKClcclxuLy8gQ2FuY2VscyB0aGUgZWZmZWN0cyBvZiBhIHByZXZpb3VzIFtgTC5Eb21VdGlsLnByZXZlbnRPdXRsaW5lYF0oKS5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVPdXRsaW5lKCkge1xyXG5cdGlmICghX291dGxpbmVFbGVtZW50KSB7IHJldHVybjsgfVxyXG5cdF9vdXRsaW5lRWxlbWVudC5zdHlsZS5vdXRsaW5lU3R5bGUgPSBfb3V0bGluZVN0eWxlO1xyXG5cdF9vdXRsaW5lRWxlbWVudCA9IHVuZGVmaW5lZDtcclxuXHRfb3V0bGluZVN0eWxlID0gdW5kZWZpbmVkO1xyXG5cdERvbUV2ZW50Lm9mZih3aW5kb3csICdrZXlkb3duJywgcmVzdG9yZU91dGxpbmUpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0U2l6ZWRQYXJlbnROb2RlKGVsOiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcbi8vIEZpbmRzIHRoZSBjbG9zZXN0IHBhcmVudCBub2RlIHdoaWNoIHNpemUgKHdpZHRoIGFuZCBoZWlnaHQpIGlzIG5vdCBudWxsLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2l6ZWRQYXJlbnROb2RlKGVsZW1lbnQpIHtcclxuXHRkbyB7XHJcblx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG5cdH0gd2hpbGUgKCghZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAhZWxlbWVudC5vZmZzZXRIZWlnaHQpICYmIGVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpO1xyXG5cdHJldHVybiBlbGVtZW50O1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2V0U2NhbGUoZWw6IEhUTUxFbGVtZW50KTogT2JqZWN0XHJcbi8vIENvbXB1dGVzIHRoZSBDU1Mgc2NhbGUgY3VycmVudGx5IGFwcGxpZWQgb24gdGhlIGVsZW1lbnQuXHJcbi8vIFJldHVybnMgYW4gb2JqZWN0IHdpdGggYHhgIGFuZCBgeWAgbWVtYmVycyBhcyBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBzY2FsZXMgcmVzcGVjdGl2ZWx5LFxyXG4vLyBhbmQgYGJvdW5kaW5nQ2xpZW50UmVjdGAgYXMgdGhlIHJlc3VsdCBvZiBbYGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0Qm91bmRpbmdDbGllbnRSZWN0KS5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjYWxlKGVsZW1lbnQpIHtcclxuXHR2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIFJlYWQtb25seSBpbiBvbGQgYnJvd3NlcnMuXHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR4OiByZWN0LndpZHRoIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxLFxyXG5cdFx0eTogcmVjdC5oZWlnaHQgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxLFxyXG5cdFx0Ym91bmRpbmdDbGllbnRSZWN0OiByZWN0XHJcblx0fTtcclxufVxyXG4iLCJpbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0IHthZGRQb2ludGVyTGlzdGVuZXIsIHJlbW92ZVBvaW50ZXJMaXN0ZW5lcn0gZnJvbSAnLi9Eb21FdmVudC5Qb2ludGVyJztcclxuaW1wb3J0IHthZGREb3VibGVUYXBMaXN0ZW5lciwgcmVtb3ZlRG91YmxlVGFwTGlzdGVuZXJ9IGZyb20gJy4vRG9tRXZlbnQuRG91YmxlVGFwJztcclxuaW1wb3J0IHtnZXRTY2FsZX0gZnJvbSAnLi9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgRG9tRXZlbnRcclxuICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gd29yayB3aXRoIHRoZSBbRE9NIGV2ZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0V2ZW50KSwgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkuXHJcbiAqL1xyXG5cclxuLy8gSW5zcGlyZWQgYnkgSm9obiBSZXNpZywgRGVhbiBFZHdhcmRzIGFuZCBZVUkgYWRkRXZlbnQgaW1wbGVtZW50YXRpb25zLlxyXG5cclxuLy8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgdHlwZXM6IFN0cmluZywgZm46IEZ1bmN0aW9uLCBjb250ZXh0PzogT2JqZWN0KTogdGhpc1xyXG4vLyBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gKGBmbmApIHRvIGEgcGFydGljdWxhciBET00gZXZlbnQgdHlwZSBvZiB0aGVcclxuLy8gZWxlbWVudCBgZWxgLiBZb3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgY29udGV4dCBvZiB0aGUgbGlzdGVuZXJcclxuLy8gKG9iamVjdCB0aGUgYHRoaXNgIGtleXdvcmQgd2lsbCBwb2ludCB0bykuIFlvdSBjYW4gYWxzbyBwYXNzIHNldmVyYWxcclxuLy8gc3BhY2Utc2VwYXJhdGVkIHR5cGVzIChlLmcuIGAnY2xpY2sgZGJsY2xpY2snYCkuXHJcblxyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZ1bmN0aW9uIG9uKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gQWRkcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5leHBvcnQgZnVuY3Rpb24gb24ob2JqLCB0eXBlcywgZm4sIGNvbnRleHQpIHtcclxuXHJcblx0aWYgKHR5cGVzICYmIHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0YWRkT25lKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0dHlwZXMgPSBVdGlsLnNwbGl0V29yZHModHlwZXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRhZGRPbmUob2JqLCB0eXBlc1tpXSwgZm4sIGNvbnRleHQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbnZhciBldmVudHNLZXkgPSAnX2xlYWZsZXRfZXZlbnRzJztcclxuXHJcbi8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nLCBmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcbi8vIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZ1bmN0aW9uLlxyXG4vLyBOb3RlIHRoYXQgaWYgeW91IHBhc3NlZCBhIGN1c3RvbSBjb250ZXh0IHRvIG9uLCB5b3UgbXVzdCBwYXNzIHRoZSBzYW1lXHJcbi8vIGNvbnRleHQgdG8gYG9mZmAgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCwgZXZlbnRNYXA6IE9iamVjdCwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuLy8gUmVtb3ZlcyBhIHNldCBvZiB0eXBlL2xpc3RlbmVyIHBhaXJzLCBlLmcuIGB7Y2xpY2s6IG9uQ2xpY2ssIG1vdXNlbW92ZTogb25Nb3VzZU1vdmV9YFxyXG5cclxuLy8gQGFsdGVybmF0aXZlXHJcbi8vIEBmdW5jdGlvbiBvZmYoZWw6IEhUTUxFbGVtZW50LCB0eXBlczogU3RyaW5nKTogdGhpc1xyXG4vLyBSZW1vdmVzIGFsbCBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVycyBvZiBnaXZlbiB0eXBlcy5cclxuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZnVuY3Rpb24gb2ZmKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuLy8gUmVtb3ZlcyBhbGwgcHJldmlvdXNseSBhZGRlZCBsaXN0ZW5lcnMgZnJvbSBnaXZlbiBIVE1MRWxlbWVudFxyXG5leHBvcnQgZnVuY3Rpb24gb2ZmKG9iaiwgdHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XHJcblx0XHRiYXRjaFJlbW92ZShvYmopO1xyXG5cdFx0ZGVsZXRlIG9ialtldmVudHNLZXldO1xyXG5cclxuXHR9IGVsc2UgaWYgKHR5cGVzICYmIHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdGZvciAodmFyIHR5cGUgaW4gdHlwZXMpIHtcclxuXHRcdFx0cmVtb3ZlT25lKG9iaiwgdHlwZSwgdHlwZXNbdHlwZV0sIGZuKTtcclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIHtcclxuXHRcdHR5cGVzID0gVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xyXG5cdFx0XHRiYXRjaFJlbW92ZShvYmosIGZ1bmN0aW9uICh0eXBlKSB7XHJcblx0XHRcdFx0cmV0dXJuIFV0aWwuaW5kZXhPZih0eXBlcywgdHlwZSkgIT09IC0xO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHJlbW92ZU9uZShvYmosIHR5cGVzW2ldLCBmbiwgY29udGV4dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBiYXRjaFJlbW92ZShvYmosIGZpbHRlckZuKSB7XHJcblx0Zm9yICh2YXIgaWQgaW4gb2JqW2V2ZW50c0tleV0pIHtcclxuXHRcdHZhciB0eXBlID0gaWQuc3BsaXQoL1xcZC8pWzBdO1xyXG5cdFx0aWYgKCFmaWx0ZXJGbiB8fCBmaWx0ZXJGbih0eXBlKSkge1xyXG5cdFx0XHRyZW1vdmVPbmUob2JqLCB0eXBlLCBudWxsLCBudWxsLCBpZCk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG52YXIgbW91c2VTdWJzdCA9IHtcclxuXHRtb3VzZWVudGVyOiAnbW91c2VvdmVyJyxcclxuXHRtb3VzZWxlYXZlOiAnbW91c2VvdXQnLFxyXG5cdHdoZWVsOiAhKCdvbndoZWVsJyBpbiB3aW5kb3cpICYmICdtb3VzZXdoZWVsJ1xyXG59O1xyXG5cclxuZnVuY3Rpb24gYWRkT25lKG9iaiwgdHlwZSwgZm4sIGNvbnRleHQpIHtcclxuXHR2YXIgaWQgPSB0eXBlICsgVXRpbC5zdGFtcChmbikgKyAoY29udGV4dCA/ICdfJyArIFV0aWwuc3RhbXAoY29udGV4dCkgOiAnJyk7XHJcblxyXG5cdGlmIChvYmpbZXZlbnRzS2V5XSAmJiBvYmpbZXZlbnRzS2V5XVtpZF0pIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0cmV0dXJuIGZuLmNhbGwoY29udGV4dCB8fCBvYmosIGUgfHwgd2luZG93LmV2ZW50KTtcclxuXHR9O1xyXG5cclxuXHR2YXIgb3JpZ2luYWxIYW5kbGVyID0gaGFuZGxlcjtcclxuXHJcblx0aWYgKCFCcm93c2VyLnRvdWNoTmF0aXZlICYmIEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdC8vIE5lZWRzIERvbUV2ZW50LlBvaW50ZXIuanNcclxuXHRcdGhhbmRsZXIgPSBhZGRQb2ludGVyTGlzdGVuZXIob2JqLCB0eXBlLCBoYW5kbGVyKTtcclxuXHJcblx0fSBlbHNlIGlmIChCcm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSkge1xyXG5cdFx0aGFuZGxlciA9IGFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlcik7XHJcblxyXG5cdH0gZWxzZSBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIG9iaikge1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ3RvdWNobW92ZScgfHwgdHlwZSA9PT0gJ3doZWVsJyB8fCAgdHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKG1vdXNlU3Vic3RbdHlwZV0gfHwgdHlwZSwgaGFuZGxlciwgQnJvd3Nlci5wYXNzaXZlRXZlbnRzID8ge3Bhc3NpdmU6IGZhbHNlfSA6IGZhbHNlKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdtb3VzZWVudGVyJyB8fCB0eXBlID09PSAnbW91c2VsZWF2ZScpIHtcclxuXHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xyXG5cdFx0XHRcdGlmIChpc0V4dGVybmFsVGFyZ2V0KG9iaiwgZSkpIHtcclxuXHRcdFx0XHRcdG9yaWdpbmFsSGFuZGxlcihlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKG1vdXNlU3Vic3RbdHlwZV0sIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBvcmlnaW5hbEhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIHtcclxuXHRcdG9iai5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0fVxyXG5cclxuXHRvYmpbZXZlbnRzS2V5XSA9IG9ialtldmVudHNLZXldIHx8IHt9O1xyXG5cdG9ialtldmVudHNLZXldW2lkXSA9IGhhbmRsZXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZU9uZShvYmosIHR5cGUsIGZuLCBjb250ZXh0LCBpZCkge1xyXG5cdGlkID0gaWQgfHwgdHlwZSArIFV0aWwuc3RhbXAoZm4pICsgKGNvbnRleHQgPyAnXycgKyBVdGlsLnN0YW1wKGNvbnRleHQpIDogJycpO1xyXG5cdHZhciBoYW5kbGVyID0gb2JqW2V2ZW50c0tleV0gJiYgb2JqW2V2ZW50c0tleV1baWRdO1xyXG5cclxuXHRpZiAoIWhhbmRsZXIpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0aWYgKCFCcm93c2VyLnRvdWNoTmF0aXZlICYmIEJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdHJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGhhbmRsZXIpO1xyXG5cclxuXHR9IGVsc2UgaWYgKEJyb3dzZXIudG91Y2ggJiYgKHR5cGUgPT09ICdkYmxjbGljaycpKSB7XHJcblx0XHRyZW1vdmVEb3VibGVUYXBMaXN0ZW5lcihvYmosIGhhbmRsZXIpO1xyXG5cclxuXHR9IGVsc2UgaWYgKCdyZW1vdmVFdmVudExpc3RlbmVyJyBpbiBvYmopIHtcclxuXHJcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihtb3VzZVN1YnN0W3R5cGVdIHx8IHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHRcdG9iai5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XHJcblx0fVxyXG5cclxuXHRvYmpbZXZlbnRzS2V5XVtpZF0gPSBudWxsO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2OiBET01FdmVudCk6IHRoaXNcclxuLy8gU3RvcCB0aGUgZ2l2ZW4gZXZlbnQgZnJvbSBwcm9wYWdhdGlvbiB0byBwYXJlbnQgZWxlbWVudHMuIFVzZWQgaW5zaWRlIHRoZSBsaXN0ZW5lciBmdW5jdGlvbnM6XHJcbi8vIGBgYGpzXHJcbi8vIEwuRG9tRXZlbnQub24oZGl2LCAnY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuLy8gXHRMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbihldik7XHJcbi8vIH0pO1xyXG4vLyBgYGBcclxuZXhwb3J0IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihlKSB7XHJcblxyXG5cdGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xyXG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHR9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudCkgeyAgLy8gSW4gY2FzZSBvZiBMZWFmbGV0IGV2ZW50LlxyXG5cdFx0ZS5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkID0gdHJ1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBkaXNhYmxlU2Nyb2xsUHJvcGFnYXRpb24oZWw6IEhUTUxFbGVtZW50KTogdGhpc1xyXG4vLyBBZGRzIGBzdG9wUHJvcGFnYXRpb25gIHRvIHRoZSBlbGVtZW50J3MgYCd3aGVlbCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihlbCkge1xyXG5cdGFkZE9uZShlbCwgJ3doZWVsJywgc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsOiBIVE1MRWxlbWVudCk6IHRoaXNcclxuLy8gQWRkcyBgc3RvcFByb3BhZ2F0aW9uYCB0byB0aGUgZWxlbWVudCdzIGAnY2xpY2snYCwgYCdkYmxjbGljaydgLCBgJ2NvbnRleHRtZW51J2AsXHJcbi8vIGAnbW91c2Vkb3duJ2AgYW5kIGAndG91Y2hzdGFydCdgIGV2ZW50cyAocGx1cyBicm93c2VyIHZhcmlhbnRzKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGVsKSB7XHJcblx0b24oZWwsICdtb3VzZWRvd24gdG91Y2hzdGFydCBkYmxjbGljayBjb250ZXh0bWVudScsIHN0b3BQcm9wYWdhdGlvbik7XHJcblx0ZWxbJ19sZWFmbGV0X2Rpc2FibGVfY2xpY2snXSA9IHRydWU7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgRE9NIEV2ZW50IGBldmAgZnJvbSBoYXBwZW5pbmcgKHN1Y2ggYXNcclxuLy8gZm9sbG93aW5nIGEgbGluayBpbiB0aGUgaHJlZiBvZiB0aGUgYSBlbGVtZW50LCBvciBkb2luZyBhIFBPU1QgcmVxdWVzdFxyXG4vLyB3aXRoIHBhZ2UgcmVsb2FkIHdoZW4gYSBgPGZvcm0+YCBpcyBzdWJtaXR0ZWQpLlxyXG4vLyBVc2UgaXQgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcclxuXHRpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xyXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gc3RvcChldjogRE9NRXZlbnQpOiB0aGlzXHJcbi8vIERvZXMgYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgYXQgdGhlIHNhbWUgdGltZS5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0b3AoZSkge1xyXG5cdHByZXZlbnREZWZhdWx0KGUpO1xyXG5cdHN0b3BQcm9wYWdhdGlvbihlKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldFByb3BhZ2F0aW9uUGF0aChldjogRE9NRXZlbnQpOiBBcnJheVxyXG4vLyBDb21wYXRpYmlsaXR5IHBvbHlmaWxsIGZvciBbYEV2ZW50LmNvbXBvc2VkUGF0aCgpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50L2NvbXBvc2VkUGF0aCkuXHJcbi8vIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgYEhUTUxFbGVtZW50YHMgdGhhdCB0aGUgZ2l2ZW4gRE9NIGV2ZW50XHJcbi8vIHNob3VsZCBwcm9wYWdhdGUgdG8gKGlmIG5vdCBzdG9wcGVkKS5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb3BhZ2F0aW9uUGF0aChldikge1xyXG5cdGlmIChldi5jb21wb3NlZFBhdGgpIHtcclxuXHRcdHJldHVybiBldi5jb21wb3NlZFBhdGgoKTtcclxuXHR9XHJcblxyXG5cdHZhciBwYXRoID0gW107XHJcblx0dmFyIGVsID0gZXYudGFyZ2V0O1xyXG5cclxuXHR3aGlsZSAoZWwpIHtcclxuXHRcdHBhdGgucHVzaChlbCk7XHJcblx0XHRlbCA9IGVsLnBhcmVudE5vZGU7XHJcblx0fVxyXG5cdHJldHVybiBwYXRoO1xyXG59XHJcblxyXG5cclxuLy8gQGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZXY6IERPTUV2ZW50LCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IFBvaW50XHJcbi8vIEdldHMgbm9ybWFsaXplZCBtb3VzZSBwb3NpdGlvbiBmcm9tIGEgRE9NIGV2ZW50IHJlbGF0aXZlIHRvIHRoZVxyXG4vLyBgY29udGFpbmVyYCAoYm9yZGVyIGV4Y2x1ZGVkKSBvciB0byB0aGUgd2hvbGUgcGFnZSBpZiBub3Qgc3BlY2lmaWVkLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihlLCBjb250YWluZXIpIHtcclxuXHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChlLmNsaWVudFgsIGUuY2xpZW50WSk7XHJcblx0fVxyXG5cclxuXHR2YXIgc2NhbGUgPSBnZXRTY2FsZShjb250YWluZXIpLFxyXG5cdCAgICBvZmZzZXQgPSBzY2FsZS5ib3VuZGluZ0NsaWVudFJlY3Q7IC8vIGxlZnQgYW5kIHRvcCAgdmFsdWVzIGFyZSBpbiBwYWdlIHNjYWxlIChsaWtlIHRoZSBldmVudCBjbGllbnRYL1kpXHJcblxyXG5cdHJldHVybiBuZXcgUG9pbnQoXHJcblx0XHQvLyBvZmZzZXQubGVmdC90b3AgdmFsdWVzIGFyZSBpbiBwYWdlIHNjYWxlIChsaWtlIGNsaWVudFgvWSksXHJcblx0XHQvLyB3aGVyZWFzIGNsaWVudExlZnQvVG9wIChib3JkZXIgd2lkdGgpIHZhbHVlcyBhcmUgdGhlIG9yaWdpbmFsIHZhbHVlcyAoYmVmb3JlIENTUyBzY2FsZSBhcHBsaWVzKS5cclxuXHRcdChlLmNsaWVudFggLSBvZmZzZXQubGVmdCkgLyBzY2FsZS54IC0gY29udGFpbmVyLmNsaWVudExlZnQsXHJcblx0XHQoZS5jbGllbnRZIC0gb2Zmc2V0LnRvcCkgLyBzY2FsZS55IC0gY29udGFpbmVyLmNsaWVudFRvcFxyXG5cdCk7XHJcbn1cclxuXHJcblxyXG4vLyAgZXhjZXB0ICwgU2FmYXJpIGFuZFxyXG4vLyBXZSBuZWVkIGRvdWJsZSB0aGUgc2Nyb2xsIHBpeGVscyAoc2VlICM3NDAzIGFuZCAjNDUzOCkgZm9yIGFsbCBCcm93c2Vyc1xyXG4vLyBleGNlcHQgT1NYIChNYWMpIC0+IDN4LCBDaHJvbWUgcnVubmluZyBvbiBMaW51eCAxeFxyXG5cclxudmFyIHdoZWVsUHhGYWN0b3IgPVxyXG5cdChCcm93c2VyLmxpbnV4ICYmIEJyb3dzZXIuY2hyb21lKSA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDpcclxuXHRCcm93c2VyLm1hYyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICogMyA6XHJcblx0d2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAwID8gMiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcclxuLy8gQGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZXY6IERPTUV2ZW50KTogTnVtYmVyXHJcbi8vIEdldHMgbm9ybWFsaXplZCB3aGVlbCBkZWx0YSBmcm9tIGEgd2hlZWwgRE9NIGV2ZW50LCBpbiB2ZXJ0aWNhbFxyXG4vLyBwaXhlbHMgc2Nyb2xsZWQgKG5lZ2F0aXZlIGlmIHNjcm9sbGluZyBkb3duKS5cclxuLy8gRXZlbnRzIGZyb20gcG9pbnRpbmcgZGV2aWNlcyB3aXRob3V0IHByZWNpc2Ugc2Nyb2xsaW5nIGFyZSBtYXBwZWQgdG9cclxuLy8gYSBiZXN0IGd1ZXNzIG9mIDYwIHBpeGVscy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZSkge1xyXG5cdHJldHVybiAoQnJvd3Nlci5lZGdlKSA/IGUud2hlZWxEZWx0YVkgLyAyIDogLy8gRG9uJ3QgdHJ1c3Qgd2luZG93LWdlb21ldHJ5LWJhc2VkIGRlbHRhXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMCkgPyAtZS5kZWx0YVkgLyB3aGVlbFB4RmFjdG9yIDogLy8gUGl4ZWxzXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMSkgPyAtZS5kZWx0YVkgKiAyMCA6IC8vIExpbmVzXHJcblx0ICAgICAgIChlLmRlbHRhWSAmJiBlLmRlbHRhTW9kZSA9PT0gMikgPyAtZS5kZWx0YVkgKiA2MCA6IC8vIFBhZ2VzXHJcblx0ICAgICAgIChlLmRlbHRhWCB8fCBlLmRlbHRhWikgPyAwIDpcdC8vIFNraXAgaG9yaXpvbnRhbC9kZXB0aCB3aGVlbCBldmVudHNcclxuXHQgICAgICAgZS53aGVlbERlbHRhID8gKGUud2hlZWxEZWx0YVkgfHwgZS53aGVlbERlbHRhKSAvIDIgOiAvLyBMZWdhY3kgSUUgcGl4ZWxzXHJcblx0ICAgICAgIChlLmRldGFpbCAmJiBNYXRoLmFicyhlLmRldGFpbCkgPCAzMjc2NSkgPyAtZS5kZXRhaWwgKiAyMCA6IC8vIExlZ2FjeSBNb3ogbGluZXNcclxuXHQgICAgICAgZS5kZXRhaWwgPyBlLmRldGFpbCAvIC0zMjc2NSAqIDYwIDogLy8gTGVnYWN5IE1veiBwYWdlc1xyXG5cdCAgICAgICAwO1xyXG59XHJcblxyXG4vLyBjaGVjayBpZiBlbGVtZW50IHJlYWxseSBsZWZ0L2VudGVyZWQgdGhlIGV2ZW50IHRhcmdldCAoZm9yIG1vdXNlZW50ZXIvbW91c2VsZWF2ZSlcclxuZXhwb3J0IGZ1bmN0aW9uIGlzRXh0ZXJuYWxUYXJnZXQoZWwsIGUpIHtcclxuXHJcblx0dmFyIHJlbGF0ZWQgPSBlLnJlbGF0ZWRUYXJnZXQ7XHJcblxyXG5cdGlmICghcmVsYXRlZCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cclxuXHR0cnkge1xyXG5cdFx0d2hpbGUgKHJlbGF0ZWQgJiYgKHJlbGF0ZWQgIT09IGVsKSkge1xyXG5cdFx0XHRyZWxhdGVkID0gcmVsYXRlZC5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHRyZXR1cm4gKHJlbGF0ZWQgIT09IGVsKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFkZExpc3RlbmVyKOKApik6IHRoaXNcclxuLy8gQWxpYXMgdG8gW2BMLkRvbUV2ZW50Lm9uYF0oI2RvbWV2ZW50LW9uKVxyXG5leHBvcnQge29uIGFzIGFkZExpc3RlbmVyfTtcclxuXHJcbi8vIEBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcijigKYpOiB0aGlzXHJcbi8vIEFsaWFzIHRvIFtgTC5Eb21FdmVudC5vZmZgXSgjZG9tZXZlbnQtb2ZmKVxyXG5leHBvcnQge29mZiBhcyByZW1vdmVMaXN0ZW5lcn07XHJcbiIsImltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcbmltcG9ydCB7RXZlbnRlZH0gZnJvbSAnLi4vY29yZS9FdmVudHMnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XG5cblxuLypcbiAqIEBjbGFzcyBQb3NBbmltYXRpb25cbiAqIEBha2EgTC5Qb3NBbmltYXRpb25cbiAqIEBpbmhlcml0cyBFdmVudGVkXG4gKiBVc2VkIGludGVybmFsbHkgZm9yIHBhbm5pbmcgYW5pbWF0aW9ucywgdXRpbGl6aW5nIENTUzMgVHJhbnNpdGlvbnMgZm9yIG1vZGVybiBicm93c2VycyBhbmQgYSB0aW1lciBmYWxsYmFjayBmb3IgSUU2LTkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiB2YXIgbXlQb3NpdGlvbk1hcmtlciA9IEwubWFya2VyKFs0OC44NjQ3MTYsIDIuMjk0Njk0XSkuYWRkVG8obWFwKTtcbiAqXG4gKiBteVBvc2l0aW9uTWFya2VyLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gKiBcdHZhciBwb3MgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KG15UG9zaXRpb25NYXJrZXIuZ2V0TGF0TG5nKCkpO1xuICogXHRwb3MueSAtPSAyNTtcbiAqIFx0dmFyIGZ4ID0gbmV3IEwuUG9zQW5pbWF0aW9uKCk7XG4gKlxuICogXHRmeC5vbmNlKCdlbmQnLGZ1bmN0aW9uKCkge1xuICogXHRcdHBvcy55ICs9IDI1O1xuICogXHRcdGZ4LnJ1bihteVBvc2l0aW9uTWFya2VyLl9pY29uLCBwb3MsIDAuOCk7XG4gKiBcdH0pO1xuICpcbiAqIFx0ZngucnVuKG15UG9zaXRpb25NYXJrZXIuX2ljb24sIHBvcywgMC4zKTtcbiAqIH0pO1xuICpcbiAqIGBgYFxuICpcbiAqIEBjb25zdHJ1Y3RvciBMLlBvc0FuaW1hdGlvbigpXG4gKiBDcmVhdGVzIGEgYFBvc0FuaW1hdGlvbmAgb2JqZWN0LlxuICpcbiAqL1xuXG5leHBvcnQgdmFyIFBvc0FuaW1hdGlvbiA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBAbWV0aG9kIHJ1bihlbDogSFRNTEVsZW1lbnQsIG5ld1BvczogUG9pbnQsIGR1cmF0aW9uPzogTnVtYmVyLCBlYXNlTGluZWFyaXR5PzogTnVtYmVyKVxuXHQvLyBSdW4gYW4gYW5pbWF0aW9uIG9mIGEgZ2l2ZW4gZWxlbWVudCB0byBhIG5ldyBwb3NpdGlvbiwgb3B0aW9uYWxseSBzZXR0aW5nXG5cdC8vIGR1cmF0aW9uIGluIHNlY29uZHMgKGAwLjI1YCBieSBkZWZhdWx0KSBhbmQgZWFzaW5nIGxpbmVhcml0eSBmYWN0b3IgKDNyZFxuXHQvLyBhcmd1bWVudCBvZiB0aGUgW2N1YmljIGJlemllciBjdXJ2ZV0oaHR0cHM6Ly9jdWJpYy1iZXppZXIuY29tLyMwLDAsLjUsMSksXG5cdC8vIGAwLjVgIGJ5IGRlZmF1bHQpLlxuXHRydW46IGZ1bmN0aW9uIChlbCwgbmV3UG9zLCBkdXJhdGlvbiwgZWFzZUxpbmVhcml0eSkge1xuXHRcdHRoaXMuc3RvcCgpO1xuXG5cdFx0dGhpcy5fZWwgPSBlbDtcblx0XHR0aGlzLl9pblByb2dyZXNzID0gdHJ1ZTtcblx0XHR0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDAuMjU7XG5cdFx0dGhpcy5fZWFzZU91dFBvd2VyID0gMSAvIE1hdGgubWF4KGVhc2VMaW5lYXJpdHkgfHwgMC41LCAwLjIpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSBEb21VdGlsLmdldFBvc2l0aW9uKGVsKTtcblx0XHR0aGlzLl9vZmZzZXQgPSBuZXdQb3Muc3VidHJhY3QodGhpcy5fc3RhcnRQb3MpO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXG5cdFx0Ly8gQGV2ZW50IHN0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydHNcblx0XHR0aGlzLmZpcmUoJ3N0YXJ0Jyk7XG5cblx0XHR0aGlzLl9hbmltYXRlKCk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzdG9wKClcblx0Ly8gU3RvcHMgdGhlIGFuaW1hdGlvbiAoaWYgY3VycmVudGx5IHJ1bm5pbmcpLlxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fc3RlcCh0cnVlKTtcblx0XHR0aGlzLl9jb21wbGV0ZSgpO1xuXHR9LFxuXG5cdF9hbmltYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gYW5pbWF0aW9uIGxvb3Bcblx0XHR0aGlzLl9hbmltSWQgPSBVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fYW5pbWF0ZSwgdGhpcyk7XG5cdFx0dGhpcy5fc3RlcCgpO1xuXHR9LFxuXG5cdF9zdGVwOiBmdW5jdGlvbiAocm91bmQpIHtcblx0XHR2YXIgZWxhcHNlZCA9ICgrbmV3IERhdGUoKSkgLSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xuXG5cdFx0aWYgKGVsYXBzZWQgPCBkdXJhdGlvbikge1xuXHRcdFx0dGhpcy5fcnVuRnJhbWUodGhpcy5fZWFzZU91dChlbGFwc2VkIC8gZHVyYXRpb24pLCByb3VuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3J1bkZyYW1lKDEpO1xuXHRcdFx0dGhpcy5fY29tcGxldGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3J1bkZyYW1lOiBmdW5jdGlvbiAocHJvZ3Jlc3MsIHJvdW5kKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeShwcm9ncmVzcykpO1xuXHRcdGlmIChyb3VuZCkge1xuXHRcdFx0cG9zLl9yb3VuZCgpO1xuXHRcdH1cblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2VsLCBwb3MpO1xuXG5cdFx0Ly8gQGV2ZW50IHN0ZXA6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyB0aGUgYW5pbWF0aW9uLlxuXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xuXHR9LFxuXG5cdF9jb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1JZCk7XG5cblx0XHR0aGlzLl9pblByb2dyZXNzID0gZmFsc2U7XG5cdFx0Ly8gQGV2ZW50IGVuZDogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gZW5kcy5cblx0XHR0aGlzLmZpcmUoJ2VuZCcpO1xuXHR9LFxuXG5cdF9lYXNlT3V0OiBmdW5jdGlvbiAodCkge1xuXHRcdHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIHRoaXMuX2Vhc2VPdXRQb3dlcik7XG5cdH1cbn0pO1xuIiwiaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcclxuaW1wb3J0IHtFUFNHMzg1N30gZnJvbSAnLi4vZ2VvL2Nycy9DUlMuRVBTRzM4NTcnO1xyXG5pbXBvcnQge1BvaW50LCB0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcbmltcG9ydCB7Qm91bmRzLCB0b0JvdW5kc30gZnJvbSAnLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtMYXRMbmcsIHRvTGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0IHtMYXRMbmdCb3VuZHMsIHRvTGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCB7UG9zQW5pbWF0aW9ufSBmcm9tICcuLi9kb20vUG9zQW5pbWF0aW9uJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBNYXBcclxuICogQGFrYSBMLk1hcFxyXG4gKiBAaW5oZXJpdHMgRXZlbnRlZFxyXG4gKlxyXG4gKiBUaGUgY2VudHJhbCBjbGFzcyBvZiB0aGUgQVBJIOKAlCBpdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG1hcCBvbiBhIHBhZ2UgYW5kIG1hbmlwdWxhdGUgaXQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIC8vIGluaXRpYWxpemUgdGhlIG1hcCBvbiB0aGUgXCJtYXBcIiBkaXYgd2l0aCBhIGdpdmVuIGNlbnRlciBhbmQgem9vbVxyXG4gKiB2YXIgbWFwID0gTC5tYXAoJ21hcCcsIHtcclxuICogXHRjZW50ZXI6IFs1MS41MDUsIC0wLjA5XSxcclxuICogXHR6b29tOiAxM1xyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBNYXAgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBzZWN0aW9uIE1hcCBTdGF0ZSBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGNyczogQ1JTID0gTC5DUlMuRVBTRzM4NTdcclxuXHRcdC8vIFRoZSBbQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtXSgjY3JzKSB0byB1c2UuIERvbid0IGNoYW5nZSB0aGlzIGlmIHlvdSdyZSBub3RcclxuXHRcdC8vIHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogRVBTRzM4NTcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBjZW50ZXI6IExhdExuZyA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBnZW9ncmFwaGljIGNlbnRlciBvZiB0aGUgbWFwXHJcblx0XHRjZW50ZXI6IHVuZGVmaW5lZCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpvb206IE51bWJlciA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gSW5pdGlhbCBtYXAgem9vbSBsZXZlbFxyXG5cdFx0em9vbTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbWluWm9vbTogTnVtYmVyID0gKlxyXG5cdFx0Ly8gTWluaW11bSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcblx0XHQvLyBJZiBub3Qgc3BlY2lmaWVkIGFuZCBhdCBsZWFzdCBvbmUgYEdyaWRMYXllcmAgb3IgYFRpbGVMYXllcmAgaXMgaW4gdGhlIG1hcCxcclxuXHRcdC8vIHRoZSBsb3dlc3Qgb2YgdGhlaXIgYG1pblpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcblx0XHRtaW5ab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAqXHJcblx0XHQvLyBNYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cclxuXHRcdC8vIElmIG5vdCBzcGVjaWZpZWQgYW5kIGF0IGxlYXN0IG9uZSBgR3JpZExheWVyYCBvciBgVGlsZUxheWVyYCBpcyBpbiB0aGUgbWFwLFxyXG5cdFx0Ly8gdGhlIGhpZ2hlc3Qgb2YgdGhlaXIgYG1heFpvb21gIG9wdGlvbnMgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcblx0XHRtYXhab29tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBsYXllcnM6IExheWVyW10gPSBbXVxyXG5cdFx0Ly8gQXJyYXkgb2YgbGF5ZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgbWFwIGluaXRpYWxseVxyXG5cdFx0bGF5ZXJzOiBbXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heEJvdW5kczogTGF0TG5nQm91bmRzID0gbnVsbFxyXG5cdFx0Ly8gV2hlbiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSBtYXAgcmVzdHJpY3RzIHRoZSB2aWV3IHRvIHRoZSBnaXZlblxyXG5cdFx0Ly8gZ2VvZ3JhcGhpY2FsIGJvdW5kcywgYm91bmNpbmcgdGhlIHVzZXIgYmFjayBpZiB0aGUgdXNlciB0cmllcyB0byBwYW5cclxuXHRcdC8vIG91dHNpZGUgdGhlIHZpZXcuIFRvIHNldCB0aGUgcmVzdHJpY3Rpb24gZHluYW1pY2FsbHksIHVzZVxyXG5cdFx0Ly8gW2BzZXRNYXhCb3VuZHNgXSgjbWFwLXNldG1heGJvdW5kcykgbWV0aG9kLlxyXG5cdFx0bWF4Qm91bmRzOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByZW5kZXJlcjogUmVuZGVyZXIgPSAqXHJcblx0XHQvLyBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGRyYXdpbmcgdmVjdG9yIGxheWVycyBvbiB0aGUgbWFwLiBgTC5TVkdgXHJcblx0XHQvLyBvciBgTC5DYW52YXNgIGJ5IGRlZmF1bHQgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydC5cclxuXHRcdHJlbmRlcmVyOiB1bmRlZmluZWQsXHJcblxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIEFuaW1hdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIHpvb21BbmltYXRpb246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBtYXAgem9vbSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdHpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tQW5pbWF0aW9uVGhyZXNob2xkOiBOdW1iZXIgPSA0XHJcblx0XHQvLyBXb24ndCBhbmltYXRlIHpvb20gaWYgdGhlIHpvb20gZGlmZmVyZW5jZSBleGNlZWRzIHRoaXMgdmFsdWUuXHJcblx0XHR6b29tQW5pbWF0aW9uVGhyZXNob2xkOiA0LFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZmFkZUFuaW1hdGlvbjogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHRpbGUgZmFkZSBhbmltYXRpb24gaXMgZW5hYmxlZC4gQnkgZGVmYXVsdCBpdCdzIGVuYWJsZWRcclxuXHRcdC8vIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdGZhZGVBbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXJrZXJab29tQW5pbWF0aW9uOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciBtYXJrZXJzIGFuaW1hdGUgdGhlaXIgem9vbSB3aXRoIHRoZSB6b29tIGFuaW1hdGlvbiwgaWYgZGlzYWJsZWRcclxuXHRcdC8vIHRoZXkgd2lsbCBkaXNhcHBlYXIgZm9yIHRoZSBsZW5ndGggb2YgdGhlIGFuaW1hdGlvbi4gQnkgZGVmYXVsdCBpdCdzXHJcblx0XHQvLyBlbmFibGVkIGluIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgQ1NTMyBUcmFuc2l0aW9ucyBleGNlcHQgQW5kcm9pZC5cclxuXHRcdG1hcmtlclpvb21BbmltYXRpb246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0cmFuc2Zvcm0zRExpbWl0OiBOdW1iZXIgPSAyXjIzXHJcblx0XHQvLyBEZWZpbmVzIHRoZSBtYXhpbXVtIHNpemUgb2YgYSBDU1MgdHJhbnNsYXRpb24gdHJhbnNmb3JtLiBUaGUgZGVmYXVsdFxyXG5cdFx0Ly8gdmFsdWUgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIHVubGVzcyBhIHdlYiBicm93c2VyIHBvc2l0aW9ucyBsYXllcnMgaW5cclxuXHRcdC8vIHRoZSB3cm9uZyBwbGFjZSBhZnRlciBkb2luZyBhIGxhcmdlIGBwYW5CeWAuXHJcblx0XHR0cmFuc2Zvcm0zRExpbWl0OiA4Mzg4NjA4LCAvLyBQcmVjaXNpb24gbGltaXQgb2YgYSAzMi1iaXQgZmxvYXRcclxuXHJcblx0XHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIHpvb21TbmFwOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBGb3JjZXMgdGhlIG1hcCdzIHpvb20gbGV2ZWwgdG8gYWx3YXlzIGJlIGEgbXVsdGlwbGUgb2YgdGhpcywgcGFydGljdWxhcmx5XHJcblx0XHQvLyByaWdodCBhZnRlciBhIFtgZml0Qm91bmRzKClgXSgjbWFwLWZpdGJvdW5kcykgb3IgYSBwaW5jaC16b29tLlxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgdGhlIHpvb20gbGV2ZWwgc25hcHMgdG8gdGhlIG5lYXJlc3QgaW50ZWdlcjsgbG93ZXIgdmFsdWVzXHJcblx0XHQvLyAoZS5nLiBgMC41YCBvciBgMC4xYCkgYWxsb3cgZm9yIGdyZWF0ZXIgZ3JhbnVsYXJpdHkuIEEgdmFsdWUgb2YgYDBgXHJcblx0XHQvLyBtZWFucyB0aGUgem9vbSBsZXZlbCB3aWxsIG5vdCBiZSBzbmFwcGVkIGFmdGVyIGBmaXRCb3VuZHNgIG9yIGEgcGluY2gtem9vbS5cclxuXHRcdHpvb21TbmFwOiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbURlbHRhOiBOdW1iZXIgPSAxXHJcblx0XHQvLyBDb250cm9scyBob3cgbXVjaCB0aGUgbWFwJ3Mgem9vbSBsZXZlbCB3aWxsIGNoYW5nZSBhZnRlciBhXHJcblx0XHQvLyBbYHpvb21JbigpYF0oI21hcC16b29taW4pLCBbYHpvb21PdXQoKWBdKCNtYXAtem9vbW91dCksIHByZXNzaW5nIGArYFxyXG5cdFx0Ly8gb3IgYC1gIG9uIHRoZSBrZXlib2FyZCwgb3IgdXNpbmcgdGhlIFt6b29tIGNvbnRyb2xzXSgjY29udHJvbC16b29tKS5cclxuXHRcdC8vIFZhbHVlcyBzbWFsbGVyIHRoYW4gYDFgIChlLmcuIGAwLjVgKSBhbGxvdyBmb3IgZ3JlYXRlciBncmFudWxhcml0eS5cclxuXHRcdHpvb21EZWx0YTogMSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHRyYWNrUmVzaXplOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFwIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBicm93c2VyIHdpbmRvdyByZXNpemUgdG8gdXBkYXRlIGl0c2VsZi5cclxuXHRcdHRyYWNrUmVzaXplOiB0cnVlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7IC8vIChIVE1MRWxlbWVudCBvciBTdHJpbmcsIE9iamVjdClcclxuXHRcdG9wdGlvbnMgPSBVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0Ly8gTWFrZSBzdXJlIHRvIGFzc2lnbiBpbnRlcm5hbCBmbGFncyBhdCB0aGUgYmVnaW5uaW5nLFxyXG5cdFx0Ly8gdG8gYXZvaWQgaW5jb25zaXN0ZW50IHN0YXRlIGluIHNvbWUgZWRnZSBjYXNlcy5cclxuXHRcdHRoaXMuX2hhbmRsZXJzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3pvb21Cb3VuZExheWVycyA9IHt9O1xyXG5cdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuX2luaXRDb250YWluZXIoaWQpO1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cclxuXHRcdC8vIGhhY2sgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzE5ODBcclxuXHRcdHRoaXMuX29uUmVzaXplID0gVXRpbC5iaW5kKHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XHJcblx0XHRcdHRoaXMuc2V0TWF4Qm91bmRzKG9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5fem9vbSA9IHRoaXMuX2xpbWl0Wm9vbShvcHRpb25zLnpvb20pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmNlbnRlciAmJiBvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnNldFZpZXcodG9MYXRMbmcob3B0aW9ucy5jZW50ZXIpLCBvcHRpb25zLnpvb20sIHtyZXNldDogdHJ1ZX0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgb24gYnJvd3NlcnMgd2l0aG91dCBoYXJkd2FyZS1hY2NlbGVyYXRlZCB0cmFuc2l0aW9ucyBvciBvbGQgQW5kcm9pZC9PcGVyYVxyXG5cdFx0dGhpcy5fem9vbUFuaW1hdGVkID0gRG9tVXRpbC5UUkFOU0lUSU9OICYmIEJyb3dzZXIuYW55M2QgJiYgIUJyb3dzZXIubW9iaWxlT3BlcmEgJiZcclxuXHRcdFx0XHR0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbjtcclxuXHJcblx0XHQvLyB6b29tIHRyYW5zaXRpb25zIHJ1biB3aXRoIHRoZSBzYW1lIGR1cmF0aW9uIGZvciBhbGwgbGF5ZXJzLCBzbyBpZiBvbmUgb2YgdHJhbnNpdGlvbmVuZCBldmVudHNcclxuXHRcdC8vIGhhcHBlbnMgYWZ0ZXIgc3RhcnRpbmcgem9vbSBhbmltYXRpb24gKHByb3BhZ2F0aW5nIHRvIHRoZSBtYXAgcGFuZSksIHdlIGtub3cgdGhhdCBpdCBlbmRlZCBnbG9iYWxseVxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHR0aGlzLl9jcmVhdGVBbmltUHJveHkoKTtcclxuXHRcdFx0RG9tRXZlbnQub24odGhpcy5fcHJveHksIERvbVV0aWwuVFJBTlNJVElPTl9FTkQsIHRoaXMuX2NhdGNoVHJhbnNpdGlvbkVuZCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYWRkTGF5ZXJzKHRoaXMub3B0aW9ucy5sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBAc2VjdGlvbiBNZXRob2RzIGZvciBtb2RpZnlpbmcgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VmlldyhjZW50ZXI6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB2aWV3IG9mIHRoZSBtYXAgKGdlb2dyYXBoaWNhbCBjZW50ZXIgYW5kIHpvb20pIHdpdGggdGhlIGdpdmVuXHJcblx0Ly8gYW5pbWF0aW9uIG9wdGlvbnMuXHJcblx0c2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cdFx0Y2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIodG9MYXRMbmcoY2VudGVyKSwgem9vbSwgdGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHR0aGlzLl9zdG9wKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiAhb3B0aW9ucy5yZXNldCAmJiBvcHRpb25zICE9PSB0cnVlKSB7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb20gPSBVdGlsLmV4dGVuZCh7YW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlfSwgb3B0aW9ucy56b29tKTtcclxuXHRcdFx0XHRvcHRpb25zLnBhbiA9IFV0aWwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGUsIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9ufSwgb3B0aW9ucy5wYW4pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB0cnkgYW5pbWF0aW5nIHBhbiBvciB6b29tXHJcblx0XHRcdHZhciBtb3ZlZCA9ICh0aGlzLl96b29tICE9PSB6b29tKSA/XHJcblx0XHRcdFx0dGhpcy5fdHJ5QW5pbWF0ZWRab29tICYmIHRoaXMuX3RyeUFuaW1hdGVkWm9vbShjZW50ZXIsIHpvb20sIG9wdGlvbnMuem9vbSkgOlxyXG5cdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkUGFuKGNlbnRlciwgb3B0aW9ucy5wYW4pO1xyXG5cclxuXHRcdFx0aWYgKG1vdmVkKSB7XHJcblx0XHRcdFx0Ly8gcHJldmVudCByZXNpemUgaGFuZGxlciBjYWxsLCB0aGUgdmlldyB3aWxsIHJlZnJlc2ggYWZ0ZXIgYW5pbWF0aW9uIGFueXdheVxyXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYW5pbWF0aW9uIGRpZG4ndCBzdGFydCwganVzdCByZXNldCB0aGUgbWFwIHZpZXdcclxuXHRcdHRoaXMuX3Jlc2V0VmlldyhjZW50ZXIsIHpvb20sIG9wdGlvbnMucGFuICYmIG9wdGlvbnMucGFuLm5vTW92ZVN0YXJ0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpvb20oem9vbTogTnVtYmVyLCBvcHRpb25zPzogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSB6b29tIG9mIHRoZSBtYXAuXHJcblx0c2V0Wm9vbTogZnVuY3Rpb24gKHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB6b29tO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgem9vbSwge3pvb206IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb21JbihkZWx0YT86IE51bWJlciwgb3B0aW9ucz86IFpvb20gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBJbmNyZWFzZXMgdGhlIHpvb20gb2YgdGhlIG1hcCBieSBgZGVsdGFgIChbYHpvb21EZWx0YWBdKCNtYXAtem9vbWRlbHRhKSBieSBkZWZhdWx0KS5cclxuXHR6b29tSW46IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0ZGVsdGEgPSBkZWx0YSB8fCAoQnJvd3Nlci5hbnkzZCA/IHRoaXMub3B0aW9ucy56b29tRGVsdGEgOiAxKTtcclxuXHRcdHJldHVybiB0aGlzLnNldFpvb20odGhpcy5fem9vbSArIGRlbHRhLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHpvb21PdXQoZGVsdGE/OiBOdW1iZXIsIG9wdGlvbnM/OiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gRGVjcmVhc2VzIHRoZSB6b29tIG9mIHRoZSBtYXAgYnkgYGRlbHRhYCAoW2B6b29tRGVsdGFgXSgjbWFwLXpvb21kZWx0YSkgYnkgZGVmYXVsdCkuXHJcblx0em9vbU91dDogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcblx0XHRkZWx0YSA9IGRlbHRhIHx8IChCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21EZWx0YSA6IDEpO1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tIC0gZGVsdGEsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Wm9vbUFyb3VuZChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyLCBvcHRpb25zOiBab29tIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gWm9vbXMgdGhlIG1hcCB3aGlsZSBrZWVwaW5nIGEgc3BlY2lmaWVkIGdlb2dyYXBoaWNhbCBwb2ludCBvbiB0aGUgbWFwXHJcblx0Ly8gc3RhdGlvbmFyeSAoZS5nLiB1c2VkIGludGVybmFsbHkgZm9yIHNjcm9sbCB6b29tIGFuZCBkb3VibGUtY2xpY2sgem9vbSkuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCBzZXRab29tQXJvdW5kKG9mZnNldDogUG9pbnQsIHpvb206IE51bWJlciwgb3B0aW9uczogWm9vbSBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFpvb21zIHRoZSBtYXAgd2hpbGUga2VlcGluZyBhIHNwZWNpZmllZCBwaXhlbCBvbiB0aGUgbWFwIChyZWxhdGl2ZSB0byB0aGUgdG9wLWxlZnQgY29ybmVyKSBzdGF0aW9uYXJ5LlxyXG5cdHNldFpvb21Bcm91bmQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMiksXHJcblx0XHQgICAgY29udGFpbmVyUG9pbnQgPSBsYXRsbmcgaW5zdGFuY2VvZiBQb2ludCA/IGxhdGxuZyA6IHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmcpLFxyXG5cclxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBjb250YWluZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZikubXVsdGlwbHlCeSgxIC0gMSAvIHNjYWxlKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodmlld0hhbGYuYWRkKGNlbnRlck9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcobmV3Q2VudGVyLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRCb3VuZHNDZW50ZXJab29tOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRib3VuZHMgPSBib3VuZHMuZ2V0Qm91bmRzID8gYm91bmRzLmdldEJvdW5kcygpIDogdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgcGFkZGluZ1RMID0gdG9Qb2ludChvcHRpb25zLnBhZGRpbmdUb3BMZWZ0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nQm90dG9tUmlnaHQgfHwgb3B0aW9ucy5wYWRkaW5nIHx8IFswLCAwXSksXHJcblxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLmdldEJvdW5kc1pvb20oYm91bmRzLCBmYWxzZSwgcGFkZGluZ1RMLmFkZChwYWRkaW5nQlIpKTtcclxuXHJcblx0XHR6b29tID0gKHR5cGVvZiBvcHRpb25zLm1heFpvb20gPT09ICdudW1iZXInKSA/IE1hdGgubWluKG9wdGlvbnMubWF4Wm9vbSwgem9vbSkgOiB6b29tO1xyXG5cclxuXHRcdGlmICh6b29tID09PSBJbmZpbml0eSkge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGNlbnRlcjogYm91bmRzLmdldENlbnRlcigpLFxyXG5cdFx0XHRcdHpvb206IHpvb21cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcGFkZGluZ09mZnNldCA9IHBhZGRpbmdCUi5zdWJ0cmFjdChwYWRkaW5nVEwpLmRpdmlkZUJ5KDIpLFxyXG5cclxuXHRcdCAgICBzd1BvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSksXHJcblx0XHQgICAgbmVQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIGNlbnRlciA9IHRoaXMudW5wcm9qZWN0KHN3UG9pbnQuYWRkKG5lUG9pbnQpLmRpdmlkZUJ5KDIpLmFkZChwYWRkaW5nT2Zmc2V0KSwgem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXHJcblx0XHRcdHpvb206IHpvb21cclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmaXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBjb250YWlucyB0aGUgZ2l2ZW4gZ2VvZ3JhcGhpY2FsIGJvdW5kcyB3aXRoIHRoZVxyXG5cdC8vIG1heGltdW0gem9vbSBsZXZlbCBwb3NzaWJsZS5cclxuXHRmaXRCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHJcblx0XHRib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICghYm91bmRzLmlzVmFsaWQoKSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kcyBhcmUgbm90IHZhbGlkLicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldC5jZW50ZXIsIHRhcmdldC56b29tLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGZpdFdvcmxkKG9wdGlvbnM/OiBmaXRCb3VuZHMgb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBTZXRzIGEgbWFwIHZpZXcgdGhhdCBtb3N0bHkgY29udGFpbnMgdGhlIHdob2xlIHdvcmxkIHdpdGggdGhlIG1heGltdW1cclxuXHQvLyB6b29tIGxldmVsIHBvc3NpYmxlLlxyXG5cdGZpdFdvcmxkOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZml0Qm91bmRzKFtbLTkwLCAtMTgwXSwgWzkwLCAxODBdXSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5UbyhsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IFBhbiBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0byBhIGdpdmVuIGNlbnRlci5cclxuXHRwYW5UbzogZnVuY3Rpb24gKGNlbnRlciwgb3B0aW9ucykgeyAvLyAoTGF0TG5nKVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhjZW50ZXIsIHRoaXMuX3pvb20sIHtwYW46IG9wdGlvbnN9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHBhbkJ5KG9mZnNldDogUG9pbnQsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgYnkgYSBnaXZlbiBudW1iZXIgb2YgcGl4ZWxzIChhbmltYXRlZCkuXHJcblx0cGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQsIG9wdGlvbnMpIHtcclxuXHRcdG9mZnNldCA9IHRvUG9pbnQob2Zmc2V0KS5yb3VuZCgpO1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gSWYgd2UgcGFuIHRvbyBmYXIsIENocm9tZSBnZXRzIGlzc3VlcyB3aXRoIHRpbGVzXHJcblx0XHQvLyBhbmQgbWFrZXMgdGhlbSBkaXNhcHBlYXIgb3IgYXBwZWFyIGluIHRoZSB3cm9uZyBwbGFjZSAoc2xpZ2h0bHkgb2Zmc2V0KSAjMjYwMlxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkge1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy51bnByb2plY3QodGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLmFkZChvZmZzZXQpKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbSA9IG5ldyBQb3NBbmltYXRpb24oKTtcclxuXHJcblx0XHRcdHRoaXMuX3BhbkFuaW0ub24oe1xyXG5cdFx0XHRcdCdzdGVwJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uU3RlcCxcclxuXHRcdFx0XHQnZW5kJzogdGhpcy5fb25QYW5UcmFuc2l0aW9uRW5kXHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGRvbid0IGZpcmUgbW92ZXN0YXJ0IGlmIGFuaW1hdGluZyBpbmVydGlhXHJcblx0XHRpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBhbmltYXRlIHBhbiB1bmxlc3MgYW5pbWF0ZTogZmFsc2Ugc3BlY2lmaWVkXHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlICE9PSBmYWxzZSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XHJcblxyXG5cdFx0XHR2YXIgbmV3UG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkucm91bmQoKTtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5ydW4odGhpcy5fbWFwUGFuZSwgbmV3UG9zLCBvcHRpb25zLmR1cmF0aW9uIHx8IDAuMjUsIG9wdGlvbnMuZWFzZUxpbmVhcml0eSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9yYXdQYW5CeShvZmZzZXQpO1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnKS5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbHlUbyhsYXRsbmc6IExhdExuZywgem9vbT86IE51bWJlciwgb3B0aW9ucz86IFpvb20vcGFuIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgdmlldyBvZiB0aGUgbWFwIChnZW9ncmFwaGljYWwgY2VudGVyIGFuZCB6b29tKSBwZXJmb3JtaW5nIGEgc21vb3RoXHJcblx0Ly8gcGFuLXpvb20gYW5pbWF0aW9uLlxyXG5cdGZseVRvOiBmdW5jdGlvbiAodGFyZ2V0Q2VudGVyLCB0YXJnZXRab29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRpZiAob3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSB8fCAhQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRWaWV3KHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc3RvcCgpO1xyXG5cclxuXHRcdHZhciBmcm9tID0gdGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLFxyXG5cdFx0ICAgIHRvID0gdGhpcy5wcm9qZWN0KHRhcmdldENlbnRlciksXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIHN0YXJ0Wm9vbSA9IHRoaXMuX3pvb207XHJcblxyXG5cdFx0dGFyZ2V0Q2VudGVyID0gdG9MYXRMbmcodGFyZ2V0Q2VudGVyKTtcclxuXHRcdHRhcmdldFpvb20gPSB0YXJnZXRab29tID09PSB1bmRlZmluZWQgPyBzdGFydFpvb20gOiB0YXJnZXRab29tO1xyXG5cclxuXHRcdHZhciB3MCA9IE1hdGgubWF4KHNpemUueCwgc2l6ZS55KSxcclxuXHRcdCAgICB3MSA9IHcwICogdGhpcy5nZXRab29tU2NhbGUoc3RhcnRab29tLCB0YXJnZXRab29tKSxcclxuXHRcdCAgICB1MSA9ICh0by5kaXN0YW5jZVRvKGZyb20pKSB8fCAxLFxyXG5cdFx0ICAgIHJobyA9IDEuNDIsXHJcblx0XHQgICAgcmhvMiA9IHJobyAqIHJobztcclxuXHJcblx0XHRmdW5jdGlvbiByKGkpIHtcclxuXHRcdFx0dmFyIHMxID0gaSA/IC0xIDogMSxcclxuXHRcdFx0ICAgIHMyID0gaSA/IHcxIDogdzAsXHJcblx0XHRcdCAgICB0MSA9IHcxICogdzEgLSB3MCAqIHcwICsgczEgKiByaG8yICogcmhvMiAqIHUxICogdTEsXHJcblx0XHRcdCAgICBiMSA9IDIgKiBzMiAqIHJobzIgKiB1MSxcclxuXHRcdFx0ICAgIGIgPSB0MSAvIGIxLFxyXG5cdFx0XHQgICAgc3EgPSBNYXRoLnNxcnQoYiAqIGIgKyAxKSAtIGI7XHJcblxyXG5cdFx0XHQgICAgLy8gd29ya2Fyb3VuZCBmb3IgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uIGJ1ZyB3aGVuIHNxID0gMCwgbG9nID0gLUluZmluaXRlLFxyXG5cdFx0XHQgICAgLy8gdGh1cyB0cmlnZ2VyaW5nIGFuIGluZmluaXRlIGxvb3AgaW4gZmx5VG9cclxuXHRcdFx0ICAgIHZhciBsb2cgPSBzcSA8IDAuMDAwMDAwMDAxID8gLTE4IDogTWF0aC5sb2coc3EpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGxvZztcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzaW5oKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSAtIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcblx0XHRmdW5jdGlvbiBjb3NoKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSArIE1hdGguZXhwKC1uKSkgLyAyOyB9XHJcblx0XHRmdW5jdGlvbiB0YW5oKG4pIHsgcmV0dXJuIHNpbmgobikgLyBjb3NoKG4pOyB9XHJcblxyXG5cdFx0dmFyIHIwID0gcigwKTtcclxuXHJcblx0XHRmdW5jdGlvbiB3KHMpIHsgcmV0dXJuIHcwICogKGNvc2gocjApIC8gY29zaChyMCArIHJobyAqIHMpKTsgfVxyXG5cdFx0ZnVuY3Rpb24gdShzKSB7IHJldHVybiB3MCAqIChjb3NoKHIwKSAqIHRhbmgocjAgKyByaG8gKiBzKSAtIHNpbmgocjApKSAvIHJobzI7IH1cclxuXHJcblx0XHRmdW5jdGlvbiBlYXNlT3V0KHQpIHsgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgMS41KTsgfVxyXG5cclxuXHRcdHZhciBzdGFydCA9IERhdGUubm93KCksXHJcblx0XHQgICAgUyA9IChyKDEpIC0gcjApIC8gcmhvLFxyXG5cdFx0ICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiA/IDEwMDAgKiBvcHRpb25zLmR1cmF0aW9uIDogMTAwMCAqIFMgKiAwLjg7XHJcblxyXG5cdFx0ZnVuY3Rpb24gZnJhbWUoKSB7XHJcblx0XHRcdHZhciB0ID0gKERhdGUubm93KCkgLSBzdGFydCkgLyBkdXJhdGlvbixcclxuXHRcdFx0ICAgIHMgPSBlYXNlT3V0KHQpICogUztcclxuXHJcblx0XHRcdGlmICh0IDw9IDEpIHtcclxuXHRcdFx0XHR0aGlzLl9mbHlUb0ZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKGZyYW1lLCB0aGlzKTtcclxuXHJcblx0XHRcdFx0dGhpcy5fbW92ZShcclxuXHRcdFx0XHRcdHRoaXMudW5wcm9qZWN0KGZyb20uYWRkKHRvLnN1YnRyYWN0KGZyb20pLm11bHRpcGx5QnkodShzKSAvIHUxKSksIHN0YXJ0Wm9vbSksXHJcblx0XHRcdFx0XHR0aGlzLmdldFNjYWxlWm9vbSh3MCAvIHcocyksIHN0YXJ0Wm9vbSksXHJcblx0XHRcdFx0XHR7Zmx5VG86IHRydWV9KTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpc1xyXG5cdFx0XHRcdFx0Ll9tb3ZlKHRhcmdldENlbnRlciwgdGFyZ2V0Wm9vbSlcclxuXHRcdFx0XHRcdC5fbW92ZUVuZCh0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX21vdmVTdGFydCh0cnVlLCBvcHRpb25zLm5vTW92ZVN0YXJ0KTtcclxuXHJcblx0XHRmcmFtZS5jYWxsKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBmbHlUb0JvdW5kcyhib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IGZpdEJvdW5kcyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHZpZXcgb2YgdGhlIG1hcCB3aXRoIGEgc21vb3RoIGFuaW1hdGlvbiBsaWtlIFtgZmx5VG9gXSgjbWFwLWZseXRvKSxcclxuXHQvLyBidXQgdGFrZXMgYSBib3VuZHMgcGFyYW1ldGVyIGxpa2UgW2BmaXRCb3VuZHNgXSgjbWFwLWZpdGJvdW5kcykuXHJcblx0Zmx5VG9Cb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKGJvdW5kcywgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdGhpcy5mbHlUbyh0YXJnZXQuY2VudGVyLCB0YXJnZXQuem9vbSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRNYXhCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMpOiB0aGlzXHJcblx0Ly8gUmVzdHJpY3RzIHRoZSBtYXAgdmlldyB0byB0aGUgZ2l2ZW4gYm91bmRzIChzZWUgdGhlIFttYXhCb3VuZHNdKCNtYXAtbWF4Ym91bmRzKSBvcHRpb24pLlxyXG5cdHNldE1heEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRpZiAodGhpcy5saXN0ZW5zKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKSkge1xyXG5cdFx0XHR0aGlzLm9mZignbW92ZWVuZCcsIHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFib3VuZHMuaXNWYWxpZCgpKSB7XHJcblx0XHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBudWxsO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Qm91bmRzID0gYm91bmRzO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0TWluWm9vbSh6b29tOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgbG93ZXIgbGltaXQgZm9yIHRoZSBhdmFpbGFibGUgem9vbSBsZXZlbHMgKHNlZSB0aGUgW21pblpvb21dKCNtYXAtbWluem9vbSkgb3B0aW9uKS5cclxuXHRzZXRNaW5ab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG9sZFpvb20gPSB0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuXHRcdHRoaXMub3B0aW9ucy5taW5ab29tID0gem9vbTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmIG9sZFpvb20gIT09IHpvb20pIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5nZXRab29tKCkgPCB0aGlzLm9wdGlvbnMubWluWm9vbSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNldFpvb20oem9vbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE1heFpvb20oem9vbTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIHVwcGVyIGxpbWl0IGZvciB0aGUgYXZhaWxhYmxlIHpvb20gbGV2ZWxzIChzZWUgdGhlIFttYXhab29tXSgjbWFwLW1heHpvb20pIG9wdGlvbikuXHJcblx0c2V0TWF4Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBvbGRab29tID0gdGhpcy5vcHRpb25zLm1heFpvb207XHJcblx0XHR0aGlzLm9wdGlvbnMubWF4Wm9vbSA9IHpvb207XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCAmJiBvbGRab29tICE9PSB6b29tKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnem9vbWxldmVsc2NoYW5nZScpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuZ2V0Wm9vbSgpID4gdGhpcy5vcHRpb25zLm1heFpvb20pIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHpvb20pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBwYW5JbnNpZGVCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBQYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBQYW5zIHRoZSBtYXAgdG8gdGhlIGNsb3Nlc3QgdmlldyB0aGF0IHdvdWxkIGxpZSBpbnNpZGUgdGhlIGdpdmVuIGJvdW5kcyAoaWYgaXQncyBub3QgYWxyZWFkeSksIGNvbnRyb2xsaW5nIHRoZSBhbmltYXRpb24gdXNpbmcgdGhlIG9wdGlvbnMgc3BlY2lmaWMsIGlmIGFueS5cclxuXHRwYW5JbnNpZGVCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcblx0XHR2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcihjZW50ZXIsIHRoaXMuX3pvb20sIHRvTGF0TG5nQm91bmRzKGJvdW5kcykpO1xyXG5cclxuXHRcdGlmICghY2VudGVyLmVxdWFscyhuZXdDZW50ZXIpKSB7XHJcblx0XHRcdHRoaXMucGFuVG8obmV3Q2VudGVyLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcGFuSW5zaWRlKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogcGFkZGluZyBvcHRpb25zKTogdGhpc1xyXG5cdC8vIFBhbnMgdGhlIG1hcCB0aGUgbWluaW11bSBhbW91bnQgdG8gbWFrZSB0aGUgYGxhdGxuZ2AgdmlzaWJsZS4gVXNlXHJcblx0Ly8gcGFkZGluZyBvcHRpb25zIHRvIGZpdCB0aGUgZGlzcGxheSB0byBtb3JlIHJlc3RyaWN0ZWQgYm91bmRzLlxyXG5cdC8vIElmIGBsYXRsbmdgIGlzIGFscmVhZHkgd2l0aGluIHRoZSAob3B0aW9uYWxseSBwYWRkZWQpIGRpc3BsYXkgYm91bmRzLFxyXG5cdC8vIHRoZSBtYXAgd2lsbCBub3QgYmUgcGFubmVkLlxyXG5cdHBhbkluc2lkZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdUTCA9IHRvUG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSB0b1BvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cdFx0ICAgIHBpeGVsQ2VudGVyID0gdGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLFxyXG5cdFx0ICAgIHBpeGVsUG9pbnQgPSB0aGlzLnByb2plY3QobGF0bG5nKSxcclxuXHRcdCAgICBwaXhlbEJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBwYWRkZWRCb3VuZHMgPSB0b0JvdW5kcyhbcGl4ZWxCb3VuZHMubWluLmFkZChwYWRkaW5nVEwpLCBwaXhlbEJvdW5kcy5tYXguc3VidHJhY3QocGFkZGluZ0JSKV0pLFxyXG5cdFx0ICAgIHBhZGRlZFNpemUgPSBwYWRkZWRCb3VuZHMuZ2V0U2l6ZSgpO1xyXG5cclxuXHRcdGlmICghcGFkZGVkQm91bmRzLmNvbnRhaW5zKHBpeGVsUG9pbnQpKSB7XHJcblx0XHRcdHRoaXMuX2VuZm9yY2luZ0JvdW5kcyA9IHRydWU7XHJcblx0XHRcdHZhciBjZW50ZXJPZmZzZXQgPSBwaXhlbFBvaW50LnN1YnRyYWN0KHBhZGRlZEJvdW5kcy5nZXRDZW50ZXIoKSk7XHJcblx0XHRcdHZhciBvZmZzZXQgPSBwYWRkZWRCb3VuZHMuZXh0ZW5kKHBpeGVsUG9pbnQpLmdldFNpemUoKS5zdWJ0cmFjdChwYWRkZWRTaXplKTtcclxuXHRcdFx0cGl4ZWxDZW50ZXIueCArPSBjZW50ZXJPZmZzZXQueCA8IDAgPyAtb2Zmc2V0LnggOiBvZmZzZXQueDtcclxuXHRcdFx0cGl4ZWxDZW50ZXIueSArPSBjZW50ZXJPZmZzZXQueSA8IDAgPyAtb2Zmc2V0LnkgOiBvZmZzZXQueTtcclxuXHRcdFx0dGhpcy5wYW5Ubyh0aGlzLnVucHJvamVjdChwaXhlbENlbnRlciksIG9wdGlvbnMpO1xyXG5cdFx0XHR0aGlzLl9lbmZvcmNpbmdCb3VuZHMgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52YWxpZGF0ZVNpemUob3B0aW9uczogWm9vbS9wYW4gb3B0aW9ucyk6IHRoaXNcclxuXHQvLyBDaGVja3MgaWYgdGhlIG1hcCBjb250YWluZXIgc2l6ZSBjaGFuZ2VkIGFuZCB1cGRhdGVzIHRoZSBtYXAgaWYgc28g4oCUXHJcblx0Ly8gY2FsbCBpdCBhZnRlciB5b3UndmUgY2hhbmdlZCB0aGUgbWFwIHNpemUgZHluYW1pY2FsbHksIGFsc28gYW5pbWF0aW5nXHJcblx0Ly8gcGFuIGJ5IGRlZmF1bHQuIElmIGBvcHRpb25zLnBhbmAgaXMgYGZhbHNlYCwgcGFubmluZyB3aWxsIG5vdCBvY2N1ci5cclxuXHQvLyBJZiBgb3B0aW9ucy5kZWJvdW5jZU1vdmVlbmRgIGlzIGB0cnVlYCwgaXQgd2lsbCBkZWxheSBgbW92ZWVuZGAgZXZlbnQgc29cclxuXHQvLyB0aGF0IGl0IGRvZXNuJ3QgaGFwcGVuIG9mdGVuIGV2ZW4gaWYgdGhlIG1ldGhvZCBpcyBjYWxsZWQgbWFueVxyXG5cdC8vIHRpbWVzIGluIGEgcm93LlxyXG5cclxuXHQvLyBAYWx0ZXJuYXRpdmVcclxuXHQvLyBAbWV0aG9kIGludmFsaWRhdGVTaXplKGFuaW1hdGU6IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gQ2hlY2tzIGlmIHRoZSBtYXAgY29udGFpbmVyIHNpemUgY2hhbmdlZCBhbmQgdXBkYXRlcyB0aGUgbWFwIGlmIHNvIOKAlFxyXG5cdC8vIGNhbGwgaXQgYWZ0ZXIgeW91J3ZlIGNoYW5nZWQgdGhlIG1hcCBzaXplIGR5bmFtaWNhbGx5LCBhbHNvIGFuaW1hdGluZ1xyXG5cdC8vIHBhbiBieSBkZWZhdWx0LlxyXG5cdGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0aWYgKCF0aGlzLl9sb2FkZWQpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRvcHRpb25zID0gVXRpbC5leHRlbmQoe1xyXG5cdFx0XHRhbmltYXRlOiBmYWxzZSxcclxuXHRcdFx0cGFuOiB0cnVlXHJcblx0XHR9LCBvcHRpb25zID09PSB0cnVlID8ge2FuaW1hdGU6IHRydWV9IDogb3B0aW9ucyk7XHJcblxyXG5cdFx0dmFyIG9sZFNpemUgPSB0aGlzLmdldFNpemUoKTtcclxuXHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX2xhc3RDZW50ZXIgPSBudWxsO1xyXG5cclxuXHRcdHZhciBuZXdTaXplID0gdGhpcy5nZXRTaXplKCksXHJcblx0XHQgICAgb2xkQ2VudGVyID0gb2xkU2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG5ld0NlbnRlciA9IG5ld1NpemUuZGl2aWRlQnkoMikucm91bmQoKSxcclxuXHRcdCAgICBvZmZzZXQgPSBvbGRDZW50ZXIuc3VidHJhY3QobmV3Q2VudGVyKTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgJiYgb3B0aW9ucy5wYW4pIHtcclxuXHRcdFx0dGhpcy5wYW5CeShvZmZzZXQpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChvcHRpb25zLnBhbikge1xyXG5cdFx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuZGVib3VuY2VNb3ZlZW5kKSB7XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3NpemVUaW1lcik7XHJcblx0XHRcdFx0dGhpcy5fc2l6ZVRpbWVyID0gc2V0VGltZW91dChVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbW92ZWVuZCcpLCAyMDApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb24gTWFwIHN0YXRlIGNoYW5nZSBldmVudHNcclxuXHRcdC8vIEBldmVudCByZXNpemU6IFJlc2l6ZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXAgaXMgcmVzaXplZC5cclxuXHRcdHJldHVybiB0aGlzLmZpcmUoJ3Jlc2l6ZScsIHtcclxuXHRcdFx0b2xkU2l6ZTogb2xkU2l6ZSxcclxuXHRcdFx0bmV3U2l6ZTogbmV3U2l6ZVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgbW9kaWZ5aW5nIG1hcCBzdGF0ZVxyXG5cdC8vIEBtZXRob2Qgc3RvcCgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgdGhlIGN1cnJlbnRseSBydW5uaW5nIGBwYW5Ub2Agb3IgYGZseVRvYCBhbmltYXRpb24sIGlmIGFueS5cclxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnNldFpvb20odGhpcy5fbGltaXRab29tKHRoaXMuX3pvb20pKTtcclxuXHRcdGlmICghdGhpcy5vcHRpb25zLnpvb21TbmFwKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgndmlld3Jlc2V0Jyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc3RvcCgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIEdlb2xvY2F0aW9uIG1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGxvY2F0ZShvcHRpb25zPzogTG9jYXRlIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gVHJpZXMgdG8gbG9jYXRlIHRoZSB1c2VyIHVzaW5nIHRoZSBHZW9sb2NhdGlvbiBBUEksIGZpcmluZyBhIFtgbG9jYXRpb25mb3VuZGBdKCNtYXAtbG9jYXRpb25mb3VuZClcclxuXHQvLyBldmVudCB3aXRoIGxvY2F0aW9uIGRhdGEgb24gc3VjY2VzcyBvciBhIFtgbG9jYXRpb25lcnJvcmBdKCNtYXAtbG9jYXRpb25lcnJvcikgZXZlbnQgb24gZmFpbHVyZSxcclxuXHQvLyBhbmQgb3B0aW9uYWxseSBzZXRzIHRoZSBtYXAgdmlldyB0byB0aGUgdXNlcidzIGxvY2F0aW9uIHdpdGggcmVzcGVjdCB0b1xyXG5cdC8vIGRldGVjdGlvbiBhY2N1cmFjeSAob3IgdG8gdGhlIHdvcmxkIHZpZXcgaWYgZ2VvbG9jYXRpb24gZmFpbGVkKS5cclxuXHQvLyBOb3RlIHRoYXQsIGlmIHlvdXIgcGFnZSBkb2Vzbid0IHVzZSBIVFRQUywgdGhpcyBtZXRob2Qgd2lsbCBmYWlsIGluXHJcblx0Ly8gbW9kZXJuIGJyb3dzZXJzIChbQ2hyb21lIDUwIGFuZCBuZXdlcl0oaHR0cHM6Ly9zaXRlcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2Rldi9Ib21lL2Nocm9taXVtLXNlY3VyaXR5L2RlcHJlY2F0aW5nLXBvd2VyZnVsLWZlYXR1cmVzLW9uLWluc2VjdXJlLW9yaWdpbnMpKVxyXG5cdC8vIFNlZSBgTG9jYXRlIG9wdGlvbnNgIGZvciBtb3JlIGRldGFpbHMuXHJcblx0bG9jYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSB0aGlzLl9sb2NhdGVPcHRpb25zID0gVXRpbC5leHRlbmQoe1xyXG5cdFx0XHR0aW1lb3V0OiAxMDAwMCxcclxuXHRcdFx0d2F0Y2g6IGZhbHNlXHJcblx0XHRcdC8vIHNldFZpZXc6IGZhbHNlXHJcblx0XHRcdC8vIG1heFpvb206IDxOdW1iZXI+XHJcblx0XHRcdC8vIG1heGltdW1BZ2U6IDBcclxuXHRcdFx0Ly8gZW5hYmxlSGlnaEFjY3VyYWN5OiBmYWxzZVxyXG5cdFx0fSwgb3B0aW9ucyk7XHJcblxyXG5cdFx0aWYgKCEoJ2dlb2xvY2F0aW9uJyBpbiBuYXZpZ2F0b3IpKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3Ioe1xyXG5cdFx0XHRcdGNvZGU6IDAsXHJcblx0XHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIG5vdCBzdXBwb3J0ZWQuJ1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9uUmVzcG9uc2UgPSBVdGlsLmJpbmQodGhpcy5faGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSwgdGhpcyksXHJcblx0XHQgICAgb25FcnJvciA9IFV0aWwuYmluZCh0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yLCB0aGlzKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy53YXRjaCkge1xyXG5cdFx0XHR0aGlzLl9sb2NhdGlvbldhdGNoSWQgPVxyXG5cdFx0XHQgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihvblJlc3BvbnNlLCBvbkVycm9yLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc3RvcExvY2F0ZSgpOiB0aGlzXHJcblx0Ly8gU3RvcHMgd2F0Y2hpbmcgbG9jYXRpb24gcHJldmlvdXNseSBpbml0aWF0ZWQgYnkgYG1hcC5sb2NhdGUoe3dhdGNoOiB0cnVlfSlgXHJcblx0Ly8gYW5kIGFib3J0cyByZXNldHRpbmcgdGhlIG1hcCB2aWV3IGlmIG1hcC5sb2NhdGUgd2FzIGNhbGxlZCB3aXRoXHJcblx0Ly8gYHtzZXRWaWV3OiB0cnVlfWAuXHJcblx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbiAmJiBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCkge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcblx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuXHRcdCAgICAgICAgICAgIChjID09PSAxID8gJ3Blcm1pc3Npb24gZGVuaWVkJyA6XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXRXb3JsZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIExvY2F0aW9uIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGxvY2F0aW9uZXJyb3I6IEVycm9yRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gZ2VvbG9jYXRpb24gKHVzaW5nIHRoZSBbYGxvY2F0ZWBdKCNtYXAtbG9jYXRlKSBtZXRob2QpIGZhaWxlZC5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuXHRcdFx0Y29kZTogYyxcclxuXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBsYXQgPSBwb3MuY29vcmRzLmxhdGl0dWRlLFxyXG5cdFx0ICAgIGxuZyA9IHBvcy5jb29yZHMubG9uZ2l0dWRlLFxyXG5cdFx0ICAgIGxhdGxuZyA9IG5ldyBMYXRMbmcobGF0LCBsbmcpLFxyXG5cdFx0ICAgIGJvdW5kcyA9IGxhdGxuZy50b0JvdW5kcyhwb3MuY29vcmRzLmFjY3VyYWN5ICogMiksXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuc2V0Vmlldykge1xyXG5cdFx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMpO1xyXG5cdFx0XHR0aGlzLnNldFZpZXcobGF0bG5nLCBvcHRpb25zLm1heFpvb20gPyBNYXRoLm1pbih6b29tLCBvcHRpb25zLm1heFpvb20pIDogem9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdGxhdGxuZzogbGF0bG5nLFxyXG5cdFx0XHRib3VuZHM6IGJvdW5kcyxcclxuXHRcdFx0dGltZXN0YW1wOiBwb3MudGltZXN0YW1wXHJcblx0XHR9O1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gcG9zLmNvb3Jkcykge1xyXG5cdFx0XHRpZiAodHlwZW9mIHBvcy5jb29yZHNbaV0gPT09ICdudW1iZXInKSB7XHJcblx0XHRcdFx0ZGF0YVtpXSA9IHBvcy5jb29yZHNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBAZXZlbnQgbG9jYXRpb25mb3VuZDogTG9jYXRpb25FdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBnZW9sb2NhdGlvbiAodXNpbmcgdGhlIFtgbG9jYXRlYF0oI21hcC1sb2NhdGUpIG1ldGhvZClcclxuXHRcdC8vIHdlbnQgc3VjY2Vzc2Z1bGx5LlxyXG5cdFx0dGhpcy5maXJlKCdsb2NhdGlvbmZvdW5kJywgZGF0YSk7XHJcblx0fSxcclxuXHJcblx0Ly8gVE9ETyBBcHByb3ByaWF0ZSBkb2NzIHNlY3Rpb24/XHJcblx0Ly8gQHNlY3Rpb24gT3RoZXIgTWV0aG9kc1xyXG5cdC8vIEBtZXRob2QgYWRkSGFuZGxlcihuYW1lOiBTdHJpbmcsIEhhbmRsZXJDbGFzczogRnVuY3Rpb24pOiB0aGlzXHJcblx0Ly8gQWRkcyBhIG5ldyBgSGFuZGxlcmAgdG8gdGhlIG1hcCwgZ2l2ZW4gaXRzIG5hbWUgYW5kIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG5cdGFkZEhhbmRsZXI6IGZ1bmN0aW9uIChuYW1lLCBIYW5kbGVyQ2xhc3MpIHtcclxuXHRcdGlmICghSGFuZGxlckNsYXNzKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSB0aGlzW25hbWVdID0gbmV3IEhhbmRsZXJDbGFzcyh0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuXHRcdFx0aGFuZGxlci5lbmFibGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlbW92ZSgpOiB0aGlzXHJcblx0Ly8gRGVzdHJveXMgdGhlIG1hcCBhbmQgY2xlYXJzIGFsbCByZWxhdGVkIGV2ZW50IGxpc3RlbmVycy5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKHRydWUpO1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpIHsgdGhpcy5vZmYoJ21vdmVlbmQnLCB0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpOyB9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcklkICE9PSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGJlaW5nIHJldXNlZCBieSBhbm90aGVyIGluc3RhbmNlJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gdGhyb3dzIGVycm9yIGluIElFNi04XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQ7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb250YWluZXJJZDtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Lyplc2xpbnQtZGlzYWJsZSAqL1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdC8qIGVzbGludC1lbmFibGUgKi9cclxuXHRcdFx0dGhpcy5fY29udGFpbmVySWQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHRoaXMuc3RvcExvY2F0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3N0b3AoKTtcclxuXHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9tYXBQYW5lKTtcclxuXHJcblx0XHRpZiAodGhpcy5fY2xlYXJDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2NsZWFyQ29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpIHtcclxuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fcmVzaXplUmVxdWVzdCk7XHJcblx0XHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NsZWFySGFuZGxlcnMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCB1bmxvYWQ6IEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBkZXN0cm95ZWQgd2l0aCBbcmVtb3ZlXSgjbWFwLXJlbW92ZSkgbWV0aG9kLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ3VubG9hZCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpO1xyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ucmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fcGFuZXMpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fcGFuZXNbaV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5fcGFuZXMgPSBbXTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9tYXBQYW5lO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX3JlbmRlcmVyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHQvLyBAbWV0aG9kIGNyZWF0ZVBhbmUobmFtZTogU3RyaW5nLCBjb250YWluZXI/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ3JlYXRlcyBhIG5ldyBbbWFwIHBhbmVdKCNtYXAtcGFuZSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHksXHJcblx0Ly8gdGhlbiByZXR1cm5zIGl0LiBUaGUgcGFuZSBpcyBjcmVhdGVkIGFzIGEgY2hpbGQgb2YgYGNvbnRhaW5lcmAsIG9yXHJcblx0Ly8gYXMgYSBjaGlsZCBvZiB0aGUgbWFpbiBtYXAgcGFuZSBpZiBub3Qgc2V0LlxyXG5cdGNyZWF0ZVBhbmU6IGZ1bmN0aW9uIChuYW1lLCBjb250YWluZXIpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1wYW5lJyArIChuYW1lID8gJyBsZWFmbGV0LScgKyBuYW1lLnJlcGxhY2UoJ1BhbmUnLCAnJykgKyAnLXBhbmUnIDogJycpLFxyXG5cdFx0ICAgIHBhbmUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIgfHwgdGhpcy5fbWFwUGFuZSk7XHJcblxyXG5cdFx0aWYgKG5hbWUpIHtcclxuXHRcdFx0dGhpcy5fcGFuZXNbbmFtZV0gPSBwYW5lO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHBhbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gTWV0aG9kcyBmb3IgR2V0dGluZyBNYXAgU3RhdGVcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDZW50ZXIoKTogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgZ2VvZ3JhcGhpY2FsIGNlbnRlciBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGFzdENlbnRlciAmJiAhdGhpcy5fbW92ZWQoKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fbGFzdENlbnRlci5jbG9uZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX2dldENlbnRlckxheWVyUG9pbnQoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBvZiB0aGUgbWFwIHZpZXdcclxuXHRnZXRab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fem9vbTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgYm91bmRzIHZpc2libGUgaW4gdGhlIGN1cnJlbnQgbWFwIHZpZXdcclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgc3cgPSB0aGlzLnVucHJvamVjdChib3VuZHMuZ2V0Qm90dG9tTGVmdCgpKSxcclxuXHRcdCAgICBuZSA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRUb3BSaWdodCgpKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhzdywgbmUpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TWluWm9vbSgpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoaWYgc2V0IGluIHRoZSBgbWluWm9vbWAgb3B0aW9uIG9mIHRoZSBtYXAgb3Igb2YgYW55IGxheWVycyksIG9yIGAwYCBieSBkZWZhdWx0LlxyXG5cdGdldE1pblpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fbGF5ZXJzTWluWm9vbSB8fCAwIDogdGhpcy5vcHRpb25zLm1pblpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRNYXhab29tKCk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwIChpZiBzZXQgaW4gdGhlIGBtYXhab29tYCBvcHRpb24gb2YgdGhlIG1hcCBvciBvZiBhbnkgbGF5ZXJzKS5cclxuXHRnZXRNYXhab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdCh0aGlzLl9sYXllcnNNYXhab29tID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHRoaXMuX2xheWVyc01heFpvb20pIDpcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heFpvb207XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRCb3VuZHNab29tKGJvdW5kczogTGF0TG5nQm91bmRzLCBpbnNpZGU/OiBCb29sZWFuLCBwYWRkaW5nPzogUG9pbnQpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGdpdmVuIGJvdW5kcyBmaXQgdG8gdGhlIG1hcFxyXG5cdC8vIHZpZXcgaW4gaXRzIGVudGlyZXR5LiBJZiBgaW5zaWRlYCAob3B0aW9uYWwpIGlzIHNldCB0byBgdHJ1ZWAsIHRoZSBtZXRob2RcclxuXHQvLyBpbnN0ZWFkIHJldHVybnMgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbWFwIHZpZXcgZml0cyBpbnRvXHJcblx0Ly8gdGhlIGdpdmVuIGJvdW5kcyBpbiBpdHMgZW50aXJldHkuXHJcblx0Z2V0Qm91bmRzWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgaW5zaWRlLCBwYWRkaW5nKSB7IC8vIChMYXRMbmdCb3VuZHNbLCBCb29sZWFuLCBQb2ludF0pIC0+IE51bWJlclxyXG5cdFx0Ym91bmRzID0gdG9MYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHRcdHBhZGRpbmcgPSB0b1BvaW50KHBhZGRpbmcgfHwgWzAsIDBdKTtcclxuXHJcblx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0Wm9vbSgpIHx8IDAsXHJcblx0XHQgICAgbWluID0gdGhpcy5nZXRNaW5ab29tKCksXHJcblx0XHQgICAgbWF4ID0gdGhpcy5nZXRNYXhab29tKCksXHJcblx0XHQgICAgbncgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCksXHJcblx0XHQgICAgc2UgPSBib3VuZHMuZ2V0U291dGhFYXN0KCksXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLnN1YnRyYWN0KHBhZGRpbmcpLFxyXG5cdFx0ICAgIGJvdW5kc1NpemUgPSB0b0JvdW5kcyh0aGlzLnByb2plY3Qoc2UsIHpvb20pLCB0aGlzLnByb2plY3QobncsIHpvb20pKS5nZXRTaXplKCksXHJcblx0XHQgICAgc25hcCA9IEJyb3dzZXIuYW55M2QgPyB0aGlzLm9wdGlvbnMuem9vbVNuYXAgOiAxLFxyXG5cdFx0ICAgIHNjYWxleCA9IHNpemUueCAvIGJvdW5kc1NpemUueCxcclxuXHRcdCAgICBzY2FsZXkgPSBzaXplLnkgLyBib3VuZHNTaXplLnksXHJcblx0XHQgICAgc2NhbGUgPSBpbnNpZGUgPyBNYXRoLm1heChzY2FsZXgsIHNjYWxleSkgOiBNYXRoLm1pbihzY2FsZXgsIHNjYWxleSk7XHJcblxyXG5cdFx0em9vbSA9IHRoaXMuZ2V0U2NhbGVab29tKHNjYWxlLCB6b29tKTtcclxuXHJcblx0XHRpZiAoc25hcCkge1xyXG5cdFx0XHR6b29tID0gTWF0aC5yb3VuZCh6b29tIC8gKHNuYXAgLyAxMDApKSAqIChzbmFwIC8gMTAwKTsgLy8gZG9uJ3QganVtcCBpZiB3aXRoaW4gMSUgb2YgYSBzbmFwIGxldmVsXHJcblx0XHRcdHpvb20gPSBpbnNpZGUgPyBNYXRoLmNlaWwoem9vbSAvIHNuYXApICogc25hcCA6IE1hdGguZmxvb3Ioem9vbSAvIHNuYXApICogc25hcDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNpemUoKTogUG9pbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIG1hcCBjb250YWluZXIgKGluIHBpeGVscykuXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9zaXplIHx8IHRoaXMuX3NpemVDaGFuZ2VkKSB7XHJcblx0XHRcdHRoaXMuX3NpemUgPSBuZXcgUG9pbnQoXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRoIHx8IDAsXHJcblx0XHRcdFx0dGhpcy5fY29udGFpbmVyLmNsaWVudEhlaWdodCB8fCAwKTtcclxuXHJcblx0XHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZS5jbG9uZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxCb3VuZHMoKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IG1hcCB2aWV3IGluIHByb2plY3RlZCBwaXhlbFxyXG5cdC8vIGNvb3JkaW5hdGVzIChzb21ldGltZXMgdXNlZnVsIGluIGxheWVyIGFuZCBvdmVybGF5IGltcGxlbWVudGF0aW9ucykuXHJcblx0Z2V0UGl4ZWxCb3VuZHM6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcclxuXHRcdHZhciB0b3BMZWZ0UG9pbnQgPSB0aGlzLl9nZXRUb3BMZWZ0UG9pbnQoY2VudGVyLCB6b29tKTtcclxuXHRcdHJldHVybiBuZXcgQm91bmRzKHRvcExlZnRQb2ludCwgdG9wTGVmdFBvaW50LmFkZCh0aGlzLmdldFNpemUoKSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE86IENoZWNrIHNlbWFudGljcyAtIGlzbid0IHRoZSBwaXhlbCBvcmlnaW4gdGhlIDAsMCBjb29yZCByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBtYXAgcGFuZT8gXCJsZWZ0IHBvaW50IG9mIHRoZSBtYXAgbGF5ZXJcIiBjYW4gYmUgY29uZnVzaW5nLCBzcGVjaWFsbHlcclxuXHQvLyBzaW5jZSB0aGVyZSBjYW4gYmUgbmVnYXRpdmUgb2Zmc2V0cy5cclxuXHQvLyBAbWV0aG9kIGdldFBpeGVsT3JpZ2luKCk6IFBvaW50XHJcblx0Ly8gUmV0dXJucyB0aGUgcHJvamVjdGVkIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSB0b3AgbGVmdCBwb2ludCBvZlxyXG5cdC8vIHRoZSBtYXAgbGF5ZXIgKHVzZWZ1bCBpbiBjdXN0b20gbGF5ZXIgYW5kIG92ZXJsYXkgaW1wbGVtZW50YXRpb25zKS5cclxuXHRnZXRQaXhlbE9yaWdpbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY2hlY2tJZkxvYWRlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsT3JpZ2luO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0UGl4ZWxXb3JsZEJvdW5kcyh6b29tPzogTnVtYmVyKTogQm91bmRzXHJcblx0Ly8gUmV0dXJucyB0aGUgd29ybGQncyBib3VuZHMgaW4gcGl4ZWwgY29vcmRpbmF0ZXMgZm9yIHpvb20gbGV2ZWwgYHpvb21gLlxyXG5cdC8vIElmIGB6b29tYCBpcyBvbWl0dGVkLCB0aGUgbWFwJ3MgY3VycmVudCB6b29tIGxldmVsIGlzIHVzZWQuXHJcblx0Z2V0UGl4ZWxXb3JsZEJvdW5kczogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmdldFByb2plY3RlZEJvdW5kcyh6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFpvb20oKSA6IHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBzZWN0aW9uIE90aGVyIE1ldGhvZHNcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQYW5lKHBhbmU6IFN0cmluZ3xIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyBhIFttYXAgcGFuZV0oI21hcC1wYW5lKSwgZ2l2ZW4gaXRzIG5hbWUgb3IgaXRzIEhUTUwgZWxlbWVudCAoaXRzIGlkZW50aXR5KS5cclxuXHRnZXRQYW5lOiBmdW5jdGlvbiAocGFuZSkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBwYW5lID09PSAnc3RyaW5nJyA/IHRoaXMuX3BhbmVzW3BhbmVdIDogcGFuZTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFBhbmVzKCk6IE9iamVjdFxyXG5cdC8vIFJldHVybnMgYSBwbGFpbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIFtwYW5lc10oI21hcC1wYW5lKSBhcyBrZXlzIGFuZFxyXG5cdC8vIHRoZSBwYW5lcyBhcyB2YWx1ZXMuXHJcblx0Z2V0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wYW5lcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgbWFwLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gQHNlY3Rpb24gQ29udmVyc2lvbiBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Wm9vbVNjYWxlKHRvWm9vbTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgc2NhbGUgZmFjdG9yIHRvIGJlIGFwcGxpZWQgdG8gYSBtYXAgdHJhbnNpdGlvbiBmcm9tIHpvb20gbGV2ZWxcclxuXHQvLyBgZnJvbVpvb21gIHRvIGB0b1pvb21gLiBVc2VkIGludGVybmFsbHkgdG8gaGVscCB3aXRoIHpvb20gYW5pbWF0aW9ucy5cclxuXHRnZXRab29tU2NhbGU6IGZ1bmN0aW9uICh0b1pvb20sIGZyb21ab29tKSB7XHJcblx0XHQvLyBUT0RPIHJlcGxhY2Ugd2l0aCB1bml2ZXJzYWwgaW1wbGVtZW50YXRpb24gYWZ0ZXIgcmVmYWN0b3JpbmcgcHJvamVjdGlvbnNcclxuXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG5cdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG5cdFx0cmV0dXJuIGNycy5zY2FsZSh0b1pvb20pIC8gY3JzLnNjYWxlKGZyb21ab29tKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldFNjYWxlWm9vbShzY2FsZTogTnVtYmVyLCBmcm9tWm9vbTogTnVtYmVyKTogTnVtYmVyXHJcblx0Ly8gUmV0dXJucyB0aGUgem9vbSBsZXZlbCB0aGF0IHRoZSBtYXAgd291bGQgZW5kIHVwIGF0LCBpZiBpdCBpcyBhdCBgZnJvbVpvb21gXHJcblx0Ly8gbGV2ZWwgYW5kIGV2ZXJ5dGhpbmcgaXMgc2NhbGVkIGJ5IGEgZmFjdG9yIG9mIGBzY2FsZWAuIEludmVyc2Ugb2ZcclxuXHQvLyBbYGdldFpvb21TY2FsZWBdKCNtYXAtZ2V0Wm9vbVNjYWxlKS5cclxuXHRnZXRTY2FsZVpvb206IGZ1bmN0aW9uIChzY2FsZSwgZnJvbVpvb20pIHtcclxuXHRcdHZhciBjcnMgPSB0aGlzLm9wdGlvbnMuY3JzO1xyXG5cdFx0ZnJvbVpvb20gPSBmcm9tWm9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IGZyb21ab29tO1xyXG5cdFx0dmFyIHpvb20gPSBjcnMuem9vbShzY2FsZSAqIGNycy5zY2FsZShmcm9tWm9vbSkpO1xyXG5cdFx0cmV0dXJuIGlzTmFOKHpvb20pID8gSW5maW5pdHkgOiB6b29tO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZywgem9vbTogTnVtYmVyKTogUG9pbnRcclxuXHQvLyBQcm9qZWN0cyBhIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIGBMYXRMbmdgIGFjY29yZGluZyB0byB0aGUgcHJvamVjdGlvblxyXG5cdC8vIG9mIHRoZSBtYXAncyBDUlMsIHRoZW4gc2NhbGVzIGl0IGFjY29yZGluZyB0byBgem9vbWAgYW5kIHRoZSBDUlMnc1xyXG5cdC8vIGBUcmFuc2Zvcm1hdGlvbmAuIFRoZSByZXN1bHQgaXMgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0b1xyXG5cdC8vIHRoZSBDUlMgb3JpZ2luLlxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHtcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLmxhdExuZ1RvUG9pbnQodG9MYXRMbmcobGF0bG5nKSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50LCB6b29tOiBOdW1iZXIpOiBMYXRMbmdcclxuXHQvLyBJbnZlcnNlIG9mIFtgcHJvamVjdGBdKCNtYXAtcHJvamVjdCkuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQsIHpvb20pIHtcclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogem9vbTtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLnBvaW50VG9MYXRMbmcodG9Qb2ludChwb2ludCksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF5ZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbiksXHJcblx0Ly8gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSAoZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpLlxyXG5cdGxheWVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgcHJvamVjdGVkUG9pbnQgPSB0b1BvaW50KHBvaW50KS5hZGQodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChwcm9qZWN0ZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBsYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nOiBMYXRMbmcpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwgY29vcmRpbmF0ZVxyXG5cdC8vIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKS5cclxuXHRsYXRMbmdUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdCh0b0xhdExuZyhsYXRsbmcpKS5fcm91bmQoKTtcclxuXHRcdHJldHVybiBwcm9qZWN0ZWRQb2ludC5fc3VidHJhY3QodGhpcy5nZXRQaXhlbE9yaWdpbigpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHdyYXBMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiBMYXRMbmdcclxuXHQvLyBSZXR1cm5zIGEgYExhdExuZ2Agd2hlcmUgYGxhdGAgYW5kIGBsbmdgIGhhcyBiZWVuIHdyYXBwZWQgYWNjb3JkaW5nIHRvIHRoZVxyXG5cdC8vIG1hcCdzIENSUydzIGB3cmFwTGF0YCBhbmQgYHdyYXBMbmdgIHByb3BlcnRpZXMsIGlmIHRoZXkgYXJlIG91dHNpZGUgdGhlXHJcblx0Ly8gQ1JTJ3MgYm91bmRzLlxyXG5cdC8vIEJ5IGRlZmF1bHQgdGhpcyBtZWFucyBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG5cdC8vIHZhbHVlIGlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLlxyXG5cdHdyYXBMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmcodG9MYXRMbmcobGF0bG5nKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCB3cmFwTGF0TG5nQm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogTGF0TG5nQm91bmRzXHJcblx0Ly8gUmV0dXJucyBhIGBMYXRMbmdCb3VuZHNgIHdpdGggdGhlIHNhbWUgc2l6ZSBhcyB0aGUgZ2l2ZW4gb25lLCBlbnN1cmluZyB0aGF0XHJcblx0Ly8gaXRzIGNlbnRlciBpcyB3aXRoaW4gdGhlIENSUydzIGJvdW5kcy5cclxuXHQvLyBCeSBkZWZhdWx0IHRoaXMgbWVhbnMgdGhlIGNlbnRlciBsb25naXR1ZGUgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGRhdGVsaW5lIHNvIGl0c1xyXG5cdC8vIHZhbHVlIGlzIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzLCBhbmQgdGhlIG1ham9yaXR5IG9mIHRoZSBib3VuZHNcclxuXHQvLyBvdmVybGFwcyB0aGUgQ1JTJ3MgYm91bmRzLlxyXG5cdHdyYXBMYXRMbmdCb3VuZHM6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmdCb3VuZHModG9MYXRMbmdCb3VuZHMobGF0bG5nKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXN0YW5jZShsYXRsbmcxOiBMYXRMbmcsIGxhdGxuZzI6IExhdExuZyk6IE51bWJlclxyXG5cdC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBhY2NvcmRpbmcgdG9cclxuXHQvLyB0aGUgbWFwJ3MgQ1JTLiBCeSBkZWZhdWx0IHRoaXMgbWVhc3VyZXMgZGlzdGFuY2UgaW4gbWV0ZXJzLlxyXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZGlzdGFuY2UodG9MYXRMbmcobGF0bG5nMSksIHRvTGF0TG5nKGxhdGxuZzIpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBtYXAgY29udGFpbmVyLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nXHJcblx0Ly8gcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgW29yaWdpbiBwaXhlbF0oI21hcC1nZXRwaXhlbG9yaWdpbikuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHBvaW50OiBQb2ludCk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBbb3JpZ2luIHBpeGVsXSgjbWFwLWdldHBpeGVsb3JpZ2luKSxcclxuXHQvLyByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcblx0bGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gdG9Qb2ludChwb2ludCkuYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjb250YWluZXJQb2ludFRvTGF0TG5nKHBvaW50OiBQb2ludCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgcGl4ZWwgY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgbWFwIGNvbnRhaW5lciwgcmV0dXJuc1xyXG5cdC8vIHRoZSBjb3JyZXNwb25kaW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIChmb3IgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgbGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQodG9Qb2ludChwb2ludCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmc6IExhdExuZyk6IFBvaW50XHJcblx0Ly8gR2l2ZW4gYSBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCBjb29yZGluYXRlXHJcblx0Ly8gcmVsYXRpdmUgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcblx0bGF0TG5nVG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQodGhpcy5sYXRMbmdUb0xheWVyUG9pbnQodG9MYXRMbmcobGF0bG5nKSkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgbW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZXY6IE1vdXNlRXZlbnQpOiBQb2ludFxyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgdGhlIHBpeGVsIGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlXHJcblx0Ly8gbWFwIGNvbnRhaW5lciB3aGVyZSB0aGUgZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiBEb21FdmVudC5nZXRNb3VzZVBvc2l0aW9uKGUsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBtb3VzZUV2ZW50VG9MYXllclBvaW50KGV2OiBNb3VzZUV2ZW50KTogUG9pbnRcclxuXHQvLyBHaXZlbiBhIE1vdXNlRXZlbnQgb2JqZWN0LCByZXR1cm5zIHRoZSBwaXhlbCBjb29yZGluYXRlIHJlbGF0aXZlIHRvXHJcblx0Ly8gdGhlIFtvcmlnaW4gcGl4ZWxdKCNtYXAtZ2V0cGl4ZWxvcmlnaW4pIHdoZXJlIHRoZSBldmVudCB0b29rIHBsYWNlLlxyXG5cdG1vdXNlRXZlbnRUb0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIG1vdXNlRXZlbnRUb0xhdExuZyhldjogTW91c2VFdmVudCk6IExhdExuZ1xyXG5cdC8vIEdpdmVuIGEgTW91c2VFdmVudCBvYmplY3QsIHJldHVybnMgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUgd2hlcmUgdGhlXHJcblx0Ly8gZXZlbnQgdG9vayBwbGFjZS5cclxuXHRtb3VzZUV2ZW50VG9MYXRMbmc6IGZ1bmN0aW9uIChlKSB7IC8vIChNb3VzZUV2ZW50KVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIG1hcCBpbml0aWFsaXphdGlvbiBtZXRob2RzXHJcblxyXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmdldChpZCk7XHJcblxyXG5cdFx0aWYgKCFjb250YWluZXIpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIG5vdCBmb3VuZC4nKTtcclxuXHRcdH0gZWxzZSBpZiAoY29udGFpbmVyLl9sZWFmbGV0X2lkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWFwIGNvbnRhaW5lciBpcyBhbHJlYWR5IGluaXRpYWxpemVkLicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbUV2ZW50Lm9uKGNvbnRhaW5lciwgJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsLCB0aGlzKTtcclxuXHRcdHRoaXMuX2NvbnRhaW5lcklkID0gVXRpbC5zdGFtcChjb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0TGF5b3V0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xyXG5cclxuXHRcdHRoaXMuX2ZhZGVBbmltYXRlZCA9IHRoaXMub3B0aW9ucy5mYWRlQW5pbWF0aW9uICYmIEJyb3dzZXIuYW55M2Q7XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRhaW5lcicgK1xyXG5cdFx0XHQoQnJvd3Nlci50b3VjaCA/ICcgbGVhZmxldC10b3VjaCcgOiAnJykgK1xyXG5cdFx0XHQoQnJvd3Nlci5yZXRpbmEgPyAnIGxlYWZsZXQtcmV0aW5hJyA6ICcnKSArXHJcblx0XHRcdChCcm93c2VyLmllbHQ5ID8gJyBsZWFmbGV0LW9sZGllJyA6ICcnKSArXHJcblx0XHRcdChCcm93c2VyLnNhZmFyaSA/ICcgbGVhZmxldC1zYWZhcmknIDogJycpICtcclxuXHRcdFx0KHRoaXMuX2ZhZGVBbmltYXRlZCA/ICcgbGVhZmxldC1mYWRlLWFuaW0nIDogJycpKTtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBEb21VdGlsLmdldFN0eWxlKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJyk7XHJcblxyXG5cdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAncmVsYXRpdmUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnICYmIHBvc2l0aW9uICE9PSAnc3RpY2t5Jykge1xyXG5cdFx0XHRjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2luaXRQYW5lcygpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9pbml0Q29udHJvbFBvcykge1xyXG5cdFx0XHR0aGlzLl9pbml0Q29udHJvbFBvcygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0UGFuZXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYW5lcyA9IHRoaXMuX3BhbmVzID0ge307XHJcblx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzID0ge307XHJcblxyXG5cdFx0Ly8gQHNlY3Rpb25cclxuXHRcdC8vXHJcblx0XHQvLyBQYW5lcyBhcmUgRE9NIGVsZW1lbnRzIHVzZWQgdG8gY29udHJvbCB0aGUgb3JkZXJpbmcgb2YgbGF5ZXJzIG9uIHRoZSBtYXAuIFlvdVxyXG5cdFx0Ly8gY2FuIGFjY2VzcyBwYW5lcyB3aXRoIFtgbWFwLmdldFBhbmVgXSgjbWFwLWdldHBhbmUpIG9yXHJcblx0XHQvLyBbYG1hcC5nZXRQYW5lc2BdKCNtYXAtZ2V0cGFuZXMpIG1ldGhvZHMuIE5ldyBwYW5lcyBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZVxyXG5cdFx0Ly8gW2BtYXAuY3JlYXRlUGFuZWBdKCNtYXAtY3JlYXRlcGFuZSkgbWV0aG9kLlxyXG5cdFx0Ly9cclxuXHRcdC8vIEV2ZXJ5IG1hcCBoYXMgdGhlIGZvbGxvd2luZyBkZWZhdWx0IHBhbmVzIHRoYXQgZGlmZmVyIG9ubHkgaW4gekluZGV4LlxyXG5cdFx0Ly9cclxuXHRcdC8vIEBwYW5lIG1hcFBhbmU6IEhUTUxFbGVtZW50ID0gJ2F1dG8nXHJcblx0XHQvLyBQYW5lIHRoYXQgY29udGFpbnMgYWxsIG90aGVyIG1hcCBwYW5lc1xyXG5cclxuXHRcdHRoaXMuX21hcFBhbmUgPSB0aGlzLmNyZWF0ZVBhbmUoJ21hcFBhbmUnLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9tYXBQYW5lLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG5cclxuXHRcdC8vIEBwYW5lIHRpbGVQYW5lOiBIVE1MRWxlbWVudCA9IDIwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgYEdyaWRMYXllcmBzIGFuZCBgVGlsZUxheWVyYHNcclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgndGlsZVBhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG92ZXJsYXlQYW5lOiBIVE1MRWxlbWVudCA9IDQwMFxyXG5cdFx0Ly8gUGFuZSBmb3IgdmVjdG9ycyAoYFBhdGhgcywgbGlrZSBgUG9seWxpbmVgcyBhbmQgYFBvbHlnb25gcyksIGBJbWFnZU92ZXJsYXlgcyBhbmQgYFZpZGVvT3ZlcmxheWBzXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ292ZXJsYXlQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBzaGFkb3dQYW5lOiBIVE1MRWxlbWVudCA9IDUwMFxyXG5cdFx0Ly8gUGFuZSBmb3Igb3ZlcmxheSBzaGFkb3dzIChlLmcuIGBNYXJrZXJgIHNoYWRvd3MpXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3NoYWRvd1BhbmUnKTtcclxuXHRcdC8vIEBwYW5lIG1hcmtlclBhbmU6IEhUTUxFbGVtZW50ID0gNjAwXHJcblx0XHQvLyBQYW5lIGZvciBgSWNvbmBzIG9mIGBNYXJrZXJgc1xyXG5cdFx0dGhpcy5jcmVhdGVQYW5lKCdtYXJrZXJQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSB0b29sdGlwUGFuZTogSFRNTEVsZW1lbnQgPSA2NTBcclxuXHRcdC8vIFBhbmUgZm9yIGBUb29sdGlwYHMuXHJcblx0XHR0aGlzLmNyZWF0ZVBhbmUoJ3Rvb2x0aXBQYW5lJyk7XHJcblx0XHQvLyBAcGFuZSBwb3B1cFBhbmU6IEhUTUxFbGVtZW50ID0gNzAwXHJcblx0XHQvLyBQYW5lIGZvciBgUG9wdXBgcy5cclxuXHRcdHRoaXMuY3JlYXRlUGFuZSgncG9wdXBQYW5lJyk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhbmVzLm1hcmtlclBhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhbmVzLnNoYWRvd1BhbmUsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwcml2YXRlIG1ldGhvZHMgdGhhdCBtb2RpZnkgbWFwIHN0YXRlXHJcblxyXG5cdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXHJcblx0X3Jlc2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgbm9Nb3ZlU3RhcnQpIHtcclxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgbmV3IFBvaW50KDAsIDApKTtcclxuXHJcblx0XHR2YXIgbG9hZGluZyA9ICF0aGlzLl9sb2FkZWQ7XHJcblx0XHR0aGlzLl9sb2FkZWQgPSB0cnVlO1xyXG5cdFx0em9vbSA9IHRoaXMuX2xpbWl0Wm9vbSh6b29tKTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdwcmVyZXNldCcpO1xyXG5cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblx0XHR0aGlzXHJcblx0XHRcdC5fbW92ZVN0YXJ0KHpvb21DaGFuZ2VkLCBub01vdmVTdGFydClcclxuXHRcdFx0Ll9tb3ZlKGNlbnRlciwgem9vbSlcclxuXHRcdFx0Ll9tb3ZlRW5kKHpvb21DaGFuZ2VkKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgdmlld3Jlc2V0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIG5lZWRzIHRvIHJlZHJhdyBpdHMgY29udGVudCAodGhpcyB1c3VhbGx5IGhhcHBlbnNcclxuXHRcdC8vIG9uIG1hcCB6b29tIG9yIGxvYWQpLiBWZXJ5IHVzZWZ1bCBmb3IgY3JlYXRpbmcgY3VzdG9tIG92ZXJsYXlzLlxyXG5cdFx0dGhpcy5maXJlKCd2aWV3cmVzZXQnKTtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcCBpcyBpbml0aWFsaXplZCAod2hlbiBpdHMgY2VudGVyIGFuZCB6b29tIGFyZSBzZXRcclxuXHRcdC8vIGZvciB0aGUgZmlyc3QgdGltZSkuXHJcblx0XHRpZiAobG9hZGluZykge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfbW92ZVN0YXJ0OiBmdW5jdGlvbiAoem9vbUNoYW5nZWQsIG5vTW92ZVN0YXJ0KSB7XHJcblx0XHQvLyBAZXZlbnQgem9vbXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gaXMgYWJvdXQgdG8gY2hhbmdlIChlLmcuIGJlZm9yZSB6b29tIGFuaW1hdGlvbikuXHJcblx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdmlldyBvZiB0aGUgbWFwIHN0YXJ0cyBjaGFuZ2luZyAoZS5nLiB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFwKS5cclxuXHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21zdGFydCcpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCFub01vdmVTdGFydCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X21vdmU6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGRhdGEsIHN1cHJlc3NFdmVudCkge1xyXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR6b29tID0gdGhpcy5fem9vbTtcclxuXHRcdH1cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9IHRoaXMuX3pvb20gIT09IHpvb207XHJcblxyXG5cdFx0dGhpcy5fem9vbSA9IHpvb207XHJcblx0XHR0aGlzLl9sYXN0Q2VudGVyID0gY2VudGVyO1xyXG5cdFx0dGhpcy5fcGl4ZWxPcmlnaW4gPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIpO1xyXG5cclxuXHRcdGlmICghc3VwcmVzc0V2ZW50KSB7XHJcblx0XHRcdC8vIEBldmVudCB6b29tOiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbnkgY2hhbmdlIGluIHpvb20gbGV2ZWwsXHJcblx0XHRcdC8vIGluY2x1ZGluZyB6b29tIGFuZCBmbHkgYW5pbWF0aW9ucy5cclxuXHRcdFx0aWYgKHpvb21DaGFuZ2VkIHx8IChkYXRhICYmIGRhdGEucGluY2gpKSB7XHQvLyBBbHdheXMgZmlyZSAnem9vbScgaWYgcGluY2hpbmcgYmVjYXVzZSAjMzUzMFxyXG5cdFx0XHRcdHRoaXMuZmlyZSgnem9vbScsIGRhdGEpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYW55IG1vdmVtZW50IG9mIHRoZSBtYXAsXHJcblx0XHRcdC8vIGluY2x1ZGluZyBwYW4gYW5kIGZseSBhbmltYXRpb25zLlxyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmUnLCBkYXRhKTtcclxuXHRcdH0gZWxzZSBpZiAoZGF0YSAmJiBkYXRhLnBpbmNoKSB7XHQvLyBBbHdheXMgZmlyZSAnem9vbScgaWYgcGluY2hpbmcgYmVjYXVzZSAjMzUzMFxyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb20nLCBkYXRhKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlRW5kOiBmdW5jdGlvbiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdC8vIEBldmVudCB6b29tZW5kOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gY2hhbmdlZCwgYWZ0ZXIgYW55IGFuaW1hdGlvbnMuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tZW5kJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmVlbmQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjZW50ZXIgb2YgdGhlIG1hcCBzdG9wcyBjaGFuZ2luZ1xyXG5cdFx0Ly8gKGUuZy4gdXNlciBzdG9wcGVkIGRyYWdnaW5nIHRoZSBtYXAgb3IgYWZ0ZXIgbm9uLWNlbnRlcmVkIHpvb20pLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdF9zdG9wOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mbHlUb0ZyYW1lKTtcclxuXHRcdGlmICh0aGlzLl9wYW5BbmltKSB7XHJcblx0XHRcdHRoaXMuX3BhbkFuaW0uc3RvcCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3Jhd1BhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Wm9vbVNwYW46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldE1heFpvb20oKSAtIHRoaXMuZ2V0TWluWm9vbSgpO1xyXG5cdH0sXHJcblxyXG5cdF9wYW5JbnNpZGVNYXhCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5mb3JjaW5nQm91bmRzKSB7XHJcblx0XHRcdHRoaXMucGFuSW5zaWRlQm91bmRzKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9jaGVja0lmTG9hZGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NldCBtYXAgY2VudGVyIGFuZCB6b29tIGZpcnN0LicpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIERPTSBldmVudCBoYW5kbGluZ1xyXG5cclxuXHQvLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBldmVudHNcclxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKHJlbW92ZSkge1xyXG5cdFx0dGhpcy5fdGFyZ2V0cyA9IHt9O1xyXG5cdFx0dGhpcy5fdGFyZ2V0c1tVdGlsLnN0YW1wKHRoaXMuX2NvbnRhaW5lcildID0gdGhpcztcclxuXHJcblx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyBEb21FdmVudC5vZmYgOiBEb21FdmVudC5vbjtcclxuXHJcblx0XHQvLyBAZXZlbnQgY2xpY2s6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIChvciB0YXBzKSB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IGRibGNsaWNrOiBNb3VzZUV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB1c2VyIGRvdWJsZS1jbGlja3MgKG9yIGRvdWJsZS10YXBzKSB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlZG93bjogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNldXA6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgdGhlIG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlb3ZlcjogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbW91c2UgZW50ZXJzIHRoZSBtYXAuXHJcblx0XHQvLyBAZXZlbnQgbW91c2VvdXQ6IE1vdXNlRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgbWFwLlxyXG5cdFx0Ly8gQGV2ZW50IG1vdXNlbW92ZTogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hpbGUgdGhlIG1vdXNlIG1vdmVzIG92ZXIgdGhlIG1hcC5cclxuXHRcdC8vIEBldmVudCBjb250ZXh0bWVudTogTW91c2VFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwdXNoZXMgdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvbiBvbiB0aGUgbWFwLCBwcmV2ZW50c1xyXG5cdFx0Ly8gZGVmYXVsdCBicm93c2VyIGNvbnRleHQgbWVudSBmcm9tIHNob3dpbmcgaWYgdGhlcmUgYXJlIGxpc3RlbmVycyBvblxyXG5cdFx0Ly8gdGhpcyBldmVudC4gQWxzbyBmaXJlZCBvbiBtb2JpbGUgd2hlbiB0aGUgdXNlciBob2xkcyBhIHNpbmdsZSB0b3VjaFxyXG5cdFx0Ly8gZm9yIGEgc2Vjb25kIChhbHNvIGNhbGxlZCBsb25nIHByZXNzKS5cclxuXHRcdC8vIEBldmVudCBrZXlwcmVzczogS2V5Ym9hcmRFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGZyb20gdGhlIGtleWJvYXJkIHRoYXQgcHJvZHVjZXMgYSBjaGFyYWN0ZXIgdmFsdWUgd2hpbGUgdGhlIG1hcCBpcyBmb2N1c2VkLlxyXG5cdFx0Ly8gQGV2ZW50IGtleWRvd246IEtleWJvYXJkRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuIFVubGlrZSB0aGUgYGtleXByZXNzYCBldmVudCxcclxuXHRcdC8vIHRoZSBga2V5ZG93bmAgZXZlbnQgaXMgZmlyZWQgZm9yIGtleXMgdGhhdCBwcm9kdWNlIGEgY2hhcmFjdGVyIHZhbHVlIGFuZCBmb3Iga2V5c1xyXG5cdFx0Ly8gdGhhdCBkbyBub3QgcHJvZHVjZSBhIGNoYXJhY3RlciB2YWx1ZS5cclxuXHRcdC8vIEBldmVudCBrZXl1cDogS2V5Ym9hcmRFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyBhIGtleSBmcm9tIHRoZSBrZXlib2FyZCB3aGlsZSB0aGUgbWFwIGlzIGZvY3VzZWQuXHJcblx0XHRvbk9mZih0aGlzLl9jb250YWluZXIsICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCAnICtcclxuXHRcdFx0J21vdXNlb3ZlciBtb3VzZW91dCBtb3VzZW1vdmUgY29udGV4dG1lbnUga2V5cHJlc3Mga2V5ZG93biBrZXl1cCcsIHRoaXMuX2hhbmRsZURPTUV2ZW50LCB0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnRyYWNrUmVzaXplKSB7XHJcblx0XHRcdG9uT2ZmKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoQnJvd3Nlci5hbnkzZCAmJiB0aGlzLm9wdGlvbnMudHJhbnNmb3JtM0RMaW1pdCkge1xyXG5cdFx0XHQocmVtb3ZlID8gdGhpcy5vZmYgOiB0aGlzLm9uKS5jYWxsKHRoaXMsICdtb3ZlZW5kJywgdGhpcy5fb25Nb3ZlRW5kKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25SZXNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX3Jlc2l6ZVJlcXVlc3QpO1xyXG5cdFx0dGhpcy5fcmVzaXplUmVxdWVzdCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZShcclxuXHRcdCAgICAgICAgZnVuY3Rpb24gKCkgeyB0aGlzLmludmFsaWRhdGVTaXplKHtkZWJvdW5jZU1vdmVlbmQ6IHRydWV9KTsgfSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uU2Nyb2xsOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsVG9wICA9IDA7XHJcblx0XHR0aGlzLl9jb250YWluZXIuc2Nyb2xsTGVmdCA9IDA7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuXHRcdGlmIChNYXRoLm1heChNYXRoLmFicyhwb3MueCksIE1hdGguYWJzKHBvcy55KSkgPj0gdGhpcy5vcHRpb25zLnRyYW5zZm9ybTNETGltaXQpIHtcclxuXHRcdFx0Ly8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIwMzg3MyBidXQgV2Via2l0IGFsc28gaGF2ZVxyXG5cdFx0XHQvLyBhIHBpeGVsIG9mZnNldCBvbiB2ZXJ5IGhpZ2ggdmFsdWVzLCBzZWU6IGh0dHBzOi8vanNmaWRkbGUubmV0L2RnNnI1aGhiL1xyXG5cdFx0XHR0aGlzLl9yZXNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgdGhpcy5nZXRab29tKCkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9maW5kRXZlbnRUYXJnZXRzOiBmdW5jdGlvbiAoZSwgdHlwZSkge1xyXG5cdFx0dmFyIHRhcmdldHMgPSBbXSxcclxuXHRcdCAgICB0YXJnZXQsXHJcblx0XHQgICAgaXNIb3ZlciA9IHR5cGUgPT09ICdtb3VzZW91dCcgfHwgdHlwZSA9PT0gJ21vdXNlb3ZlcicsXHJcblx0XHQgICAgc3JjID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxyXG5cdFx0ICAgIGRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0d2hpbGUgKHNyYykge1xyXG5cdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXRzW1V0aWwuc3RhbXAoc3JjKV07XHJcblx0XHRcdGlmICh0YXJnZXQgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ3ByZWNsaWNrJykgJiYgdGhpcy5fZHJhZ2dhYmxlTW92ZWQodGFyZ2V0KSkge1xyXG5cdFx0XHRcdC8vIFByZXZlbnQgZmlyaW5nIGNsaWNrIGFmdGVyIHlvdSBqdXN0IGRyYWdnZWQgYW4gb2JqZWN0LlxyXG5cdFx0XHRcdGRyYWdnaW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGFyZ2V0ICYmIHRhcmdldC5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdFx0aWYgKGlzSG92ZXIgJiYgIURvbUV2ZW50LmlzRXh0ZXJuYWxUYXJnZXQoc3JjLCBlKSkgeyBicmVhazsgfVxyXG5cdFx0XHRcdHRhcmdldHMucHVzaCh0YXJnZXQpO1xyXG5cdFx0XHRcdGlmIChpc0hvdmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHNyYyA9PT0gdGhpcy5fY29udGFpbmVyKSB7IGJyZWFrOyB9XHJcblx0XHRcdHNyYyA9IHNyYy5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCAmJiAhZHJhZ2dpbmcgJiYgIWlzSG92ZXIgJiYgdGhpcy5saXN0ZW5zKHR5cGUsIHRydWUpKSB7XHJcblx0XHRcdHRhcmdldHMgPSBbdGhpc107XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGFyZ2V0cztcclxuXHR9LFxyXG5cclxuXHRfaXNDbGlja0Rpc2FibGVkOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdHdoaWxlIChlbCAmJiBlbCAhPT0gdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdGlmIChlbFsnX2xlYWZsZXRfZGlzYWJsZV9jbGljayddKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdGVsID0gZWwucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgZWwgPSAoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KTtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkIHx8IGVsWydfbGVhZmxldF9kaXNhYmxlX2V2ZW50cyddIHx8IGUudHlwZSA9PT0gJ2NsaWNrJyAmJiB0aGlzLl9pc0NsaWNrRGlzYWJsZWQoZWwpKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdHlwZSA9IGUudHlwZTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ21vdXNlZG93bicpIHtcclxuXHRcdFx0Ly8gcHJldmVudHMgb3V0bGluZSB3aGVuIGNsaWNraW5nIG9uIGtleWJvYXJkLWZvY3VzYWJsZSBlbGVtZW50XHJcblx0XHRcdERvbVV0aWwucHJldmVudE91dGxpbmUoZWwpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ZpcmVET01FdmVudChlLCB0eXBlKTtcclxuXHR9LFxyXG5cclxuXHRfbW91c2VFdmVudHM6IFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ2NvbnRleHRtZW51J10sXHJcblxyXG5cdF9maXJlRE9NRXZlbnQ6IGZ1bmN0aW9uIChlLCB0eXBlLCBjYW52YXNUYXJnZXRzKSB7XHJcblxyXG5cdFx0aWYgKGUudHlwZSA9PT0gJ2NsaWNrJykge1xyXG5cdFx0XHQvLyBGaXJlIGEgc3ludGhldGljICdwcmVjbGljaycgZXZlbnQgd2hpY2ggcHJvcGFnYXRlcyB1cCAobWFpbmx5IGZvciBjbG9zaW5nIHBvcHVwcykuXHJcblx0XHRcdC8vIEBldmVudCBwcmVjbGljazogTW91c2VFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCBiZWZvcmUgbW91c2UgY2xpY2sgb24gdGhlIG1hcCAoc29tZXRpbWVzIHVzZWZ1bCB3aGVuIHlvdVxyXG5cdFx0XHQvLyB3YW50IHNvbWV0aGluZyB0byBoYXBwZW4gb24gY2xpY2sgYmVmb3JlIGFueSBleGlzdGluZyBjbGlja1xyXG5cdFx0XHQvLyBoYW5kbGVycyBzdGFydCBydW5uaW5nKS5cclxuXHRcdFx0dmFyIHN5bnRoID0gVXRpbC5leHRlbmQoe30sIGUpO1xyXG5cdFx0XHRzeW50aC50eXBlID0gJ3ByZWNsaWNrJztcclxuXHRcdFx0dGhpcy5fZmlyZURPTUV2ZW50KHN5bnRoLCBzeW50aC50eXBlLCBjYW52YXNUYXJnZXRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBGaW5kIHRoZSBsYXllciB0aGUgZXZlbnQgaXMgcHJvcGFnYXRpbmcgZnJvbSBhbmQgaXRzIHBhcmVudHMuXHJcblx0XHR2YXIgdGFyZ2V0cyA9IHRoaXMuX2ZpbmRFdmVudFRhcmdldHMoZSwgdHlwZSk7XHJcblxyXG5cdFx0aWYgKGNhbnZhc1RhcmdldHMpIHtcclxuXHRcdFx0dmFyIGZpbHRlcmVkID0gW107IC8vIHBpY2sgb25seSB0YXJnZXRzIHdpdGggbGlzdGVuZXJzXHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2FudmFzVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmIChjYW52YXNUYXJnZXRzW2ldLmxpc3RlbnModHlwZSwgdHJ1ZSkpIHtcclxuXHRcdFx0XHRcdGZpbHRlcmVkLnB1c2goY2FudmFzVGFyZ2V0c1tpXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRhcmdldHMgPSBmaWx0ZXJlZC5jb25jYXQodGFyZ2V0cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0YXJnZXRzLmxlbmd0aCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAodHlwZSA9PT0gJ2NvbnRleHRtZW51Jykge1xyXG5cdFx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1swXTtcclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRvcmlnaW5hbEV2ZW50OiBlXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChlLnR5cGUgIT09ICdrZXlwcmVzcycgJiYgZS50eXBlICE9PSAna2V5ZG93bicgJiYgZS50eXBlICE9PSAna2V5dXAnKSB7XHJcblx0XHRcdHZhciBpc01hcmtlciA9IHRhcmdldC5nZXRMYXRMbmcgJiYgKCF0YXJnZXQuX3JhZGl1cyB8fCB0YXJnZXQuX3JhZGl1cyA8PSAxMCk7XHJcblx0XHRcdGRhdGEuY29udGFpbmVyUG9pbnQgPSBpc01hcmtlciA/XHJcblx0XHRcdFx0dGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHRhcmdldC5nZXRMYXRMbmcoKSkgOiB0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xyXG5cdFx0XHRkYXRhLmxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGRhdGEuY29udGFpbmVyUG9pbnQpO1xyXG5cdFx0XHRkYXRhLmxhdGxuZyA9IGlzTWFya2VyID8gdGFyZ2V0LmdldExhdExuZygpIDogdGhpcy5sYXllclBvaW50VG9MYXRMbmcoZGF0YS5sYXllclBvaW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0YXJnZXRzW2ldLmZpcmUodHlwZSwgZGF0YSwgdHJ1ZSk7XHJcblx0XHRcdGlmIChkYXRhLm9yaWdpbmFsRXZlbnQuX3N0b3BwZWQgfHxcclxuXHRcdFx0XHQodGFyZ2V0c1tpXS5vcHRpb25zLmJ1YmJsaW5nTW91c2VFdmVudHMgPT09IGZhbHNlICYmIFV0aWwuaW5kZXhPZih0aGlzLl9tb3VzZUV2ZW50cywgdHlwZSkgIT09IC0xKSkgeyByZXR1cm47IH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZHJhZ2dhYmxlTW92ZWQ6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdG9iaiA9IG9iai5kcmFnZ2luZyAmJiBvYmouZHJhZ2dpbmcuZW5hYmxlZCgpID8gb2JqIDogdGhpcztcclxuXHRcdHJldHVybiAob2JqLmRyYWdnaW5nICYmIG9iai5kcmFnZ2luZy5tb3ZlZCgpKSB8fCAodGhpcy5ib3hab29tICYmIHRoaXMuYm94Wm9vbS5tb3ZlZCgpKTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJIYW5kbGVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2hhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2hhbmRsZXJzW2ldLmRpc2FibGUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAc2VjdGlvbiBPdGhlciBNZXRob2RzXHJcblxyXG5cdC8vIEBtZXRob2Qgd2hlblJlYWR5KGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcclxuXHQvLyBSdW5zIHRoZSBnaXZlbiBmdW5jdGlvbiBgZm5gIHdoZW4gdGhlIG1hcCBnZXRzIGluaXRpYWxpemVkIHdpdGhcclxuXHQvLyBhIHZpZXcgKGNlbnRlciBhbmQgem9vbSkgYW5kIGF0IGxlYXN0IG9uZSBsYXllciwgb3IgaW1tZWRpYXRlbHlcclxuXHQvLyBpZiBpdCdzIGFscmVhZHkgaW5pdGlhbGl6ZWQsIG9wdGlvbmFsbHkgcGFzc2luZyBhIGZ1bmN0aW9uIGNvbnRleHQuXHJcblx0d2hlblJlYWR5OiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0Y2FsbGJhY2suY2FsbChjb250ZXh0IHx8IHRoaXMsIHt0YXJnZXQ6IHRoaXN9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMub24oJ2xvYWQnLCBjYWxsYmFjaywgY29udGV4dCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIGZvciBnZXR0aW5nIG1hcCBzdGF0ZVxyXG5cclxuXHRfZ2V0TWFwUGFuZVBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIERvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSkgfHwgbmV3IFBvaW50KDAsIDApO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKTtcclxuXHRcdHJldHVybiBwb3MgJiYgIXBvcy5lcXVhbHMoWzAsIDBdKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VG9wTGVmdFBvaW50OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgcGl4ZWxPcmlnaW4gPSBjZW50ZXIgJiYgem9vbSAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFx0dGhpcy5fZ2V0TmV3UGl4ZWxPcmlnaW4oY2VudGVyLCB6b29tKSA6XHJcblx0XHRcdHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKTtcclxuXHRcdHJldHVybiBwaXhlbE9yaWdpbi5zdWJ0cmFjdCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXROZXdQaXhlbE9yaWdpbjogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0dmFyIHZpZXdIYWxmID0gdGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChjZW50ZXIsIHpvb20pLl9zdWJ0cmFjdCh2aWV3SGFsZikuX2FkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpLl9yb3VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9sYXRMbmdUb05ld0xheWVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20sIGNlbnRlcikge1xyXG5cdFx0dmFyIHRvcExlZnQgPSB0aGlzLl9nZXROZXdQaXhlbE9yaWdpbihjZW50ZXIsIHpvb20pO1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdChsYXRsbmcsIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KTtcclxuXHR9LFxyXG5cclxuXHRfbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgem9vbSwgY2VudGVyKSB7XHJcblx0XHR2YXIgdG9wTGVmdCA9IHRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSk7XHJcblx0XHRyZXR1cm4gdG9Cb3VuZHMoW1xyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHRcdHRoaXMucHJvamVjdChsYXRMbmdCb3VuZHMuZ2V0Tm9ydGhXZXN0KCksIHpvb20pLl9zdWJ0cmFjdCh0b3BMZWZ0KSxcclxuXHRcdFx0dGhpcy5wcm9qZWN0KGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKSwgem9vbSkuX3N1YnRyYWN0KHRvcExlZnQpLFxyXG5cdFx0XHR0aGlzLnByb2plY3QobGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLCB6b29tKS5fc3VidHJhY3QodG9wTGVmdClcclxuXHRcdF0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIGxheWVyIHBvaW50IG9mIHRoZSBjdXJyZW50IGNlbnRlclxyXG5cdF9nZXRDZW50ZXJMYXllclBvaW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIG9mZnNldCBvZiB0aGUgc3BlY2lmaWVkIHBsYWNlIHRvIHRoZSBjdXJyZW50IGNlbnRlciBpbiBwaXhlbHNcclxuXHRfZ2V0Q2VudGVyT2Zmc2V0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKS5zdWJ0cmFjdCh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBjZW50ZXIgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRDZW50ZXI6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGJvdW5kcykge1xyXG5cclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBjZW50ZXI7IH1cclxuXHJcblx0XHR2YXIgY2VudGVyUG9pbnQgPSB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIHZpZXdCb3VuZHMgPSBuZXcgQm91bmRzKGNlbnRlclBvaW50LnN1YnRyYWN0KHZpZXdIYWxmKSwgY2VudGVyUG9pbnQuYWRkKHZpZXdIYWxmKSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fZ2V0Qm91bmRzT2Zmc2V0KHZpZXdCb3VuZHMsIGJvdW5kcywgem9vbSk7XHJcblxyXG5cdFx0Ly8gSWYgb2Zmc2V0IGlzIGxlc3MgdGhhbiBhIHBpeGVsLCBpZ25vcmUuXHJcblx0XHQvLyBUaGlzIHByZXZlbnRzIHVuc3RhYmxlIHByb2plY3Rpb25zIGZyb20gZ2V0dGluZyBpbnRvXHJcblx0XHQvLyBhbiBpbmZpbml0ZSBsb29wIG9mIHRpbnkgb2Zmc2V0cy5cclxuXHRcdGlmIChNYXRoLmFicyhvZmZzZXQueCkgPD0gMSAmJiBNYXRoLmFicyhvZmZzZXQueSkgPD0gMSkge1xyXG5cdFx0XHRyZXR1cm4gY2VudGVyO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnVucHJvamVjdChjZW50ZXJQb2ludC5hZGQob2Zmc2V0KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Ly8gYWRqdXN0IG9mZnNldCBmb3IgdmlldyB0byBnZXQgaW5zaWRlIGJvdW5kc1xyXG5cdF9saW1pdE9mZnNldDogZnVuY3Rpb24gKG9mZnNldCwgYm91bmRzKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gb2Zmc2V0OyB9XHJcblxyXG5cdFx0dmFyIHZpZXdCb3VuZHMgPSB0aGlzLmdldFBpeGVsQm91bmRzKCksXHJcblx0XHQgICAgbmV3Qm91bmRzID0gbmV3IEJvdW5kcyh2aWV3Qm91bmRzLm1pbi5hZGQob2Zmc2V0KSwgdmlld0JvdW5kcy5tYXguYWRkKG9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiBvZmZzZXQuYWRkKHRoaXMuX2dldEJvdW5kc09mZnNldChuZXdCb3VuZHMsIGJvdW5kcykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybnMgb2Zmc2V0IG5lZWRlZCBmb3IgcHhCb3VuZHMgdG8gZ2V0IGluc2lkZSBtYXhCb3VuZHMgYXQgYSBzcGVjaWZpZWQgem9vbVxyXG5cdF9nZXRCb3VuZHNPZmZzZXQ6IGZ1bmN0aW9uIChweEJvdW5kcywgbWF4Qm91bmRzLCB6b29tKSB7XHJcblx0XHR2YXIgcHJvamVjdGVkTWF4Qm91bmRzID0gdG9Cb3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMucHJvamVjdChtYXhCb3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgICAgICB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldFNvdXRoV2VzdCgpLCB6b29tKVxyXG5cdFx0ICAgICksXHJcblx0XHQgICAgbWluT2Zmc2V0ID0gcHJvamVjdGVkTWF4Qm91bmRzLm1pbi5zdWJ0cmFjdChweEJvdW5kcy5taW4pLFxyXG5cdFx0ICAgIG1heE9mZnNldCA9IHByb2plY3RlZE1heEJvdW5kcy5tYXguc3VidHJhY3QocHhCb3VuZHMubWF4KSxcclxuXHJcblx0XHQgICAgZHggPSB0aGlzLl9yZWJvdW5kKG1pbk9mZnNldC54LCAtbWF4T2Zmc2V0LngpLFxyXG5cdFx0ICAgIGR5ID0gdGhpcy5fcmVib3VuZChtaW5PZmZzZXQueSwgLW1heE9mZnNldC55KTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGR4LCBkeSk7XHJcblx0fSxcclxuXHJcblx0X3JlYm91bmQ6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xyXG5cdFx0cmV0dXJuIGxlZnQgKyByaWdodCA+IDAgP1xyXG5cdFx0XHRNYXRoLnJvdW5kKGxlZnQgLSByaWdodCkgLyAyIDpcclxuXHRcdFx0TWF0aC5tYXgoMCwgTWF0aC5jZWlsKGxlZnQpKSAtIE1hdGgubWF4KDAsIE1hdGguZmxvb3IocmlnaHQpKTtcclxuXHR9LFxyXG5cclxuXHRfbGltaXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIG1pbiA9IHRoaXMuZ2V0TWluWm9vbSgpLFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuZ2V0TWF4Wm9vbSgpLFxyXG5cdFx0ICAgIHNuYXAgPSBCcm93c2VyLmFueTNkID8gdGhpcy5vcHRpb25zLnpvb21TbmFwIDogMTtcclxuXHRcdGlmIChzbmFwKSB7XHJcblx0XHRcdHpvb20gPSBNYXRoLnJvdW5kKHpvb20gLyBzbmFwKSAqIHNuYXA7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9LFxyXG5cclxuXHRfb25QYW5UcmFuc2l0aW9uU3RlcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblx0fSxcclxuXHJcblx0X29uUGFuVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG5cdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0X3RyeUFuaW1hdGVkUGFuOiBmdW5jdGlvbiAoY2VudGVyLCBvcHRpb25zKSB7XHJcblx0XHQvLyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG5ldyBhbmQgY3VycmVudCBjZW50ZXJzIGluIHBpeGVsc1xyXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl90cnVuYygpO1xyXG5cclxuXHRcdC8vIGRvbid0IGFuaW1hdGUgdG9vIGZhciB1bmxlc3MgYW5pbWF0ZTogdHJ1ZSBzcGVjaWZpZWQgaW4gb3B0aW9uc1xyXG5cdFx0aWYgKChvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0ZSkgIT09IHRydWUgJiYgIXRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKG9mZnNldCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0dGhpcy5wYW5CeShvZmZzZXQsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVBbmltUHJveHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcHJveHkgPSB0aGlzLl9wcm94eSA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1wcm94eSBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHRcdHRoaXMuX3BhbmVzLm1hcFBhbmUuYXBwZW5kQ2hpbGQocHJveHkpO1xyXG5cclxuXHRcdHRoaXMub24oJ3pvb21hbmltJywgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0dmFyIHByb3AgPSBEb21VdGlsLlRSQU5TRk9STSxcclxuXHRcdFx0ICAgIHRyYW5zZm9ybSA9IHRoaXMuX3Byb3h5LnN0eWxlW3Byb3BdO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0odGhpcy5fcHJveHksIHRoaXMucHJvamVjdChlLmNlbnRlciwgZS56b29tKSwgdGhpcy5nZXRab29tU2NhbGUoZS56b29tLCAxKSk7XHJcblxyXG5cdFx0XHQvLyB3b3JrYXJvdW5kIGZvciBjYXNlIHdoZW4gdHJhbnNmb3JtIGlzIHRoZSBzYW1lIGFuZCBzbyB0cmFuc2l0aW9uZW5kIGV2ZW50IGlzIG5vdCBmaXJlZFxyXG5cdFx0XHRpZiAodHJhbnNmb3JtID09PSB0aGlzLl9wcm94eS5zdHlsZVtwcm9wXSAmJiB0aGlzLl9hbmltYXRpbmdab29tKSB7XHJcblx0XHRcdFx0dGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLm9uKCdsb2FkIG1vdmVlbmQnLCB0aGlzLl9hbmltTW92ZUVuZCwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fb24oJ3VubG9hZCcsIHRoaXMuX2Rlc3Ryb3lBbmltUHJveHksIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9kZXN0cm95QW5pbVByb3h5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9wcm94eSk7XHJcblx0XHR0aGlzLm9mZignbG9hZCBtb3ZlZW5kJywgdGhpcy5fYW5pbU1vdmVFbmQsIHRoaXMpO1xyXG5cdFx0ZGVsZXRlIHRoaXMuX3Byb3h5O1xyXG5cdH0sXHJcblxyXG5cdF9hbmltTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGMgPSB0aGlzLmdldENlbnRlcigpLFxyXG5cdFx0ICAgIHogPSB0aGlzLmdldFpvb20oKTtcclxuXHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX3Byb3h5LCB0aGlzLnByb2plY3QoYywgeiksIHRoaXMuZ2V0Wm9vbVNjYWxlKHosIDEpKTtcclxuXHR9LFxyXG5cclxuXHRfY2F0Y2hUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20gJiYgZS5wcm9wZXJ0eU5hbWUuaW5kZXhPZigndHJhbnNmb3JtJykgPj0gMCkge1xyXG5cdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X25vdGhpbmdUb0FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpLmxlbmd0aDtcclxuXHR9LFxyXG5cclxuXHRfdHJ5QW5pbWF0ZWRab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIGRpc2FibGVkLCBub3Qgc3VwcG9ydGVkIG9yIHpvb20gZGlmZmVyZW5jZSBpcyB0b28gbGFyZ2VcclxuXHRcdGlmICghdGhpcy5fem9vbUFuaW1hdGVkIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgdGhpcy5fbm90aGluZ1RvQW5pbWF0ZSgpIHx8XHJcblx0XHQgICAgICAgIE1hdGguYWJzKHpvb20gLSB0aGlzLl96b29tKSA+IHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uVGhyZXNob2xkKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdC8vIG9mZnNldCBpcyB0aGUgcGl4ZWwgY29vcmRzIG9mIHRoZSB6b29tIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjZW50ZXJcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl9kaXZpZGVCeSgxIC0gMSAvIHNjYWxlKTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIHRoZSB6b29tIG9yaWdpbiBpc24ndCB3aXRoaW4gb25lIHNjcmVlbiBmcm9tIHRoZSBjdXJyZW50IGNlbnRlciwgdW5sZXNzIGZvcmNlZFxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdCAgICAuX21vdmVTdGFydCh0cnVlLCBvcHRpb25zLm5vTW92ZVN0YXJ0IHx8IGZhbHNlKVxyXG5cdFx0XHQgICAgLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRydWUpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBzdGFydEFuaW0sIG5vVXBkYXRlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcFBhbmUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHN0YXJ0QW5pbSkge1xyXG5cdFx0XHR0aGlzLl9hbmltYXRpbmdab29tID0gdHJ1ZTtcclxuXHJcblx0XHRcdC8vIHJlbWVtYmVyIHdoYXQgY2VudGVyL3pvb20gdG8gc2V0IGFmdGVyIGFuaW1hdGlvblxyXG5cdFx0XHR0aGlzLl9hbmltYXRlVG9DZW50ZXIgPSBjZW50ZXI7XHJcblx0XHRcdHRoaXMuX2FuaW1hdGVUb1pvb20gPSB6b29tO1xyXG5cclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAc2VjdGlvbiBPdGhlciBFdmVudHNcclxuXHRcdC8vIEBldmVudCB6b29tYW5pbTogWm9vbUFuaW1FdmVudFxyXG5cdFx0Ly8gRmlyZWQgYXQgbGVhc3Qgb25jZSBwZXIgem9vbSBhbmltYXRpb24uIEZvciBjb250aW51b3VzIHpvb20sIGxpa2UgcGluY2ggem9vbWluZywgZmlyZWQgb25jZSBwZXIgZnJhbWUgZHVyaW5nIHpvb20uXHJcblx0XHR0aGlzLmZpcmUoJ3pvb21hbmltJywge1xyXG5cdFx0XHRjZW50ZXI6IGNlbnRlcixcclxuXHRcdFx0em9vbTogem9vbSxcclxuXHRcdFx0bm9VcGRhdGU6IG5vVXBkYXRlXHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50KSB7XHJcblx0XHRcdHRoaXMuX3RlbXBGaXJlWm9vbUV2ZW50ID0gdGhpcy5fem9vbSAhPT0gdGhpcy5fYW5pbWF0ZVRvWm9vbTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tb3ZlKHRoaXMuX2FuaW1hdGVUb0NlbnRlciwgdGhpcy5fYW5pbWF0ZVRvWm9vbSwgdW5kZWZpbmVkLCB0cnVlKTtcclxuXHJcblx0XHQvLyBXb3JrIGFyb3VuZCB3ZWJraXQgbm90IGZpcmluZyAndHJhbnNpdGlvbmVuZCcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zNjg5LCAyNjkzXHJcblx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kLCB0aGlzKSwgMjUwKTtcclxuXHR9LFxyXG5cclxuXHRfb25ab29tVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9tYXBQYW5lKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX21vdmUodGhpcy5fYW5pbWF0ZVRvQ2VudGVyLCB0aGlzLl9hbmltYXRlVG9ab29tLCB1bmRlZmluZWQsIHRydWUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl90ZW1wRmlyZVpvb21FdmVudCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb20nKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSB0aGlzLl90ZW1wRmlyZVpvb21FdmVudDtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcblx0XHR0aGlzLl9tb3ZlRW5kKHRydWUpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAc2VjdGlvblxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXAoaWQ6IFN0cmluZywgb3B0aW9ucz86IE1hcCBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBtYXAgb2JqZWN0IGdpdmVuIHRoZSBET00gSUQgb2YgYSBgPGRpdj5gIGVsZW1lbnRcclxuLy8gYW5kIG9wdGlvbmFsbHkgYW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBgTWFwIG9wdGlvbnNgLlxyXG4vL1xyXG4vLyBAYWx0ZXJuYXRpdmVcclxuLy8gQGZhY3RvcnkgTC5tYXAoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zPzogTWFwIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIG1hcCBvYmplY3QgZ2l2ZW4gYW4gaW5zdGFuY2Ugb2YgYSBgPGRpdj5gIEhUTUwgZWxlbWVudFxyXG4vLyBhbmQgb3B0aW9uYWxseSBhbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGBNYXAgb3B0aW9uc2AuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNYXAoaWQsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IE1hcChpZCwgb3B0aW9ucyk7XHJcbn1cclxuIiwiXHJcbmltcG9ydCB7Q2xhc3N9IGZyb20gJy4uL2NvcmUvQ2xhc3MnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbFxyXG4gKiBAYWthIEwuQ29udHJvbFxyXG4gKiBAaW5oZXJpdHMgQ2xhc3NcclxuICpcclxuICogTC5Db250cm9sIGlzIGEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIG1hcCBjb250cm9scy4gSGFuZGxlcyBwb3NpdGlvbmluZy5cclxuICogQWxsIG90aGVyIGNvbnRyb2xzIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBDb250cm9sID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbCBPcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBwb3NpdGlvbjogU3RyaW5nID0gJ3RvcHJpZ2h0J1xyXG5cdFx0Ly8gVGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sIChvbmUgb2YgdGhlIG1hcCBjb3JuZXJzKS4gUG9zc2libGUgdmFsdWVzIGFyZSBgJ3RvcGxlZnQnYCxcclxuXHRcdC8vIGAndG9wcmlnaHQnYCwgYCdib3R0b21sZWZ0J2Agb3IgYCdib3R0b21yaWdodCdgXHJcblx0XHRwb3NpdGlvbjogJ3RvcHJpZ2h0J1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKiBDbGFzc2VzIGV4dGVuZGluZyBMLkNvbnRyb2wgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgZ2V0UG9zaXRpb246IHN0cmluZ1xyXG5cdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLlxyXG5cdCAqL1xyXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UG9zaXRpb24ocG9zaXRpb246IHN0cmluZyk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLnJlbW92ZUNvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAuYWRkQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldENvbnRhaW5lcjogSFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBIVE1MRWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBjb250cm9sLlxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZFRvKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGNvbnRyb2wgdG8gdGhlIGdpdmVuIG1hcC5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5yZW1vdmUoKTtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApLFxyXG5cdFx0ICAgIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcclxuXHRcdCAgICBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XHJcblxyXG5cdFx0RG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wnKTtcclxuXHJcblx0XHRpZiAocG9zLmluZGV4T2YoJ2JvdHRvbScpICE9PSAtMSkge1xyXG5cdFx0XHRjb3JuZXIuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgY29ybmVyLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29ybmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwLm9uKCd1bmxvYWQnLCB0aGlzLnJlbW92ZSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmU6IHRoaXNcclxuXHQvLyBSZW1vdmVzIHRoZSBjb250cm9sIGZyb20gdGhlIG1hcCBpdCBpcyBjdXJyZW50bHkgYWN0aXZlIG9uLlxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5vblJlbW92ZSkge1xyXG5cdFx0XHR0aGlzLm9uUmVtb3ZlKHRoaXMuX21hcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwLm9mZigndW5sb2FkJywgdGhpcy5yZW1vdmUsIHRoaXMpO1xyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmVmb2N1c09uTWFwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Ly8gaWYgbWFwIGV4aXN0cyBhbmQgZXZlbnQgaXMgbm90IGEga2V5Ym9hcmQgZXZlbnRcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgZSAmJiBlLnNjcmVlblggPiAwICYmIGUuc2NyZWVuWSA+IDApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbmV4cG9ydCB2YXIgY29udHJvbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBDb250cm9sKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuLyogQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuICogQHVuaW5oZXJpdGFibGVcclxuICpcclxuICogRXZlcnkgY29udHJvbCBzaG91bGQgZXh0ZW5kIGZyb20gYEwuQ29udHJvbGAgYW5kIChyZS0paW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgbWV0aG9kcy5cclxuICpcclxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IEhUTUxFbGVtZW50XHJcbiAqIFNob3VsZCByZXR1cm4gdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wgYW5kIGFkZCBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy4gQ2FsbGVkIG9uIFtgY29udHJvbC5hZGRUbyhtYXApYF0oI2NvbnRyb2wtYWRkVG8pLlxyXG4gKlxyXG4gKiBAbWV0aG9kIG9uUmVtb3ZlKG1hcDogTWFwKVxyXG4gKiBPcHRpb25hbCBtZXRob2QuIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNjb250cm9sLW9uYWRkKS4gQ2FsbGVkIG9uIFtgY29udHJvbC5yZW1vdmUoKWBdKCNjb250cm9sLXJlbW92ZSkuXHJcbiAqL1xyXG5cclxuLyogQG5hbWVzcGFjZSBNYXBcclxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xyXG4gKi9cclxuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2QgYWRkQ29udHJvbChjb250cm9sOiBDb250cm9sKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGNvbnRyb2wgdG8gdGhlIG1hcFxyXG5cdGFkZENvbnRyb2w6IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcblx0XHRjb250cm9sLmFkZFRvKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVDb250cm9sKGNvbnRyb2w6IENvbnRyb2wpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gY29udHJvbCBmcm9tIHRoZSBtYXBcclxuXHRyZW1vdmVDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5yZW1vdmUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0Q29udHJvbFBvczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvcm5lcnMgPSB0aGlzLl9jb250cm9sQ29ybmVycyA9IHt9LFxyXG5cdFx0ICAgIGwgPSAnbGVhZmxldC0nLFxyXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRyb2xDb250YWluZXIgPVxyXG5cdFx0ICAgICAgICAgICAgRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGwgKyAnY29udHJvbC1jb250YWluZXInLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvcm5lcih2U2lkZSwgaFNpZGUpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGwgKyB2U2lkZSArICcgJyArIGwgKyBoU2lkZTtcclxuXHJcblx0XHRcdGNvcm5lcnNbdlNpZGUgKyBoU2lkZV0gPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ3JpZ2h0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdyaWdodCcpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckNvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fY29udHJvbENvcm5lcnMpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udHJvbENvcm5lcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udHJvbENvbnRhaW5lcik7XHJcblx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvcm5lcnM7XHJcblx0XHRkZWxldGUgdGhpcy5fY29udHJvbENvbnRhaW5lcjtcclxuXHR9XHJcbn0pO1xyXG4iLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuLypcclxuICogQGNsYXNzIENvbnRyb2wuTGF5ZXJzXHJcbiAqIEBha2EgTC5Db250cm9sLkxheWVyc1xyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgbGF5ZXJzIGNvbnRyb2wgZ2l2ZXMgdXNlcnMgdGhlIGFiaWxpdHkgdG8gc3dpdGNoIGJldHdlZW4gZGlmZmVyZW50IGJhc2UgbGF5ZXJzIGFuZCBzd2l0Y2ggb3ZlcmxheXMgb24vb2ZmIChjaGVjayBvdXQgdGhlIFtkZXRhaWxlZCBleGFtcGxlXShodHRwczovL2xlYWZsZXRqcy5jb20vZXhhbXBsZXMvbGF5ZXJzLWNvbnRyb2wvKSkuIEV4dGVuZHMgYENvbnRyb2xgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgYmFzZUxheWVycyA9IHtcclxuICogXHRcIk1hcGJveFwiOiBtYXBib3gsXHJcbiAqIFx0XCJPcGVuU3RyZWV0TWFwXCI6IG9zbVxyXG4gKiB9O1xyXG4gKlxyXG4gKiB2YXIgb3ZlcmxheXMgPSB7XHJcbiAqIFx0XCJNYXJrZXJcIjogbWFya2VyLFxyXG4gKiBcdFwiUm9hZHNcIjogcm9hZHNMYXllclxyXG4gKiB9O1xyXG4gKlxyXG4gKiBMLmNvbnRyb2wubGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogVGhlIGBiYXNlTGF5ZXJzYCBhbmQgYG92ZXJsYXlzYCBwYXJhbWV0ZXJzIGFyZSBvYmplY3QgbGl0ZXJhbHMgd2l0aCBsYXllciBuYW1lcyBhcyBrZXlzIGFuZCBgTGF5ZXJgIG9iamVjdHMgYXMgdmFsdWVzOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB7XHJcbiAqICAgICBcIjxzb21lTmFtZTE+XCI6IGxheWVyMSxcclxuICogICAgIFwiPHNvbWVOYW1lMj5cIjogbGF5ZXIyXHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIFRoZSBsYXllciBuYW1lcyBjYW4gY29udGFpbiBIVE1MLCB3aGljaCBhbGxvd3MgeW91IHRvIGFkZCBhZGRpdGlvbmFsIHN0eWxpbmcgdG8gdGhlIGl0ZW1zOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB7XCI8aW1nIHNyYz0nbXktbGF5ZXItaWNvbicgLz4gPHNwYW4gY2xhc3M9J215LWxheWVyLWl0ZW0nPk15IExheWVyPC9zcGFuPlwiOiBteUxheWVyfVxyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIExheWVycyA9IENvbnRyb2wuZXh0ZW5kKHtcclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgQ29udHJvbC5MYXllcnMgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gY29sbGFwc2VkOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgY29udHJvbCB3aWxsIGJlIGNvbGxhcHNlZCBpbnRvIGFuIGljb24gYW5kIGV4cGFuZGVkIG9uIG1vdXNlIGhvdmVyLCB0b3VjaCwgb3Iga2V5Ym9hcmQgYWN0aXZhdGlvbi5cclxuXHRcdGNvbGxhcHNlZDogdHJ1ZSxcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1pJbmRleDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIElmIGB0cnVlYCwgdGhlIGNvbnRyb2wgd2lsbCBhc3NpZ24gekluZGV4ZXMgaW4gaW5jcmVhc2luZyBvcmRlciB0byBhbGwgb2YgaXRzIGxheWVycyBzbyB0aGF0IHRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQgd2hlbiBzd2l0Y2hpbmcgdGhlbSBvbi9vZmYuXHJcblx0XHRhdXRvWkluZGV4OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gaGlkZVNpbmdsZUJhc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgYmFzZSBsYXllcnMgaW4gdGhlIGNvbnRyb2wgd2lsbCBiZSBoaWRkZW4gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZS5cclxuXHRcdGhpZGVTaW5nbGVCYXNlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNvcnRMYXllcnM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0byBzb3J0IHRoZSBsYXllcnMuIFdoZW4gYGZhbHNlYCwgbGF5ZXJzIHdpbGwga2VlcCB0aGUgb3JkZXJcclxuXHRcdC8vIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZCB0byB0aGUgY29udHJvbC5cclxuXHRcdHNvcnRMYXllcnM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gc29ydEZ1bmN0aW9uOiBGdW5jdGlvbiA9ICpcclxuXHRcdC8vIEEgW2NvbXBhcmUgZnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQpXHJcblx0XHQvLyB0aGF0IHdpbGwgYmUgdXNlZCBmb3Igc29ydGluZyB0aGUgbGF5ZXJzLCB3aGVuIGBzb3J0TGF5ZXJzYCBpcyBgdHJ1ZWAuXHJcblx0XHQvLyBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYm90aCB0aGUgYEwuTGF5ZXJgIGluc3RhbmNlcyBhbmQgdGhlaXIgbmFtZXMsIGFzIGluXHJcblx0XHQvLyBgc29ydEZ1bmN0aW9uKGxheWVyQSwgbGF5ZXJCLCBuYW1lQSwgbmFtZUIpYC5cclxuXHRcdC8vIEJ5IGRlZmF1bHQsIGl0IHNvcnRzIGxheWVycyBhbHBoYWJldGljYWxseSBieSB0aGVpciBuYW1lLlxyXG5cdFx0c29ydEZ1bmN0aW9uOiBmdW5jdGlvbiAobGF5ZXJBLCBsYXllckIsIG5hbWVBLCBuYW1lQikge1xyXG5cdFx0XHRyZXR1cm4gbmFtZUEgPCBuYW1lQiA/IC0xIDogKG5hbWVCIDwgbmFtZUEgPyAxIDogMCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzID0gW107XHJcblx0XHR0aGlzLl9sYXllcnMgPSBbXTtcclxuXHRcdHRoaXMuX2xhc3RaSW5kZXggPSAwO1xyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fcHJldmVudENsaWNrID0gZmFsc2U7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBiYXNlTGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKGJhc2VMYXllcnNbaV0sIGkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSBpbiBvdmVybGF5cykge1xyXG5cdFx0XHR0aGlzLl9hZGRMYXllcihvdmVybGF5c1tpXSwgaSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsIHRoaXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpXS5sYXllci5vbignYWRkIHJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdENvbnRyb2wucHJvdG90eXBlLmFkZFRvLmNhbGwodGhpcywgbWFwKTtcclxuXHRcdC8vIFRyaWdnZXIgZXhwYW5kIGFmdGVyIExheWVycyBDb250cm9sIGhhcyBiZWVuIGluc2VydGVkIGludG8gRE9NIHNvIHRoYXQgaXMgbm93IGhhcyBhbiBhY3R1YWwgaGVpZ2h0LlxyXG5cdFx0cmV0dXJuIHRoaXMuX2V4cGFuZElmTm90Q29sbGFwc2VkKCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzLCB0aGlzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzLl9sYXllcnNbaV0ubGF5ZXIub2ZmKCdhZGQgcmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRCYXNlTGF5ZXIobGF5ZXI6IExheWVyLCBuYW1lOiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhIGJhc2UgbGF5ZXIgKHJhZGlvIGJ1dHRvbiBlbnRyeSkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB0byB0aGUgY29udHJvbC5cclxuXHRhZGRCYXNlTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG5cdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUpO1xyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkT3ZlcmxheShsYXllcjogTGF5ZXIsIG5hbWU6IFN0cmluZyk6IHRoaXNcclxuXHQvLyBBZGRzIGFuIG92ZXJsYXkgKGNoZWNrYm94IGVudHJ5KSB3aXRoIHRoZSBnaXZlbiBuYW1lIHRvIHRoZSBjb250cm9sLlxyXG5cdGFkZE92ZXJsYXk6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG5cdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUsIHRydWUpO1xyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZSB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgY29udHJvbC5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRsYXllci5vZmYoJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoVXRpbC5zdGFtcChsYXllcikpO1xyXG5cdFx0aWYgKG9iaikge1xyXG5cdFx0XHR0aGlzLl9sYXllcnMuc3BsaWNlKHRoaXMuX2xheWVycy5pbmRleE9mKG9iaiksIDEpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuICh0aGlzLl9tYXApID8gdGhpcy5fdXBkYXRlKCkgOiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZXhwYW5kKCk6IHRoaXNcclxuXHQvLyBFeHBhbmQgdGhlIGNvbnRyb2wgY29udGFpbmVyIGlmIGNvbGxhcHNlZC5cclxuXHRleHBhbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xyXG5cdFx0dGhpcy5fc2VjdGlvbi5zdHlsZS5oZWlnaHQgPSBudWxsO1xyXG5cdFx0dmFyIGFjY2VwdGFibGVIZWlnaHQgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLnkgLSAodGhpcy5fY29udGFpbmVyLm9mZnNldFRvcCArIDUwKTtcclxuXHRcdGlmIChhY2NlcHRhYmxlSGVpZ2h0IDwgdGhpcy5fc2VjdGlvbi5jbGllbnRIZWlnaHQpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9zZWN0aW9uLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1zY3JvbGxiYXInKTtcclxuXHRcdFx0dGhpcy5fc2VjdGlvbi5zdHlsZS5oZWlnaHQgPSBhY2NlcHRhYmxlSGVpZ2h0ICsgJ3B4JztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fc2VjdGlvbiwgJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyJyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9jaGVja0Rpc2FibGVkTGF5ZXJzKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNvbGxhcHNlKCk6IHRoaXNcclxuXHQvLyBDb2xsYXBzZSB0aGUgY29udHJvbCBjb250YWluZXIgaWYgZXhwYW5kZWQuXHJcblx0Y29sbGFwc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycycsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSksXHJcblx0XHQgICAgY29sbGFwc2VkID0gdGhpcy5vcHRpb25zLmNvbGxhcHNlZDtcclxuXHJcblx0XHQvLyBtYWtlcyB0aGlzIHdvcmsgb24gSUUgdG91Y2ggZGV2aWNlcyBieSBzdG9wcGluZyBpdCBmcm9tIGZpcmluZyBhIG1vdXNlb3V0IGV2ZW50IHdoZW4gdGhlIHRvdWNoIGlzIHJlbGVhc2VkXHJcblx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgdHJ1ZSk7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHRcdERvbUV2ZW50LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cclxuXHRcdHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbiA9IERvbVV0aWwuY3JlYXRlKCdzZWN0aW9uJywgY2xhc3NOYW1lICsgJy1saXN0Jyk7XHJcblxyXG5cdFx0aWYgKGNvbGxhcHNlZCkge1xyXG5cdFx0XHR0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5jb2xsYXBzZSwgdGhpcyk7XHJcblxyXG5cdFx0XHREb21FdmVudC5vbihjb250YWluZXIsIHtcclxuXHRcdFx0XHRtb3VzZWVudGVyOiB0aGlzLl9leHBhbmRTYWZlbHksXHJcblx0XHRcdFx0bW91c2VsZWF2ZTogdGhpcy5jb2xsYXBzZVxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbGluayA9IHRoaXMuX2xheWVyc0xpbmsgPSBEb21VdGlsLmNyZWF0ZSgnYScsIGNsYXNzTmFtZSArICctdG9nZ2xlJywgY29udGFpbmVyKTtcclxuXHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdGxpbmsudGl0bGUgPSAnTGF5ZXJzJztcclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xyXG5cclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssIHtcclxuXHRcdFx0a2V5ZG93bjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRpZiAoZS5rZXlDb2RlID09PSAxMykge1xyXG5cdFx0XHRcdFx0dGhpcy5fZXhwYW5kU2FmZWx5KCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHQvLyBDZXJ0YWluIHNjcmVlbiByZWFkZXJzIGludGVyY2VwdCB0aGUga2V5IGV2ZW50IGFuZCBpbnN0ZWFkIHNlbmQgYSBjbGljayBldmVudFxyXG5cdFx0XHRjbGljazogZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdFx0XHR0aGlzLl9leHBhbmRTYWZlbHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKCFjb2xsYXBzZWQpIHtcclxuXHRcdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9iYXNlTGF5ZXJzTGlzdCA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLWJhc2UnLCBzZWN0aW9uKTtcclxuXHRcdHRoaXMuX3NlcGFyYXRvciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLXNlcGFyYXRvcicsIHNlY3Rpb24pO1xyXG5cdFx0dGhpcy5fb3ZlcmxheXNMaXN0ID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctb3ZlcmxheXMnLCBzZWN0aW9uKTtcclxuXHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc2VjdGlvbik7XHJcblx0fSxcclxuXHJcblx0X2dldExheWVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5fbGF5ZXJzW2ldICYmIFV0aWwuc3RhbXAodGhpcy5fbGF5ZXJzW2ldLmxheWVyKSA9PT0gaWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5hbWUsIG92ZXJsYXkpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0bGF5ZXIub24oJ2FkZCByZW1vdmUnLCB0aGlzLl9vbkxheWVyQ2hhbmdlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9sYXllcnMucHVzaCh7XHJcblx0XHRcdGxheWVyOiBsYXllcixcclxuXHRcdFx0bmFtZTogbmFtZSxcclxuXHRcdFx0b3ZlcmxheTogb3ZlcmxheVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5zb3J0TGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2xheWVycy5zb3J0KFV0aWwuYmluZChmdW5jdGlvbiAoYSwgYikge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc29ydEZ1bmN0aW9uKGEubGF5ZXIsIGIubGF5ZXIsIGEubmFtZSwgYi5uYW1lKTtcclxuXHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1pJbmRleCAmJiBsYXllci5zZXRaSW5kZXgpIHtcclxuXHRcdFx0dGhpcy5fbGFzdFpJbmRleCsrO1xyXG5cdFx0XHRsYXllci5zZXRaSW5kZXgodGhpcy5fbGFzdFpJbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdERvbVV0aWwuZW1wdHkodGhpcy5fYmFzZUxheWVyc0xpc3QpO1xyXG5cdFx0RG9tVXRpbC5lbXB0eSh0aGlzLl9vdmVybGF5c0xpc3QpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cyA9IFtdO1xyXG5cdFx0dmFyIGJhc2VMYXllcnNQcmVzZW50LCBvdmVybGF5c1ByZXNlbnQsIGksIG9iaiwgYmFzZUxheWVyc0NvdW50ID0gMDtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHRcdFx0dGhpcy5fYWRkSXRlbShvYmopO1xyXG5cdFx0XHRvdmVybGF5c1ByZXNlbnQgPSBvdmVybGF5c1ByZXNlbnQgfHwgb2JqLm92ZXJsYXk7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgfHwgIW9iai5vdmVybGF5O1xyXG5cdFx0XHRiYXNlTGF5ZXJzQ291bnQgKz0gIW9iai5vdmVybGF5ID8gMSA6IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSGlkZSBiYXNlIGxheWVycyBzZWN0aW9uIGlmIHRoZXJlJ3Mgb25seSBvbmUgbGF5ZXIuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmhpZGVTaW5nbGVCYXNlKSB7XHJcblx0XHRcdGJhc2VMYXllcnNQcmVzZW50ID0gYmFzZUxheWVyc1ByZXNlbnQgJiYgYmFzZUxheWVyc0NvdW50ID4gMTtcclxuXHRcdFx0dGhpcy5fYmFzZUxheWVyc0xpc3Quc3R5bGUuZGlzcGxheSA9IGJhc2VMYXllcnNQcmVzZW50ID8gJycgOiAnbm9uZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc2VwYXJhdG9yLnN0eWxlLmRpc3BsYXkgPSBvdmVybGF5c1ByZXNlbnQgJiYgYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfb25MYXllckNoYW5nZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5faGFuZGxpbmdDbGljaykge1xyXG5cdFx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb2JqID0gdGhpcy5fZ2V0TGF5ZXIoVXRpbC5zdGFtcChlLnRhcmdldCkpO1xyXG5cclxuXHRcdC8vIEBuYW1lc3BhY2UgTWFwXHJcblx0XHQvLyBAc2VjdGlvbiBMYXllciBldmVudHNcclxuXHRcdC8vIEBldmVudCBiYXNlbGF5ZXJjaGFuZ2U6IExheWVyc0NvbnRyb2xFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgYmFzZSBsYXllciBpcyBjaGFuZ2VkIHRocm91Z2ggdGhlIFtsYXllcnMgY29udHJvbF0oI2NvbnRyb2wtbGF5ZXJzKS5cclxuXHRcdC8vIEBldmVudCBvdmVybGF5YWRkOiBMYXllcnNDb250cm9sRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYW4gb3ZlcmxheSBpcyBzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXJzIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAZXZlbnQgb3ZlcmxheXJlbW92ZTogTGF5ZXJzQ29udHJvbEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGFuIG92ZXJsYXkgaXMgZGVzZWxlY3RlZCB0aHJvdWdoIHRoZSBbbGF5ZXJzIGNvbnRyb2xdKCNjb250cm9sLWxheWVycykuXHJcblx0XHQvLyBAbmFtZXNwYWNlIENvbnRyb2wuTGF5ZXJzXHJcblx0XHR2YXIgdHlwZSA9IG9iai5vdmVybGF5ID9cclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnb3ZlcmxheWFkZCcgOiAnb3ZlcmxheXJlbW92ZScpIDpcclxuXHRcdFx0KGUudHlwZSA9PT0gJ2FkZCcgPyAnYmFzZWxheWVyY2hhbmdlJyA6IG51bGwpO1xyXG5cclxuXHRcdGlmICh0eXBlKSB7XHJcblx0XHRcdHRoaXMuX21hcC5maXJlKHR5cGUsIG9iaik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gSUU3IGJ1Z3Mgb3V0IGlmIHlvdSBjcmVhdGUgYSByYWRpbyBkeW5hbWljYWxseSwgc28geW91IGhhdmUgdG8gZG8gaXQgdGhpcyBoYWNreSB3YXkgKHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTE5MDc5KVxyXG5cdF9jcmVhdGVSYWRpb0VsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lLCBjaGVja2VkKSB7XHJcblxyXG5cdFx0dmFyIHJhZGlvSHRtbCA9ICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicgK1xyXG5cdFx0XHRcdG5hbWUgKyAnXCInICsgKGNoZWNrZWQgPyAnIGNoZWNrZWQ9XCJjaGVja2VkXCInIDogJycpICsgJy8+JztcclxuXHJcblx0XHR2YXIgcmFkaW9GcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cdFx0cmFkaW9GcmFnbWVudC5pbm5lckhUTUwgPSByYWRpb0h0bWw7XHJcblxyXG5cdFx0cmV0dXJuIHJhZGlvRnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuXHR9LFxyXG5cclxuXHRfYWRkSXRlbTogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0dmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSxcclxuXHRcdCAgICBjaGVja2VkID0gdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllciksXHJcblx0XHQgICAgaW5wdXQ7XHJcblxyXG5cdFx0aWYgKG9iai5vdmVybGF5KSB7XHJcblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuXHRcdFx0aW5wdXQudHlwZSA9ICdjaGVja2JveCc7XHJcblx0XHRcdGlucHV0LmNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yJztcclxuXHRcdFx0aW5wdXQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW5wdXQgPSB0aGlzLl9jcmVhdGVSYWRpb0VsZW1lbnQoJ2xlYWZsZXQtYmFzZS1sYXllcnNfJyArIFV0aWwuc3RhbXAodGhpcyksIGNoZWNrZWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2xheWVyQ29udHJvbElucHV0cy5wdXNoKGlucHV0KTtcclxuXHRcdGlucHV0LmxheWVySWQgPSBVdGlsLnN0YW1wKG9iai5sYXllcik7XHJcblxyXG5cdFx0RG9tRXZlbnQub24oaW5wdXQsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyk7XHJcblxyXG5cdFx0dmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcblx0XHRuYW1lLmlubmVySFRNTCA9ICcgJyArIG9iai5uYW1lO1xyXG5cclxuXHRcdC8vIEhlbHBzIGZyb20gcHJldmVudGluZyBsYXllciBjb250cm9sIGZsaWNrZXIgd2hlbiBjaGVja2JveGVzIGFyZSBkaXNhYmxlZFxyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMjc3MVxyXG5cdFx0dmFyIGhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuXHJcblx0XHRsYWJlbC5hcHBlbmRDaGlsZChob2xkZXIpO1xyXG5cdFx0aG9sZGVyLmFwcGVuZENoaWxkKGlucHV0KTtcclxuXHRcdGhvbGRlci5hcHBlbmRDaGlsZChuYW1lKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gb2JqLm92ZXJsYXkgPyB0aGlzLl9vdmVybGF5c0xpc3QgOiB0aGlzLl9iYXNlTGF5ZXJzTGlzdDtcclxuXHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XHJcblxyXG5cdFx0dGhpcy5fY2hlY2tEaXNhYmxlZExheWVycygpO1xyXG5cdFx0cmV0dXJuIGxhYmVsO1xyXG5cdH0sXHJcblxyXG5cdF9vbklucHV0Q2xpY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIGV4cGFuZGluZyB0aGUgY29udHJvbCBvbiBtb2JpbGUgd2l0aCBhIGNsaWNrIGNhbiBjYXVzZSBhZGRpbmcgYSBsYXllciAtIHdlIGRvbid0IHdhbnQgdGhpc1xyXG5cdFx0aWYgKHRoaXMuX3ByZXZlbnRDbGljaykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuXHRcdCAgICBpbnB1dCwgbGF5ZXI7XHJcblx0XHR2YXIgYWRkZWRMYXllcnMgPSBbXSxcclxuXHRcdCAgICByZW1vdmVkTGF5ZXJzID0gW107XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IGlucHV0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRpbnB1dCA9IGlucHV0c1tpXTtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9nZXRMYXllcihpbnB1dC5sYXllcklkKS5sYXllcjtcclxuXHJcblx0XHRcdGlmIChpbnB1dC5jaGVja2VkKSB7XHJcblx0XHRcdFx0YWRkZWRMYXllcnMucHVzaChsYXllcik7XHJcblx0XHRcdH0gZWxzZSBpZiAoIWlucHV0LmNoZWNrZWQpIHtcclxuXHRcdFx0XHRyZW1vdmVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQnVnZml4IGlzc3VlIDIzMTg6IFNob3VsZCByZW1vdmUgYWxsIG9sZCBsYXllcnMgYmVmb3JlIHJlYWRkaW5nIG5ldyBvbmVzXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlZExheWVycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHJlbW92ZWRMYXllcnNbaV0pKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHJlbW92ZWRMYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgYWRkZWRMYXllcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKCF0aGlzLl9tYXAuaGFzTGF5ZXIoYWRkZWRMYXllcnNbaV0pKSB7XHJcblx0XHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKGFkZGVkTGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLl9yZWZvY3VzT25NYXAoKTtcclxuXHR9LFxyXG5cclxuXHRfY2hlY2tEaXNhYmxlZExheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGlucHV0cyA9IHRoaXMuX2xheWVyQ29udHJvbElucHV0cyxcclxuXHRcdCAgICBpbnB1dCxcclxuXHRcdCAgICBsYXllcixcclxuXHRcdCAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gaW5wdXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2dldExheWVyKGlucHV0LmxheWVySWQpLmxheWVyO1xyXG5cdFx0XHRpbnB1dC5kaXNhYmxlZCA9IChsYXllci5vcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tIDwgbGF5ZXIub3B0aW9ucy5taW5ab29tKSB8fFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgIChsYXllci5vcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCAmJiB6b29tID4gbGF5ZXIub3B0aW9ucy5tYXhab29tKTtcclxuXHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2V4cGFuZElmTm90Q29sbGFwc2VkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwICYmICF0aGlzLm9wdGlvbnMuY29sbGFwc2VkKSB7XHJcblx0XHRcdHRoaXMuZXhwYW5kKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfZXhwYW5kU2FmZWx5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb247XHJcblx0XHR0aGlzLl9wcmV2ZW50Q2xpY2sgPSB0cnVlO1xyXG5cdFx0RG9tRXZlbnQub24oc2VjdGlvbiwgJ2NsaWNrJywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdFx0dGhpcy5leHBhbmQoKTtcclxuXHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHREb21FdmVudC5vZmYoc2VjdGlvbiwgJ2NsaWNrJywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG5cdFx0XHR0aGF0Ll9wcmV2ZW50Q2xpY2sgPSBmYWxzZTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC5sYXllcnMoYmFzZWxheWVycz86IE9iamVjdCwgb3ZlcmxheXM/OiBPYmplY3QsIG9wdGlvbnM/OiBDb250cm9sLkxheWVycyBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgbGF5ZXJzIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gbGF5ZXJzLiBCYXNlIGxheWVycyB3aWxsIGJlIHN3aXRjaGVkIHdpdGggcmFkaW8gYnV0dG9ucywgd2hpbGUgb3ZlcmxheXMgd2lsbCBiZSBzd2l0Y2hlZCB3aXRoIGNoZWNrYm94ZXMuIE5vdGUgdGhhdCBhbGwgYmFzZSBsYXllcnMgc2hvdWxkIGJlIHBhc3NlZCBpbiB0aGUgYmFzZSBsYXllcnMgb2JqZWN0LCBidXQgb25seSBvbmUgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBtYXAgZHVyaW5nIG1hcCBpbnN0YW50aWF0aW9uLlxyXG5leHBvcnQgdmFyIGxheWVycyA9IGZ1bmN0aW9uIChiYXNlTGF5ZXJzLCBvdmVybGF5cywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTGF5ZXJzKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKTtcclxufTtcclxuIiwiXHJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcclxuaW1wb3J0IHtNYXB9IGZyb20gJy4uL21hcC9NYXAnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBDb250cm9sLlpvb21cclxuICogQGFrYSBMLkNvbnRyb2wuWm9vbVxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBBIGJhc2ljIHpvb20gY29udHJvbCB3aXRoIHR3byBidXR0b25zICh6b29tIGluIGFuZCB6b29tIG91dCkuIEl0IGlzIHB1dCBvbiB0aGUgbWFwIGJ5IGRlZmF1bHQgdW5sZXNzIHlvdSBzZXQgaXRzIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgdG8gYGZhbHNlYC4gRXh0ZW5kcyBgQ29udHJvbGAuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBab29tID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLlpvb20gb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAndG9wbGVmdCcsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tSW5UZXh0OiBTdHJpbmcgPSAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+Kzwvc3Bhbj4nXHJcblx0XHQvLyBUaGUgdGV4dCBzZXQgb24gdGhlICd6b29tIGluJyBidXR0b24uXHJcblx0XHR6b29tSW5UZXh0OiAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+Kzwvc3Bhbj4nLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbUluVGl0bGU6IFN0cmluZyA9ICdab29tIGluJ1xyXG5cdFx0Ly8gVGhlIHRpdGxlIHNldCBvbiB0aGUgJ3pvb20gaW4nIGJ1dHRvbi5cclxuXHRcdHpvb21JblRpdGxlOiAnWm9vbSBpbicsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGV4dDogU3RyaW5nID0gJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjeDIyMTI7PC9zcGFuPidcclxuXHRcdC8vIFRoZSB0ZXh0IHNldCBvbiB0aGUgJ3pvb20gb3V0JyBidXR0b24uXHJcblx0XHR6b29tT3V0VGV4dDogJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjeDIyMTI7PC9zcGFuPicsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB6b29tT3V0VGl0bGU6IFN0cmluZyA9ICdab29tIG91dCdcclxuXHRcdC8vIFRoZSB0aXRsZSBzZXQgb24gdGhlICd6b29tIG91dCcgYnV0dG9uLlxyXG5cdFx0em9vbU91dFRpdGxlOiAnWm9vbSBvdXQnXHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHZhciB6b29tTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtem9vbScsXHJcblx0XHQgICAgY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHpvb21OYW1lICsgJyBsZWFmbGV0LWJhcicpLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0dGhpcy5fem9vbUluQnV0dG9uICA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihvcHRpb25zLnpvb21JblRleHQsIG9wdGlvbnMuem9vbUluVGl0bGUsXHJcblx0XHQgICAgICAgIHpvb21OYW1lICsgJy1pbicsICBjb250YWluZXIsIHRoaXMuX3pvb21Jbik7XHJcblx0XHR0aGlzLl96b29tT3V0QnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKG9wdGlvbnMuem9vbU91dFRleHQsIG9wdGlvbnMuem9vbU91dFRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctb3V0JywgY29udGFpbmVyLCB0aGlzLl96b29tT3V0KTtcclxuXHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9mZignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX3VwZGF0ZURpc2FibGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3pvb21JbjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tIDwgdGhpcy5fbWFwLmdldE1heFpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbUluKHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSAqIChlLnNoaWZ0S2V5ID8gMyA6IDEpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfem9vbU91dDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fZGlzYWJsZWQgJiYgdGhpcy5fbWFwLl96b29tID4gdGhpcy5fbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHR0aGlzLl9tYXAuem9vbU91dCh0aGlzLl9tYXAub3B0aW9ucy56b29tRGVsdGEgKiAoZS5zaGlmdEtleSA/IDMgOiAxKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24gKGh0bWwsIHRpdGxlLCBjbGFzc05hbWUsIGNvbnRhaW5lciwgZm4pIHtcclxuXHRcdHZhciBsaW5rID0gRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHRsaW5rLmlubmVySFRNTCA9IGh0bWw7XHJcblx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRsaW5rLnRpdGxlID0gdGl0bGU7XHJcblxyXG5cdFx0LypcclxuXHRcdCAqIFdpbGwgZm9yY2Ugc2NyZWVuIHJlYWRlcnMgbGlrZSBWb2ljZU92ZXIgdG8gcmVhZCB0aGlzIGFzIFwiWm9vbSBpbiAtIGJ1dHRvblwiXHJcblx0XHQgKi9cclxuXHRcdGxpbmsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpO1xyXG5cdFx0bGluay5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aXRsZSk7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24obGluayk7XHJcblx0XHREb21FdmVudC5vbihsaW5rLCAnY2xpY2snLCBEb21FdmVudC5zdG9wKTtcclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIGZuLCB0aGlzKTtcclxuXHRcdERvbUV2ZW50Lm9uKGxpbmssICdjbGljaycsIHRoaXMuX3JlZm9jdXNPbk1hcCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGxpbms7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZURpc2FibGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWRpc2FibGVkJztcclxuXHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdHRoaXMuX3pvb21JbkJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcclxuXHRcdHRoaXMuX3pvb21PdXRCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2Rpc2FibGVkIHx8IG1hcC5fem9vbSA9PT0gbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHRcdHRoaXMuX3pvb21PdXRCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLl9kaXNhYmxlZCB8fCBtYXAuX3pvb20gPT09IG1hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl96b29tSW5CdXR0b24sIGNsYXNzTmFtZSk7XHJcblx0XHRcdHRoaXMuX3pvb21JbkJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcFxyXG4vLyBAc2VjdGlvbiBDb250cm9sIG9wdGlvbnNcclxuLy8gQG9wdGlvbiB6b29tQ29udHJvbDogQm9vbGVhbiA9IHRydWVcclxuLy8gV2hldGhlciBhIFt6b29tIGNvbnRyb2xdKCNjb250cm9sLXpvb20pIGlzIGFkZGVkIHRvIHRoZSBtYXAgYnkgZGVmYXVsdC5cclxuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0em9vbUNvbnRyb2w6IHRydWVcclxufSk7XHJcblxyXG5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG5cdGlmICh0aGlzLm9wdGlvbnMuem9vbUNvbnRyb2wpIHtcclxuXHRcdC8vIEBzZWN0aW9uIENvbnRyb2xzXHJcblx0XHQvLyBAcHJvcGVydHkgem9vbUNvbnRyb2w6IENvbnRyb2wuWm9vbVxyXG5cdFx0Ly8gVGhlIGRlZmF1bHQgem9vbSBjb250cm9sIChvbmx5IGF2YWlsYWJsZSBpZiB0aGVcclxuXHRcdC8vIFtgem9vbUNvbnRyb2xgIG9wdGlvbl0oI21hcC16b29tY29udHJvbCkgd2FzIGB0cnVlYCB3aGVuIGNyZWF0aW5nIHRoZSBtYXApLlxyXG5cdFx0dGhpcy56b29tQ29udHJvbCA9IG5ldyBab29tKCk7XHJcblx0XHR0aGlzLmFkZENvbnRyb2wodGhpcy56b29tQ29udHJvbCk7XHJcblx0fVxyXG59KTtcclxuXHJcbi8vIEBuYW1lc3BhY2UgQ29udHJvbC5ab29tXHJcbi8vIEBmYWN0b3J5IEwuY29udHJvbC56b29tKG9wdGlvbnM6IENvbnRyb2wuWm9vbSBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgem9vbSBjb250cm9sXHJcbmV4cG9ydCB2YXIgem9vbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBab29tKG9wdGlvbnMpO1xyXG59O1xyXG4iLCJcbmltcG9ydCB7Q29udHJvbH0gZnJvbSAnLi9Db250cm9sJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQGNsYXNzIENvbnRyb2wuU2NhbGVcbiAqIEBha2EgTC5Db250cm9sLlNjYWxlXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxuICpcbiAqIEEgc2ltcGxlIHNjYWxlIGNvbnRyb2wgdGhhdCBzaG93cyB0aGUgc2NhbGUgb2YgdGhlIGN1cnJlbnQgY2VudGVyIG9mIHNjcmVlbiBpbiBtZXRyaWMgKG0va20pIGFuZCBpbXBlcmlhbCAobWkvZnQpIHN5c3RlbXMuIEV4dGVuZHMgYENvbnRyb2xgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY29udHJvbC5zY2FsZSgpLmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqL1xuXG5leHBvcnQgdmFyIFNjYWxlID0gQ29udHJvbC5leHRlbmQoe1xuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENvbnRyb2wuU2NhbGUgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0cG9zaXRpb246ICdib3R0b21sZWZ0JyxcblxuXHRcdC8vIEBvcHRpb24gbWF4V2lkdGg6IE51bWJlciA9IDEwMFxuXHRcdC8vIE1heGltdW0gd2lkdGggb2YgdGhlIGNvbnRyb2wgaW4gcGl4ZWxzLiBUaGUgd2lkdGggaXMgc2V0IGR5bmFtaWNhbGx5IHRvIHNob3cgcm91bmQgdmFsdWVzIChlLmcuIDEwMCwgMjAwLCA1MDApLlxuXHRcdG1heFdpZHRoOiAxMDAsXG5cblx0XHQvLyBAb3B0aW9uIG1ldHJpYzogQm9vbGVhbiA9IFRydWVcblx0XHQvLyBXaGV0aGVyIHRvIHNob3cgdGhlIG1ldHJpYyBzY2FsZSBsaW5lIChtL2ttKS5cblx0XHRtZXRyaWM6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGltcGVyaWFsOiBCb29sZWFuID0gVHJ1ZVxuXHRcdC8vIFdoZXRoZXIgdG8gc2hvdyB0aGUgaW1wZXJpYWwgc2NhbGUgbGluZSAobWkvZnQpLlxuXHRcdGltcGVyaWFsOiB0cnVlXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZVdoZW5JZGxlOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBjb250cm9sIGlzIHVwZGF0ZWQgb24gW2Btb3ZlZW5kYF0oI21hcC1tb3ZlZW5kKSwgb3RoZXJ3aXNlIGl0J3MgYWx3YXlzIHVwLXRvLWRhdGUgKHVwZGF0ZWQgb24gW2Btb3ZlYF0oI21hcC1tb3ZlKSkuXG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1zY2FsZScsXG5cdFx0ICAgIGNvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpLFxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dGhpcy5fYWRkU2NhbGVzKG9wdGlvbnMsIGNsYXNzTmFtZSArICctbGluZScsIGNvbnRhaW5lcik7XG5cblx0XHRtYXAub24ob3B0aW9ucy51cGRhdGVXaGVuSWRsZSA/ICdtb3ZlZW5kJyA6ICdtb3ZlJywgdGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0XHRtYXAud2hlblJlYWR5KHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLm9mZih0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdH0sXG5cblx0X2FkZFNjYWxlczogZnVuY3Rpb24gKG9wdGlvbnMsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XG5cdFx0aWYgKG9wdGlvbnMubWV0cmljKSB7XG5cdFx0XHR0aGlzLl9tU2NhbGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xuXHRcdH1cblx0XHRpZiAob3B0aW9ucy5pbXBlcmlhbCkge1xuXHRcdFx0dGhpcy5faVNjYWxlID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHkgPSBtYXAuZ2V0U2l6ZSgpLnkgLyAyO1xuXG5cdFx0dmFyIG1heE1ldGVycyA9IG1hcC5kaXN0YW5jZShcblx0XHRcdG1hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKFswLCB5XSksXG5cdFx0XHRtYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbdGhpcy5vcHRpb25zLm1heFdpZHRoLCB5XSkpO1xuXG5cdFx0dGhpcy5fdXBkYXRlU2NhbGVzKG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZVNjYWxlczogZnVuY3Rpb24gKG1heE1ldGVycykge1xuXHRcdGlmICh0aGlzLm9wdGlvbnMubWV0cmljICYmIG1heE1ldGVycykge1xuXHRcdFx0dGhpcy5fdXBkYXRlTWV0cmljKG1heE1ldGVycyk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW1wZXJpYWwgJiYgbWF4TWV0ZXJzKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVJbXBlcmlhbChtYXhNZXRlcnMpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlTWV0cmljOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1ldGVycyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1ldGVycyksXG5cdFx0ICAgIGxhYmVsID0gbWV0ZXJzIDwgMTAwMCA/IG1ldGVycyArICcgbScgOiAobWV0ZXJzIC8gMTAwMCkgKyAnIGttJztcblxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX21TY2FsZSwgbGFiZWwsIG1ldGVycyAvIG1heE1ldGVycyk7XG5cdH0sXG5cblx0X3VwZGF0ZUltcGVyaWFsOiBmdW5jdGlvbiAobWF4TWV0ZXJzKSB7XG5cdFx0dmFyIG1heEZlZXQgPSBtYXhNZXRlcnMgKiAzLjI4MDgzOTksXG5cdFx0ICAgIG1heE1pbGVzLCBtaWxlcywgZmVldDtcblxuXHRcdGlmIChtYXhGZWV0ID4gNTI4MCkge1xuXHRcdFx0bWF4TWlsZXMgPSBtYXhGZWV0IC8gNTI4MDtcblx0XHRcdG1pbGVzID0gdGhpcy5fZ2V0Um91bmROdW0obWF4TWlsZXMpO1xuXHRcdFx0dGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLCBtaWxlcyArICcgbWknLCBtaWxlcyAvIG1heE1pbGVzKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmZWV0ID0gdGhpcy5fZ2V0Um91bmROdW0obWF4RmVldCk7XG5cdFx0XHR0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsIGZlZXQgKyAnIGZ0JywgZmVldCAvIG1heEZlZXQpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlU2NhbGU6IGZ1bmN0aW9uIChzY2FsZSwgdGV4dCwgcmF0aW8pIHtcblx0XHRzY2FsZS5zdHlsZS53aWR0aCA9IE1hdGgucm91bmQodGhpcy5vcHRpb25zLm1heFdpZHRoICogcmF0aW8pICsgJ3B4Jztcblx0XHRzY2FsZS5pbm5lckhUTUwgPSB0ZXh0O1xuXHR9LFxuXG5cdF9nZXRSb3VuZE51bTogZnVuY3Rpb24gKG51bSkge1xuXHRcdHZhciBwb3cxMCA9IE1hdGgucG93KDEwLCAoTWF0aC5mbG9vcihudW0pICsgJycpLmxlbmd0aCAtIDEpLFxuXHRcdCAgICBkID0gbnVtIC8gcG93MTA7XG5cblx0XHRkID0gZCA+PSAxMCA/IDEwIDpcblx0XHQgICAgZCA+PSA1ID8gNSA6XG5cdFx0ICAgIGQgPj0gMyA/IDMgOlxuXHRcdCAgICBkID49IDIgPyAyIDogMTtcblxuXHRcdHJldHVybiBwb3cxMCAqIGQ7XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuY29udHJvbC5zY2FsZShvcHRpb25zPzogQ29udHJvbC5TY2FsZSBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhbiBzY2FsZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG5leHBvcnQgdmFyIHNjYWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBTY2FsZShvcHRpb25zKTtcbn07XG4iLCJcclxuaW1wb3J0IHtDb250cm9sfSBmcm9tICcuL0NvbnRyb2wnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uL2NvcmUvQnJvd3Nlcic7XHJcblxyXG52YXIgdWtyYWluaWFuRmxhZyA9ICc8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjEyXCIgaGVpZ2h0PVwiOFwiIHZpZXdCb3g9XCIwIDAgMTIgOFwiIGNsYXNzPVwibGVhZmxldC1hdHRyaWJ1dGlvbi1mbGFnXCI+PHBhdGggZmlsbD1cIiM0QzdCRTFcIiBkPVwiTTAgMGgxMnY0SDB6XCIvPjxwYXRoIGZpbGw9XCIjRkZENTAwXCIgZD1cIk0wIDRoMTJ2M0gwelwiLz48cGF0aCBmaWxsPVwiI0UwQkMwMFwiIGQ9XCJNMCA3aDEydjFIMHpcIi8+PC9zdmc+JztcclxuXHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAYWthIEwuQ29udHJvbC5BdHRyaWJ1dGlvblxyXG4gKiBAaW5oZXJpdHMgQ29udHJvbFxyXG4gKlxyXG4gKiBUaGUgYXR0cmlidXRpb24gY29udHJvbCBhbGxvd3MgeW91IHRvIGRpc3BsYXkgYXR0cmlidXRpb24gZGF0YSBpbiBhIHNtYWxsIHRleHQgYm94IG9uIGEgbWFwLiBJdCBpcyBwdXQgb24gdGhlIG1hcCBieSBkZWZhdWx0IHVubGVzcyB5b3Ugc2V0IGl0cyBbYGF0dHJpYnV0aW9uQ29udHJvbGAgb3B0aW9uXSgjbWFwLWF0dHJpYnV0aW9uY29udHJvbCkgdG8gYGZhbHNlYCwgYW5kIGl0IGZldGNoZXMgYXR0cmlidXRpb24gdGV4dHMgZnJvbSBsYXllcnMgd2l0aCB0aGUgW2BnZXRBdHRyaWJ1dGlvbmAgbWV0aG9kXSgjbGF5ZXItZ2V0YXR0cmlidXRpb24pIGF1dG9tYXRpY2FsbHkuIEV4dGVuZHMgQ29udHJvbC5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIEF0dHJpYnV0aW9uID0gQ29udHJvbC5leHRlbmQoe1xyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBDb250cm9sLkF0dHJpYnV0aW9uIG9wdGlvbnNcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ2JvdHRvbXJpZ2h0JyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHByZWZpeDogU3RyaW5nfGZhbHNlID0gJ0xlYWZsZXQnXHJcblx0XHQvLyBUaGUgSFRNTCB0ZXh0IHNob3duIGJlZm9yZSB0aGUgYXR0cmlidXRpb25zLiBQYXNzIGBmYWxzZWAgdG8gZGlzYWJsZS5cclxuXHRcdHByZWZpeDogJzxhIGhyZWY9XCJodHRwczovL2xlYWZsZXRqcy5jb21cIiB0aXRsZT1cIkEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzXCI+JyArIChCcm93c2VyLmlubGluZVN2ZyA/IHVrcmFpbmlhbkZsYWcgKyAnICcgOiAnJykgKyAnTGVhZmxldDwvYT4nXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnMgPSB7fTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmF0dHJpYnV0aW9uQ29udHJvbCA9IHRoaXM7XHJcblx0XHR0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbicpO1xyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHQvLyBUT0RPIHVnbHksIHJlZmFjdG9yXHJcblx0XHRmb3IgKHZhciBpIGluIG1hcC5fbGF5ZXJzKSB7XHJcblx0XHRcdGlmIChtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbikge1xyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRpb24obWFwLl9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24oKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHJcblx0XHRtYXAub24oJ2xheWVyYWRkJywgdGhpcy5fYWRkQXR0cmlidXRpb24sIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5vZmYoJ2xheWVyYWRkJywgdGhpcy5fYWRkQXR0cmlidXRpb24sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGRBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKGV2KSB7XHJcblx0XHRpZiAoZXYubGF5ZXIuZ2V0QXR0cmlidXRpb24pIHtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihldi5sYXllci5nZXRBdHRyaWJ1dGlvbigpKTtcclxuXHRcdFx0ZXYubGF5ZXIub25jZSgncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRpb24oZXYubGF5ZXIuZ2V0QXR0cmlidXRpb24oKSk7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UHJlZml4KHByZWZpeDogU3RyaW5nfGZhbHNlKTogdGhpc1xyXG5cdC8vIFRoZSBIVE1MIHRleHQgc2hvd24gYmVmb3JlIHRoZSBhdHRyaWJ1dGlvbnMuIFBhc3MgYGZhbHNlYCB0byBkaXNhYmxlLlxyXG5cdHNldFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnByZWZpeCA9IHByZWZpeDtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBhZGRBdHRyaWJ1dGlvbih0ZXh0OiBTdHJpbmcpOiB0aGlzXHJcblx0Ly8gQWRkcyBhbiBhdHRyaWJ1dGlvbiB0ZXh0IChlLmcuIGAnJmNvcHk7IE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzJ2ApLlxyXG5cdGFkZEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSsrO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgcmVtb3ZlQXR0cmlidXRpb24odGV4dDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgYW4gYXR0cmlidXRpb24gdGV4dC5cclxuXHRyZW1vdmVBdHRyaWJ1dGlvbjogZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdGlmICghdGV4dCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdLS07XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBhdHRyaWJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1tpXSkge1xyXG5cdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW107XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5wcmVmaXgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGF0dHJpYnMubGVuZ3RoKSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaChhdHRyaWJzLmpvaW4oJywgJykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBwcmVmaXhBbmRBdHRyaWJzLmpvaW4oJyA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj58PC9zcGFuPiAnKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBNYXBcclxuLy8gQHNlY3Rpb24gQ29udHJvbCBvcHRpb25zXHJcbi8vIEBvcHRpb24gYXR0cmlidXRpb25Db250cm9sOiBCb29sZWFuID0gdHJ1ZVxyXG4vLyBXaGV0aGVyIGEgW2F0dHJpYnV0aW9uIGNvbnRyb2xdKCNjb250cm9sLWF0dHJpYnV0aW9uKSBpcyBhZGRlZCB0byB0aGUgbWFwIGJ5IGRlZmF1bHQuXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbk1hcC5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHtcclxuXHRcdG5ldyBBdHRyaWJ1dGlvbigpLmFkZFRvKHRoaXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENvbnRyb2wuQXR0cmlidXRpb25cclxuLy8gQGZhY3RvcnkgTC5jb250cm9sLmF0dHJpYnV0aW9uKG9wdGlvbnM6IENvbnRyb2wuQXR0cmlidXRpb24gb3B0aW9ucylcclxuLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGlvbiBjb250cm9sLlxyXG5leHBvcnQgdmFyIGF0dHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEF0dHJpYnV0aW9uKG9wdGlvbnMpO1xyXG59O1xyXG4iLCJpbXBvcnQge0NvbnRyb2wsIGNvbnRyb2x9IGZyb20gJy4vQ29udHJvbCc7XG5pbXBvcnQge0xheWVycywgbGF5ZXJzfSBmcm9tICcuL0NvbnRyb2wuTGF5ZXJzJztcbmltcG9ydCB7Wm9vbSwgem9vbX0gZnJvbSAnLi9Db250cm9sLlpvb20nO1xuaW1wb3J0IHtTY2FsZSwgc2NhbGV9IGZyb20gJy4vQ29udHJvbC5TY2FsZSc7XG5pbXBvcnQge0F0dHJpYnV0aW9uLCBhdHRyaWJ1dGlvbn0gZnJvbSAnLi9Db250cm9sLkF0dHJpYnV0aW9uJztcblxuQ29udHJvbC5MYXllcnMgPSBMYXllcnM7XG5Db250cm9sLlpvb20gPSBab29tO1xuQ29udHJvbC5TY2FsZSA9IFNjYWxlO1xuQ29udHJvbC5BdHRyaWJ1dGlvbiA9IEF0dHJpYnV0aW9uO1xuXG5jb250cm9sLmxheWVycyA9IGxheWVycztcbmNvbnRyb2wuem9vbSA9IHpvb207XG5jb250cm9sLnNjYWxlID0gc2NhbGU7XG5jb250cm9sLmF0dHJpYnV0aW9uID0gYXR0cmlidXRpb247XG5cbmV4cG9ydCB7Q29udHJvbCwgY29udHJvbH07XG4iLCJpbXBvcnQge0NsYXNzfSBmcm9tICcuL0NsYXNzJztcblxuLypcblx0TC5IYW5kbGVyIGlzIGEgYmFzZSBjbGFzcyBmb3IgaGFuZGxlciBjbGFzc2VzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseSB0byBpbmplY3Rcblx0aW50ZXJhY3Rpb24gZmVhdHVyZXMgbGlrZSBkcmFnZ2luZyB0byBjbGFzc2VzIGxpa2UgTWFwIGFuZCBNYXJrZXIuXG4qL1xuXG4vLyBAY2xhc3MgSGFuZGxlclxuLy8gQGFrYSBMLkhhbmRsZXJcbi8vIEFic3RyYWN0IGNsYXNzIGZvciBtYXAgaW50ZXJhY3Rpb24gaGFuZGxlcnNcblxuZXhwb3J0IHZhciBIYW5kbGVyID0gQ2xhc3MuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGVuYWJsZSgpOiB0aGlzXG5cdC8vIEVuYWJsZXMgdGhlIGhhbmRsZXJcblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuYWRkSG9va3MoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGRpc2FibGUoKTogdGhpc1xuXHQvLyBEaXNhYmxlcyB0aGUgaGFuZGxlclxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5yZW1vdmVIb29rcygpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZW5hYmxlZCgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWRcblx0ZW5hYmxlZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2VuYWJsZWQ7XG5cdH1cblxuXHQvLyBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuXHQvLyBDbGFzc2VzIGluaGVyaXRpbmcgZnJvbSBgSGFuZGxlcmAgbXVzdCBpbXBsZW1lbnQgdGhlIHR3byBmb2xsb3dpbmcgbWV0aG9kczpcblx0Ly8gQG1ldGhvZCBhZGRIb29rcygpXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBoYW5kbGVyIGlzIGVuYWJsZWQsIHNob3VsZCBhZGQgZXZlbnQgaG9va3MuXG5cdC8vIEBtZXRob2QgcmVtb3ZlSG9va3MoKVxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgaGFuZGxlciBpcyBkaXNhYmxlZCwgc2hvdWxkIHJlbW92ZSB0aGUgZXZlbnQgaG9va3MgYWRkZWQgcHJldmlvdXNseS5cbn0pO1xuXG4vLyBAc2VjdGlvbiBUaGVyZSBpcyBzdGF0aWMgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIGNhbGxlZCB3aXRob3V0IGluc3RhbnRpYXRpbmcgTC5IYW5kbGVyOlxuLy8gQGZ1bmN0aW9uIGFkZFRvKG1hcDogTWFwLCBuYW1lOiBTdHJpbmcpOiB0aGlzXG4vLyBBZGRzIGEgbmV3IEhhbmRsZXIgdG8gdGhlIGdpdmVuIG1hcCB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuSGFuZGxlci5hZGRUbyA9IGZ1bmN0aW9uIChtYXAsIG5hbWUpIHtcblx0bWFwLmFkZEhhbmRsZXIobmFtZSwgdGhpcyk7XG5cdHJldHVybiB0aGlzO1xufTtcbiIsImltcG9ydCBCcm93c2VyIGZyb20gJy4vQnJvd3Nlcic7XG5leHBvcnQge0Jyb3dzZXJ9O1xuXG5leHBvcnQge0NsYXNzfSBmcm9tICcuL0NsYXNzJztcblxuaW1wb3J0IHtFdmVudGVkfSBmcm9tICcuL0V2ZW50cyc7XG5pbXBvcnQge0V2ZW50c30gZnJvbSAnLi9FdmVudHMnO1xuZXhwb3J0IHtFdmVudGVkfTtcbmV4cG9ydCB2YXIgTWl4aW4gPSB7RXZlbnRzOiBFdmVudHN9O1xuXG5leHBvcnQge0hhbmRsZXJ9IGZyb20gJy4vSGFuZGxlcic7XG5cbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi9VdGlsJztcbmV4cG9ydCB7VXRpbH07XG5leHBvcnQge2V4dGVuZCwgYmluZCwgc3RhbXAsIHNldE9wdGlvbnN9IGZyb20gJy4vVXRpbCc7XG4iLCJpbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcclxuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vY29yZS9Ccm93c2VyJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgRHJhZ2dhYmxlXHJcbiAqIEBha2EgTC5EcmFnZ2FibGVcclxuICogQGluaGVyaXRzIEV2ZW50ZWRcclxuICpcclxuICogQSBjbGFzcyBmb3IgbWFraW5nIERPTSBlbGVtZW50cyBkcmFnZ2FibGUgKGluY2x1ZGluZyB0b3VjaCBzdXBwb3J0KS5cclxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBtYXAgYW5kIG1hcmtlciBkcmFnZ2luZy4gT25seSB3b3JrcyBmb3IgZWxlbWVudHNcclxuICogdGhhdCB3ZXJlIHBvc2l0aW9uZWQgd2l0aCBbYEwuRG9tVXRpbC5zZXRQb3NpdGlvbmBdKCNkb211dGlsLXNldHBvc2l0aW9uKS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogdmFyIGRyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShlbGVtZW50VG9EcmFnKTtcclxuICogZHJhZ2dhYmxlLmVuYWJsZSgpO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG52YXIgU1RBUlQgPSBCcm93c2VyLnRvdWNoID8gJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyA6ICdtb3VzZWRvd24nO1xyXG5cclxuZXhwb3J0IHZhciBEcmFnZ2FibGUgPSBFdmVudGVkLmV4dGVuZCh7XHJcblxyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBzZWN0aW9uXHJcblx0XHQvLyBAYWthIERyYWdnYWJsZSBvcHRpb25zXHJcblx0XHQvLyBAb3B0aW9uIGNsaWNrVG9sZXJhbmNlOiBOdW1iZXIgPSAzXHJcblx0XHQvLyBUaGUgbWF4IG51bWJlciBvZiBwaXhlbHMgYSB1c2VyIGNhbiBzaGlmdCB0aGUgbW91c2UgcG9pbnRlciBkdXJpbmcgYSBjbGlja1xyXG5cdFx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCBjbGljayAoYXMgb3Bwb3NlZCB0byBhIG1vdXNlIGRyYWcpLlxyXG5cdFx0Y2xpY2tUb2xlcmFuY2U6IDNcclxuXHR9LFxyXG5cclxuXHQvLyBAY29uc3RydWN0b3IgTC5EcmFnZ2FibGUoZWw6IEhUTUxFbGVtZW50LCBkcmFnSGFuZGxlPzogSFRNTEVsZW1lbnQsIHByZXZlbnRPdXRsaW5lPzogQm9vbGVhbiwgb3B0aW9ucz86IERyYWdnYWJsZSBvcHRpb25zKVxyXG5cdC8vIENyZWF0ZXMgYSBgRHJhZ2dhYmxlYCBvYmplY3QgZm9yIG1vdmluZyBgZWxgIHdoZW4geW91IHN0YXJ0IGRyYWdnaW5nIHRoZSBgZHJhZ0hhbmRsZWAgZWxlbWVudCAoZXF1YWxzIGBlbGAgaXRzZWxmIGJ5IGRlZmF1bHQpLlxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChlbGVtZW50LCBkcmFnU3RhcnRUYXJnZXQsIHByZXZlbnRPdXRsaW5lLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9kcmFnU3RhcnRUYXJnZXQgPSBkcmFnU3RhcnRUYXJnZXQgfHwgZWxlbWVudDtcclxuXHRcdHRoaXMuX3ByZXZlbnRPdXRsaW5lID0gcHJldmVudE91dGxpbmU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBlbmFibGUoKVxyXG5cdC8vIEVuYWJsZXMgdGhlIGRyYWdnaW5nIGFiaWxpdHlcclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgU1RBUlQsIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBkaXNhYmxlKClcclxuXHQvLyBEaXNhYmxlcyB0aGUgZHJhZ2dpbmcgYWJpbGl0eVxyXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBJZiB3ZSdyZSBjdXJyZW50bHkgZHJhZ2dpbmcgdGhpcyBkcmFnZ2FibGUsXHJcblx0XHQvLyBkaXNhYmxpbmcgaXQgY291bnRzIGFzIGZpcnN0IGVuZGluZyB0aGUgZHJhZy5cclxuXHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nID09PSB0aGlzKSB7XHJcblx0XHRcdHRoaXMuZmluaXNoRHJhZyh0cnVlKTtcclxuXHRcdH1cclxuXHJcblx0XHREb21FdmVudC5vZmYodGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LCBTVEFSVCwgdGhpcy5fb25Eb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoRG9tVXRpbC5oYXNDbGFzcyh0aGlzLl9lbGVtZW50LCAnbGVhZmxldC16b29tLWFuaW0nKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggIT09IDEpIHtcclxuXHRcdFx0Ly8gRmluaXNoIGRyYWdnaW5nIHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggdG91Y2hab29tXHJcblx0XHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nID09PSB0aGlzKSB7XHJcblx0XHRcdFx0dGhpcy5maW5pc2hEcmFnKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChEcmFnZ2FibGUuX2RyYWdnaW5nIHx8IGUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpICYmICFlLnRvdWNoZXMpKSB7IHJldHVybjsgfVxyXG5cdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IHRoaXM7ICAvLyBQcmV2ZW50IGRyYWdnaW5nIG11bHRpcGxlIG9iamVjdHMgYXQgb25jZS5cclxuXHJcblx0XHRpZiAodGhpcy5fcHJldmVudE91dGxpbmUpIHtcclxuXHRcdFx0RG9tVXRpbC5wcmV2ZW50T3V0bGluZSh0aGlzLl9lbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHREb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcclxuXHRcdERvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92aW5nKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIEBldmVudCBkb3duOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGRyYWcgaXMgYWJvdXQgdG8gc3RhcnQuXHJcblx0XHR0aGlzLmZpcmUoJ2Rvd24nKTtcclxuXHJcblx0XHR2YXIgZmlyc3QgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxyXG5cdFx0ICAgIHNpemVkUGFyZW50ID0gRG9tVXRpbC5nZXRTaXplZFBhcmVudE5vZGUodGhpcy5fZWxlbWVudCk7XHJcblxyXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcclxuXHRcdHRoaXMuX3N0YXJ0UG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50KTtcclxuXHJcblx0XHQvLyBDYWNoZSB0aGUgc2NhbGUsIHNvIHRoYXQgd2UgY2FuIGNvbnRpbnVvdXNseSBjb21wZW5zYXRlIGZvciBpdCBkdXJpbmcgZHJhZyAoX29uTW92ZSkuXHJcblx0XHR0aGlzLl9wYXJlbnRTY2FsZSA9IERvbVV0aWwuZ2V0U2NhbGUoc2l6ZWRQYXJlbnQpO1xyXG5cclxuXHRcdHZhciBtb3VzZWV2ZW50ID0gZS50eXBlID09PSAnbW91c2Vkb3duJztcclxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCBtb3VzZWV2ZW50ID8gJ21vdXNlbW92ZScgOiAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCBtb3VzZWV2ZW50ID8gJ21vdXNldXAnIDogJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25VcCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uTW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgZGlzYWJsZWQ7IHRoaXMgaGFwcGVucyBpbiBJRTExXHJcblx0XHQvLyB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIHNlZSAjMzY2Ni5cclxuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHRpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmaXJzdCA9IChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSA/IGUudG91Y2hlc1swXSA6IGUpLFxyXG5cdFx0ICAgIG9mZnNldCA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKS5fc3VidHJhY3QodGhpcy5fc3RhcnRQb2ludCk7XHJcblxyXG5cdFx0aWYgKCFvZmZzZXQueCAmJiAhb2Zmc2V0LnkpIHsgcmV0dXJuOyB9XHJcblx0XHRpZiAoTWF0aC5hYnMob2Zmc2V0LngpICsgTWF0aC5hYnMob2Zmc2V0LnkpIDwgdGhpcy5vcHRpb25zLmNsaWNrVG9sZXJhbmNlKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IHRoZSBwYXJlbnQgY29udGFpbmVyJ3MgcG9zaXRpb24sIGJvcmRlciBhbmQgc2NhbGUgZG8gbm90IGNoYW5nZSBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBkcmFnLlxyXG5cdFx0Ly8gVGhlcmVmb3JlIHRoZXJlIGlzIG5vIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlIHBvc2l0aW9uIGFuZCBib3JkZXIgKHRoZXkgYXJlIGVsaW1pbmF0ZWQgYnkgdGhlIHN1YnRyYWN0aW9uKVxyXG5cdFx0Ly8gYW5kIHdlIGNhbiB1c2UgdGhlIGNhY2hlZCB2YWx1ZSBmb3IgdGhlIHNjYWxlLlxyXG5cdFx0b2Zmc2V0LnggLz0gdGhpcy5fcGFyZW50U2NhbGUueDtcclxuXHRcdG9mZnNldC55IC89IHRoaXMuX3BhcmVudFNjYWxlLnk7XHJcblxyXG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xyXG5cdFx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxyXG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgZHJhZyBzdGFydHNcclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnc3RhcnQnKTtcclxuXHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHJcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2xlYWZsZXQtZHJhZ2dpbmcnKTtcclxuXHJcblx0XHRcdHRoaXMuX2xhc3RUYXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XHJcblx0XHRcdC8vIElFIGFuZCBFZGdlIGRvIG5vdCBnaXZlIHRoZSA8dXNlPiBlbGVtZW50LCBzbyBmZXRjaCBpdFxyXG5cdFx0XHQvLyBpZiBuZWNlc3NhcnlcclxuXHRcdFx0aWYgKHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UgJiYgdGhpcy5fbGFzdFRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UpIHtcclxuXHRcdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gdGhpcy5fbGFzdFRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcclxuXHRcdFx0fVxyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2xhc3RUYXJnZXQsICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbmV3UG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKG9mZnNldCk7XHJcblx0XHR0aGlzLl9tb3ZpbmcgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuX2xhc3RFdmVudCA9IGU7XHJcblx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGUgPSB7b3JpZ2luYWxFdmVudDogdGhpcy5fbGFzdEV2ZW50fTtcclxuXHJcblx0XHQvLyBAZXZlbnQgcHJlZHJhZzogRXZlbnRcclxuXHRcdC8vIEZpcmVkIGNvbnRpbnVvdXNseSBkdXJpbmcgZHJhZ2dpbmcgKmJlZm9yZSogZWFjaCBjb3JyZXNwb25kaW5nXHJcblx0XHQvLyB1cGRhdGUgb2YgdGhlIGVsZW1lbnQncyBwb3NpdGlvbi5cclxuXHRcdHRoaXMuZmlyZSgncHJlZHJhZycsIGUpO1xyXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50LCB0aGlzLl9uZXdQb3MpO1xyXG5cclxuXHRcdC8vIEBldmVudCBkcmFnOiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgY29udGludW91c2x5IGR1cmluZyBkcmFnZ2luZy5cclxuXHRcdHRoaXMuZmlyZSgnZHJhZycsIGUpO1xyXG5cdH0sXHJcblxyXG5cdF9vblVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGRpc2FibGVkOyB0aGlzIGhhcHBlbnMgaW4gSUUxMVxyXG5cdFx0Ly8gdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBzZWUgIzM2NjYuXHJcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblx0XHR0aGlzLmZpbmlzaERyYWcoKTtcclxuXHR9LFxyXG5cclxuXHRmaW5pc2hEcmFnOiBmdW5jdGlvbiAobm9JbmVydGlhKSB7XHJcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2xhc3RUYXJnZXQpIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9sYXN0VGFyZ2V0LCAnbGVhZmxldC1kcmFnLXRhcmdldCcpO1xyXG5cdFx0XHR0aGlzLl9sYXN0VGFyZ2V0ID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUgdG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcclxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ21vdXNldXAgdG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuXHJcblx0XHREb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0RG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XHJcblxyXG5cdFx0dmFyIGZpcmVEcmFnZW5kID0gdGhpcy5fbW92ZWQgJiYgdGhpcy5fbW92aW5nO1xyXG5cclxuXHRcdHRoaXMuX21vdmluZyA9IGZhbHNlO1xyXG5cdFx0RHJhZ2dhYmxlLl9kcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChmaXJlRHJhZ2VuZCkge1xyXG5cdFx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGRyYWcgZW5kcy5cclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnZW5kJywge1xyXG5cdFx0XHRcdG5vSW5lcnRpYTogbm9JbmVydGlhLFxyXG5cdFx0XHRcdGRpc3RhbmNlOiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcylcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxufSk7XHJcbiIsImltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4vTGluZVV0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi9nZW8vTGF0TG5nJztcclxuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuL1BvaW50JztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgUG9seVV0aWxcclxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgcG9seWdvbiBnZW9tZXRyaWVzLlxyXG4gKi9cclxuXHJcbi8qIEBmdW5jdGlvbiBjbGlwUG9seWdvbihwb2ludHM6IFBvaW50W10sIGJvdW5kczogQm91bmRzLCByb3VuZD86IEJvb2xlYW4pOiBQb2ludFtdXHJcbiAqIENsaXBzIHRoZSBwb2x5Z29uIGdlb21ldHJ5IGRlZmluZWQgYnkgdGhlIGdpdmVuIGBwb2ludHNgIGJ5IHRoZSBnaXZlbiBib3VuZHMgKHVzaW5nIHRoZSBbU3V0aGVybGFuZC1Ib2RnbWFuIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3V0aGVybGFuZCVFMiU4MCU5M0hvZGdtYW5fYWxnb3JpdGhtKSkuXHJcbiAqIFVzZWQgYnkgTGVhZmxldCB0byBvbmx5IHNob3cgcG9seWdvbiBwb2ludHMgdGhhdCBhcmUgb24gdGhlIHNjcmVlbiBvciBuZWFyLCBpbmNyZWFzaW5nXHJcbiAqIHBlcmZvcm1hbmNlLiBOb3RlIHRoYXQgcG9seWdvbiBwb2ludHMgbmVlZHMgZGlmZmVyZW50IGFsZ29yaXRobSBmb3IgY2xpcHBpbmdcclxuICogdGhhbiBwb2x5bGluZSwgc28gdGhlcmUncyBhIHNlcGFyYXRlIG1ldGhvZCBmb3IgaXQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2xpcFBvbHlnb24ocG9pbnRzLCBib3VuZHMsIHJvdW5kKSB7XHJcblx0dmFyIGNsaXBwZWRQb2ludHMsXHJcblx0ICAgIGVkZ2VzID0gWzEsIDQsIDIsIDhdLFxyXG5cdCAgICBpLCBqLCBrLFxyXG5cdCAgICBhLCBiLFxyXG5cdCAgICBsZW4sIGVkZ2UsIHA7XHJcblxyXG5cdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0cG9pbnRzW2ldLl9jb2RlID0gTGluZVV0aWwuX2dldEJpdENvZGUocG9pbnRzW2ldLCBib3VuZHMpO1xyXG5cdH1cclxuXHJcblx0Ly8gZm9yIGVhY2ggZWRnZSAobGVmdCwgYm90dG9tLCByaWdodCwgdG9wKVxyXG5cdGZvciAoayA9IDA7IGsgPCA0OyBrKyspIHtcclxuXHRcdGVkZ2UgPSBlZGdlc1trXTtcclxuXHRcdGNsaXBwZWRQb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xyXG5cdFx0XHRhID0gcG9pbnRzW2ldO1xyXG5cdFx0XHRiID0gcG9pbnRzW2pdO1xyXG5cclxuXHRcdFx0Ly8gaWYgYSBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93XHJcblx0XHRcdGlmICghKGEuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdC8vIGlmIGIgaXMgb3V0c2lkZSB0aGUgY2xpcCB3aW5kb3cgKGEtPmIgZ29lcyBvdXQgb2Ygc2NyZWVuKVxyXG5cdFx0XHRcdGlmIChiLl9jb2RlICYgZWRnZSkge1xyXG5cdFx0XHRcdFx0cCA9IExpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRcdFx0cC5fY29kZSA9IExpbmVVdGlsLl9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblx0XHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2gocCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChhKTtcclxuXHJcblx0XHRcdC8vIGVsc2UgaWYgYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93IChhLT5iIGVudGVycyB0aGUgc2NyZWVuKVxyXG5cdFx0XHR9IGVsc2UgaWYgKCEoYi5fY29kZSAmIGVkZ2UpKSB7XHJcblx0XHRcdFx0cCA9IExpbmVVdGlsLl9nZXRFZGdlSW50ZXJzZWN0aW9uKGIsIGEsIGVkZ2UsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0XHRcdHAuX2NvZGUgPSBMaW5lVXRpbC5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cG9pbnRzID0gY2xpcHBlZFBvaW50cztcclxuXHR9XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn1cclxuXHJcbi8qIEBmdW5jdGlvbiBwb2x5Z29uQ2VudGVyKGxhdGxuZ3M6IExhdExuZ1tdLCBjcnM6IENSUyk6IExhdExuZ1xyXG4gKiBSZXR1cm5zIHRoZSBjZW50ZXIgKFtjZW50cm9pZF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DZW50cm9pZCkpIG9mIHRoZSBwYXNzZWQgTGF0TG5ncyAoZmlyc3QgcmluZykgZnJvbSBhIHBvbHlnb24uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbkNlbnRlcihsYXRsbmdzLCBjcnMpIHtcclxuXHR2YXIgaSwgaiwgcDEsIHAyLCBmLCBhcmVhLCB4LCB5LCBjZW50ZXI7XHJcblxyXG5cdGlmICghbGF0bG5ncyB8fCBsYXRsbmdzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdsYXRsbmdzIG5vdCBwYXNzZWQnKTtcclxuXHR9XHJcblxyXG5cdGlmICghTGluZVV0aWwuaXNGbGF0KGxhdGxuZ3MpKSB7XHJcblx0XHRjb25zb2xlLndhcm4oJ2xhdGxuZ3MgYXJlIG5vdCBmbGF0ISBPbmx5IHRoZSBmaXJzdCByaW5nIHdpbGwgYmUgdXNlZCcpO1xyXG5cdFx0bGF0bG5ncyA9IGxhdGxuZ3NbMF07XHJcblx0fVxyXG5cclxuXHR2YXIgY2VudHJvaWRMYXRMbmcgPSB0b0xhdExuZyhbMCwgMF0pO1xyXG5cclxuXHR2YXIgYm91bmRzID0gdG9MYXRMbmdCb3VuZHMobGF0bG5ncyk7XHJcblx0dmFyIGFyZWFCb3VuZHMgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCkuZGlzdGFuY2VUbyhib3VuZHMuZ2V0U291dGhXZXN0KCkpICogYm91bmRzLmdldE5vcnRoRWFzdCgpLmRpc3RhbmNlVG8oYm91bmRzLmdldE5vcnRoV2VzdCgpKTtcclxuXHQvLyB0ZXN0cyBzaG93ZWQgdGhhdCBiZWxvdyAxNzAwIHJvdW5kaW5nIGVycm9ycyBhcmUgaGFwcGVuaW5nXHJcblx0aWYgKGFyZWFCb3VuZHMgPCAxNzAwKSB7XHJcblx0XHQvLyBnZXR0aW5nIGEgaW5leGFjdCBjZW50ZXIsIHRvIG1vdmUgdGhlIGxhdGxuZ3MgbmVhciB0byBbMCwgMF0gdG8gcHJldmVudCByb3VuZGluZyBlcnJvcnNcclxuXHRcdGNlbnRyb2lkTGF0TG5nID0gY2VudHJvaWQobGF0bG5ncyk7XHJcblx0fVxyXG5cclxuXHR2YXIgbGVuID0gbGF0bG5ncy5sZW5ndGg7XHJcblx0dmFyIHBvaW50cyA9IFtdO1xyXG5cdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0dmFyIGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZ3NbaV0pO1xyXG5cdFx0cG9pbnRzLnB1c2goY3JzLnByb2plY3QodG9MYXRMbmcoW2xhdGxuZy5sYXQgLSBjZW50cm9pZExhdExuZy5sYXQsIGxhdGxuZy5sbmcgLSBjZW50cm9pZExhdExuZy5sbmddKSkpO1xyXG5cdH1cclxuXHJcblx0YXJlYSA9IHggPSB5ID0gMDtcclxuXHJcblx0Ly8gcG9seWdvbiBjZW50cm9pZCBhbGdvcml0aG07XHJcblx0Zm9yIChpID0gMCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcclxuXHRcdHAxID0gcG9pbnRzW2ldO1xyXG5cdFx0cDIgPSBwb2ludHNbal07XHJcblxyXG5cdFx0ZiA9IHAxLnkgKiBwMi54IC0gcDIueSAqIHAxLng7XHJcblx0XHR4ICs9IChwMS54ICsgcDIueCkgKiBmO1xyXG5cdFx0eSArPSAocDEueSArIHAyLnkpICogZjtcclxuXHRcdGFyZWEgKz0gZiAqIDM7XHJcblx0fVxyXG5cclxuXHRpZiAoYXJlYSA9PT0gMCkge1xyXG5cdFx0Ly8gUG9seWdvbiBpcyBzbyBzbWFsbCB0aGF0IGFsbCBwb2ludHMgYXJlIG9uIHNhbWUgcGl4ZWwuXHJcblx0XHRjZW50ZXIgPSBwb2ludHNbMF07XHJcblx0fSBlbHNlIHtcclxuXHRcdGNlbnRlciA9IFt4IC8gYXJlYSwgeSAvIGFyZWFdO1xyXG5cdH1cclxuXHJcblx0dmFyIGxhdGxuZ0NlbnRlciA9IGNycy51bnByb2plY3QodG9Qb2ludChjZW50ZXIpKTtcclxuXHRyZXR1cm4gdG9MYXRMbmcoW2xhdGxuZ0NlbnRlci5sYXQgKyBjZW50cm9pZExhdExuZy5sYXQsIGxhdGxuZ0NlbnRlci5sbmcgKyBjZW50cm9pZExhdExuZy5sbmddKTtcclxufVxyXG5cclxuLyogQGZ1bmN0aW9uIGNlbnRyb2lkKGxhdGxuZ3M6IExhdExuZ1tdKTogTGF0TG5nXHJcbiAqIFJldHVybnMgdGhlICdjZW50ZXIgb2YgbWFzcycgb2YgdGhlIHBhc3NlZCBMYXRMbmdzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNlbnRyb2lkKGNvb3Jkcykge1xyXG5cdHZhciBsYXRTdW0gPSAwO1xyXG5cdHZhciBsbmdTdW0gPSAwO1xyXG5cdHZhciBsZW4gPSAwO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgbGF0bG5nID0gdG9MYXRMbmcoY29vcmRzW2ldKTtcclxuXHRcdGxhdFN1bSArPSBsYXRsbmcubGF0O1xyXG5cdFx0bG5nU3VtICs9IGxhdGxuZy5sbmc7XHJcblx0XHRsZW4rKztcclxuXHR9XHJcblx0cmV0dXJuIHRvTGF0TG5nKFtsYXRTdW0gLyBsZW4sIGxuZ1N1bSAvIGxlbl0pO1xyXG59XHJcbiIsImltcG9ydCB7UG9pbnQsIHRvUG9pbnR9IGZyb20gJy4vUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQge2NlbnRyb2lkfSBmcm9tICcuL1BvbHlVdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcblxyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBMaW5lVXRpbFxyXG4gKlxyXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5bGluZSBwb2ludHMgcHJvY2Vzc2luZywgdXNlZCBieSBMZWFmbGV0IGludGVybmFsbHkgdG8gbWFrZSBwb2x5bGluZXMgbGlnaHRuaW5nLWZhc3QuXHJcbiAqL1xyXG5cclxuLy8gU2ltcGxpZnkgcG9seWxpbmUgd2l0aCB2ZXJ0ZXggcmVkdWN0aW9uIGFuZCBEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24uXHJcbi8vIEltcHJvdmVzIHJlbmRlcmluZyBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgYnkgbGVzc2VuaW5nIHRoZSBudW1iZXIgb2YgcG9pbnRzIHRvIGRyYXcuXHJcblxyXG4vLyBAZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzOiBQb2ludFtdLCB0b2xlcmFuY2U6IE51bWJlcik6IFBvaW50W11cclxuLy8gRHJhbWF0aWNhbGx5IHJlZHVjZXMgdGhlIG51bWJlciBvZiBwb2ludHMgaW4gYSBwb2x5bGluZSB3aGlsZSByZXRhaW5pbmdcclxuLy8gaXRzIHNoYXBlIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IG9mIHNpbXBsaWZpZWQgcG9pbnRzLCB1c2luZyB0aGVcclxuLy8gW1JhbWVyLURvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JhbWVyLURvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG0pLlxyXG4vLyBVc2VkIGZvciBhIGh1Z2UgcGVyZm9ybWFuY2UgYm9vc3Qgd2hlbiBwcm9jZXNzaW5nL2Rpc3BsYXlpbmcgTGVhZmxldCBwb2x5bGluZXMgZm9yXHJcbi8vIGVhY2ggem9vbSBsZXZlbCBhbmQgYWxzbyByZWR1Y2luZyB2aXN1YWwgbm9pc2UuIHRvbGVyYW5jZSBhZmZlY3RzIHRoZSBhbW91bnQgb2ZcclxuLy8gc2ltcGxpZmljYXRpb24gKGxlc3NlciB2YWx1ZSBtZWFucyBoaWdoZXIgcXVhbGl0eSBidXQgc2xvd2VyIGFuZCB3aXRoIG1vcmUgcG9pbnRzKS5cclxuLy8gQWxzbyByZWxlYXNlZCBhcyBhIHNlcGFyYXRlZCBtaWNyby1saWJyYXJ5IFtTaW1wbGlmeS5qc10oaHR0cHM6Ly9tb3VybmVyLmdpdGh1Yi5pby9zaW1wbGlmeS1qcy8pLlxyXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UpIHtcclxuXHRpZiAoIXRvbGVyYW5jZSB8fCAhcG9pbnRzLmxlbmd0aCkge1xyXG5cdFx0cmV0dXJuIHBvaW50cy5zbGljZSgpO1xyXG5cdH1cclxuXHJcblx0dmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xyXG5cclxuXHQgICAgLy8gc3RhZ2UgMTogdmVydGV4IHJlZHVjdGlvblxyXG5cdCAgICBwb2ludHMgPSBfcmVkdWNlUG9pbnRzKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuXHQgICAgLy8gc3RhZ2UgMjogRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uXHJcblx0ICAgIHBvaW50cyA9IF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiBwb2ludCBgcGAgYW5kIHNlZ21lbnQgYHAxYCB0byBgcDJgLlxyXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwMSwgcDIpIHtcclxuXHRyZXR1cm4gTWF0aC5zcXJ0KF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHRydWUpKTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGNsb3Nlc3RQb2ludE9uU2VnbWVudChwOiBQb2ludCwgcDE6IFBvaW50LCBwMjogUG9pbnQpOiBOdW1iZXJcclxuLy8gUmV0dXJucyB0aGUgY2xvc2VzdCBwb2ludCBmcm9tIGEgcG9pbnQgYHBgIG9uIGEgc2VnbWVudCBgcDFgIHRvIGBwMmAuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbG9zZXN0UG9pbnRPblNlZ21lbnQocCwgcDEsIHAyKSB7XHJcblx0cmV0dXJuIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpO1xyXG59XHJcblxyXG4vLyBSYW1lci1Eb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24sIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW1lci1Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtXHJcbmZ1bmN0aW9uIF9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpIHtcclxuXHJcblx0dmFyIGxlbiA9IHBvaW50cy5sZW5ndGgsXHJcblx0ICAgIEFycmF5Q29uc3RydWN0b3IgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gdW5kZWZpbmVkICsgJycgPyBVaW50OEFycmF5IDogQXJyYXksXHJcblx0ICAgIG1hcmtlcnMgPSBuZXcgQXJyYXlDb25zdHJ1Y3RvcihsZW4pO1xyXG5cclxuXHQgICAgbWFya2Vyc1swXSA9IG1hcmtlcnNbbGVuIC0gMV0gPSAxO1xyXG5cclxuXHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgMCwgbGVuIC0gMSk7XHJcblxyXG5cdHZhciBpLFxyXG5cdCAgICBuZXdQb2ludHMgPSBbXTtcclxuXHJcblx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRpZiAobWFya2Vyc1tpXSkge1xyXG5cdFx0XHRuZXdQb2ludHMucHVzaChwb2ludHNbaV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ld1BvaW50cztcclxufVxyXG5cclxuZnVuY3Rpb24gX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBsYXN0KSB7XHJcblxyXG5cdHZhciBtYXhTcURpc3QgPSAwLFxyXG5cdGluZGV4LCBpLCBzcURpc3Q7XHJcblxyXG5cdGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8PSBsYXN0IC0gMTsgaSsrKSB7XHJcblx0XHRzcURpc3QgPSBfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0sIHRydWUpO1xyXG5cclxuXHRcdGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcclxuXHRcdFx0aW5kZXggPSBpO1xyXG5cdFx0XHRtYXhTcURpc3QgPSBzcURpc3Q7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdG1hcmtlcnNbaW5kZXhdID0gMTtcclxuXHJcblx0XHRfc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBtYXJrZXJzLCBzcVRvbGVyYW5jZSwgZmlyc3QsIGluZGV4KTtcclxuXHRcdF9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBpbmRleCwgbGFzdCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyByZWR1Y2UgcG9pbnRzIHRoYXQgYXJlIHRvbyBjbG9zZSB0byBlYWNoIG90aGVyIHRvIGEgc2luZ2xlIHBvaW50XHJcbmZ1bmN0aW9uIF9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cdHZhciByZWR1Y2VkUG9pbnRzID0gW3BvaW50c1swXV07XHJcblxyXG5cdGZvciAodmFyIGkgPSAxLCBwcmV2ID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRpZiAoX3NxRGlzdChwb2ludHNbaV0sIHBvaW50c1twcmV2XSkgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdFx0cHJldiA9IGk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChwcmV2IDwgbGVuIC0gMSkge1xyXG5cdFx0cmVkdWNlZFBvaW50cy5wdXNoKHBvaW50c1tsZW4gLSAxXSk7XHJcblx0fVxyXG5cdHJldHVybiByZWR1Y2VkUG9pbnRzO1xyXG59XHJcblxyXG52YXIgX2xhc3RDb2RlO1xyXG5cclxuLy8gQGZ1bmN0aW9uIGNsaXBTZWdtZW50KGE6IFBvaW50LCBiOiBQb2ludCwgYm91bmRzOiBCb3VuZHMsIHVzZUxhc3RDb2RlPzogQm9vbGVhbiwgcm91bmQ/OiBCb29sZWFuKTogUG9pbnRbXXxCb29sZWFuXHJcbi8vIENsaXBzIHRoZSBzZWdtZW50IGEgdG8gYiBieSByZWN0YW5ndWxhciBib3VuZHMgd2l0aCB0aGVcclxuLy8gW0NvaGVuLVN1dGhlcmxhbmQgYWxnb3JpdGhtXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2hlbiVFMiU4MCU5M1N1dGhlcmxhbmRfYWxnb3JpdGhtKVxyXG4vLyAobW9kaWZ5aW5nIHRoZSBzZWdtZW50IHBvaW50cyBkaXJlY3RseSEpLiBVc2VkIGJ5IExlYWZsZXQgdG8gb25seSBzaG93IHBvbHlsaW5lXHJcbi8vIHBvaW50cyB0aGF0IGFyZSBvbiB0aGUgc2NyZWVuIG9yIG5lYXIsIGluY3JlYXNpbmcgcGVyZm9ybWFuY2UuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGlwU2VnbWVudChhLCBiLCBib3VuZHMsIHVzZUxhc3RDb2RlLCByb3VuZCkge1xyXG5cdHZhciBjb2RlQSA9IHVzZUxhc3RDb2RlID8gX2xhc3RDb2RlIDogX2dldEJpdENvZGUoYSwgYm91bmRzKSxcclxuXHQgICAgY29kZUIgPSBfZ2V0Qml0Q29kZShiLCBib3VuZHMpLFxyXG5cclxuXHQgICAgY29kZU91dCwgcCwgbmV3Q29kZTtcclxuXHJcblx0ICAgIC8vIHNhdmUgMm5kIGNvZGUgdG8gYXZvaWQgY2FsY3VsYXRpbmcgaXQgb24gdGhlIG5leHQgc2VnbWVudFxyXG5cdCAgICBfbGFzdENvZGUgPSBjb2RlQjtcclxuXHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdC8vIGlmIGEsYiBpcyBpbnNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIGFjY2VwdClcclxuXHRcdGlmICghKGNvZGVBIHwgY29kZUIpKSB7XHJcblx0XHRcdHJldHVybiBbYSwgYl07XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaWYgYSxiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIHJlamVjdClcclxuXHRcdGlmIChjb2RlQSAmIGNvZGVCKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBvdGhlciBjYXNlc1xyXG5cdFx0Y29kZU91dCA9IGNvZGVBIHx8IGNvZGVCO1xyXG5cdFx0cCA9IF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGVPdXQsIGJvdW5kcywgcm91bmQpO1xyXG5cdFx0bmV3Q29kZSA9IF9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKGNvZGVPdXQgPT09IGNvZGVBKSB7XHJcblx0XHRcdGEgPSBwO1xyXG5cdFx0XHRjb2RlQSA9IG5ld0NvZGU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRiID0gcDtcclxuXHRcdFx0Y29kZUIgPSBuZXdDb2RlO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRFZGdlSW50ZXJzZWN0aW9uKGEsIGIsIGNvZGUsIGJvdW5kcywgcm91bmQpIHtcclxuXHR2YXIgZHggPSBiLnggLSBhLngsXHJcblx0ICAgIGR5ID0gYi55IC0gYS55LFxyXG5cdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdCAgICBtYXggPSBib3VuZHMubWF4LFxyXG5cdCAgICB4LCB5O1xyXG5cclxuXHRpZiAoY29kZSAmIDgpIHsgLy8gdG9wXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWF4LnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWF4Lnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDQpIHsgLy8gYm90dG9tXHJcblx0XHR4ID0gYS54ICsgZHggKiAobWluLnkgLSBhLnkpIC8gZHk7XHJcblx0XHR5ID0gbWluLnk7XHJcblxyXG5cdH0gZWxzZSBpZiAoY29kZSAmIDIpIHsgLy8gcmlnaHRcclxuXHRcdHggPSBtYXgueDtcclxuXHRcdHkgPSBhLnkgKyBkeSAqIChtYXgueCAtIGEueCkgLyBkeDtcclxuXHJcblx0fSBlbHNlIGlmIChjb2RlICYgMSkgeyAvLyBsZWZ0XHJcblx0XHR4ID0gbWluLng7XHJcblx0XHR5ID0gYS55ICsgZHkgKiAobWluLnggLSBhLngpIC8gZHg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbmV3IFBvaW50KHgsIHksIHJvdW5kKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRCaXRDb2RlKHAsIGJvdW5kcykge1xyXG5cdHZhciBjb2RlID0gMDtcclxuXHJcblx0aWYgKHAueCA8IGJvdW5kcy5taW4ueCkgeyAvLyBsZWZ0XHJcblx0XHRjb2RlIHw9IDE7XHJcblx0fSBlbHNlIGlmIChwLnggPiBib3VuZHMubWF4LngpIHsgLy8gcmlnaHRcclxuXHRcdGNvZGUgfD0gMjtcclxuXHR9XHJcblxyXG5cdGlmIChwLnkgPCBib3VuZHMubWluLnkpIHsgLy8gYm90dG9tXHJcblx0XHRjb2RlIHw9IDQ7XHJcblx0fSBlbHNlIGlmIChwLnkgPiBib3VuZHMubWF4LnkpIHsgLy8gdG9wXHJcblx0XHRjb2RlIHw9IDg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gY29kZTtcclxufVxyXG5cclxuLy8gc3F1YXJlIGRpc3RhbmNlICh0byBhdm9pZCB1bm5lY2Vzc2FyeSBNYXRoLnNxcnQgY2FsbHMpXHJcbmZ1bmN0aW9uIF9zcURpc3QocDEsIHAyKSB7XHJcblx0dmFyIGR4ID0gcDIueCAtIHAxLngsXHJcblx0ICAgIGR5ID0gcDIueSAtIHAxLnk7XHJcblx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG59XHJcblxyXG4vLyByZXR1cm4gY2xvc2VzdCBwb2ludCBvbiBzZWdtZW50IG9yIGRpc3RhbmNlIHRvIHRoYXQgcG9pbnRcclxuZXhwb3J0IGZ1bmN0aW9uIF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHNxRGlzdCkge1xyXG5cdHZhciB4ID0gcDEueCxcclxuXHQgICAgeSA9IHAxLnksXHJcblx0ICAgIGR4ID0gcDIueCAtIHgsXHJcblx0ICAgIGR5ID0gcDIueSAtIHksXHJcblx0ICAgIGRvdCA9IGR4ICogZHggKyBkeSAqIGR5LFxyXG5cdCAgICB0O1xyXG5cclxuXHRpZiAoZG90ID4gMCkge1xyXG5cdFx0dCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIGRvdDtcclxuXHJcblx0XHRpZiAodCA+IDEpIHtcclxuXHRcdFx0eCA9IHAyLng7XHJcblx0XHRcdHkgPSBwMi55O1xyXG5cdFx0fSBlbHNlIGlmICh0ID4gMCkge1xyXG5cdFx0XHR4ICs9IGR4ICogdDtcclxuXHRcdFx0eSArPSBkeSAqIHQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRkeCA9IHAueCAtIHg7XHJcblx0ZHkgPSBwLnkgLSB5O1xyXG5cclxuXHRyZXR1cm4gc3FEaXN0ID8gZHggKiBkeCArIGR5ICogZHkgOiBuZXcgUG9pbnQoeCwgeSk7XHJcbn1cclxuXHJcblxyXG4vLyBAZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3M6IExhdExuZ1tdKTogQm9vbGVhblxyXG4vLyBSZXR1cm5zIHRydWUgaWYgYGxhdGxuZ3NgIGlzIGEgZmxhdCBhcnJheSwgZmFsc2UgaXMgbmVzdGVkLlxyXG5leHBvcnQgZnVuY3Rpb24gaXNGbGF0KGxhdGxuZ3MpIHtcclxuXHRyZXR1cm4gIVV0aWwuaXNBcnJheShsYXRsbmdzWzBdKSB8fCAodHlwZW9mIGxhdGxuZ3NbMF1bMF0gIT09ICdvYmplY3QnICYmIHR5cGVvZiBsYXRsbmdzWzBdWzBdICE9PSAndW5kZWZpbmVkJyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfZmxhdChsYXRsbmdzKSB7XHJcblx0Y29uc29sZS53YXJuKCdEZXByZWNhdGVkIHVzZSBvZiBfZmxhdCwgcGxlYXNlIHVzZSBMLkxpbmVVdGlsLmlzRmxhdCBpbnN0ZWFkLicpO1xyXG5cdHJldHVybiBpc0ZsYXQobGF0bG5ncyk7XHJcbn1cclxuXHJcbi8qIEBmdW5jdGlvbiBwb2x5bGluZUNlbnRlcihsYXRsbmdzOiBMYXRMbmdbXSwgY3JzOiBDUlMpOiBMYXRMbmdcclxuICogUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgcGFzc2VkIExhdExuZ3MgKGZpcnN0IHJpbmcpIGZyb20gYSBwb2x5bGluZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwb2x5bGluZUNlbnRlcihsYXRsbmdzLCBjcnMpIHtcclxuXHR2YXIgaSwgaGFsZkRpc3QsIHNlZ0Rpc3QsIGRpc3QsIHAxLCBwMiwgcmF0aW8sIGNlbnRlcjtcclxuXHJcblx0aWYgKCFsYXRsbmdzIHx8IGxhdGxuZ3MubGVuZ3RoID09PSAwKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2xhdGxuZ3Mgbm90IHBhc3NlZCcpO1xyXG5cdH1cclxuXHJcblx0aWYgKCFpc0ZsYXQobGF0bG5ncykpIHtcclxuXHRcdGNvbnNvbGUud2FybignbGF0bG5ncyBhcmUgbm90IGZsYXQhIE9ubHkgdGhlIGZpcnN0IHJpbmcgd2lsbCBiZSB1c2VkJyk7XHJcblx0XHRsYXRsbmdzID0gbGF0bG5nc1swXTtcclxuXHR9XHJcblxyXG5cdHZhciBjZW50cm9pZExhdExuZyA9IHRvTGF0TG5nKFswLCAwXSk7XHJcblxyXG5cdHZhciBib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhsYXRsbmdzKTtcclxuXHR2YXIgYXJlYUJvdW5kcyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKS5kaXN0YW5jZVRvKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSkgKiBib3VuZHMuZ2V0Tm9ydGhFYXN0KCkuZGlzdGFuY2VUbyhib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpO1xyXG5cdC8vIHRlc3RzIHNob3dlZCB0aGF0IGJlbG93IDE3MDAgcm91bmRpbmcgZXJyb3JzIGFyZSBoYXBwZW5pbmdcclxuXHRpZiAoYXJlYUJvdW5kcyA8IDE3MDApIHtcclxuXHRcdC8vIGdldHRpbmcgYSBpbmV4YWN0IGNlbnRlciwgdG8gbW92ZSB0aGUgbGF0bG5ncyBuZWFyIHRvIFswLCAwXSB0byBwcmV2ZW50IHJvdW5kaW5nIGVycm9yc1xyXG5cdFx0Y2VudHJvaWRMYXRMbmcgPSBjZW50cm9pZChsYXRsbmdzKTtcclxuXHR9XHJcblxyXG5cdHZhciBsZW4gPSBsYXRsbmdzLmxlbmd0aDtcclxuXHR2YXIgcG9pbnRzID0gW107XHJcblx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR2YXIgbGF0bG5nID0gdG9MYXRMbmcobGF0bG5nc1tpXSk7XHJcblx0XHRwb2ludHMucHVzaChjcnMucHJvamVjdCh0b0xhdExuZyhbbGF0bG5nLmxhdCAtIGNlbnRyb2lkTGF0TG5nLmxhdCwgbGF0bG5nLmxuZyAtIGNlbnRyb2lkTGF0TG5nLmxuZ10pKSk7XHJcblx0fVxyXG5cclxuXHRmb3IgKGkgPSAwLCBoYWxmRGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcclxuXHRcdGhhbGZEaXN0ICs9IHBvaW50c1tpXS5kaXN0YW5jZVRvKHBvaW50c1tpICsgMV0pIC8gMjtcclxuXHR9XHJcblxyXG5cdC8vIFRoZSBsaW5lIGlzIHNvIHNtYWxsIGluIHRoZSBjdXJyZW50IHZpZXcgdGhhdCBhbGwgcG9pbnRzIGFyZSBvbiB0aGUgc2FtZSBwaXhlbC5cclxuXHRpZiAoaGFsZkRpc3QgPT09IDApIHtcclxuXHRcdGNlbnRlciA9IHBvaW50c1swXTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Zm9yIChpID0gMCwgZGlzdCA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcclxuXHRcdFx0cDEgPSBwb2ludHNbaV07XHJcblx0XHRcdHAyID0gcG9pbnRzW2kgKyAxXTtcclxuXHRcdFx0c2VnRGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xyXG5cdFx0XHRkaXN0ICs9IHNlZ0Rpc3Q7XHJcblxyXG5cdFx0XHRpZiAoZGlzdCA+IGhhbGZEaXN0KSB7XHJcblx0XHRcdFx0cmF0aW8gPSAoZGlzdCAtIGhhbGZEaXN0KSAvIHNlZ0Rpc3Q7XHJcblx0XHRcdFx0Y2VudGVyID0gW1xyXG5cdFx0XHRcdFx0cDIueCAtIHJhdGlvICogKHAyLnggLSBwMS54KSxcclxuXHRcdFx0XHRcdHAyLnkgLSByYXRpbyAqIChwMi55IC0gcDEueSlcclxuXHRcdFx0XHRdO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR2YXIgbGF0bG5nQ2VudGVyID0gY3JzLnVucHJvamVjdCh0b1BvaW50KGNlbnRlcikpO1xyXG5cdHJldHVybiB0b0xhdExuZyhbbGF0bG5nQ2VudGVyLmxhdCArIGNlbnRyb2lkTGF0TG5nLmxhdCwgbGF0bG5nQ2VudGVyLmxuZyArIGNlbnRyb2lkTGF0TG5nLmxuZ10pO1xyXG59XHJcbiIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBzZWN0aW9uXHJcbiAqIExlYWZsZXQgY29tZXMgd2l0aCBhIHNldCBvZiBhbHJlYWR5IGRlZmluZWQgUHJvamVjdGlvbnMgb3V0IG9mIHRoZSBib3g6XHJcbiAqXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5Mb25MYXRcclxuICpcclxuICogRXF1aXJlY3Rhbmd1bGFyLCBvciBQbGF0ZSBDYXJyZWUgcHJvamVjdGlvbiDigJQgdGhlIG1vc3Qgc2ltcGxlIHByb2plY3Rpb24sXHJcbiAqIG1vc3RseSB1c2VkIGJ5IEdJUyBlbnRodXNpYXN0cy4gRGlyZWN0bHkgbWFwcyBgeGAgYXMgbG9uZ2l0dWRlLCBhbmQgYHlgIGFzXHJcbiAqIGxhdGl0dWRlLiBBbHNvIHN1aXRhYmxlIGZvciBmbGF0IHdvcmxkcywgZS5nLiBnYW1lIG1hcHMuIFVzZWQgYnkgdGhlXHJcbiAqIGBFUFNHOjQzMjZgIGFuZCBgU2ltcGxlYCBDUlMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBMb25MYXQgPSB7XHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcocG9pbnQueSwgcG9pbnQueCk7XHJcblx0fSxcclxuXHJcblx0Ym91bmRzOiBuZXcgQm91bmRzKFstMTgwLCAtOTBdLCBbMTgwLCA5MF0pXHJcbn07XHJcbiIsImltcG9ydCB7TGF0TG5nfSBmcm9tICcuLi9MYXRMbmcnO1xyXG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBQcm9qZWN0aW9uXHJcbiAqIEBwcm9qZWN0aW9uIEwuUHJvamVjdGlvbi5NZXJjYXRvclxyXG4gKlxyXG4gKiBFbGxpcHRpY2FsIE1lcmNhdG9yIHByb2plY3Rpb24g4oCUIG1vcmUgY29tcGxleCB0aGFuIFNwaGVyaWNhbCBNZXJjYXRvci4gQXNzdW1lcyB0aGF0IEVhcnRoIGlzIGFuIGVsbGlwc29pZC4gVXNlZCBieSB0aGUgRVBTRzozMzk1IENSUy5cclxuICovXHJcblxyXG5leHBvcnQgdmFyIE1lcmNhdG9yID0ge1xyXG5cdFI6IDYzNzgxMzcsXHJcblx0Ul9NSU5PUjogNjM1Njc1Mi4zMTQyNDUxNzksXHJcblxyXG5cdGJvdW5kczogbmV3IEJvdW5kcyhbLTIwMDM3NTA4LjM0Mjc5LCAtMTU0OTY1NzAuNzM5NzJdLCBbMjAwMzc1MDguMzQyNzksIDE4NzY0NjU2LjIzMTM4XSksXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBkID0gTWF0aC5QSSAvIDE4MCxcclxuXHRcdCAgICByID0gdGhpcy5SLFxyXG5cdFx0ICAgIHkgPSBsYXRsbmcubGF0ICogZCxcclxuXHRcdCAgICB0bXAgPSB0aGlzLlJfTUlOT1IgLyByLFxyXG5cdFx0ICAgIGUgPSBNYXRoLnNxcnQoMSAtIHRtcCAqIHRtcCksXHJcblx0XHQgICAgY29uID0gZSAqIE1hdGguc2luKHkpO1xyXG5cclxuXHRcdHZhciB0cyA9IE1hdGgudGFuKE1hdGguUEkgLyA0IC0geSAvIDIpIC8gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlIC8gMik7XHJcblx0XHR5ID0gLXIgKiBNYXRoLmxvZyhNYXRoLm1heCh0cywgMUUtMTApKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBvaW50KGxhdGxuZy5sbmcgKiBkICogciwgeSk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHZhciBkID0gMTgwIC8gTWF0aC5QSSxcclxuXHRcdCAgICByID0gdGhpcy5SLFxyXG5cdFx0ICAgIHRtcCA9IHRoaXMuUl9NSU5PUiAvIHIsXHJcblx0XHQgICAgZSA9IE1hdGguc3FydCgxIC0gdG1wICogdG1wKSxcclxuXHRcdCAgICB0cyA9IE1hdGguZXhwKC1wb2ludC55IC8gciksXHJcblx0XHQgICAgcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgZHBoaSA9IDAuMSwgY29uOyBpIDwgMTUgJiYgTWF0aC5hYnMoZHBoaSkgPiAxZS03OyBpKyspIHtcclxuXHRcdFx0Y29uID0gZSAqIE1hdGguc2luKHBoaSk7XHJcblx0XHRcdGNvbiA9IE1hdGgucG93KCgxIC0gY29uKSAvICgxICsgY29uKSwgZSAvIDIpO1xyXG5cdFx0XHRkcGhpID0gTWF0aC5QSSAvIDIgLSAyICogTWF0aC5hdGFuKHRzICogY29uKSAtIHBoaTtcclxuXHRcdFx0cGhpICs9IGRwaGk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRMbmcocGhpICogZCwgcG9pbnQueCAqIGQgLyByKTtcclxuXHR9XHJcbn07XHJcbiIsIi8qXG4gKiBAY2xhc3MgUHJvamVjdGlvblxuXG4gKiBBbiBvYmplY3Qgd2l0aCBtZXRob2RzIGZvciBwcm9qZWN0aW5nIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgd29ybGQgb250b1xuICogYSBmbGF0IHN1cmZhY2UgKGFuZCBiYWNrKS4gU2VlIFtNYXAgcHJvamVjdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFwX3Byb2plY3Rpb24pLlxuXG4gKiBAcHJvcGVydHkgYm91bmRzOiBCb3VuZHNcbiAqIFRoZSBib3VuZHMgKHNwZWNpZmllZCBpbiBDUlMgdW5pdHMpIHdoZXJlIHRoZSBwcm9qZWN0aW9uIGlzIHZhbGlkXG5cbiAqIEBtZXRob2QgcHJvamVjdChsYXRsbmc6IExhdExuZyk6IFBvaW50XG4gKiBQcm9qZWN0cyBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMgaW50byBhIDJEIHBvaW50LlxuICogT25seSBhY2NlcHRzIGFjdHVhbCBgTC5MYXRMbmdgIGluc3RhbmNlcywgbm90IGFycmF5cy5cblxuICogQG1ldGhvZCB1bnByb2plY3QocG9pbnQ6IFBvaW50KTogTGF0TG5nXG4gKiBUaGUgaW52ZXJzZSBvZiBgcHJvamVjdGAuIFByb2plY3RzIGEgMkQgcG9pbnQgaW50byBhIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi5cbiAqIE9ubHkgYWNjZXB0cyBhY3R1YWwgYEwuUG9pbnRgIGluc3RhbmNlcywgbm90IGFycmF5cy5cblxuICogTm90ZSB0aGF0IHRoZSBwcm9qZWN0aW9uIGluc3RhbmNlcyBkbyBub3QgaW5oZXJpdCBmcm9tIExlYWZsZXQncyBgQ2xhc3NgIG9iamVjdCxcbiAqIGFuZCBjYW4ndCBiZSBpbnN0YW50aWF0ZWQuIEFsc28sIG5ldyBjbGFzc2VzIGNhbid0IGluaGVyaXQgZnJvbSB0aGVtLFxuICogYW5kIG1ldGhvZHMgY2FuJ3QgYmUgYWRkZWQgdG8gdGhlbSB3aXRoIHRoZSBgaW5jbHVkZWAgZnVuY3Rpb24uXG5cbiAqL1xuXG5leHBvcnQge0xvbkxhdH0gZnJvbSAnLi9Qcm9qZWN0aW9uLkxvbkxhdCc7XG5leHBvcnQge01lcmNhdG9yfSBmcm9tICcuL1Byb2plY3Rpb24uTWVyY2F0b3InO1xuZXhwb3J0IHtTcGhlcmljYWxNZXJjYXRvcn0gZnJvbSAnLi9Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yJztcbiIsImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtNZXJjYXRvcn0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLk1lcmNhdG9yJztcclxuaW1wb3J0IHt0b1RyYW5zZm9ybWF0aW9ufSBmcm9tICcuLi8uLi9nZW9tZXRyeS9UcmFuc2Zvcm1hdGlvbic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgQ1JTXHJcbiAqIEBjcnMgTC5DUlMuRVBTRzMzOTVcclxuICpcclxuICogUmFyZWx5IHVzZWQgYnkgc29tZSBjb21tZXJjaWFsIHRpbGUgcHJvdmlkZXJzLiBVc2VzIEVsbGlwdGljYWwgTWVyY2F0b3IgcHJvamVjdGlvbi5cclxuICovXHJcbmV4cG9ydCB2YXIgRVBTRzMzOTUgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzozMzk1JyxcclxuXHRwcm9qZWN0aW9uOiBNZXJjYXRvcixcclxuXHJcblx0dHJhbnNmb3JtYXRpb246IChmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIE1lcmNhdG9yLlIpO1xyXG5cdFx0cmV0dXJuIHRvVHJhbnNmb3JtYXRpb24oc2NhbGUsIDAuNSwgLXNjYWxlLCAwLjUpO1xyXG5cdH0oKSlcclxufSk7XHJcbiIsImltcG9ydCB7RWFydGh9IGZyb20gJy4vQ1JTLkVhcnRoJztcclxuaW1wb3J0IHtMb25MYXR9IGZyb20gJy4uL3Byb2plY3Rpb24vUHJvamVjdGlvbi5Mb25MYXQnO1xyXG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5cclxuLypcclxuICogQG5hbWVzcGFjZSBDUlNcclxuICogQGNycyBMLkNSUy5FUFNHNDMyNlxyXG4gKlxyXG4gKiBBIGNvbW1vbiBDUlMgYW1vbmcgR0lTIGVudGh1c2lhc3RzLiBVc2VzIHNpbXBsZSBFcXVpcmVjdGFuZ3VsYXIgcHJvamVjdGlvbi5cclxuICpcclxuICogTGVhZmxldCAxLjAueCBjb21wbGllcyB3aXRoIHRoZSBbVE1TIGNvb3JkaW5hdGUgc2NoZW1lIGZvciBFUFNHOjQzMjZdKGh0dHBzOi8vd2lraS5vc2dlby5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlX1NwZWNpZmljYXRpb24jZ2xvYmFsLWdlb2RldGljKSxcclxuICogd2hpY2ggaXMgYSBicmVha2luZyBjaGFuZ2UgZnJvbSAwLjcueCBiZWhhdmlvdXIuICBJZiB5b3UgYXJlIHVzaW5nIGEgYFRpbGVMYXllcmBcclxuICogd2l0aCB0aGlzIENSUywgZW5zdXJlIHRoYXQgdGhlcmUgYXJlIHR3byAyNTZ4MjU2IHBpeGVsIHRpbGVzIGNvdmVyaW5nIHRoZVxyXG4gKiB3aG9sZSBlYXJ0aCBhdCB6b29tIGxldmVsIHplcm8sIGFuZCB0aGF0IHRoZSB0aWxlIGNvb3JkaW5hdGUgb3JpZ2luIGlzICgtMTgwLCs5MCksXHJcbiAqIG9yICgtMTgwLC05MCkgZm9yIGBUaWxlTGF5ZXJgcyB3aXRoIFt0aGUgYHRtc2Agb3B0aW9uXSgjdGlsZWxheWVyLXRtcykgc2V0LlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRVBTRzQzMjYgPSBVdGlsLmV4dGVuZCh7fSwgRWFydGgsIHtcclxuXHRjb2RlOiAnRVBTRzo0MzI2JyxcclxuXHRwcm9qZWN0aW9uOiBMb25MYXQsXHJcblx0dHJhbnNmb3JtYXRpb246IHRvVHJhbnNmb3JtYXRpb24oMSAvIDE4MCwgMSwgLTEgLyAxODAsIDAuNSlcclxufSk7XHJcbiIsImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQge0xvbkxhdH0gZnJvbSAnLi4vcHJvamVjdGlvbi9Qcm9qZWN0aW9uLkxvbkxhdCc7XG5pbXBvcnQge3RvVHJhbnNmb3JtYXRpb259IGZyb20gJy4uLy4uL2dlb21ldHJ5L1RyYW5zZm9ybWF0aW9uJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBuYW1lc3BhY2UgQ1JTXG4gKiBAY3JzIEwuQ1JTLlNpbXBsZVxuICpcbiAqIEEgc2ltcGxlIENSUyB0aGF0IG1hcHMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBpbnRvIGB4YCBhbmQgYHlgIGRpcmVjdGx5LlxuICogTWF5IGJlIHVzZWQgZm9yIG1hcHMgb2YgZmxhdCBzdXJmYWNlcyAoZS5nLiBnYW1lIG1hcHMpLiBOb3RlIHRoYXQgdGhlIGB5YFxuICogYXhpcyBzaG91bGQgc3RpbGwgYmUgaW52ZXJ0ZWQgKGdvaW5nIGZyb20gYm90dG9tIHRvIHRvcCkuIGBkaXN0YW5jZSgpYCByZXR1cm5zXG4gKiBzaW1wbGUgZXVjbGlkZWFuIGRpc3RhbmNlLlxuICovXG5cbmV4cG9ydCB2YXIgU2ltcGxlID0gVXRpbC5leHRlbmQoe30sIENSUywge1xuXHRwcm9qZWN0aW9uOiBMb25MYXQsXG5cdHRyYW5zZm9ybWF0aW9uOiB0b1RyYW5zZm9ybWF0aW9uKDEsIDAsIC0xLCAwKSxcblxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcblx0XHRyZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7XG5cdH0sXG5cblx0em9vbTogZnVuY3Rpb24gKHNjYWxlKSB7XG5cdFx0cmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yO1xuXHR9LFxuXG5cdGRpc3RhbmNlOiBmdW5jdGlvbiAobGF0bG5nMSwgbGF0bG5nMikge1xuXHRcdHZhciBkeCA9IGxhdGxuZzIubG5nIC0gbGF0bG5nMS5sbmcsXG5cdFx0ICAgIGR5ID0gbGF0bG5nMi5sYXQgLSBsYXRsbmcxLmxhdDtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHR9LFxuXG5cdGluZmluaXRlOiB0cnVlXG59KTtcbiIsImltcG9ydCB7Q1JTfSBmcm9tICcuL0NSUyc7XG5pbXBvcnQge0VhcnRofSBmcm9tICcuL0NSUy5FYXJ0aCc7XG5pbXBvcnQge0VQU0czMzk1fSBmcm9tICcuL0NSUy5FUFNHMzM5NSc7XG5pbXBvcnQge0VQU0czODU3LCBFUFNHOTAwOTEzfSBmcm9tICcuL0NSUy5FUFNHMzg1Nyc7XG5pbXBvcnQge0VQU0c0MzI2fSBmcm9tICcuL0NSUy5FUFNHNDMyNic7XG5pbXBvcnQge1NpbXBsZX0gZnJvbSAnLi9DUlMuU2ltcGxlJztcblxuQ1JTLkVhcnRoID0gRWFydGg7XG5DUlMuRVBTRzMzOTUgPSBFUFNHMzM5NTtcbkNSUy5FUFNHMzg1NyA9IEVQU0czODU3O1xuQ1JTLkVQU0c5MDA5MTMgPSBFUFNHOTAwOTEzO1xuQ1JTLkVQU0c0MzI2ID0gRVBTRzQzMjY7XG5DUlMuU2ltcGxlID0gU2ltcGxlO1xuXG5leHBvcnQge0NSU307XG4iLCJpbXBvcnQge0V2ZW50ZWR9IGZyb20gJy4uL2NvcmUvRXZlbnRzJztcbmltcG9ydCB7TWFwfSBmcm9tICcuLi9tYXAvTWFwJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBjbGFzcyBMYXllclxuICogQGluaGVyaXRzIEV2ZW50ZWRcbiAqIEBha2EgTC5MYXllclxuICogQGFrYSBJTGF5ZXJcbiAqXG4gKiBBIHNldCBvZiBtZXRob2RzIGZyb20gdGhlIExheWVyIGJhc2UgY2xhc3MgdGhhdCBhbGwgTGVhZmxldCBsYXllcnMgdXNlLlxuICogSW5oZXJpdHMgYWxsIG1ldGhvZHMsIG9wdGlvbnMgYW5kIGV2ZW50cyBmcm9tIGBMLkV2ZW50ZWRgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIHZhciBsYXllciA9IEwubWFya2VyKGxhdGxuZykuYWRkVG8obWFwKTtcbiAqIGxheWVyLmFkZFRvKG1hcCk7XG4gKiBsYXllci5yZW1vdmUoKTtcbiAqIGBgYFxuICpcbiAqIEBldmVudCBhZGQ6IEV2ZW50XG4gKiBGaXJlZCBhZnRlciB0aGUgbGF5ZXIgaXMgYWRkZWQgdG8gYSBtYXBcbiAqXG4gKiBAZXZlbnQgcmVtb3ZlOiBFdmVudFxuICogRmlyZWQgYWZ0ZXIgdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSBhIG1hcFxuICovXG5cblxuZXhwb3J0IHZhciBMYXllciA9IEV2ZW50ZWQuZXh0ZW5kKHtcblxuXHQvLyBDbGFzc2VzIGV4dGVuZGluZyBgTC5MYXllcmAgd2lsbCBpbmhlcml0IHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcblx0b3B0aW9uczoge1xuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ292ZXJsYXlQYW5lJ1xuXHRcdC8vIEJ5IGRlZmF1bHQgdGhlIGxheWVyIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcCdzIFtvdmVybGF5IHBhbmVdKCNtYXAtb3ZlcmxheXBhbmUpLiBPdmVycmlkaW5nIHRoaXMgb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGxheWVyIHRvIGJlIHBsYWNlZCBvbiBhbm90aGVyIHBhbmUgYnkgZGVmYXVsdC5cblx0XHRwYW5lOiAnb3ZlcmxheVBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBhdHRyaWJ1dGlvbjogU3RyaW5nID0gbnVsbFxuXHRcdC8vIFN0cmluZyB0byBiZSBzaG93biBpbiB0aGUgYXR0cmlidXRpb24gY29udHJvbCwgZS5nLiBcIsKpIE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzXCIuIEl0IGRlc2NyaWJlcyB0aGUgbGF5ZXIgZGF0YSBhbmQgaXMgb2Z0ZW4gYSBsZWdhbCBvYmxpZ2F0aW9uIHRvd2FyZHMgY29weXJpZ2h0IGhvbGRlcnMgYW5kIHRpbGUgcHJvdmlkZXJzLlxuXHRcdGF0dHJpYnV0aW9uOiBudWxsLFxuXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuXHR9LFxuXG5cdC8qIEBzZWN0aW9uXG5cdCAqIENsYXNzZXMgZXh0ZW5kaW5nIGBMLkxheWVyYCB3aWxsIGluaGVyaXQgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuXHQgKlxuXHQgKiBAbWV0aG9kIGFkZFRvKG1hcDogTWFwfExheWVyR3JvdXApOiB0aGlzXG5cdCAqIEFkZHMgdGhlIGxheWVyIHRvIHRoZSBnaXZlbiBtYXAgb3IgbGF5ZXIgZ3JvdXAuXG5cdCAqL1xuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHJlbW92ZTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBsYXllciBmcm9tIHRoZSBtYXAgaXQgaXMgY3VycmVudGx5IGFjdGl2ZSBvbi5cblx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlRnJvbSh0aGlzLl9tYXAgfHwgdGhpcy5fbWFwVG9BZGQpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlRnJvbShtYXA6IE1hcCk6IHRoaXNcblx0Ly8gUmVtb3ZlcyB0aGUgbGF5ZXIgZnJvbSB0aGUgZ2l2ZW4gbWFwXG5cdC8vXG5cdC8vIEBhbHRlcm5hdGl2ZVxuXHQvLyBAbWV0aG9kIHJlbW92ZUZyb20oZ3JvdXA6IExheWVyR3JvdXApOiB0aGlzXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIGZyb20gdGhlIGdpdmVuIGBMYXllckdyb3VwYFxuXHRyZW1vdmVGcm9tOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0aWYgKG9iaikge1xuXHRcdFx0b2JqLnJlbW92ZUxheWVyKHRoaXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFBhbmUobmFtZT8gOiBTdHJpbmcpOiBIVE1MRWxlbWVudFxuXHQvLyBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIHJlcHJlc2VudGluZyB0aGUgbmFtZWQgcGFuZSBvbiB0aGUgbWFwLiBJZiBgbmFtZWAgaXMgb21pdHRlZCwgcmV0dXJucyB0aGUgcGFuZSBmb3IgdGhpcyBsYXllci5cblx0Z2V0UGFuZTogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFwLmdldFBhbmUobmFtZSA/ICh0aGlzLm9wdGlvbnNbbmFtZV0gfHwgbmFtZSkgOiB0aGlzLm9wdGlvbnMucGFuZSk7XG5cdH0sXG5cblx0YWRkSW50ZXJhY3RpdmVUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuXHRcdHRoaXMuX21hcC5fdGFyZ2V0c1tVdGlsLnN0YW1wKHRhcmdldEVsKV0gPSB0aGlzO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUludGVyYWN0aXZlVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcblx0XHRkZWxldGUgdGhpcy5fbWFwLl90YXJnZXRzW1V0aWwuc3RhbXAodGFyZ2V0RWwpXTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEF0dHJpYnV0aW9uOiBTdHJpbmdcblx0Ly8gVXNlZCBieSB0aGUgYGF0dHJpYnV0aW9uIGNvbnRyb2xgLCByZXR1cm5zIHRoZSBbYXR0cmlidXRpb24gb3B0aW9uXSgjZ3JpZGxheWVyLWF0dHJpYnV0aW9uKS5cblx0Z2V0QXR0cmlidXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xuXHR9LFxuXG5cdF9sYXllckFkZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gZS50YXJnZXQ7XG5cblx0XHQvLyBjaGVjayBpbiBjYXNlIGxheWVyIGdldHMgYWRkZWQgYW5kIHRoZW4gcmVtb3ZlZCBiZWZvcmUgdGhlIG1hcCBpcyByZWFkeVxuXHRcdGlmICghbWFwLmhhc0xheWVyKHRoaXMpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xuXG5cdFx0aWYgKHRoaXMuZ2V0RXZlbnRzKSB7XG5cdFx0XHR2YXIgZXZlbnRzID0gdGhpcy5nZXRFdmVudHMoKTtcblx0XHRcdG1hcC5vbihldmVudHMsIHRoaXMpO1xuXHRcdFx0dGhpcy5vbmNlKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdG1hcC5vZmYoZXZlbnRzLCB0aGlzKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMub25BZGQobWFwKTtcblxuXHRcdHRoaXMuZmlyZSgnYWRkJyk7XG5cdFx0bWFwLmZpcmUoJ2xheWVyYWRkJywge2xheWVyOiB0aGlzfSk7XG5cdH1cbn0pO1xuXG4vKiBAc2VjdGlvbiBFeHRlbnNpb24gbWV0aG9kc1xuICogQHVuaW5oZXJpdGFibGVcbiAqXG4gKiBFdmVyeSBsYXllciBzaG91bGQgZXh0ZW5kIGZyb20gYEwuTGF5ZXJgIGFuZCAocmUtKWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZHMuXG4gKlxuICogQG1ldGhvZCBvbkFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGNvZGUgdGhhdCBjcmVhdGVzIERPTSBlbGVtZW50cyBmb3IgdGhlIGxheWVyLCBhZGRzIHRoZW0gdG8gYG1hcCBwYW5lc2Agd2hlcmUgdGhleSBzaG91bGQgYmVsb25nIGFuZCBwdXRzIGxpc3RlbmVycyBvbiByZWxldmFudCBtYXAgZXZlbnRzLiBDYWxsZWQgb24gW2BtYXAuYWRkTGF5ZXIobGF5ZXIpYF0oI21hcC1hZGRsYXllcikuXG4gKlxuICogQG1ldGhvZCBvblJlbW92ZShtYXA6IE1hcCk6IHRoaXNcbiAqIFNob3VsZCBjb250YWluIGFsbCBjbGVhbiB1cCBjb2RlIHRoYXQgcmVtb3ZlcyB0aGUgbGF5ZXIncyBlbGVtZW50cyBmcm9tIHRoZSBET00gYW5kIHJlbW92ZXMgbGlzdGVuZXJzIHByZXZpb3VzbHkgYWRkZWQgaW4gW2BvbkFkZGBdKCNsYXllci1vbmFkZCkuIENhbGxlZCBvbiBbYG1hcC5yZW1vdmVMYXllcihsYXllcilgXSgjbWFwLXJlbW92ZWxheWVyKS5cbiAqXG4gKiBAbWV0aG9kIGdldEV2ZW50cygpOiBPYmplY3RcbiAqIFRoaXMgb3B0aW9uYWwgbWV0aG9kIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IGxpa2UgYHsgdmlld3Jlc2V0OiB0aGlzLl9yZXNldCB9YCBmb3IgW2BhZGRFdmVudExpc3RlbmVyYF0oI2V2ZW50ZWQtYWRkZXZlbnRsaXN0ZW5lcikuIFRoZSBldmVudCBoYW5kbGVycyBpbiB0aGlzIG9iamVjdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgbWFwIHdpdGggeW91ciBsYXllci5cbiAqXG4gKiBAbWV0aG9kIGdldEF0dHJpYnV0aW9uKCk6IFN0cmluZ1xuICogVGhpcyBvcHRpb25hbCBtZXRob2Qgc2hvdWxkIHJldHVybiBhIHN0cmluZyBjb250YWluaW5nIEhUTUwgdG8gYmUgc2hvd24gb24gdGhlIGBBdHRyaWJ1dGlvbiBjb250cm9sYCB3aGVuZXZlciB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIGJlZm9yZUFkZChtYXA6IE1hcCk6IHRoaXNcbiAqIE9wdGlvbmFsIG1ldGhvZC4gQ2FsbGVkIG9uIFtgbWFwLmFkZExheWVyKGxheWVyKWBdKCNtYXAtYWRkbGF5ZXIpLCBiZWZvcmUgdGhlIGxheWVyIGlzIGFkZGVkIHRvIHRoZSBtYXAsIGJlZm9yZSBldmVudHMgYXJlIGluaXRpYWxpemVkLCB3aXRob3V0IHdhaXRpbmcgdW50aWwgdGhlIG1hcCBpcyBpbiBhIHVzYWJsZSBzdGF0ZS4gVXNlIGZvciBlYXJseSBpbml0aWFsaXphdGlvbiBvbmx5LlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXBcbiAqIEBzZWN0aW9uIExheWVyIGV2ZW50c1xuICpcbiAqIEBldmVudCBsYXllcmFkZDogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBhIG5ldyBsYXllciBpcyBhZGRlZCB0byB0aGUgbWFwLlxuICpcbiAqIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxuICogRmlyZWQgd2hlbiBzb21lIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwXG4gKlxuICogQHNlY3Rpb24gTWV0aG9kcyBmb3IgTGF5ZXJzIGFuZCBDb250cm9sc1xuICovXG5NYXAuaW5jbHVkZSh7XG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBBZGRzIHRoZSBnaXZlbiBsYXllciB0byB0aGUgbWFwXG5cdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIWxheWVyLl9sYXllckFkZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgb2JqZWN0IGlzIG5vdCBhIExheWVyLicpO1xuXHRcdH1cblxuXHRcdHZhciBpZCA9IFV0aWwuc3RhbXAobGF5ZXIpO1xuXHRcdGlmICh0aGlzLl9sYXllcnNbaWRdKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fbGF5ZXJzW2lkXSA9IGxheWVyO1xuXG5cdFx0bGF5ZXIuX21hcFRvQWRkID0gdGhpcztcblxuXHRcdGlmIChsYXllci5iZWZvcmVBZGQpIHtcblx0XHRcdGxheWVyLmJlZm9yZUFkZCh0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLndoZW5SZWFkeShsYXllci5fbGF5ZXJBZGQsIGxheWVyKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVtb3ZlTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBtYXAuXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBVdGlsLnN0YW1wKGxheWVyKTtcblxuXHRcdGlmICghdGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0bGF5ZXIub25SZW1vdmUodGhpcyk7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG5cblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywge2xheWVyOiBsYXllcn0pO1xuXHRcdFx0bGF5ZXIuZmlyZSgncmVtb3ZlJyk7XG5cdFx0fVxuXG5cdFx0bGF5ZXIuX21hcCA9IGxheWVyLl9tYXBUb0FkZCA9IG51bGw7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGhhc0xheWVyKGxheWVyOiBMYXllcik6IEJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGN1cnJlbnRseSBhZGRlZCB0byB0aGUgbWFwXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRyZXR1cm4gVXRpbC5zdGFtcChsYXllcikgaW4gdGhpcy5fbGF5ZXJzO1xuXHR9LFxuXG5cdC8qIEBtZXRob2QgZWFjaExheWVyKGZuOiBGdW5jdGlvbiwgY29udGV4dD86IE9iamVjdCk6IHRoaXNcblx0ICogSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBtYXAsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyBjb250ZXh0IG9mIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cblx0ICogYGBgXG5cdCAqIG1hcC5lYWNoTGF5ZXIoZnVuY3Rpb24obGF5ZXIpe1xuXHQgKiAgICAgbGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xuXHQgKiB9KTtcblx0ICogYGBgXG5cdCAqL1xuXHRlYWNoTGF5ZXI6IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2FkZExheWVyczogZnVuY3Rpb24gKGxheWVycykge1xuXHRcdGxheWVycyA9IGxheWVycyA/IChVdGlsLmlzQXJyYXkobGF5ZXJzKSA/IGxheWVycyA6IFtsYXllcnNdKSA6IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkWm9vbUxpbWl0OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAoIWlzTmFOKGxheWVyLm9wdGlvbnMubWF4Wm9vbSkgfHwgIWlzTmFOKGxheWVyLm9wdGlvbnMubWluWm9vbSkpIHtcblx0XHRcdHRoaXMuX3pvb21Cb3VuZExheWVyc1tVdGlsLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0XHRcdHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVpvb21MaW1pdDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gVXRpbC5zdGFtcChsYXllcik7XG5cblx0XHRpZiAodGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXSkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF07XG5cdFx0XHR0aGlzLl91cGRhdGVab29tTGV2ZWxzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVab29tTGV2ZWxzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1pblpvb20gPSBJbmZpbml0eSxcblx0XHQgICAgbWF4Wm9vbSA9IC1JbmZpbml0eSxcblx0XHQgICAgb2xkWm9vbVNwYW4gPSB0aGlzLl9nZXRab29tU3BhbigpO1xuXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl96b29tQm91bmRMYXllcnMpIHtcblx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2ldLm9wdGlvbnM7XG5cblx0XHRcdG1pblpvb20gPSBvcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/IG1pblpvb20gOiBNYXRoLm1pbihtaW5ab29tLCBvcHRpb25zLm1pblpvb20pO1xuXHRcdFx0bWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkID8gbWF4Wm9vbSA6IE1hdGgubWF4KG1heFpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGF5ZXJzTWF4Wm9vbSA9IG1heFpvb20gPT09IC1JbmZpbml0eSA/IHVuZGVmaW5lZCA6IG1heFpvb207XG5cdFx0dGhpcy5fbGF5ZXJzTWluWm9vbSA9IG1pblpvb20gPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogbWluWm9vbTtcblxuXHRcdC8vIEBzZWN0aW9uIE1hcCBzdGF0ZSBjaGFuZ2UgZXZlbnRzXG5cdFx0Ly8gQGV2ZW50IHpvb21sZXZlbHNjaGFuZ2U6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbnVtYmVyIG9mIHpvb21sZXZlbHMgb24gdGhlIG1hcCBpcyBjaGFuZ2VkIGR1ZVxuXHRcdC8vIHRvIGFkZGluZyBvciByZW1vdmluZyBhIGxheWVyLlxuXHRcdGlmIChvbGRab29tU3BhbiAhPT0gdGhpcy5fZ2V0Wm9vbVNwYW4oKSkge1xuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWF4Wm9vbSAmJiB0aGlzLmdldFpvb20oKSA+IHRoaXMuX2xheWVyc01heFpvb20pIHtcblx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNYXhab29tKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgJiYgdGhpcy5fbGF5ZXJzTWluWm9vbSAmJiB0aGlzLmdldFpvb20oKSA8IHRoaXMuX2xheWVyc01pblpvb20pIHtcblx0XHRcdHRoaXMuc2V0Wm9vbSh0aGlzLl9sYXllcnNNaW5ab29tKTtcblx0XHR9XG5cdH1cbn0pO1xuIiwiXHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgTGF5ZXJHcm91cFxyXG4gKiBAYWthIEwuTGF5ZXJHcm91cFxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICpcclxuICogVXNlZCB0byBncm91cCBzZXZlcmFsIGxheWVycyBhbmQgaGFuZGxlIHRoZW0gYXMgb25lLiBJZiB5b3UgYWRkIGl0IHRvIHRoZSBtYXAsXHJcbiAqIGFueSBsYXllcnMgYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSBncm91cCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgb24gdGhlIG1hcCBhc1xyXG4gKiB3ZWxsLiBFeHRlbmRzIGBMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIEwubGF5ZXJHcm91cChbbWFya2VyMSwgbWFya2VyMl0pXHJcbiAqIFx0LmFkZExheWVyKHBvbHlsaW5lKVxyXG4gKiBcdC5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIExheWVyR3JvdXAgPSBMYXllci5leHRlbmQoe1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzLCBvcHRpb25zKSB7XHJcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblxyXG5cdFx0dmFyIGksIGxlbjtcclxuXHJcblx0XHRpZiAobGF5ZXJzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYWRkTGF5ZXIobGF5ZXI6IExheWVyKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSBncm91cC5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSB0aGlzLmdldExheWVySWQobGF5ZXIpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5hZGRMYXllcihsYXllcik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihsYXllcjogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgZ3JvdXAuXHJcblx0Ly8gQGFsdGVybmF0aXZlXHJcblx0Ly8gQG1ldGhvZCByZW1vdmVMYXllcihpZDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIGludGVybmFsIElEIGZyb20gdGhlIGdyb3VwLlxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IGxheWVyIGluIHRoaXMuX2xheWVycyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwICYmIHRoaXMuX2xheWVyc1tpZF0pIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIobGF5ZXI6IExheWVyKTogQm9vbGVhblxyXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2QgaGFzTGF5ZXIoaWQ6IE51bWJlcik6IEJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQgaXMgY3VycmVudGx5IGFkZGVkIHRvIHRoZSBncm91cC5cclxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgbGF5ZXJJZCA9IHR5cGVvZiBsYXllciA9PT0gJ251bWJlcicgPyBsYXllciA6IHRoaXMuZ2V0TGF5ZXJJZChsYXllcik7XHJcblx0XHRyZXR1cm4gbGF5ZXJJZCBpbiB0aGlzLl9sYXllcnM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbGVhckxheWVycygpOiB0aGlzXHJcblx0Ly8gUmVtb3ZlcyBhbGwgdGhlIGxheWVycyBmcm9tIHRoZSBncm91cC5cclxuXHRjbGVhckxheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKHRoaXMucmVtb3ZlTGF5ZXIsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaW52b2tlKG1ldGhvZE5hbWU6IFN0cmluZywg4oCmKTogdGhpc1xyXG5cdC8vIENhbGxzIGBtZXRob2ROYW1lYCBvbiBldmVyeSBsYXllciBjb250YWluZWQgaW4gdGhpcyBncm91cCwgcGFzc2luZyBhbnlcclxuXHQvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMuIEhhcyBubyBlZmZlY3QgaWYgdGhlIGxheWVycyBjb250YWluZWQgZG8gbm90XHJcblx0Ly8gaW1wbGVtZW50IGBtZXRob2ROYW1lYC5cclxuXHRpbnZva2U6IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XHJcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXHJcblx0XHQgICAgaSwgbGF5ZXI7XHJcblxyXG5cdFx0Zm9yIChpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tpXTtcclxuXHJcblx0XHRcdGlmIChsYXllclttZXRob2ROYW1lXSkge1xyXG5cdFx0XHRcdGxheWVyW21ldGhvZE5hbWVdLmFwcGx5KGxheWVyLCBhcmdzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLmVhY2hMYXllcihtYXAuYWRkTGF5ZXIsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuZWFjaExheWVyKG1hcC5yZW1vdmVMYXllciwgbWFwKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGVhY2hMYXllcihmbjogRnVuY3Rpb24sIGNvbnRleHQ/OiBPYmplY3QpOiB0aGlzXHJcblx0Ly8gSXRlcmF0ZXMgb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSBncm91cCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIGNvbnRleHQgb2YgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLlxyXG5cdC8vIGBgYGpzXHJcblx0Ly8gZ3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdC8vIFx0bGF5ZXIuYmluZFBvcHVwKCdIZWxsbycpO1xyXG5cdC8vIH0pO1xyXG5cdC8vIGBgYFxyXG5cdGVhY2hMYXllcjogZnVuY3Rpb24gKG1ldGhvZCwgY29udGV4dCkge1xyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXIoaWQ6IE51bWJlcik6IExheWVyXHJcblx0Ly8gUmV0dXJucyB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJuYWwgSUQuXHJcblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpZF07XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRMYXllcnMoKTogTGF5ZXJbXVxyXG5cdC8vIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBsYXllcnMgYWRkZWQgdG8gdGhlIGdyb3VwLlxyXG5cdGdldExheWVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGxheWVycyA9IFtdO1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobGF5ZXJzLnB1c2gsIGxheWVycyk7XHJcblx0XHRyZXR1cm4gbGF5ZXJzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENhbGxzIGBzZXRaSW5kZXhgIG9uIGV2ZXJ5IGxheWVyIGNvbnRhaW5lZCBpbiB0aGlzIGdyb3VwLCBwYXNzaW5nIHRoZSB6LWluZGV4LlxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRaSW5kZXgnLCB6SW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0TGF5ZXJJZChsYXllcjogTGF5ZXIpOiBOdW1iZXJcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnRlcm5hbCBJRCBmb3IgYSBsYXllclxyXG5cdGdldExheWVySWQ6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0cmV0dXJuIFV0aWwuc3RhbXAobGF5ZXIpO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC5sYXllckdyb3VwKGxheWVycz86IExheWVyW10sIG9wdGlvbnM/OiBPYmplY3QpXHJcbi8vIENyZWF0ZSBhIGxheWVyIGdyb3VwLCBvcHRpb25hbGx5IGdpdmVuIGFuIGluaXRpYWwgc2V0IG9mIGxheWVycyBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuZXhwb3J0IHZhciBsYXllckdyb3VwID0gZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTGF5ZXJHcm91cChsYXllcnMsIG9wdGlvbnMpO1xyXG59O1xyXG4iLCJpbXBvcnQge0xheWVyR3JvdXB9IGZyb20gJy4vTGF5ZXJHcm91cCc7XHJcbmltcG9ydCB7TGF0TG5nQm91bmRzfSBmcm9tICcuLi9nZW8vTGF0TG5nQm91bmRzJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBGZWF0dXJlR3JvdXBcclxuICogQGFrYSBMLkZlYXR1cmVHcm91cFxyXG4gKiBAaW5oZXJpdHMgTGF5ZXJHcm91cFxyXG4gKlxyXG4gKiBFeHRlbmRlZCBgTGF5ZXJHcm91cGAgdGhhdCBtYWtlcyBpdCBlYXNpZXIgdG8gZG8gdGhlIHNhbWUgdGhpbmcgdG8gYWxsIGl0cyBtZW1iZXIgbGF5ZXJzOlxyXG4gKiAgKiBbYGJpbmRQb3B1cGBdKCNsYXllci1iaW5kcG9wdXApIGJpbmRzIGEgcG9wdXAgdG8gYWxsIG9mIHRoZSBsYXllcnMgYXQgb25jZSAobGlrZXdpc2Ugd2l0aCBbYGJpbmRUb29sdGlwYF0oI2xheWVyLWJpbmR0b29sdGlwKSlcclxuICogICogRXZlbnRzIGFyZSBwcm9wYWdhdGVkIHRvIHRoZSBgRmVhdHVyZUdyb3VwYCwgc28gaWYgdGhlIGdyb3VwIGhhcyBhbiBldmVudFxyXG4gKiBoYW5kbGVyLCBpdCB3aWxsIGhhbmRsZSBldmVudHMgZnJvbSBhbnkgb2YgdGhlIGxheWVycy4gVGhpcyBpbmNsdWRlcyBtb3VzZSBldmVudHNcclxuICogYW5kIGN1c3RvbSBldmVudHMuXHJcbiAqICAqIEhhcyBgbGF5ZXJhZGRgIGFuZCBgbGF5ZXJyZW1vdmVgIGV2ZW50c1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLmZlYXR1cmVHcm91cChbbWFya2VyMSwgbWFya2VyMiwgcG9seWxpbmVdKVxyXG4gKiBcdC5iaW5kUG9wdXAoJ0hlbGxvIHdvcmxkIScpXHJcbiAqIFx0Lm9uKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBhbGVydCgnQ2xpY2tlZCBvbiBhIG1lbWJlciBvZiB0aGUgZ3JvdXAhJyk7IH0pXHJcbiAqIFx0LmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgRmVhdHVyZUdyb3VwID0gTGF5ZXJHcm91cC5leHRlbmQoe1xyXG5cclxuXHRhZGRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAodGhpcy5oYXNMYXllcihsYXllcikpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIuYWRkRXZlbnRQYXJlbnQodGhpcyk7XHJcblxyXG5cdFx0TGF5ZXJHcm91cC5wcm90b3R5cGUuYWRkTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxheWVyYWRkOiBMYXllckV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgbGF5ZXIgaXMgYWRkZWQgdG8gdGhpcyBgRmVhdHVyZUdyb3VwYFxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKCF0aGlzLmhhc0xheWVyKGxheWVyKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdGlmIChsYXllciBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbbGF5ZXJdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLnJlbW92ZUV2ZW50UGFyZW50KHRoaXMpO1xyXG5cclxuXHRcdExheWVyR3JvdXAucHJvdG90eXBlLnJlbW92ZUxheWVyLmNhbGwodGhpcywgbGF5ZXIpO1xyXG5cclxuXHRcdC8vIEBldmVudCBsYXllcnJlbW92ZTogTGF5ZXJFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiBhIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGBGZWF0dXJlR3JvdXBgXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKHN0eWxlOiBQYXRoIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2l2ZW4gcGF0aCBvcHRpb25zIHRvIGVhY2ggbGF5ZXIgb2YgdGhlIGdyb3VwIHRoYXQgaGFzIGEgYHNldFN0eWxlYCBtZXRob2QuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRTdHlsZScsIHN0eWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgdG9wIG9mIGFsbCBvdGhlciBsYXllcnNcclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0Zyb250Jyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoZSBsYXllciBncm91cCB0byB0aGUgYmFjayBvZiBhbGwgb3RoZXIgbGF5ZXJzXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0JhY2snKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcclxuXHQvLyBSZXR1cm5zIHRoZSBMYXRMbmdCb3VuZHMgb2YgdGhlIEZlYXR1cmUgR3JvdXAgKGNyZWF0ZWQgZnJvbSBib3VuZHMgYW5kIGNvb3JkaW5hdGVzIG9mIGl0cyBjaGlsZHJlbikuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcygpO1xyXG5cclxuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdFx0XHRib3VuZHMuZXh0ZW5kKGxheWVyLmdldEJvdW5kcyA/IGxheWVyLmdldEJvdW5kcygpIDogbGF5ZXIuZ2V0TGF0TG5nKCkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGJvdW5kcztcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5mZWF0dXJlR3JvdXAobGF5ZXJzPzogTGF5ZXJbXSwgb3B0aW9ucz86IE9iamVjdClcclxuLy8gQ3JlYXRlIGEgZmVhdHVyZSBncm91cCwgb3B0aW9uYWxseSBnaXZlbiBhbiBpbml0aWFsIHNldCBvZiBsYXllcnMgYW5kIGFuIGBvcHRpb25zYCBvYmplY3QuXHJcbmV4cG9ydCB2YXIgZmVhdHVyZUdyb3VwID0gZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgRmVhdHVyZUdyb3VwKGxheWVycywgb3B0aW9ucyk7XHJcbn07XHJcbiIsImltcG9ydCB7Q2xhc3N9IGZyb20gJy4uLy4uL2NvcmUvQ2xhc3MnO1xyXG5pbXBvcnQge3NldE9wdGlvbnN9IGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9Qb2ludCBhcyBwb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xyXG5cclxuLypcclxuICogQGNsYXNzIEljb25cclxuICogQGFrYSBMLkljb25cclxuICpcclxuICogUmVwcmVzZW50cyBhbiBpY29uIHRvIHByb3ZpZGUgd2hlbiBjcmVhdGluZyBhIG1hcmtlci5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIG15SWNvbiA9IEwuaWNvbih7XHJcbiAqICAgICBpY29uVXJsOiAnbXktaWNvbi5wbmcnLFxyXG4gKiAgICAgaWNvblJldGluYVVybDogJ215LWljb25AMngucG5nJyxcclxuICogICAgIGljb25TaXplOiBbMzgsIDk1XSxcclxuICogICAgIGljb25BbmNob3I6IFsyMiwgOTRdLFxyXG4gKiAgICAgcG9wdXBBbmNob3I6IFstMywgLTc2XSxcclxuICogICAgIHNoYWRvd1VybDogJ215LWljb24tc2hhZG93LnBuZycsXHJcbiAqICAgICBzaGFkb3dSZXRpbmFVcmw6ICdteS1pY29uLXNoYWRvd0AyeC5wbmcnLFxyXG4gKiAgICAgc2hhZG93U2l6ZTogWzY4LCA5NV0sXHJcbiAqICAgICBzaGFkb3dBbmNob3I6IFsyMiwgOTRdXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICpcclxuICogYEwuSWNvbi5EZWZhdWx0YCBleHRlbmRzIGBMLkljb25gIGFuZCBpcyB0aGUgYmx1ZSBpY29uIExlYWZsZXQgdXNlcyBmb3IgbWFya2VycyBieSBkZWZhdWx0LlxyXG4gKlxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgSWNvbiA9IENsYXNzLmV4dGVuZCh7XHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQGFrYSBJY29uIG9wdGlvbnNcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvblVybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqICoqKHJlcXVpcmVkKSoqIFRoZSBVUkwgdG8gdGhlIGljb24gaW1hZ2UgKGFic29sdXRlIG9yIHJlbGF0aXZlIHRvIHlvdXIgc2NyaXB0IHBhdGgpLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBpY29uUmV0aW5hVXJsOiBTdHJpbmcgPSBudWxsXHJcblx0ICogVGhlIFVSTCB0byBhIHJldGluYSBzaXplZCB2ZXJzaW9uIG9mIHRoZSBpY29uIGltYWdlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSB0byB5b3VyXHJcblx0ICogc2NyaXB0IHBhdGgpLiBVc2VkIGZvciBSZXRpbmEgc2NyZWVuIGRldmljZXMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGljb25TaXplOiBQb2ludCA9IG51bGxcclxuXHQgKiBTaXplIG9mIHRoZSBpY29uIGltYWdlIGluIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gaWNvbkFuY2hvcjogUG9pbnQgPSBudWxsXHJcblx0ICogVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBcInRpcFwiIG9mIHRoZSBpY29uIChyZWxhdGl2ZSB0byBpdHMgdG9wIGxlZnQgY29ybmVyKS4gVGhlIGljb25cclxuXHQgKiB3aWxsIGJlIGFsaWduZWQgc28gdGhhdCB0aGlzIHBvaW50IGlzIGF0IHRoZSBtYXJrZXIncyBnZW9ncmFwaGljYWwgbG9jYXRpb24uIENlbnRlcmVkXHJcblx0ICogYnkgZGVmYXVsdCBpZiBzaXplIGlzIHNwZWNpZmllZCwgYWxzbyBjYW4gYmUgc2V0IGluIENTUyB3aXRoIG5lZ2F0aXZlIG1hcmdpbnMuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHBvcHVwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCBwb3B1cHMgd2lsbCBcIm9wZW5cIiwgcmVsYXRpdmUgdG8gdGhlIGljb24gYW5jaG9yLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiB0b29sdGlwQW5jaG9yOiBQb2ludCA9IFswLCAwXVxyXG5cdCAqIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbSB3aGljaCB0b29sdGlwcyB3aWxsIFwib3BlblwiLCByZWxhdGl2ZSB0byB0aGUgaWNvbiBhbmNob3IuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIHNoYWRvd1VybDogU3RyaW5nID0gbnVsbFxyXG5cdCAqIFRoZSBVUkwgdG8gdGhlIGljb24gc2hhZG93IGltYWdlLiBJZiBub3Qgc3BlY2lmaWVkLCBubyBzaGFkb3cgaW1hZ2Ugd2lsbCBiZSBjcmVhdGVkLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBzaGFkb3dSZXRpbmFVcmw6IFN0cmluZyA9IG51bGxcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93U2l6ZTogUG9pbnQgPSBudWxsXHJcblx0ICogU2l6ZSBvZiB0aGUgc2hhZG93IGltYWdlIGluIHBpeGVscy5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc2hhZG93QW5jaG9yOiBQb2ludCA9IG51bGxcclxuXHQgKiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIHNoYWRvdyAocmVsYXRpdmUgdG8gaXRzIHRvcCBsZWZ0IGNvcm5lcikgKHRoZSBzYW1lXHJcblx0ICogYXMgaWNvbkFuY2hvciBpZiBub3Qgc3BlY2lmaWVkKS5cclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdCAqIEEgY3VzdG9tIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIGJvdGggaWNvbiBhbmQgc2hhZG93IGltYWdlcy4gRW1wdHkgYnkgZGVmYXVsdC5cclxuXHQgKi9cclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9wdXBBbmNob3I6IFswLCAwXSxcclxuXHRcdHRvb2x0aXBBbmNob3I6IFswLCAwXSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgdGlsZXMuXHJcblx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyB0aWxlIHBpeGVsIGRhdGEuXHJcblx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG5cdFx0Y3Jvc3NPcmlnaW46IGZhbHNlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdHNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVJY29uKG9sZEljb24/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50XHJcblx0Ly8gQ2FsbGVkIGludGVybmFsbHkgd2hlbiB0aGUgaWNvbiBoYXMgdG8gYmUgc2hvd24sIHJldHVybnMgYSBgPGltZz5gIEhUTUwgZWxlbWVudFxyXG5cdC8vIHN0eWxlZCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnMuXHJcblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdpY29uJywgb2xkSWNvbik7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVTaGFkb3cob2xkSWNvbj86IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnRcclxuXHQvLyBBcyBgY3JlYXRlSWNvbmAsIGJ1dCBmb3IgdGhlIHNoYWRvdyBiZW5lYXRoIGl0LlxyXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdzaGFkb3cnLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSWNvbjogZnVuY3Rpb24gKG5hbWUsIG9sZEljb24pIHtcclxuXHRcdHZhciBzcmMgPSB0aGlzLl9nZXRJY29uVXJsKG5hbWUpO1xyXG5cclxuXHRcdGlmICghc3JjKSB7XHJcblx0XHRcdGlmIChuYW1lID09PSAnaWNvbicpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ljb25Vcmwgbm90IHNldCBpbiBJY29uIG9wdGlvbnMgKHNlZSB0aGUgZG9jcykuJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2NyZWF0ZUltZyhzcmMsIG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnSU1HJyA/IG9sZEljb24gOiBudWxsKTtcclxuXHRcdHRoaXMuX3NldEljb25TdHlsZXMoaW1nLCBuYW1lKTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luIHx8IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJycpIHtcclxuXHRcdFx0aW1nLmNyb3NzT3JpZ2luID0gdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSB0cnVlID8gJycgOiB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGltZztcclxuXHR9LFxyXG5cclxuXHRfc2V0SWNvblN0eWxlczogZnVuY3Rpb24gKGltZywgbmFtZSkge1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0XHR2YXIgc2l6ZU9wdGlvbiA9IG9wdGlvbnNbbmFtZSArICdTaXplJ107XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBzaXplT3B0aW9uID09PSAnbnVtYmVyJykge1xyXG5cdFx0XHRzaXplT3B0aW9uID0gW3NpemVPcHRpb24sIHNpemVPcHRpb25dO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzaXplID0gcG9pbnQoc2l6ZU9wdGlvbiksXHJcblx0XHQgICAgYW5jaG9yID0gcG9pbnQobmFtZSA9PT0gJ3NoYWRvdycgJiYgb3B0aW9ucy5zaGFkb3dBbmNob3IgfHwgb3B0aW9ucy5pY29uQW5jaG9yIHx8XHJcblx0XHQgICAgICAgICAgICBzaXplICYmIHNpemUuZGl2aWRlQnkoMiwgdHJ1ZSkpO1xyXG5cclxuXHRcdGltZy5jbGFzc05hbWUgPSAnbGVhZmxldC1tYXJrZXItJyArIG5hbWUgKyAnICcgKyAob3B0aW9ucy5jbGFzc05hbWUgfHwgJycpO1xyXG5cclxuXHRcdGlmIChhbmNob3IpIHtcclxuXHRcdFx0aW1nLnN0eWxlLm1hcmdpbkxlZnQgPSAoLWFuY2hvci54KSArICdweCc7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5Ub3AgID0gKC1hbmNob3IueSkgKyAncHgnO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzaXplKSB7XHJcblx0XHRcdGltZy5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSW1nOiBmdW5jdGlvbiAoc3JjLCBlbCkge1xyXG5cdFx0ZWwgPSBlbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuXHRcdGVsLnNyYyA9IHNyYztcclxuXHRcdHJldHVybiBlbDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcclxuXHRcdHJldHVybiBCcm93c2VyLnJldGluYSAmJiB0aGlzLm9wdGlvbnNbbmFtZSArICdSZXRpbmFVcmwnXSB8fCB0aGlzLm9wdGlvbnNbbmFtZSArICdVcmwnXTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEBmYWN0b3J5IEwuaWNvbihvcHRpb25zOiBJY29uIG9wdGlvbnMpXHJcbi8vIENyZWF0ZXMgYW4gaWNvbiBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxyXG5leHBvcnQgZnVuY3Rpb24gaWNvbihvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBJY29uKG9wdGlvbnMpO1xyXG59XHJcbiIsImltcG9ydCB7SWNvbn0gZnJvbSAnLi9JY29uJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuXG4vKlxuICogQG1pbmljbGFzcyBJY29uLkRlZmF1bHQgKEljb24pXG4gKiBAYWthIEwuSWNvbi5EZWZhdWx0XG4gKiBAc2VjdGlvblxuICpcbiAqIEEgdHJpdmlhbCBzdWJjbGFzcyBvZiBgSWNvbmAsIHJlcHJlc2VudHMgdGhlIGljb24gdG8gdXNlIGluIGBNYXJrZXJgcyB3aGVuXG4gKiBubyBpY29uIGlzIHNwZWNpZmllZC4gUG9pbnRzIHRvIHRoZSBibHVlIG1hcmtlciBpbWFnZSBkaXN0cmlidXRlZCB3aXRoIExlYWZsZXRcbiAqIHJlbGVhc2VzLlxuICpcbiAqIEluIG9yZGVyIHRvIGN1c3RvbWl6ZSB0aGUgZGVmYXVsdCBpY29uLCBqdXN0IGNoYW5nZSB0aGUgcHJvcGVydGllcyBvZiBgTC5JY29uLkRlZmF1bHQucHJvdG90eXBlLm9wdGlvbnNgXG4gKiAod2hpY2ggaXMgYSBzZXQgb2YgYEljb24gb3B0aW9uc2ApLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIF9jb21wbGV0ZWx5XyByZXBsYWNlIHRoZSBkZWZhdWx0IGljb24sIG92ZXJyaWRlIHRoZVxuICogYEwuTWFya2VyLnByb3RvdHlwZS5vcHRpb25zLmljb25gIHdpdGggeW91ciBvd24gaWNvbiBpbnN0ZWFkLlxuICovXG5cbmV4cG9ydCB2YXIgSWNvbkRlZmF1bHQgPSBJY29uLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdGljb25Vcmw6ICAgICAgICdtYXJrZXItaWNvbi5wbmcnLFxuXHRcdGljb25SZXRpbmFVcmw6ICdtYXJrZXItaWNvbi0yeC5wbmcnLFxuXHRcdHNoYWRvd1VybDogICAgICdtYXJrZXItc2hhZG93LnBuZycsXG5cdFx0aWNvblNpemU6ICAgIFsyNSwgNDFdLFxuXHRcdGljb25BbmNob3I6ICBbMTIsIDQxXSxcblx0XHRwb3B1cEFuY2hvcjogWzEsIC0zNF0sXG5cdFx0dG9vbHRpcEFuY2hvcjogWzE2LCAtMjhdLFxuXHRcdHNoYWRvd1NpemU6ICBbNDEsIDQxXVxuXHR9LFxuXG5cdF9nZXRJY29uVXJsOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGlmICh0eXBlb2YgSWNvbkRlZmF1bHQuaW1hZ2VQYXRoICE9PSAnc3RyaW5nJykge1x0Ly8gRGVwcmVjYXRlZCwgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgb25seVxuXHRcdFx0SWNvbkRlZmF1bHQuaW1hZ2VQYXRoID0gdGhpcy5fZGV0ZWN0SWNvblBhdGgoKTtcblx0XHR9XG5cblx0XHQvLyBAb3B0aW9uIGltYWdlUGF0aDogU3RyaW5nXG5cdFx0Ly8gYEljb24uRGVmYXVsdGAgd2lsbCB0cnkgdG8gYXV0by1kZXRlY3QgdGhlIGxvY2F0aW9uIG9mIHRoZVxuXHRcdC8vIGJsdWUgaWNvbiBpbWFnZXMuIElmIHlvdSBhcmUgcGxhY2luZyB0aGVzZSBpbWFnZXMgaW4gYSBub24tc3RhbmRhcmRcblx0XHQvLyB3YXksIHNldCB0aGlzIG9wdGlvbiB0byBwb2ludCB0byB0aGUgcmlnaHQgcGF0aC5cblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5pbWFnZVBhdGggfHwgSWNvbkRlZmF1bHQuaW1hZ2VQYXRoKSArIEljb24ucHJvdG90eXBlLl9nZXRJY29uVXJsLmNhbGwodGhpcywgbmFtZSk7XG5cdH0sXG5cblx0X3N0cmlwVXJsOiBmdW5jdGlvbiAocGF0aCkge1x0Ly8gc2VwYXJhdGUgZnVuY3Rpb24gdG8gdXNlIGluIHRlc3RzXG5cdFx0dmFyIHN0cmlwID0gZnVuY3Rpb24gKHN0ciwgcmUsIGlkeCkge1xuXHRcdFx0dmFyIG1hdGNoID0gcmUuZXhlYyhzdHIpO1xuXHRcdFx0cmV0dXJuIG1hdGNoICYmIG1hdGNoW2lkeF07XG5cdFx0fTtcblx0XHRwYXRoID0gc3RyaXAocGF0aCwgL151cmxcXCgoWydcIl0pPyguKylcXDFcXCkkLywgMik7XG5cdFx0cmV0dXJuIHBhdGggJiYgc3RyaXAocGF0aCwgL14oLiopbWFya2VyLWljb25cXC5wbmckLywgMSk7XG5cdH0sXG5cblx0X2RldGVjdEljb25QYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGVsID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICAnbGVhZmxldC1kZWZhdWx0LWljb24tcGF0aCcsIGRvY3VtZW50LmJvZHkpO1xuXHRcdHZhciBwYXRoID0gRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JhY2tncm91bmQtaW1hZ2UnKSB8fFxuXHRcdCAgICAgICAgICAgRG9tVXRpbC5nZXRTdHlsZShlbCwgJ2JhY2tncm91bmRJbWFnZScpO1x0Ly8gSUU4XG5cblx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcblx0XHRwYXRoID0gdGhpcy5fc3RyaXBVcmwocGF0aCk7XG5cdFx0aWYgKHBhdGgpIHsgcmV0dXJuIHBhdGg7IH1cblx0XHR2YXIgbGluayA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xpbmtbaHJlZiQ9XCJsZWFmbGV0LmNzc1wiXScpO1xuXHRcdGlmICghbGluaykgeyByZXR1cm4gJyc7IH1cblx0XHRyZXR1cm4gbGluay5ocmVmLnN1YnN0cmluZygwLCBsaW5rLmhyZWYubGVuZ3RoIC0gJ2xlYWZsZXQuY3NzJy5sZW5ndGggLSAxKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCB7RHJhZ2dhYmxlfSBmcm9tICcuLi8uLi9kb20vRHJhZ2dhYmxlJztcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQge3RvUG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7cmVxdWVzdEFuaW1GcmFtZSwgY2FuY2VsQW5pbUZyYW1lfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuXG4vKlxuICogTC5IYW5kbGVyLk1hcmtlckRyYWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEwuTWFya2VyIHRvIG1ha2UgdGhlIG1hcmtlcnMgZHJhZ2dhYmxlLlxuICovXG5cblxuLyogQG5hbWVzcGFjZSBNYXJrZXJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIGhhbmRsZXJzXG4gKlxuICogSW50ZXJhY3Rpb24gaGFuZGxlcnMgYXJlIHByb3BlcnRpZXMgb2YgYSBtYXJrZXIgaW5zdGFuY2UgdGhhdCBhbGxvdyB5b3UgdG8gY29udHJvbCBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoIGFzIGRyYWdnaW5nIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuICogYGBgXG4gKlxuICogQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4gKiBNYXJrZXIgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLiBPbmx5IHZhbGlkIHdoZW4gdGhlIG1hcmtlciBpcyBvbiB0aGUgbWFwIChPdGhlcndpc2Ugc2V0IFtgbWFya2VyLm9wdGlvbnMuZHJhZ2dhYmxlYF0oI21hcmtlci1kcmFnZ2FibGUpKS5cbiAqL1xuXG5leHBvcnQgdmFyIE1hcmtlckRyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0XHR0aGlzLl9tYXJrZXIgPSBtYXJrZXI7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaWNvbiA9IHRoaXMuX21hcmtlci5faWNvbjtcblxuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XG5cdFx0XHR0aGlzLl9kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKGljb24sIGljb24sIHRydWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRkcmFnc3RhcnQ6IHRoaXMuX29uRHJhZ1N0YXJ0LFxuXHRcdFx0cHJlZHJhZzogdGhpcy5fb25QcmVEcmFnLFxuXHRcdFx0ZHJhZzogdGhpcy5fb25EcmFnLFxuXHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0fSwgdGhpcykuZW5hYmxlKCk7XG5cblx0XHREb21VdGlsLmFkZENsYXNzKGljb24sICdsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGUnKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5vZmYoe1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLl9vbkRyYWdTdGFydCxcblx0XHRcdHByZWRyYWc6IHRoaXMuX29uUHJlRHJhZyxcblx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdGRyYWdlbmQ6IHRoaXMuX29uRHJhZ0VuZFxuXHRcdH0sIHRoaXMpLmRpc2FibGUoKTtcblxuXHRcdGlmICh0aGlzLl9tYXJrZXIuX2ljb24pIHtcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFya2VyLl9pY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcblx0XHQgICAgbWFwID0gbWFya2VyLl9tYXAsXG5cdFx0ICAgIHNwZWVkID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblNwZWVkLFxuXHRcdCAgICBwYWRkaW5nID0gdGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1BhblBhZGRpbmcsXG5cdFx0ICAgIGljb25Qb3MgPSBEb21VdGlsLmdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXG5cdFx0ICAgIGJvdW5kcyA9IG1hcC5nZXRQaXhlbEJvdW5kcygpLFxuXHRcdCAgICBvcmlnaW4gPSBtYXAuZ2V0UGl4ZWxPcmlnaW4oKTtcblxuXHRcdHZhciBwYW5Cb3VuZHMgPSB0b0JvdW5kcyhcblx0XHRcdGJvdW5kcy5taW4uX3N1YnRyYWN0KG9yaWdpbikuYWRkKHBhZGRpbmcpLFxuXHRcdFx0Ym91bmRzLm1heC5fc3VidHJhY3Qob3JpZ2luKS5zdWJ0cmFjdChwYWRkaW5nKVxuXHRcdCk7XG5cblx0XHRpZiAoIXBhbkJvdW5kcy5jb250YWlucyhpY29uUG9zKSkge1xuXHRcdFx0Ly8gQ29tcHV0ZSBpbmNyZW1lbnRhbCBtb3ZlbWVudFxuXHRcdFx0dmFyIG1vdmVtZW50ID0gdG9Qb2ludChcblx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueCwgaWNvblBvcy54KSAtIHBhbkJvdW5kcy5tYXgueCkgLyAoYm91bmRzLm1heC54IC0gcGFuQm91bmRzLm1heC54KSAtXG5cdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLngsIGljb25Qb3MueCkgLSBwYW5Cb3VuZHMubWluLngpIC8gKGJvdW5kcy5taW4ueCAtIHBhbkJvdW5kcy5taW4ueCksXG5cblx0XHRcdFx0KE1hdGgubWF4KHBhbkJvdW5kcy5tYXgueSwgaWNvblBvcy55KSAtIHBhbkJvdW5kcy5tYXgueSkgLyAoYm91bmRzLm1heC55IC0gcGFuQm91bmRzLm1heC55KSAtXG5cdFx0XHRcdChNYXRoLm1pbihwYW5Cb3VuZHMubWluLnksIGljb25Qb3MueSkgLSBwYW5Cb3VuZHMubWluLnkpIC8gKGJvdW5kcy5taW4ueSAtIHBhbkJvdW5kcy5taW4ueSlcblx0XHRcdCkubXVsdGlwbHlCeShzcGVlZCk7XG5cblx0XHRcdG1hcC5wYW5CeShtb3ZlbWVudCwge2FuaW1hdGU6IGZhbHNlfSk7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLl9hZGQobW92ZW1lbnQpO1xuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcy5fYWRkKG1vdmVtZW50KTtcblxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihtYXJrZXIuX2ljb24sIHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zKTtcblx0XHRcdHRoaXMuX29uRHJhZyhlKTtcblxuXHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBAc2VjdGlvbiBEcmFnZ2luZyBldmVudHNcblx0XHQvLyBAZXZlbnQgZHJhZ3N0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG5cblx0XHQvLyBAZXZlbnQgbW92ZXN0YXJ0OiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdGFydHMgbW92aW5nIChiZWNhdXNlIG9mIGRyYWdnaW5nKS5cblxuXHRcdHRoaXMuX29sZExhdExuZyA9IHRoaXMuX21hcmtlci5nZXRMYXRMbmcoKTtcblxuXHRcdC8vIFdoZW4gdXNpbmcgRVM2IGltcG9ydHMgaXQgY291bGQgbm90IGJlIHNldCB3aGVuIGBQb3B1cGAgd2FzIG5vdCBpbXBvcnRlZCBhcyB3ZWxsXG5cdFx0dGhpcy5fbWFya2VyLmNsb3NlUG9wdXAgJiYgdGhpcy5fbWFya2VyLmNsb3NlUG9wdXAoKTtcblxuXHRcdHRoaXMuX21hcmtlclxuXHRcdFx0LmZpcmUoJ21vdmVzdGFydCcpXG5cdFx0XHQuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cdH0sXG5cblx0X29uUHJlRHJhZzogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fbWFya2VyLm9wdGlvbnMuYXV0b1Bhbikge1xuXHRcdFx0Y2FuY2VsQW5pbUZyYW1lKHRoaXMuX3BhblJlcXVlc3QpO1xuXHRcdFx0dGhpcy5fcGFuUmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcywgZSkpO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXIsXG5cdFx0ICAgIHNoYWRvdyA9IG1hcmtlci5fc2hhZG93LFxuXHRcdCAgICBpY29uUG9zID0gRG9tVXRpbC5nZXRQb3NpdGlvbihtYXJrZXIuX2ljb24pLFxuXHRcdCAgICBsYXRsbmcgPSBtYXJrZXIuX21hcC5sYXllclBvaW50VG9MYXRMbmcoaWNvblBvcyk7XG5cblx0XHQvLyB1cGRhdGUgc2hhZG93IHBvc2l0aW9uXG5cdFx0aWYgKHNoYWRvdykge1xuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihzaGFkb3csIGljb25Qb3MpO1xuXHRcdH1cblxuXHRcdG1hcmtlci5fbGF0bG5nID0gbGF0bG5nO1xuXHRcdGUubGF0bG5nID0gbGF0bG5nO1xuXHRcdGUub2xkTGF0TG5nID0gdGhpcy5fb2xkTGF0TG5nO1xuXG5cdFx0Ly8gQGV2ZW50IGRyYWc6IEV2ZW50XG5cdFx0Ly8gRmlyZWQgcmVwZWF0ZWRseSB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgbWFya2VyLlxuXHRcdG1hcmtlclxuXHRcdCAgICAuZmlyZSgnbW92ZScsIGUpXG5cdFx0ICAgIC5maXJlKCdkcmFnJywgZSk7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBAZXZlbnQgZHJhZ2VuZDogRHJhZ0VuZEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuXG5cdFx0IGNhbmNlbEFuaW1GcmFtZSh0aGlzLl9wYW5SZXF1ZXN0KTtcblxuXHRcdC8vIEBldmVudCBtb3ZlZW5kOiBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIG1hcmtlciBzdG9wcyBtb3ZpbmcgKGJlY2F1c2Ugb2YgZHJhZ2dpbmcpLlxuXHRcdGRlbGV0ZSB0aGlzLl9vbGRMYXRMbmc7XG5cdFx0dGhpcy5fbWFya2VyXG5cdFx0ICAgIC5maXJlKCdtb3ZlZW5kJylcblx0XHQgICAgLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XHJcbmltcG9ydCB7SWNvbkRlZmF1bHR9IGZyb20gJy4vSWNvbi5EZWZhdWx0JztcclxuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQge3RvTGF0TG5nIGFzIGxhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCB7dG9Qb2ludCBhcyBwb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcclxuaW1wb3J0IHtNYXJrZXJEcmFnfSBmcm9tICcuL01hcmtlci5EcmFnJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBNYXJrZXJcclxuICogQGluaGVyaXRzIEludGVyYWN0aXZlIGxheWVyXHJcbiAqIEBha2EgTC5NYXJrZXJcclxuICogTC5NYXJrZXIgaXMgdXNlZCB0byBkaXNwbGF5IGNsaWNrYWJsZS9kcmFnZ2FibGUgaWNvbnMgb24gdGhlIG1hcC4gRXh0ZW5kcyBgTGF5ZXJgLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBMLm1hcmtlcihbNTAuNSwgMzAuNV0pLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgTWFya2VyID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIE1hcmtlciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBpY29uOiBJY29uID0gKlxyXG5cdFx0Ly8gSWNvbiBpbnN0YW5jZSB0byB1c2UgZm9yIHJlbmRlcmluZyB0aGUgbWFya2VyLlxyXG5cdFx0Ly8gU2VlIFtJY29uIGRvY3VtZW50YXRpb25dKCNMLkljb24pIGZvciBkZXRhaWxzIG9uIGhvdyB0byBjdXN0b21pemUgdGhlIG1hcmtlciBpY29uLlxyXG5cdFx0Ly8gSWYgbm90IHNwZWNpZmllZCwgYSBjb21tb24gaW5zdGFuY2Ugb2YgYEwuSWNvbi5EZWZhdWx0YCBpcyB1c2VkLlxyXG5cdFx0aWNvbjogbmV3IEljb25EZWZhdWx0KCksXHJcblxyXG5cdFx0Ly8gT3B0aW9uIGluaGVyaXRlZCBmcm9tIFwiSW50ZXJhY3RpdmUgbGF5ZXJcIiBhYnN0cmFjdCBjbGFzc1xyXG5cdFx0aW50ZXJhY3RpdmU6IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIG1hcmtlciBjYW4gYmUgdGFiYmVkIHRvIHdpdGggYSBrZXlib2FyZCBhbmQgY2xpY2tlZCBieSBwcmVzc2luZyBlbnRlci5cclxuXHRcdGtleWJvYXJkOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdGl0bGU6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYnJvd3NlciB0b29sdGlwIHRoYXQgYXBwZWFyIG9uIG1hcmtlciBob3ZlciAobm8gdG9vbHRpcCBieSBkZWZhdWx0KS5cclxuXHRcdC8vIFtVc2VmdWwgZm9yIGFjY2Vzc2liaWxpdHldKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9hY2Nlc3NpYmlsaXR5LyNtYXJrZXJzLW11c3QtYmUtbGFiZWxsZWQpLlxyXG5cdFx0dGl0bGU6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYWx0OiBTdHJpbmcgPSAnTWFya2VyJ1xyXG5cdFx0Ly8gVGV4dCBmb3IgdGhlIGBhbHRgIGF0dHJpYnV0ZSBvZiB0aGUgaWNvbiBpbWFnZS5cclxuXHRcdC8vIFtVc2VmdWwgZm9yIGFjY2Vzc2liaWxpdHldKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9leGFtcGxlcy9hY2Nlc3NpYmlsaXR5LyNtYXJrZXJzLW11c3QtYmUtbGFiZWxsZWQpLlxyXG5cdFx0YWx0OiAnTWFya2VyJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHpJbmRleE9mZnNldDogTnVtYmVyID0gMFxyXG5cdFx0Ly8gQnkgZGVmYXVsdCwgbWFya2VyIGltYWdlcyB6SW5kZXggaXMgc2V0IGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gaXRzIGxhdGl0dWRlLiBVc2UgdGhpcyBvcHRpb24gaWYgeW91IHdhbnQgdG8gcHV0IHRoZSBtYXJrZXIgb24gdG9wIG9mIGFsbCBvdGhlcnMgKG9yIGJlbG93KSwgc3BlY2lmeWluZyBhIGhpZ2ggdmFsdWUgbGlrZSBgMTAwMGAgKG9yIGhpZ2ggbmVnYXRpdmUgdmFsdWUsIHJlc3BlY3RpdmVseSkuXHJcblx0XHR6SW5kZXhPZmZzZXQ6IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBvcGFjaXR5OiBOdW1iZXIgPSAxLjBcclxuXHRcdC8vIFRoZSBvcGFjaXR5IG9mIHRoZSBtYXJrZXIuXHJcblx0XHRvcGFjaXR5OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmlzZU9uSG92ZXI6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgbWFya2VyIHdpbGwgZ2V0IG9uIHRvcCBvZiBvdGhlcnMgd2hlbiB5b3UgaG92ZXIgdGhlIG1vdXNlIG92ZXIgaXQuXHJcblx0XHRyaXNlT25Ib3ZlcjogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiByaXNlT2Zmc2V0OiBOdW1iZXIgPSAyNTBcclxuXHRcdC8vIFRoZSB6LWluZGV4IG9mZnNldCB1c2VkIGZvciB0aGUgYHJpc2VPbkhvdmVyYCBmZWF0dXJlLlxyXG5cdFx0cmlzZU9mZnNldDogMjUwLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ21hcmtlclBhbmUnXHJcblx0XHQvLyBgTWFwIHBhbmVgIHdoZXJlIHRoZSBtYXJrZXJzIGljb24gd2lsbCBiZSBhZGRlZC5cclxuXHRcdHBhbmU6ICdtYXJrZXJQYW5lJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHNoYWRvd1BhbmU6IFN0cmluZyA9ICdzaGFkb3dQYW5lJ1xyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgbWFya2VycyBzaGFkb3cgd2lsbCBiZSBhZGRlZC5cclxuXHRcdHNoYWRvd1BhbmU6ICdzaGFkb3dQYW5lJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGJ1YmJsaW5nTW91c2VFdmVudHM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBtYXJrZXIgd2lsbCB0cmlnZ2VyIHRoZSBzYW1lIGV2ZW50IG9uIHRoZSBtYXBcclxuXHRcdC8vICh1bmxlc3MgW2BMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbmBdKCNkb21ldmVudC1zdG9wcHJvcGFnYXRpb24pIGlzIHVzZWQpLlxyXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuT25Gb2N1czogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZW4gYHRydWVgLCB0aGUgbWFwIHdpbGwgcGFuIHdoZW5ldmVyIHRoZSBtYXJrZXIgaXMgZm9jdXNlZCAodmlhXHJcblx0XHQvLyBlLmcuIHByZXNzaW5nIGB0YWJgIG9uIHRoZSBrZXlib2FyZCkgdG8gZW5zdXJlIHRoZSBtYXJrZXIgaXNcclxuXHRcdC8vIHZpc2libGUgd2l0aGluIHRoZSBtYXAncyBib3VuZHNcclxuXHRcdGF1dG9QYW5PbkZvY3VzOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBzZWN0aW9uIERyYWdnYWJsZSBtYXJrZXIgb3B0aW9uc1xyXG5cdFx0Ly8gQG9wdGlvbiBkcmFnZ2FibGU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgbWFya2VyIGlzIGRyYWdnYWJsZSB3aXRoIG1vdXNlL3RvdWNoIG9yIG5vdC5cclxuXHRcdGRyYWdnYWJsZTogZmFsc2UsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdG8gcGFuIHRoZSBtYXAgd2hlbiBkcmFnZ2luZyB0aGlzIG1hcmtlciBuZWFyIGl0cyBlZGdlIG9yIG5vdC5cclxuXHRcdGF1dG9QYW46IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblBhZGRpbmc6IFBvaW50ID0gUG9pbnQoNTAsIDUwKVxyXG5cdFx0Ly8gRGlzdGFuY2UgKGluIHBpeGVscyB0byB0aGUgbGVmdC9yaWdodCBhbmQgdG8gdGhlIHRvcC9ib3R0b20pIG9mIHRoZVxyXG5cdFx0Ly8gbWFwIGVkZ2UgdG8gc3RhcnQgcGFubmluZyB0aGUgbWFwLlxyXG5cdFx0YXV0b1BhblBhZGRpbmc6IFs1MCwgNTBdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gYXV0b1BhblNwZWVkOiBOdW1iZXIgPSAxMFxyXG5cdFx0Ly8gTnVtYmVyIG9mIHBpeGVscyB0aGUgbWFwIHNob3VsZCBwYW4gYnkuXHJcblx0XHRhdXRvUGFuU3BlZWQ6IDEwXHJcblx0fSxcclxuXHJcblx0LyogQHNlY3Rpb25cclxuXHQgKlxyXG5cdCAqIEluIGFkZGl0aW9uIHRvIFtzaGFyZWQgbGF5ZXIgbWV0aG9kc10oI0xheWVyKSBsaWtlIGBhZGRUbygpYCBhbmQgYHJlbW92ZSgpYCBhbmQgW3BvcHVwIG1ldGhvZHNdKCNQb3B1cCkgbGlrZSBiaW5kUG9wdXAoKSB5b3UgY2FuIGFsc28gdXNlIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gbGF0TG5nKGxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IHRoaXMuX3pvb21BbmltYXRlZCAmJiBtYXAub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9uKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0SWNvbigpO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0aWYgKHRoaXMuZHJhZ2dpbmcgJiYgdGhpcy5kcmFnZ2luZy5lbmFibGVkKCkpIHtcclxuXHRcdFx0dGhpcy5vcHRpb25zLmRyYWdnYWJsZSA9IHRydWU7XHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcucmVtb3ZlSG9va3MoKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSB0aGlzLmRyYWdnaW5nO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9mZignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR6b29tOiB0aGlzLnVwZGF0ZSxcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLnVwZGF0ZVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGdldExhdExuZzogTGF0TG5nXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBnZW9ncmFwaGljYWwgcG9zaXRpb24gb2YgdGhlIG1hcmtlci5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgbWFya2VyIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiBwb2ludC5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHZhciBvbGRMYXRMbmcgPSB0aGlzLl9sYXRsbmc7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBsYXRMbmcobGF0bG5nKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0Ly8gQGV2ZW50IG1vdmU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI21hcmtlci1zZXRsYXRsbmcpIG9yIGJ5IFtkcmFnZ2luZ10oI21hcmtlci1kcmFnZ2luZykuIE9sZCBhbmQgbmV3IGNvb3JkaW5hdGVzIGFyZSBpbmNsdWRlZCBpbiBldmVudCBhcmd1bWVudHMgYXMgYG9sZExhdExuZ2AsIGBsYXRsbmdgLlxyXG5cdFx0cmV0dXJuIHRoaXMuZmlyZSgnbW92ZScsIHtvbGRMYXRMbmc6IG9sZExhdExuZywgbGF0bG5nOiB0aGlzLl9sYXRsbmd9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFpJbmRleE9mZnNldChvZmZzZXQ6IE51bWJlcik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4IG9mZnNldF0oI21hcmtlci16aW5kZXhvZmZzZXQpIG9mIHRoZSBtYXJrZXIuXHJcblx0c2V0WkluZGV4T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0ID0gb2Zmc2V0O1xyXG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRJY29uOiBJY29uXHJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCBpY29uIHVzZWQgYnkgdGhlIG1hcmtlclxyXG5cdGdldEljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldEljb24oaWNvbjogSWNvbik6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHRoZSBtYXJrZXIgaWNvbi5cclxuXHRzZXRJY29uOiBmdW5jdGlvbiAoaWNvbikge1xyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5pY29uID0gaWNvbjtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJY29uKCk7XHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuYmluZFBvcHVwKHRoaXMuX3BvcHVwLCB0aGlzLl9wb3B1cC5vcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5faWNvbjtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbiAmJiB0aGlzLl9tYXApIHtcclxuXHRcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKS5yb3VuZCgpO1xyXG5cdFx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdEljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG5cdFx0ICAgIGNsYXNzVG9BZGQgPSAnbGVhZmxldC16b29tLScgKyAodGhpcy5fem9vbUFuaW1hdGVkID8gJ2FuaW1hdGVkJyA6ICdoaWRlJyk7XHJcblxyXG5cdFx0dmFyIGljb24gPSBvcHRpb25zLmljb24uY3JlYXRlSWNvbih0aGlzLl9pY29uKSxcclxuXHRcdCAgICBhZGRJY29uID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gaWYgd2UncmUgbm90IHJldXNpbmcgdGhlIGljb24sIHJlbW92ZSB0aGUgb2xkIG9uZSBhbmQgaW5pdCBuZXcgb25lXHJcblx0XHRpZiAoaWNvbiAhPT0gdGhpcy5faWNvbikge1xyXG5cdFx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUljb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRhZGRJY29uID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLnRpdGxlKSB7XHJcblx0XHRcdFx0aWNvbi50aXRsZSA9IG9wdGlvbnMudGl0bGU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChpY29uLnRhZ05hbWUgPT09ICdJTUcnKSB7XHJcblx0XHRcdFx0aWNvbi5hbHQgPSBvcHRpb25zLmFsdCB8fCAnJztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgY2xhc3NUb0FkZCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMua2V5Ym9hcmQpIHtcclxuXHRcdFx0aWNvbi50YWJJbmRleCA9ICcwJztcclxuXHRcdFx0aWNvbi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnYnV0dG9uJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faWNvbiA9IGljb247XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0dGhpcy5vbih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1Bhbk9uRm9jdXMpIHtcclxuXHRcdFx0RG9tRXZlbnQub24oaWNvbiwgJ2ZvY3VzJywgdGhpcy5fcGFuT25Gb2N1cywgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5ld1NoYWRvdyA9IG9wdGlvbnMuaWNvbi5jcmVhdGVTaGFkb3codGhpcy5fc2hhZG93KSxcclxuXHRcdCAgICBhZGRTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAobmV3U2hhZG93ICE9PSB0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlU2hhZG93KCk7XHJcblx0XHRcdGFkZFNoYWRvdyA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG5ld1NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKG5ld1NoYWRvdywgY2xhc3NUb0FkZCk7XHJcblx0XHRcdG5ld1NoYWRvdy5hbHQgPSAnJztcclxuXHRcdH1cclxuXHRcdHRoaXMuX3NoYWRvdyA9IG5ld1NoYWRvdztcclxuXHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub3BhY2l0eSA8IDEpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRpZiAoYWRkSWNvbikge1xyXG5cdFx0XHR0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2luaXRJbnRlcmFjdGlvbigpO1xyXG5cdFx0aWYgKG5ld1NoYWRvdyAmJiBhZGRTaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5nZXRQYW5lKG9wdGlvbnMuc2hhZG93UGFuZSkuYXBwZW5kQ2hpbGQodGhpcy5fc2hhZG93KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlSWNvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yaXNlT25Ib3Zlcikge1xyXG5cdFx0XHR0aGlzLm9mZih7XHJcblx0XHRcdFx0bW91c2VvdmVyOiB0aGlzLl9icmluZ1RvRnJvbnQsXHJcblx0XHRcdFx0bW91c2VvdXQ6IHRoaXMuX3Jlc2V0WkluZGV4XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1Bhbk9uRm9jdXMpIHtcclxuXHRcdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2ljb24sICdmb2N1cycsIHRoaXMuX3Bhbk9uRm9jdXMsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2ljb24pO1xyXG5cdFx0dGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHR0aGlzLl9pY29uID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlU2hhZG93OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fc2hhZG93KSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRQb3M6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2ljb24sIHBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX3NoYWRvdywgcG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl96SW5kZXggPSBwb3MueSArIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5fcmVzZXRaSW5kZXgoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHRpZiAodGhpcy5faWNvbikge1xyXG5cdFx0XHR0aGlzLl9pY29uLnN0eWxlLnpJbmRleCA9IHRoaXMuX3pJbmRleCArIG9mZnNldDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChvcHQpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5yb3VuZCgpO1xyXG5cclxuXHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2ljb24sICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XHJcblxyXG5cdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pY29uKTtcclxuXHJcblx0XHRpZiAoTWFya2VyRHJhZykge1xyXG5cdFx0XHR2YXIgZHJhZ2dhYmxlID0gdGhpcy5vcHRpb25zLmRyYWdnYWJsZTtcclxuXHRcdFx0aWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuXHRcdFx0XHRkcmFnZ2FibGUgPSB0aGlzLmRyYWdnaW5nLmVuYWJsZWQoKTtcclxuXHRcdFx0XHR0aGlzLmRyYWdnaW5nLmRpc2FibGUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5kcmFnZ2luZyA9IG5ldyBNYXJrZXJEcmFnKHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKGRyYWdnYWJsZSkge1xyXG5cdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZW5hYmxlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIG9wYWNpdHkgb2YgdGhlIG1hcmtlci5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9wYWNpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ljb24sIG9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX3NoYWRvdywgb3BhY2l0eSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KHRoaXMub3B0aW9ucy5yaXNlT2Zmc2V0KTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXRaSW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgwKTtcclxuXHR9LFxyXG5cclxuXHRfcGFuT25Gb2N1czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcclxuXHRcdGlmICghbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBpY29uT3B0cyA9IHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnM7XHJcblx0XHR2YXIgc2l6ZSA9IGljb25PcHRzLmljb25TaXplID8gcG9pbnQoaWNvbk9wdHMuaWNvblNpemUpIDogcG9pbnQoMCwgMCk7XHJcblx0XHR2YXIgYW5jaG9yID0gaWNvbk9wdHMuaWNvbkFuY2hvciA/IHBvaW50KGljb25PcHRzLmljb25BbmNob3IpIDogcG9pbnQoMCwgMCk7XHJcblxyXG5cdFx0bWFwLnBhbkluc2lkZSh0aGlzLl9sYXRsbmcsIHtcclxuXHRcdFx0cGFkZGluZ1RvcExlZnQ6IGFuY2hvcixcclxuXHRcdFx0cGFkZGluZ0JvdHRvbVJpZ2h0OiBzaXplLnN1YnRyYWN0KGFuY2hvcilcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRQb3B1cEFuY2hvcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMucG9wdXBBbmNob3I7XHJcblx0fSxcclxuXHJcblx0X2dldFRvb2x0aXBBbmNob3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnRvb2x0aXBBbmNob3I7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBmYWN0b3J5IEwubWFya2VyKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPyA6IE1hcmtlciBvcHRpb25zKVxyXG5cclxuLy8gQGZhY3RvcnkgTC5tYXJrZXIobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/IDogTWFya2VyIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIE1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcclxufVxyXG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgUGF0aFxuICogQGFrYSBMLlBhdGhcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxuICpcbiAqIEFuIGFic3RyYWN0IGNsYXNzIHRoYXQgY29udGFpbnMgb3B0aW9ucyBhbmQgY29uc3RhbnRzIHNoYXJlZCBiZXR3ZWVuIHZlY3RvclxuICogb3ZlcmxheXMgKFBvbHlnb24sIFBvbHlsaW5lLCBDaXJjbGUpLiBEbyBub3QgdXNlIGl0IGRpcmVjdGx5LiBFeHRlbmRzIGBMYXllcmAuXG4gKi9cblxuZXhwb3J0IHZhciBQYXRoID0gTGF5ZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFBhdGggb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzdHJva2U6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gV2hldGhlciB0byBkcmF3IHN0cm9rZSBhbG9uZyB0aGUgcGF0aC4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBib3JkZXJzIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0c3Ryb2tlOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiBjb2xvcjogU3RyaW5nID0gJyMzMzg4ZmYnXG5cdFx0Ly8gU3Ryb2tlIGNvbG9yXG5cdFx0Y29sb3I6ICcjMzM4OGZmJyxcblxuXHRcdC8vIEBvcHRpb24gd2VpZ2h0OiBOdW1iZXIgPSAzXG5cdFx0Ly8gU3Ryb2tlIHdpZHRoIGluIHBpeGVsc1xuXHRcdHdlaWdodDogMyxcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXG5cdFx0Ly8gU3Ryb2tlIG9wYWNpdHlcblx0XHRvcGFjaXR5OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lQ2FwOiBTdHJpbmc9ICdyb3VuZCdcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgW3NoYXBlIHRvIGJlIHVzZWQgYXQgdGhlIGVuZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWNhcCkgb2YgdGhlIHN0cm9rZS5cblx0XHRsaW5lQ2FwOiAncm91bmQnLFxuXG5cdFx0Ly8gQG9wdGlvbiBsaW5lSm9pbjogU3RyaW5nID0gJ3JvdW5kJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbc2hhcGUgdG8gYmUgdXNlZCBhdCB0aGUgY29ybmVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbGluZWpvaW4pIG9mIHRoZSBzdHJva2UuXG5cdFx0bGluZUpvaW46ICdyb3VuZCcsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hBcnJheTogU3RyaW5nID0gbnVsbFxuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyB0aGUgc3Ryb2tlIFtkYXNoIHBhdHRlcm5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hhcnJheSkuIERvZXNuJ3Qgd29yayBvbiBgQ2FudmFzYC1wb3dlcmVkIGxheWVycyBpbiBbc29tZSBvbGQgYnJvd3NlcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5KS5cblx0XHRkYXNoQXJyYXk6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGRhc2hPZmZzZXQ6IFN0cmluZyA9IG51bGxcblx0XHQvLyBBIHN0cmluZyB0aGF0IGRlZmluZXMgdGhlIFtkaXN0YW5jZSBpbnRvIHRoZSBkYXNoIHBhdHRlcm4gdG8gc3RhcnQgdGhlIGRhc2hdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hvZmZzZXQpLiBEb2Vzbid0IHdvcmsgb24gYENhbnZhc2AtcG93ZXJlZCBsYXllcnMgaW4gW3NvbWUgb2xkIGJyb3dzZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eSkuXG5cdFx0ZGFzaE9mZnNldDogbnVsbCxcblxuXHRcdC8vIEBvcHRpb24gZmlsbDogQm9vbGVhbiA9IGRlcGVuZHNcblx0XHQvLyBXaGV0aGVyIHRvIGZpbGwgdGhlIHBhdGggd2l0aCBjb2xvci4gU2V0IGl0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBmaWxsaW5nIG9uIHBvbHlnb25zIG9yIGNpcmNsZXMuXG5cdFx0ZmlsbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxDb2xvcjogU3RyaW5nID0gKlxuXHRcdC8vIEZpbGwgY29sb3IuIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBvZiB0aGUgW2Bjb2xvcmBdKCNwYXRoLWNvbG9yKSBvcHRpb25cblx0XHRmaWxsQ29sb3I6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIGZpbGxPcGFjaXR5OiBOdW1iZXIgPSAwLjJcblx0XHQvLyBGaWxsIG9wYWNpdHkuXG5cdFx0ZmlsbE9wYWNpdHk6IDAuMixcblxuXHRcdC8vIEBvcHRpb24gZmlsbFJ1bGU6IFN0cmluZyA9ICdldmVub2RkJ1xuXHRcdC8vIEEgc3RyaW5nIHRoYXQgZGVmaW5lcyBbaG93IHRoZSBpbnNpZGUgb2YgYSBzaGFwZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9maWxsLXJ1bGUpIGlzIGRldGVybWluZWQuXG5cdFx0ZmlsbFJ1bGU6ICdldmVub2RkJyxcblxuXHRcdC8vIGNsYXNzTmFtZTogJycsXG5cblx0XHQvLyBPcHRpb24gaW5oZXJpdGVkIGZyb20gXCJJbnRlcmFjdGl2ZSBsYXllclwiIGFic3RyYWN0IGNsYXNzXG5cdFx0aW50ZXJhY3RpdmU6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIGJ1YmJsaW5nTW91c2VFdmVudHM6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gV2hlbiBgdHJ1ZWAsIGEgbW91c2UgZXZlbnQgb24gdGhpcyBwYXRoIHdpbGwgdHJpZ2dlciB0aGUgc2FtZSBldmVudCBvbiB0aGUgbWFwXG5cdFx0Ly8gKHVubGVzcyBbYEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uYF0oI2RvbWV2ZW50LXN0b3Bwcm9wYWdhdGlvbikgaXMgdXNlZCkuXG5cdFx0YnViYmxpbmdNb3VzZUV2ZW50czogdHJ1ZVxuXHR9LFxuXG5cdGJlZm9yZUFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdC8vIFJlbmRlcmVyIGlzIHNldCBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBjYWxsIHJlbmRlcmVyLmdldEV2ZW50c1xuXHRcdC8vIGJlZm9yZSB0aGlzLmdldEV2ZW50cy5cblx0XHR0aGlzLl9yZW5kZXJlciA9IG1hcC5nZXRSZW5kZXJlcih0aGlzKTtcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9pbml0UGF0aCh0aGlzKTtcblx0XHR0aGlzLl9yZXNldCgpO1xuXHRcdHRoaXMuX3JlbmRlcmVyLl9hZGRQYXRoKHRoaXMpO1xuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3JlbW92ZVBhdGgodGhpcyk7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCByZWRyYXcoKTogdGhpc1xuXHQvLyBSZWRyYXdzIHRoZSBsYXllci4gU29tZXRpbWVzIHVzZWZ1bCBhZnRlciB5b3UgY2hhbmdlZCB0aGUgY29vcmRpbmF0ZXMgdGhhdCB0aGUgcGF0aCB1c2VzLlxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUGF0aCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRTdHlsZShzdHlsZTogUGF0aCBvcHRpb25zKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBhcHBlYXJhbmNlIG9mIGEgUGF0aCBiYXNlZCBvbiB0aGUgb3B0aW9ucyBpbiB0aGUgYFBhdGggb3B0aW9uc2Agb2JqZWN0LlxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIHN0eWxlKTtcblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLl91cGRhdGVTdHlsZSh0aGlzKTtcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdHlsZSwgJ3dlaWdodCcpKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udCgpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcmVuZGVyZXIuX2JyaW5nVG9Gcm9udCh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBicmluZ1RvQmFjaygpOiB0aGlzXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIGJvdHRvbSBvZiBhbGwgcGF0aCBsYXllcnMuXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlbmRlcmVyKSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJlci5fYnJpbmdUb0JhY2sodGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcblx0fSxcblxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXNcblx0XHR0aGlzLl9wcm9qZWN0KCk7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X2NsaWNrVG9sZXJhbmNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdXNlZCB3aGVuIGRvaW5nIGhpdCBkZXRlY3Rpb24gZm9yIENhbnZhcyBsYXllcnNcblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5zdHJva2UgPyB0aGlzLm9wdGlvbnMud2VpZ2h0IC8gMiA6IDApICtcblx0XHQgICh0aGlzLl9yZW5kZXJlci5vcHRpb25zLnRvbGVyYW5jZSB8fCAwKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge1BhdGh9IGZyb20gJy4vUGF0aCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge3RvTGF0TG5nfSBmcm9tICcuLi8uLi9nZW8vTGF0TG5nJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG5cbi8qXG4gKiBAY2xhc3MgQ2lyY2xlTWFya2VyXG4gKiBAYWthIEwuQ2lyY2xlTWFya2VyXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2lyY2xlIG9mIGEgZml4ZWQgc2l6ZSB3aXRoIHJhZGl1cyBzcGVjaWZpZWQgaW4gcGl4ZWxzLiBFeHRlbmRzIGBQYXRoYC5cbiAqL1xuXG5leHBvcnQgdmFyIENpcmNsZU1hcmtlciA9IFBhdGguZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENpcmNsZU1hcmtlciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHRmaWxsOiB0cnVlLFxuXG5cdFx0Ly8gQG9wdGlvbiByYWRpdXM6IE51bWJlciA9IDEwXG5cdFx0Ly8gUmFkaXVzIG9mIHRoZSBjaXJjbGUgbWFya2VyLCBpbiBwaXhlbHNcblx0XHRyYWRpdXM6IDEwXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0TG5nOiBMYXRMbmcpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHBvc2l0aW9uIG9mIGEgY2lyY2xlIG1hcmtlciB0byBhIG5ldyBsb2NhdGlvbi5cblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0dmFyIG9sZExhdExuZyA9IHRoaXMuX2xhdGxuZztcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXHRcdHRoaXMucmVkcmF3KCk7XG5cblx0XHQvLyBAZXZlbnQgbW92ZTogRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBtYXJrZXIgaXMgbW92ZWQgdmlhIFtgc2V0TGF0TG5nYF0oI2NpcmNsZW1hcmtlci1zZXRsYXRsbmcpLiBPbGQgYW5kIG5ldyBjb29yZGluYXRlcyBhcmUgaW5jbHVkZWQgaW4gZXZlbnQgYXJndW1lbnRzIGFzIGBvbGRMYXRMbmdgLCBgbGF0bG5nYC5cblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywge29sZExhdExuZzogb2xkTGF0TG5nLCBsYXRsbmc6IHRoaXMuX2xhdGxuZ30pO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0TGF0TG5nKCk6IExhdExuZ1xuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGdlb2dyYXBoaWNhbCBwb3NpdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF0bG5nO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0UmFkaXVzKHJhZGl1czogTnVtYmVyKTogdGhpc1xuXHQvLyBTZXRzIHRoZSByYWRpdXMgb2YgYSBjaXJjbGUgbWFya2VyLiBVbml0cyBhcmUgaW4gcGl4ZWxzLlxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uIChyYWRpdXMpIHtcblx0XHR0aGlzLm9wdGlvbnMucmFkaXVzID0gdGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0UmFkaXVzKCk6IE51bWJlclxuXHQvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhZGl1cyBvZiB0aGUgY2lyY2xlXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXM7XG5cdH0sXG5cblx0c2V0U3R5bGUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdHZhciByYWRpdXMgPSBvcHRpb25zICYmIG9wdGlvbnMucmFkaXVzIHx8IHRoaXMuX3JhZGl1cztcblx0XHRQYXRoLnByb3RvdHlwZS5zZXRTdHlsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuc2V0UmFkaXVzKHJhZGl1cyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKTtcblx0XHR0aGlzLl91cGRhdGVCb3VuZHMoKTtcblx0fSxcblxuXHRfdXBkYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHIgPSB0aGlzLl9yYWRpdXMsXG5cdFx0ICAgIHIyID0gdGhpcy5fcmFkaXVzWSB8fCByLFxuXHRcdCAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKSxcblx0XHQgICAgcCA9IFtyICsgdywgcjIgKyB3XTtcblx0XHR0aGlzLl9weEJvdW5kcyA9IG5ldyBCb3VuZHModGhpcy5fcG9pbnQuc3VidHJhY3QocCksIHRoaXMuX3BvaW50LmFkZChwKSk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGgoKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlQ2lyY2xlKHRoaXMpO1xuXHR9LFxuXG5cdF9lbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpdXMgJiYgIXRoaXMuX3JlbmRlcmVyLl9ib3VuZHMuaW50ZXJzZWN0cyh0aGlzLl9weEJvdW5kcyk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHRyZXR1cm4gcC5kaXN0YW5jZVRvKHRoaXMuX3BvaW50KSA8PSB0aGlzLl9yYWRpdXMgKyB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuXHR9XG59KTtcblxuXG4vLyBAZmFjdG9yeSBMLmNpcmNsZU1hcmtlcihsYXRsbmc6IExhdExuZywgb3B0aW9ucz86IENpcmNsZU1hcmtlciBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgY2lyY2xlIG1hcmtlciBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgQ2lyY2xlTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0NpcmNsZU1hcmtlcn0gZnJvbSAnLi9DaXJjbGVNYXJrZXInO1xuaW1wb3J0IHtQYXRofSBmcm9tICcuL1BhdGgnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge0VhcnRofSBmcm9tICcuLi8uLi9nZW8vY3JzL0NSUy5FYXJ0aCc7XG5cblxuLypcbiAqIEBjbGFzcyBDaXJjbGVcbiAqIEBha2EgTC5DaXJjbGVcbiAqIEBpbmhlcml0cyBDaXJjbGVNYXJrZXJcbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIGNpcmNsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgQ2lyY2xlTWFya2VyYC5cbiAqXG4gKiBJdCdzIGFuIGFwcHJveGltYXRpb24gYW5kIHN0YXJ0cyB0byBkaXZlcmdlIGZyb20gYSByZWFsIGNpcmNsZSBjbG9zZXIgdG8gcG9sZXMgKGR1ZSB0byBwcm9qZWN0aW9uIGRpc3RvcnRpb24pLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIEwuY2lyY2xlKFs1MC41LCAzMC41XSwge3JhZGl1czogMjAwfSkuYWRkVG8obWFwKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgQ2lyY2xlID0gQ2lyY2xlTWFya2VyLmV4dGVuZCh7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucywgbGVnYWN5T3B0aW9ucykge1xuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcblx0XHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggZmFjdG9yeSAobGF0bG5nLCByYWRpdXMsIG9wdGlvbnM/KVxuXHRcdFx0b3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBsZWdhY3lPcHRpb25zLCB7cmFkaXVzOiBvcHRpb25zfSk7XG5cdFx0fVxuXHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLl9sYXRsbmcgPSB0b0xhdExuZyhsYXRsbmcpO1xuXG5cdFx0aWYgKGlzTmFOKHRoaXMub3B0aW9ucy5yYWRpdXMpKSB7IHRocm93IG5ldyBFcnJvcignQ2lyY2xlIHJhZGl1cyBjYW5ub3QgYmUgTmFOJyk7IH1cblxuXHRcdC8vIEBzZWN0aW9uXG5cdFx0Ly8gQGFrYSBDaXJjbGUgb3B0aW9uc1xuXHRcdC8vIEBvcHRpb24gcmFkaXVzOiBOdW1iZXI7IFJhZGl1cyBvZiB0aGUgY2lyY2xlLCBpbiBtZXRlcnMuXG5cdFx0dGhpcy5fbVJhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRSYWRpdXMocmFkaXVzOiBOdW1iZXIpOiB0aGlzXG5cdC8vIFNldHMgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZS4gVW5pdHMgYXJlIGluIG1ldGVycy5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbiAocmFkaXVzKSB7XG5cdFx0dGhpcy5fbVJhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldFJhZGl1cygpOiBOdW1iZXJcblx0Ly8gUmV0dXJucyB0aGUgY3VycmVudCByYWRpdXMgb2YgYSBjaXJjbGUuIFVuaXRzIGFyZSBpbiBtZXRlcnMuXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tUmFkaXVzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xuXHQvLyBSZXR1cm5zIHRoZSBgTGF0TG5nQm91bmRzYCBvZiB0aGUgcGF0aC5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGhhbGYgPSBbdGhpcy5fcmFkaXVzLCB0aGlzLl9yYWRpdXNZIHx8IHRoaXMuX3JhZGl1c107XG5cblx0XHRyZXR1cm4gbmV3IExhdExuZ0JvdW5kcyhcblx0XHRcdHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuc3VidHJhY3QoaGFsZikpLFxuXHRcdFx0dGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludC5hZGQoaGFsZikpKTtcblx0fSxcblxuXHRzZXRTdHlsZTogUGF0aC5wcm90b3R5cGUuc2V0U3R5bGUsXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBsbmcgPSB0aGlzLl9sYXRsbmcubG5nLFxuXHRcdCAgICBsYXQgPSB0aGlzLl9sYXRsbmcubGF0LFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNycyA9IG1hcC5vcHRpb25zLmNycztcblxuXHRcdGlmIChjcnMuZGlzdGFuY2UgPT09IEVhcnRoLmRpc3RhbmNlKSB7XG5cdFx0XHR2YXIgZCA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHQgICAgbGF0UiA9ICh0aGlzLl9tUmFkaXVzIC8gRWFydGguUikgLyBkLFxuXHRcdFx0ICAgIHRvcCA9IG1hcC5wcm9qZWN0KFtsYXQgKyBsYXRSLCBsbmddKSxcblx0XHRcdCAgICBib3R0b20gPSBtYXAucHJvamVjdChbbGF0IC0gbGF0UiwgbG5nXSksXG5cdFx0XHQgICAgcCA9IHRvcC5hZGQoYm90dG9tKS5kaXZpZGVCeSgyKSxcblx0XHRcdCAgICBsYXQyID0gbWFwLnVucHJvamVjdChwKS5sYXQsXG5cdFx0XHQgICAgbG5nUiA9IE1hdGguYWNvcygoTWF0aC5jb3MobGF0UiAqIGQpIC0gTWF0aC5zaW4obGF0ICogZCkgKiBNYXRoLnNpbihsYXQyICogZCkpIC9cblx0XHRcdCAgICAgICAgICAgIChNYXRoLmNvcyhsYXQgKiBkKSAqIE1hdGguY29zKGxhdDIgKiBkKSkpIC8gZDtcblxuXHRcdFx0aWYgKGlzTmFOKGxuZ1IpIHx8IGxuZ1IgPT09IDApIHtcblx0XHRcdFx0bG5nUiA9IGxhdFIgLyBNYXRoLmNvcyhNYXRoLlBJIC8gMTgwICogbGF0KTsgLy8gRmFsbGJhY2sgZm9yIGVkZ2UgY2FzZSwgIzI0MjVcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBwLnN1YnRyYWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKTtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IGlzTmFOKGxuZ1IpID8gMCA6IHAueCAtIG1hcC5wcm9qZWN0KFtsYXQyLCBsbmcgLSBsbmdSXSkueDtcblx0XHRcdHRoaXMuX3JhZGl1c1kgPSBwLnkgLSB0b3AueTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbGF0bG5nMiA9IGNycy51bnByb2plY3QoY3JzLnByb2plY3QodGhpcy5fbGF0bG5nKS5zdWJ0cmFjdChbdGhpcy5fbVJhZGl1cywgMF0pKTtcblxuXHRcdFx0dGhpcy5fcG9pbnQgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSB0aGlzLl9wb2ludC54IC0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcyKS54O1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5jaXJjbGUobGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBDaXJjbGUgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhIGNpcmNsZSBvYmplY3QgZ2l2ZW4gYSBnZW9ncmFwaGljYWwgcG9pbnQsIGFuZCBhbiBvcHRpb25zIG9iamVjdFxuLy8gd2hpY2ggY29udGFpbnMgdGhlIGNpcmNsZSByYWRpdXMuXG4vLyBAYWx0ZXJuYXRpdmVcbi8vIEBmYWN0b3J5IEwuY2lyY2xlKGxhdGxuZzogTGF0TG5nLCByYWRpdXM6IE51bWJlciwgb3B0aW9ucz86IENpcmNsZSBvcHRpb25zKVxuLy8gT2Jzb2xldGUgd2F5IG9mIGluc3RhbnRpYXRpbmcgYSBjaXJjbGUsIGZvciBjb21wYXRpYmlsaXR5IHdpdGggMC43LnggY29kZS5cbi8vIERvIG5vdCB1c2UgaW4gbmV3IGFwcGxpY2F0aW9ucyBvciBwbHVnaW5zLlxuZXhwb3J0IGZ1bmN0aW9uIGNpcmNsZShsYXRsbmcsIG9wdGlvbnMsIGxlZ2FjeU9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBDaXJjbGUobGF0bG5nLCBvcHRpb25zLCBsZWdhY3lPcHRpb25zKTtcbn1cbiIsImltcG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIExpbmVVdGlsIGZyb20gJy4uLy4uL2dlb21ldHJ5L0xpbmVVdGlsJztcbmltcG9ydCB7TGF0TG5nLCB0b0xhdExuZ30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZyc7XG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcblxuLypcbiAqIEBjbGFzcyBQb2x5bGluZVxuICogQGFrYSBMLlBvbHlsaW5lXG4gKiBAaW5oZXJpdHMgUGF0aFxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWxpbmUgb3ZlcmxheXMgb24gYSBtYXAuIEV4dGVuZHMgYFBhdGhgLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5bGluZSBmcm9tIGFuIGFycmF5IG9mIExhdExuZyBwb2ludHNcbiAqIHZhciBsYXRsbmdzID0gW1xuICogXHRbNDUuNTEsIC0xMjIuNjhdLFxuICogXHRbMzcuNzcsIC0xMjIuNDNdLFxuICogXHRbMzQuMDQsIC0xMTguMl1cbiAqIF07XG4gKlxuICogdmFyIHBvbHlsaW5lID0gTC5wb2x5bGluZShsYXRsbmdzLCB7Y29sb3I6ICdyZWQnfSkuYWRkVG8obWFwKTtcbiAqXG4gKiAvLyB6b29tIHRoZSBtYXAgdG8gdGhlIHBvbHlsaW5lXG4gKiBtYXAuZml0Qm91bmRzKHBvbHlsaW5lLmdldEJvdW5kcygpKTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgYE11bHRpUG9seWxpbmVgIHNoYXBlOlxuICpcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgYSByZWQgcG9seWxpbmUgZnJvbSBhbiBhcnJheSBvZiBhcnJheXMgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiBcdFtbNDUuNTEsIC0xMjIuNjhdLFxuICogXHQgWzM3Ljc3LCAtMTIyLjQzXSxcbiAqIFx0IFszNC4wNCwgLTExOC4yXV0sXG4gKiBcdFtbNDAuNzgsIC03My45MV0sXG4gKiBcdCBbNDEuODMsIC04Ny42Ml0sXG4gKiBcdCBbMzIuNzYsIC05Ni43Ml1dXG4gKiBdO1xuICogYGBgXG4gKi9cblxuXG5leHBvcnQgdmFyIFBvbHlsaW5lID0gUGF0aC5leHRlbmQoe1xuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBha2EgUG9seWxpbmUgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBzbW9vdGhGYWN0b3I6IE51bWJlciA9IDEuMFxuXHRcdC8vIEhvdyBtdWNoIHRvIHNpbXBsaWZ5IHRoZSBwb2x5bGluZSBvbiBlYWNoIHpvb20gbGV2ZWwuIE1vcmUgbWVhbnNcblx0XHQvLyBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kIHNtb290aGVyIGxvb2ssIGFuZCBsZXNzIG1lYW5zIG1vcmUgYWNjdXJhdGUgcmVwcmVzZW50YXRpb24uXG5cdFx0c21vb3RoRmFjdG9yOiAxLjAsXG5cblx0XHQvLyBAb3B0aW9uIG5vQ2xpcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gRGlzYWJsZSBwb2x5bGluZSBjbGlwcGluZy5cblx0XHRub0NsaXA6IGZhbHNlXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5fc2V0TGF0TG5ncyhsYXRsbmdzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldExhdExuZ3MoKTogTGF0TG5nW11cblx0Ly8gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcG9pbnRzIGluIHRoZSBwYXRoLCBvciBuZXN0ZWQgYXJyYXlzIG9mIHBvaW50cyBpbiBjYXNlIG9mIG11bHRpLXBvbHlsaW5lLlxuXHRnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZ3M7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmdzKGxhdGxuZ3M6IExhdExuZ1tdKTogdGhpc1xuXHQvLyBSZXBsYWNlcyBhbGwgdGhlIHBvaW50cyBpbiB0aGUgcG9seWxpbmUgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cy5cblx0c2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR0aGlzLl9zZXRMYXRMbmdzKGxhdGxuZ3MpO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgaXNFbXB0eSgpOiBCb29sZWFuXG5cdC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBQb2x5bGluZSBoYXMgbm8gTGF0TG5ncy5cblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5fbGF0bG5ncy5sZW5ndGg7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBjbG9zZXN0TGF5ZXJQb2ludChwOiBQb2ludCk6IFBvaW50XG5cdC8vIFJldHVybnMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gYHBgIG9uIHRoZSBQb2x5bGluZS5cblx0Y2xvc2VzdExheWVyUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHksXG5cdFx0ICAgIG1pblBvaW50ID0gbnVsbCxcblx0XHQgICAgY2xvc2VzdCA9IExpbmVVdGlsLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudCxcblx0XHQgICAgcDEsIHAyO1xuXG5cdFx0Zm9yICh2YXIgaiA9IDAsIGpMZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcblx0XHRcdHZhciBwb2ludHMgPSB0aGlzLl9wYXJ0c1tqXTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRwMSA9IHBvaW50c1tpIC0gMV07XG5cdFx0XHRcdHAyID0gcG9pbnRzW2ldO1xuXG5cdFx0XHRcdHZhciBzcURpc3QgPSBjbG9zZXN0KHAsIHAxLCBwMiwgdHJ1ZSk7XG5cblx0XHRcdFx0aWYgKHNxRGlzdCA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBzcURpc3Q7XG5cdFx0XHRcdFx0bWluUG9pbnQgPSBjbG9zZXN0KHAsIHAxLCBwMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG1pblBvaW50KSB7XG5cdFx0XHRtaW5Qb2ludC5kaXN0YW5jZSA9IE1hdGguc3FydChtaW5EaXN0YW5jZSk7XG5cdFx0fVxuXHRcdHJldHVybiBtaW5Qb2ludDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NlbnRyb2lkKSkgb2YgdGhlIHBvbHlsaW5lLlxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyB0aHJvd3MgZXJyb3Igd2hlbiBub3QgeWV0IGFkZGVkIHRvIG1hcCBhcyB0aGlzIGNlbnRlciBjYWxjdWxhdGlvbiByZXF1aXJlcyBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IGFkZCBsYXllciB0byBtYXAgYmVmb3JlIHVzaW5nIGdldENlbnRlcigpJyk7XG5cdFx0fVxuXHRcdHJldHVybiBMaW5lVXRpbC5wb2x5bGluZUNlbnRlcih0aGlzLl9kZWZhdWx0U2hhcGUoKSwgdGhpcy5fbWFwLm9wdGlvbnMuY3JzKTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldEJvdW5kcygpOiBMYXRMbmdCb3VuZHNcblx0Ly8gUmV0dXJucyB0aGUgYExhdExuZ0JvdW5kc2Agb2YgdGhlIHBhdGguXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBhZGRMYXRMbmcobGF0bG5nOiBMYXRMbmcsIGxhdGxuZ3M/OiBMYXRMbmdbXSk6IHRoaXNcblx0Ly8gQWRkcyBhIGdpdmVuIHBvaW50IHRvIHRoZSBwb2x5bGluZS4gQnkgZGVmYXVsdCwgYWRkcyB0byB0aGUgZmlyc3QgcmluZyBvZlxuXHQvLyB0aGUgcG9seWxpbmUgaW4gY2FzZSBvZiBhIG11bHRpLXBvbHlsaW5lLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZ1xuXHQvLyBhIHNwZWNpZmljIHJpbmcgYXMgYSBMYXRMbmcgYXJyYXkgKHRoYXQgeW91IGNhbiBlYXJsaWVyIGFjY2VzcyB3aXRoIFtgZ2V0TGF0TG5nc2BdKCNwb2x5bGluZS1nZXRsYXRsbmdzKSkuXG5cdGFkZExhdExuZzogZnVuY3Rpb24gKGxhdGxuZywgbGF0bG5ncykge1xuXHRcdGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2RlZmF1bHRTaGFwZSgpO1xuXHRcdGxhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XG5cdFx0bGF0bG5ncy5wdXNoKGxhdGxuZyk7XG5cdFx0dGhpcy5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBMYXRMbmdCb3VuZHMoKTtcblx0XHR0aGlzLl9sYXRsbmdzID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5ncyk7XG5cdH0sXG5cblx0X2RlZmF1bHRTaGFwZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncykgPyB0aGlzLl9sYXRsbmdzIDogdGhpcy5fbGF0bG5nc1swXTtcblx0fSxcblxuXHQvLyByZWN1cnNpdmVseSBjb252ZXJ0IGxhdGxuZ3MgaW5wdXQgaW50byBhY3R1YWwgTGF0TG5nIGluc3RhbmNlczsgY2FsY3VsYXRlIGJvdW5kcyBhbG9uZyB0aGUgd2F5XG5cdF9jb252ZXJ0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0ICAgIGZsYXQgPSBMaW5lVXRpbC5pc0ZsYXQobGF0bG5ncyk7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGZsYXQpIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gdG9MYXRMbmcobGF0bG5nc1tpXSk7XG5cdFx0XHRcdHRoaXMuX2JvdW5kcy5leHRlbmQocmVzdWx0W2ldKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IHRoaXMuX2NvbnZlcnRMYXRMbmdzKGxhdGxuZ3NbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3Byb2plY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5cdFx0dGhpcy5fcmluZ3MgPSBbXTtcblx0XHR0aGlzLl9wcm9qZWN0TGF0bG5ncyh0aGlzLl9sYXRsbmdzLCB0aGlzLl9yaW5ncywgcHhCb3VuZHMpO1xuXG5cdFx0aWYgKHRoaXMuX2JvdW5kcy5pc1ZhbGlkKCkgJiYgcHhCb3VuZHMuaXNWYWxpZCgpKSB7XG5cdFx0XHR0aGlzLl9yYXdQeEJvdW5kcyA9IHB4Qm91bmRzO1xuXHRcdFx0dGhpcy5fdXBkYXRlQm91bmRzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCksXG5cdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cblx0XHRpZiAoIXRoaXMuX3Jhd1B4Qm91bmRzKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fcHhCb3VuZHMgPSBuZXcgQm91bmRzKFtcblx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzLm1pbi5zdWJ0cmFjdChwKSxcblx0XHRcdHRoaXMuX3Jhd1B4Qm91bmRzLm1heC5hZGQocClcblx0XHRdKTtcblx0fSxcblxuXHQvLyByZWN1cnNpdmVseSB0dXJucyBsYXRsbmdzIGludG8gYSBzZXQgb2YgcmluZ3Mgd2l0aCBwcm9qZWN0ZWQgY29vcmRpbmF0ZXNcblx0X3Byb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAobGF0bG5ncywgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpIHtcblx0XHR2YXIgZmxhdCA9IGxhdGxuZ3NbMF0gaW5zdGFuY2VvZiBMYXRMbmcsXG5cdFx0ICAgIGxlbiA9IGxhdGxuZ3MubGVuZ3RoLFxuXHRcdCAgICBpLCByaW5nO1xuXG5cdFx0aWYgKGZsYXQpIHtcblx0XHRcdHJpbmcgPSBbXTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyaW5nW2ldID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmdzW2ldKTtcblx0XHRcdFx0cHJvamVjdGVkQm91bmRzLmV4dGVuZChyaW5nW2ldKTtcblx0XHRcdH1cblx0XHRcdHJlc3VsdC5wdXNoKHJpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fcHJvamVjdExhdGxuZ3MobGF0bG5nc1tpXSwgcmVzdWx0LCBwcm9qZWN0ZWRCb3VuZHMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBjbGlwIHBvbHlsaW5lIGJ5IHJlbmRlcmVyIGJvdW5kcyBzbyB0aGF0IHdlIGhhdmUgbGVzcyB0byByZW5kZXIgZm9yIHBlcmZvcm1hbmNlXG5cdF9jbGlwUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3JlbmRlcmVyLl9ib3VuZHM7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuXHRcdCAgICBpLCBqLCBrLCBsZW4sIGxlbjIsIHNlZ21lbnQsIHBvaW50cztcblxuXHRcdGZvciAoaSA9IDAsIGsgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0cG9pbnRzID0gdGhpcy5fcmluZ3NbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwb2ludHMubGVuZ3RoOyBqIDwgbGVuMiAtIDE7IGorKykge1xuXHRcdFx0XHRzZWdtZW50ID0gTGluZVV0aWwuY2xpcFNlZ21lbnQocG9pbnRzW2pdLCBwb2ludHNbaiArIDFdLCBib3VuZHMsIGosIHRydWUpO1xuXG5cdFx0XHRcdGlmICghc2VnbWVudCkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRcdHBhcnRzW2tdID0gcGFydHNba10gfHwgW107XG5cdFx0XHRcdHBhcnRzW2tdLnB1c2goc2VnbWVudFswXSk7XG5cblx0XHRcdFx0Ly8gaWYgc2VnbWVudCBnb2VzIG91dCBvZiBzY3JlZW4sIG9yIGl0J3MgdGhlIGxhc3Qgb25lLCBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmUgcGFydFxuXHRcdFx0XHRpZiAoKHNlZ21lbnRbMV0gIT09IHBvaW50c1tqICsgMV0pIHx8IChqID09PSBsZW4yIC0gMikpIHtcblx0XHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMV0pO1xuXHRcdFx0XHRcdGsrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBzaW1wbGlmeSBlYWNoIGNsaXBwZWQgcGFydCBvZiB0aGUgcG9seWxpbmUgZm9yIHBlcmZvcm1hbmNlXG5cdF9zaW1wbGlmeVBvaW50czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzLFxuXHRcdCAgICB0b2xlcmFuY2UgPSB0aGlzLm9wdGlvbnMuc21vb3RoRmFjdG9yO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0c1tpXSA9IExpbmVVdGlsLnNpbXBsaWZ5KHBhcnRzW2ldLCB0b2xlcmFuY2UpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9jbGlwUG9pbnRzKCk7XG5cdFx0dGhpcy5fc2ltcGxpZnlQb2ludHMoKTtcblx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzKTtcblx0fSxcblxuXHQvLyBOZWVkZWQgYnkgdGhlIGBDYW52YXNgIHJlbmRlcmVyIGZvciBpbnRlcmFjdGl2aXR5XG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCwgY2xvc2VkKSB7XG5cdFx0dmFyIGksIGosIGssIGxlbiwgbGVuMiwgcGFydCxcblx0XHQgICAgdyA9IHRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7XG5cblx0XHRpZiAoIXRoaXMuX3B4Qm91bmRzIHx8ICF0aGlzLl9weEJvdW5kcy5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdC8vIGhpdCBkZXRlY3Rpb24gZm9yIHBvbHlsaW5lc1xuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XG5cblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSBwYXJ0Lmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuXHRcdFx0XHRpZiAoIWNsb3NlZCAmJiAoaiA9PT0gMCkpIHsgY29udGludWU7IH1cblxuXHRcdFx0XHRpZiAoTGluZVV0aWwucG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwYXJ0W2tdLCBwYXJ0W2pdKSA8PSB3KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5wb2x5bGluZShsYXRsbmdzOiBMYXRMbmdbXSwgb3B0aW9ucz86IFBvbHlsaW5lIG9wdGlvbnMpXG4vLyBJbnN0YW50aWF0ZXMgYSBwb2x5bGluZSBvYmplY3QgZ2l2ZW4gYW4gYXJyYXkgb2YgZ2VvZ3JhcGhpY2FsIHBvaW50cyBhbmRcbi8vIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuIFlvdSBjYW4gY3JlYXRlIGEgYFBvbHlsaW5lYCBvYmplY3Qgd2l0aFxuLy8gbXVsdGlwbGUgc2VwYXJhdGUgbGluZXMgKGBNdWx0aVBvbHlsaW5lYCkgYnkgcGFzc2luZyBhbiBhcnJheSBvZiBhcnJheXNcbi8vIG9mIGdlb2dyYXBoaWMgcG9pbnRzLlxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlsaW5lKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBQb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcbn1cblxuLy8gUmV0cm9jb21wYXQuIEFsbG93IHBsdWdpbnMgdG8gc3VwcG9ydCBMZWFmbGV0IHZlcnNpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgMS4xLlxuUG9seWxpbmUuX2ZsYXQgPSBMaW5lVXRpbC5fZmxhdDtcbiIsImltcG9ydCB7UG9seWxpbmV9IGZyb20gJy4vUG9seWxpbmUnO1xuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uLy4uL2dlby9MYXRMbmcnO1xuaW1wb3J0ICogYXMgTGluZVV0aWwgZnJvbSAnLi4vLi4vZ2VvbWV0cnkvTGluZVV0aWwnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0IHtCb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XG5pbXBvcnQgKiBhcyBQb2x5VXRpbCBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2x5VXRpbCc7XG5cbi8qXG4gKiBAY2xhc3MgUG9seWdvblxuICogQGFrYSBMLlBvbHlnb25cbiAqIEBpbmhlcml0cyBQb2x5bGluZVxuICpcbiAqIEEgY2xhc3MgZm9yIGRyYXdpbmcgcG9seWdvbiBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWxpbmVgLlxuICpcbiAqIE5vdGUgdGhhdCBwb2ludHMgeW91IHBhc3Mgd2hlbiBjcmVhdGluZyBhIHBvbHlnb24gc2hvdWxkbid0IGhhdmUgYW4gYWRkaXRpb25hbCBsYXN0IHBvaW50IGVxdWFsIHRvIHRoZSBmaXJzdCBvbmUg4oCUIGl0J3MgYmV0dGVyIHRvIGZpbHRlciBvdXQgc3VjaCBwb2ludHMuXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIC8vIGNyZWF0ZSBhIHJlZCBwb2x5Z29uIGZyb20gYW4gYXJyYXkgb2YgTGF0TG5nIHBvaW50c1xuICogdmFyIGxhdGxuZ3MgPSBbWzM3LCAtMTA5LjA1XSxbNDEsIC0xMDkuMDNdLFs0MSwgLTEwMi4wNV0sWzM3LCAtMTAyLjA0XV07XG4gKlxuICogdmFyIHBvbHlnb24gPSBMLnBvbHlnb24obGF0bG5ncywge2NvbG9yOiAncmVkJ30pLmFkZFRvKG1hcCk7XG4gKlxuICogLy8gem9vbSB0aGUgbWFwIHRvIHRoZSBwb2x5Z29uXG4gKiBtYXAuZml0Qm91bmRzKHBvbHlnb24uZ2V0Qm91bmRzKCkpO1xuICogYGBgXG4gKlxuICogWW91IGNhbiBhbHNvIHBhc3MgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGxhdGxuZ3MsIHdpdGggdGhlIGZpcnN0IGFycmF5IHJlcHJlc2VudGluZyB0aGUgb3V0ZXIgc2hhcGUgYW5kIHRoZSBvdGhlciBhcnJheXMgcmVwcmVzZW50aW5nIGhvbGVzIGluIHRoZSBvdXRlciBzaGFwZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIGxhdGxuZ3MgPSBbXG4gKiAgIFtbMzcsIC0xMDkuMDVdLFs0MSwgLTEwOS4wM10sWzQxLCAtMTAyLjA1XSxbMzcsIC0xMDIuMDRdXSwgLy8gb3V0ZXIgcmluZ1xuICogICBbWzM3LjI5LCAtMTA4LjU4XSxbNDAuNzEsIC0xMDguNThdLFs0MC43MSwgLTEwMi41MF0sWzM3LjI5LCAtMTAyLjUwXV0gLy8gaG9sZVxuICogXTtcbiAqIGBgYFxuICpcbiAqIEFkZGl0aW9uYWxseSwgeW91IGNhbiBwYXNzIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgdG8gcmVwcmVzZW50IGEgTXVsdGlQb2x5Z29uIHNoYXBlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGF0bG5ncyA9IFtcbiAqICAgWyAvLyBmaXJzdCBwb2x5Z29uXG4gKiAgICAgW1szNywgLTEwOS4wNV0sWzQxLCAtMTA5LjAzXSxbNDEsIC0xMDIuMDVdLFszNywgLTEwMi4wNF1dLCAvLyBvdXRlciByaW5nXG4gKiAgICAgW1szNy4yOSwgLTEwOC41OF0sWzQwLjcxLCAtMTA4LjU4XSxbNDAuNzEsIC0xMDIuNTBdLFszNy4yOSwgLTEwMi41MF1dIC8vIGhvbGVcbiAqICAgXSxcbiAqICAgWyAvLyBzZWNvbmQgcG9seWdvblxuICogICAgIFtbNDEsIC0xMTEuMDNdLFs0NSwgLTExMS4wNF0sWzQ1LCAtMTA0LjA1XSxbNDEsIC0xMDQuMDVdXVxuICogICBdXG4gKiBdO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBQb2x5Z29uID0gUG9seWxpbmUuZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0ZmlsbDogdHJ1ZVxuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2xhdGxuZ3MubGVuZ3RoIHx8ICF0aGlzLl9sYXRsbmdzWzBdLmxlbmd0aDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGdldENlbnRlcigpOiBMYXRMbmdcblx0Ly8gUmV0dXJucyB0aGUgY2VudGVyIChbY2VudHJvaWRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJvaWQpKSBvZiB0aGUgUG9seWdvbi5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gdGhyb3dzIGVycm9yIHdoZW4gbm90IHlldCBhZGRlZCB0byBtYXAgYXMgdGhpcyBjZW50ZXIgY2FsY3VsYXRpb24gcmVxdWlyZXMgcHJvamVjdGVkIGNvb3JkaW5hdGVzXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBhZGQgbGF5ZXIgdG8gbWFwIGJlZm9yZSB1c2luZyBnZXRDZW50ZXIoKScpO1xuXHRcdH1cblx0XHRyZXR1cm4gUG9seVV0aWwucG9seWdvbkNlbnRlcih0aGlzLl9kZWZhdWx0U2hhcGUoKSwgdGhpcy5fbWFwLm9wdGlvbnMuY3JzKTtcblx0fSxcblxuXHRfY29udmVydExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFBvbHlsaW5lLnByb3RvdHlwZS5fY29udmVydExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKSxcblx0XHQgICAgbGVuID0gcmVzdWx0Lmxlbmd0aDtcblxuXHRcdC8vIHJlbW92ZSBsYXN0IHBvaW50IGlmIGl0IGVxdWFscyBmaXJzdCBvbmVcblx0XHRpZiAobGVuID49IDIgJiYgcmVzdWx0WzBdIGluc3RhbmNlb2YgTGF0TG5nICYmIHJlc3VsdFswXS5lcXVhbHMocmVzdWx0W2xlbiAtIDFdKSkge1xuXHRcdFx0cmVzdWx0LnBvcCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdF9zZXRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuXHRcdFBvbHlsaW5lLnByb3RvdHlwZS5fc2V0TGF0TG5ncy5jYWxsKHRoaXMsIGxhdGxuZ3MpO1xuXHRcdGlmIChMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncykpIHtcblx0XHRcdHRoaXMuX2xhdGxuZ3MgPSBbdGhpcy5fbGF0bG5nc107XG5cdFx0fVxuXHR9LFxuXG5cdF9kZWZhdWx0U2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3NbMF0pID8gdGhpcy5fbGF0bG5nc1swXSA6IHRoaXMuX2xhdGxuZ3NbMF1bMF07XG5cdH0sXG5cblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBwb2x5Z29ucyBuZWVkIGEgZGlmZmVyZW50IGNsaXBwaW5nIGFsZ29yaXRobSBzbyB3ZSByZWRlZmluZSB0aGF0XG5cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVuZGVyZXIuX2JvdW5kcyxcblx0XHQgICAgdyA9IHRoaXMub3B0aW9ucy53ZWlnaHQsXG5cdFx0ICAgIHAgPSBuZXcgUG9pbnQodywgdyk7XG5cblx0XHQvLyBpbmNyZWFzZSBjbGlwIHBhZGRpbmcgYnkgc3Ryb2tlIHdpZHRoIHRvIGF2b2lkIHN0cm9rZSBvbiBjbGlwIGVkZ2VzXG5cdFx0Ym91bmRzID0gbmV3IEJvdW5kcyhib3VuZHMubWluLnN1YnRyYWN0KHApLCBib3VuZHMubWF4LmFkZChwKSk7XG5cblx0XHR0aGlzLl9wYXJ0cyA9IFtdO1xuXHRcdGlmICghdGhpcy5fcHhCb3VuZHMgfHwgIXRoaXMuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubm9DbGlwKSB7XG5cdFx0XHR0aGlzLl9wYXJ0cyA9IHRoaXMuX3JpbmdzO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9yaW5ncy5sZW5ndGgsIGNsaXBwZWQ7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0Y2xpcHBlZCA9IFBvbHlVdGlsLmNsaXBQb2x5Z29uKHRoaXMuX3JpbmdzW2ldLCBib3VuZHMsIHRydWUpO1xuXHRcdFx0aWYgKGNsaXBwZWQubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX3BhcnRzLnB1c2goY2xpcHBlZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuX3VwZGF0ZVBvbHkodGhpcywgdHJ1ZSk7XG5cdH0sXG5cblx0Ly8gTmVlZGVkIGJ5IHRoZSBgQ2FudmFzYCByZW5kZXJlciBmb3IgaW50ZXJhY3Rpdml0eVxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHApIHtcblx0XHR2YXIgaW5zaWRlID0gZmFsc2UsXG5cdFx0ICAgIHBhcnQsIHAxLCBwMiwgaSwgaiwgaywgbGVuLCBsZW4yO1xuXG5cdFx0aWYgKCF0aGlzLl9weEJvdW5kcyB8fCAhdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHQvLyByYXkgY2FzdGluZyBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBpZiBwb2ludCBpcyBpbiBwb2x5Z29uXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcblxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG5cdFx0XHRcdHAxID0gcGFydFtqXTtcblx0XHRcdFx0cDIgPSBwYXJ0W2tdO1xuXG5cdFx0XHRcdGlmICgoKHAxLnkgPiBwLnkpICE9PSAocDIueSA+IHAueSkpICYmIChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XG5cdFx0XHRcdFx0aW5zaWRlID0gIWluc2lkZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGFsc28gY2hlY2sgaWYgaXQncyBvbiBwb2x5Z29uIHN0cm9rZVxuXHRcdHJldHVybiBpbnNpZGUgfHwgUG9seWxpbmUucHJvdG90eXBlLl9jb250YWluc1BvaW50LmNhbGwodGhpcywgcCwgdHJ1ZSk7XG5cdH1cblxufSk7XG5cblxuLy8gQGZhY3RvcnkgTC5wb2x5Z29uKGxhdGxuZ3M6IExhdExuZ1tdLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbmV4cG9ydCBmdW5jdGlvbiBwb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBQb2x5Z29uKGxhdGxuZ3MsIG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtMYXllckdyb3VwfSBmcm9tICcuL0xheWVyR3JvdXAnO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7TWFya2VyfSBmcm9tICcuL21hcmtlci9NYXJrZXInO1xyXG5pbXBvcnQge0NpcmNsZX0gZnJvbSAnLi92ZWN0b3IvQ2lyY2xlJztcclxuaW1wb3J0IHtDaXJjbGVNYXJrZXJ9IGZyb20gJy4vdmVjdG9yL0NpcmNsZU1hcmtlcic7XHJcbmltcG9ydCB7UG9seWxpbmV9IGZyb20gJy4vdmVjdG9yL1BvbHlsaW5lJztcclxuaW1wb3J0IHtQb2x5Z29ufSBmcm9tICcuL3ZlY3Rvci9Qb2x5Z29uJztcclxuaW1wb3J0IHtMYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5pbXBvcnQgKiBhcyBMaW5lVXRpbCBmcm9tICcuLi9nZW9tZXRyeS9MaW5lVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmd9IGZyb20gJy4uL2dlby9MYXRMbmcnO1xyXG5cclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBHZW9KU09OXHJcbiAqIEBha2EgTC5HZW9KU09OXHJcbiAqIEBpbmhlcml0cyBGZWF0dXJlR3JvdXBcclxuICpcclxuICogUmVwcmVzZW50cyBhIEdlb0pTT04gb2JqZWN0IG9yIGFuIGFycmF5IG9mIEdlb0pTT04gb2JqZWN0cy4gQWxsb3dzIHlvdSB0byBwYXJzZVxyXG4gKiBHZW9KU09OIGRhdGEgYW5kIGRpc3BsYXkgaXQgb24gdGhlIG1hcC4gRXh0ZW5kcyBgRmVhdHVyZUdyb3VwYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC5nZW9KU09OKGRhdGEsIHtcclxuICogXHRzdHlsZTogZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuICogXHRcdHJldHVybiB7Y29sb3I6IGZlYXR1cmUucHJvcGVydGllcy5jb2xvcn07XHJcbiAqIFx0fVxyXG4gKiB9KS5iaW5kUG9wdXAoZnVuY3Rpb24gKGxheWVyKSB7XHJcbiAqIFx0cmV0dXJuIGxheWVyLmZlYXR1cmUucHJvcGVydGllcy5kZXNjcmlwdGlvbjtcclxuICogfSkuYWRkVG8obWFwKTtcclxuICogYGBgXHJcbiAqL1xyXG5cclxuZXhwb3J0IHZhciBHZW9KU09OID0gRmVhdHVyZUdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdC8qIEBzZWN0aW9uXHJcblx0ICogQGFrYSBHZW9KU09OIG9wdGlvbnNcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gcG9pbnRUb0xheWVyOiBGdW5jdGlvbiA9ICpcclxuXHQgKiBBIGBGdW5jdGlvbmAgZGVmaW5pbmcgaG93IEdlb0pTT04gcG9pbnRzIHNwYXduIExlYWZsZXQgbGF5ZXJzLiBJdCBpcyBpbnRlcm5hbGx5XHJcblx0ICogY2FsbGVkIHdoZW4gZGF0YSBpcyBhZGRlZCwgcGFzc2luZyB0aGUgR2VvSlNPTiBwb2ludCBmZWF0dXJlIGFuZCBpdHMgYExhdExuZ2AuXHJcblx0ICogVGhlIGRlZmF1bHQgaXMgdG8gc3Bhd24gYSBkZWZhdWx0IGBNYXJrZXJgOlxyXG5cdCAqIGBgYGpzXHJcblx0ICogZnVuY3Rpb24oZ2VvSnNvblBvaW50LCBsYXRsbmcpIHtcclxuXHQgKiBcdHJldHVybiBMLm1hcmtlcihsYXRsbmcpO1xyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gc3R5bGU6IEZ1bmN0aW9uID0gKlxyXG5cdCAqIEEgYEZ1bmN0aW9uYCBkZWZpbmluZyB0aGUgYFBhdGggb3B0aW9uc2AgZm9yIHN0eWxpbmcgR2VvSlNPTiBsaW5lcyBhbmQgcG9seWdvbnMsXHJcblx0ICogY2FsbGVkIGludGVybmFsbHkgd2hlbiBkYXRhIGlzIGFkZGVkLlxyXG5cdCAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRvIG5vdCBvdmVycmlkZSBhbnkgZGVmYXVsdHM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZ2VvSnNvbkZlYXR1cmUpIHtcclxuXHQgKiBcdHJldHVybiB7fVxyXG5cdCAqIH1cclxuXHQgKiBgYGBcclxuXHQgKlxyXG5cdCAqIEBvcHRpb24gb25FYWNoRmVhdHVyZTogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBmb3IgZWFjaCBjcmVhdGVkIGBGZWF0dXJlYCwgYWZ0ZXIgaXQgaGFzXHJcblx0ICogYmVlbiBjcmVhdGVkIGFuZCBzdHlsZWQuIFVzZWZ1bCBmb3IgYXR0YWNoaW5nIGV2ZW50cyBhbmQgcG9wdXBzIHRvIGZlYXR1cmVzLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRvIGRvIG5vdGhpbmcgd2l0aCB0aGUgbmV3bHkgY3JlYXRlZCBsYXllcnM6XHJcblx0ICogYGBganNcclxuXHQgKiBmdW5jdGlvbiAoZmVhdHVyZSwgbGF5ZXIpIHt9XHJcblx0ICogYGBgXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIGZpbHRlcjogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRlY2lkZSB3aGV0aGVyIHRvIGluY2x1ZGUgYSBmZWF0dXJlIG9yIG5vdC5cclxuXHQgKiBUaGUgZGVmYXVsdCBpcyB0byBpbmNsdWRlIGFsbCBmZWF0dXJlczpcclxuXHQgKiBgYGBqc1xyXG5cdCAqIGZ1bmN0aW9uIChnZW9Kc29uRmVhdHVyZSkge1xyXG5cdCAqIFx0cmV0dXJuIHRydWU7XHJcblx0ICogfVxyXG5cdCAqIGBgYFxyXG5cdCAqIE5vdGU6IGR5bmFtaWNhbGx5IGNoYW5naW5nIHRoZSBgZmlsdGVyYCBvcHRpb24gd2lsbCBoYXZlIGVmZmVjdCBvbmx5IG9uIG5ld2x5XHJcblx0ICogYWRkZWQgZGF0YS4gSXQgd2lsbCBfbm90XyByZS1ldmFsdWF0ZSBhbHJlYWR5IGluY2x1ZGVkIGZlYXR1cmVzLlxyXG5cdCAqXHJcblx0ICogQG9wdGlvbiBjb29yZHNUb0xhdExuZzogRnVuY3Rpb24gPSAqXHJcblx0ICogQSBgRnVuY3Rpb25gIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBjb252ZXJ0aW5nIEdlb0pTT04gY29vcmRpbmF0ZXMgdG8gYExhdExuZ2BzLlxyXG5cdCAqIFRoZSBkZWZhdWx0IGlzIHRoZSBgY29vcmRzVG9MYXRMbmdgIHN0YXRpYyBtZXRob2QuXHJcblx0ICpcclxuXHQgKiBAb3B0aW9uIG1hcmtlcnNJbmhlcml0T3B0aW9uczogQm9vbGVhbiA9IGZhbHNlXHJcblx0ICogV2hldGhlciBkZWZhdWx0IE1hcmtlcnMgZm9yIFwiUG9pbnRcIiB0eXBlIEZlYXR1cmVzIGluaGVyaXQgZnJvbSBncm91cCBvcHRpb25zLlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdGlmIChnZW9qc29uKSB7XHJcblx0XHRcdHRoaXMuYWRkRGF0YShnZW9qc29uKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGFkZERhdGEoIDxHZW9KU09OPiBkYXRhICk6IHRoaXNcclxuXHQvLyBBZGRzIGEgR2VvSlNPTiBvYmplY3QgdG8gdGhlIGxheWVyLlxyXG5cdGFkZERhdGE6IGZ1bmN0aW9uIChnZW9qc29uKSB7XHJcblx0XHR2YXIgZmVhdHVyZXMgPSBVdGlsLmlzQXJyYXkoZ2VvanNvbikgPyBnZW9qc29uIDogZ2VvanNvbi5mZWF0dXJlcyxcclxuXHRcdCAgICBpLCBsZW4sIGZlYXR1cmU7XHJcblxyXG5cdFx0aWYgKGZlYXR1cmVzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0Ly8gb25seSBhZGQgdGhpcyBpZiBnZW9tZXRyeSBvciBnZW9tZXRyaWVzIGFyZSBzZXQgYW5kIG5vdCBudWxsXHJcblx0XHRcdFx0ZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xyXG5cdFx0XHRcdGlmIChmZWF0dXJlLmdlb21ldHJpZXMgfHwgZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmZlYXR1cmVzIHx8IGZlYXR1cmUuY29vcmRpbmF0ZXMpIHtcclxuXHRcdFx0XHRcdHRoaXMuYWRkRGF0YShmZWF0dXJlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuZmlsdGVyICYmICFvcHRpb25zLmZpbHRlcihnZW9qc29uKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBsYXllciA9IGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKTtcclxuXHRcdGlmICghbGF5ZXIpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRsYXllci5mZWF0dXJlID0gYXNGZWF0dXJlKGdlb2pzb24pO1xyXG5cclxuXHRcdGxheWVyLmRlZmF1bHRPcHRpb25zID0gbGF5ZXIub3B0aW9ucztcclxuXHRcdHRoaXMucmVzZXRTdHlsZShsYXllcik7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMub25FYWNoRmVhdHVyZSkge1xyXG5cdFx0XHRvcHRpb25zLm9uRWFjaEZlYXR1cmUoZ2VvanNvbiwgbGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmFkZExheWVyKGxheWVyKTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHJlc2V0U3R5bGUoIDxQYXRoPiBsYXllcj8gKTogdGhpc1xyXG5cdC8vIFJlc2V0cyB0aGUgZ2l2ZW4gdmVjdG9yIGxheWVyJ3Mgc3R5bGUgdG8gdGhlIG9yaWdpbmFsIEdlb0pTT04gc3R5bGUsIHVzZWZ1bCBmb3IgcmVzZXR0aW5nIHN0eWxlIGFmdGVyIGhvdmVyIGV2ZW50cy5cclxuXHQvLyBJZiBgbGF5ZXJgIGlzIG9taXR0ZWQsIHRoZSBzdHlsZSBvZiBhbGwgZmVhdHVyZXMgaW4gdGhlIGN1cnJlbnQgbGF5ZXIgaXMgcmVzZXQuXHJcblx0cmVzZXRTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZXNldFN0eWxlLCB0aGlzKTtcclxuXHRcdH1cclxuXHRcdC8vIHJlc2V0IGFueSBjdXN0b20gc3R5bGVzXHJcblx0XHRsYXllci5vcHRpb25zID0gVXRpbC5leHRlbmQoe30sIGxheWVyLmRlZmF1bHRPcHRpb25zKTtcclxuXHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHRoaXMub3B0aW9ucy5zdHlsZSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldFN0eWxlKCA8RnVuY3Rpb24+IHN0eWxlICk6IHRoaXNcclxuXHQvLyBDaGFuZ2VzIHN0eWxlcyBvZiBHZW9KU09OIHZlY3RvciBsYXllcnMgd2l0aCB0aGUgZ2l2ZW4gc3R5bGUgZnVuY3Rpb24uXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCBzdHlsZSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfc2V0TGF5ZXJTdHlsZTogZnVuY3Rpb24gKGxheWVyLCBzdHlsZSkge1xyXG5cdFx0aWYgKGxheWVyLnNldFN0eWxlKSB7XHJcblx0XHRcdGlmICh0eXBlb2Ygc3R5bGUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRzdHlsZSA9IHN0eWxlKGxheWVyLmZlYXR1cmUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxheWVyLnNldFN0eWxlKHN0eWxlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQHNlY3Rpb25cclxuLy8gVGhlcmUgYXJlIHNldmVyYWwgc3RhdGljIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHdpdGhvdXQgaW5zdGFudGlhdGluZyBMLkdlb0pTT046XHJcblxyXG4vLyBAZnVuY3Rpb24gZ2VvbWV0cnlUb0xheWVyKGZlYXR1cmVEYXRhOiBPYmplY3QsIG9wdGlvbnM/OiBHZW9KU09OIG9wdGlvbnMpOiBMYXllclxyXG4vLyBDcmVhdGVzIGEgYExheWVyYCBmcm9tIGEgZ2l2ZW4gR2VvSlNPTiBmZWF0dXJlLiBDYW4gdXNlIGEgY3VzdG9tXHJcbi8vIFtgcG9pbnRUb0xheWVyYF0oI2dlb2pzb24tcG9pbnR0b2xheWVyKSBhbmQvb3IgW2Bjb29yZHNUb0xhdExuZ2BdKCNnZW9qc29uLWNvb3Jkc3RvbGF0bG5nKVxyXG4vLyBmdW5jdGlvbnMgaWYgcHJvdmlkZWQgYXMgb3B0aW9ucy5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnID8gZ2VvanNvbi5nZW9tZXRyeSA6IGdlb2pzb24sXHJcblx0ICAgIGNvb3JkcyA9IGdlb21ldHJ5ID8gZ2VvbWV0cnkuY29vcmRpbmF0ZXMgOiBudWxsLFxyXG5cdCAgICBsYXllcnMgPSBbXSxcclxuXHQgICAgcG9pbnRUb0xheWVyID0gb3B0aW9ucyAmJiBvcHRpb25zLnBvaW50VG9MYXllcixcclxuXHQgICAgX2Nvb3Jkc1RvTGF0TG5nID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nLFxyXG5cdCAgICBsYXRsbmcsIGxhdGxuZ3MsIGksIGxlbjtcclxuXHJcblx0aWYgKCFjb29yZHMgJiYgIWdlb21ldHJ5KSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdHN3aXRjaCAoZ2VvbWV0cnkudHlwZSkge1xyXG5cdGNhc2UgJ1BvaW50JzpcclxuXHRcdGxhdGxuZyA9IF9jb29yZHNUb0xhdExuZyhjb29yZHMpO1xyXG5cdFx0cmV0dXJuIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyLCBnZW9qc29uLCBsYXRsbmcsIG9wdGlvbnMpO1xyXG5cclxuXHRjYXNlICdNdWx0aVBvaW50JzpcclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRsYXRsbmcgPSBfY29vcmRzVG9MYXRMbmcoY29vcmRzW2ldKTtcclxuXHRcdFx0bGF5ZXJzLnB1c2goX3BvaW50VG9MYXllcihwb2ludFRvTGF5ZXIsIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0Y2FzZSAnTGluZVN0cmluZyc6XHJcblx0Y2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcclxuXHRcdGxhdGxuZ3MgPSBjb29yZHNUb0xhdExuZ3MoY29vcmRzLCBnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgPyAwIDogMSwgX2Nvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdHJldHVybiBuZXcgUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ1BvbHlnb24nOlxyXG5cdGNhc2UgJ011bHRpUG9seWdvbic6XHJcblx0XHRsYXRsbmdzID0gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nID8gMSA6IDIsIF9jb29yZHNUb0xhdExuZyk7XHJcblx0XHRyZXR1cm4gbmV3IFBvbHlnb24obGF0bG5ncywgb3B0aW9ucyk7XHJcblxyXG5cdGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHZhciBnZW9MYXllciA9IGdlb21ldHJ5VG9MYXllcih7XHJcblx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5Lmdlb21ldHJpZXNbaV0sXHJcblx0XHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0XHRcdHByb3BlcnRpZXM6IGdlb2pzb24ucHJvcGVydGllc1xyXG5cdFx0XHR9LCBvcHRpb25zKTtcclxuXHJcblx0XHRcdGlmIChnZW9MYXllcikge1xyXG5cdFx0XHRcdGxheWVycy5wdXNoKGdlb0xheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0Y2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gZ2VvbWV0cnkuZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dmFyIGZlYXR1cmVMYXllciA9IGdlb21ldHJ5VG9MYXllcihnZW9tZXRyeS5mZWF0dXJlc1tpXSwgb3B0aW9ucyk7XHJcblxyXG5cdFx0XHRpZiAoZmVhdHVyZUxheWVyKSB7XHJcblx0XHRcdFx0bGF5ZXJzLnB1c2goZmVhdHVyZUxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBGZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0ZGVmYXVsdDpcclxuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9wb2ludFRvTGF5ZXIocG9pbnRUb0xheWVyRm4sIGdlb2pzb24sIGxhdGxuZywgb3B0aW9ucykge1xyXG5cdHJldHVybiBwb2ludFRvTGF5ZXJGbiA/XHJcblx0XHRwb2ludFRvTGF5ZXJGbihnZW9qc29uLCBsYXRsbmcpIDpcclxuXHRcdG5ldyBNYXJrZXIobGF0bG5nLCBvcHRpb25zICYmIG9wdGlvbnMubWFya2Vyc0luaGVyaXRPcHRpb25zICYmIG9wdGlvbnMpO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmcoY29vcmRzOiBBcnJheSk6IExhdExuZ1xyXG4vLyBDcmVhdGVzIGEgYExhdExuZ2Agb2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgMiBudW1iZXJzIChsb25naXR1ZGUsIGxhdGl0dWRlKVxyXG4vLyBvciAzIG51bWJlcnMgKGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGFsdGl0dWRlKSB1c2VkIGluIEdlb0pTT04gZm9yIHBvaW50cy5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvb3Jkc1RvTGF0TG5nKGNvb3Jkcykge1xyXG5cdHJldHVybiBuZXcgTGF0TG5nKGNvb3Jkc1sxXSwgY29vcmRzWzBdLCBjb29yZHNbMl0pO1xyXG59XHJcblxyXG4vLyBAZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNvb3Jkc1RvTGF0TG5nPzogRnVuY3Rpb24pOiBBcnJheVxyXG4vLyBDcmVhdGVzIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSBvZiBgTGF0TG5nYHMgZnJvbSBhIEdlb0pTT04gY29vcmRpbmF0ZXMgYXJyYXkuXHJcbi8vIGBsZXZlbHNEZWVwYCBzcGVjaWZpZXMgdGhlIG5lc3RpbmcgbGV2ZWwgKDAgaXMgZm9yIGFuIGFycmF5IG9mIHBvaW50cywgMSBmb3IgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIHBvaW50cywgZXRjLiwgMCBieSBkZWZhdWx0KS5cclxuLy8gQ2FuIHVzZSBhIGN1c3RvbSBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpIGZ1bmN0aW9uLlxyXG5leHBvcnQgZnVuY3Rpb24gY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgbGV2ZWxzRGVlcCwgX2Nvb3Jkc1RvTGF0TG5nKSB7XHJcblx0dmFyIGxhdGxuZ3MgPSBbXTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGgsIGxhdGxuZzsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRsYXRsbmcgPSBsZXZlbHNEZWVwID9cclxuXHRcdFx0Y29vcmRzVG9MYXRMbmdzKGNvb3Jkc1tpXSwgbGV2ZWxzRGVlcCAtIDEsIF9jb29yZHNUb0xhdExuZykgOlxyXG5cdFx0XHQoX2Nvb3Jkc1RvTGF0TG5nIHx8IGNvb3Jkc1RvTGF0TG5nKShjb29yZHNbaV0pO1xyXG5cclxuXHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGxhdGxuZ3M7XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBsYXRMbmdUb0Nvb3JkcyhsYXRsbmc6IExhdExuZywgcHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogQXJyYXlcclxuLy8gUmV2ZXJzZSBvZiBbYGNvb3Jkc1RvTGF0TG5nYF0oI2dlb2pzb24tY29vcmRzdG9sYXRsbmcpXHJcbi8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbi5cclxuZXhwb3J0IGZ1bmN0aW9uIGxhdExuZ1RvQ29vcmRzKGxhdGxuZywgcHJlY2lzaW9uKSB7XHJcblx0bGF0bG5nID0gdG9MYXRMbmcobGF0bG5nKTtcclxuXHRyZXR1cm4gbGF0bG5nLmFsdCAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFtVdGlsLmZvcm1hdE51bShsYXRsbmcubG5nLCBwcmVjaXNpb24pLCBVdGlsLmZvcm1hdE51bShsYXRsbmcubGF0LCBwcmVjaXNpb24pLCBVdGlsLmZvcm1hdE51bShsYXRsbmcuYWx0LCBwcmVjaXNpb24pXSA6XHJcblx0XHRbVXRpbC5mb3JtYXROdW0obGF0bG5nLmxuZywgcHJlY2lzaW9uKSwgVXRpbC5mb3JtYXROdW0obGF0bG5nLmxhdCwgcHJlY2lzaW9uKV07XHJcbn1cclxuXHJcbi8vIEBmdW5jdGlvbiBsYXRMbmdzVG9Db29yZHMobGF0bG5nczogQXJyYXksIGxldmVsc0RlZXA/OiBOdW1iZXIsIGNsb3NlZD86IEJvb2xlYW4sIHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IEFycmF5XHJcbi8vIFJldmVyc2Ugb2YgW2Bjb29yZHNUb0xhdExuZ3NgXSgjZ2VvanNvbi1jb29yZHN0b2xhdGxuZ3MpXHJcbi8vIGBjbG9zZWRgIGRldGVybWluZXMgd2hldGhlciB0aGUgZmlyc3QgcG9pbnQgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5IHRvIGNsb3NlIHRoZSBmZWF0dXJlLCBvbmx5IHVzZWQgd2hlbiBgbGV2ZWxzRGVlcGAgaXMgMC4gRmFsc2UgYnkgZGVmYXVsdC5cclxuLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uLlxyXG5leHBvcnQgZnVuY3Rpb24gbGF0TG5nc1RvQ29vcmRzKGxhdGxuZ3MsIGxldmVsc0RlZXAsIGNsb3NlZCwgcHJlY2lzaW9uKSB7XHJcblx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0Ly8gQ2hlY2sgZm9yIGZsYXQgYXJyYXlzIHJlcXVpcmVkIHRvIGVuc3VyZSB1bmJhbGFuY2VkIGFycmF5cyBhcmUgY29ycmVjdGx5IGNvbnZlcnRlZCBpbiByZWN1cnNpb25cclxuXHRcdGNvb3Jkcy5wdXNoKGxldmVsc0RlZXAgP1xyXG5cdFx0XHRsYXRMbmdzVG9Db29yZHMobGF0bG5nc1tpXSwgTGluZVV0aWwuaXNGbGF0KGxhdGxuZ3NbaV0pID8gMCA6IGxldmVsc0RlZXAgLSAxLCBjbG9zZWQsIHByZWNpc2lvbikgOlxyXG5cdFx0XHRsYXRMbmdUb0Nvb3JkcyhsYXRsbmdzW2ldLCBwcmVjaXNpb24pKTtcclxuXHR9XHJcblxyXG5cdGlmICghbGV2ZWxzRGVlcCAmJiBjbG9zZWQgJiYgY29vcmRzLmxlbmd0aCA+IDApIHtcclxuXHRcdGNvb3Jkcy5wdXNoKGNvb3Jkc1swXS5zbGljZSgpKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBjb29yZHM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRGZWF0dXJlKGxheWVyLCBuZXdHZW9tZXRyeSkge1xyXG5cdHJldHVybiBsYXllci5mZWF0dXJlID9cclxuXHRcdFV0aWwuZXh0ZW5kKHt9LCBsYXllci5mZWF0dXJlLCB7Z2VvbWV0cnk6IG5ld0dlb21ldHJ5fSkgOlxyXG5cdFx0YXNGZWF0dXJlKG5ld0dlb21ldHJ5KTtcclxufVxyXG5cclxuLy8gQGZ1bmN0aW9uIGFzRmVhdHVyZShnZW9qc29uOiBPYmplY3QpOiBPYmplY3RcclxuLy8gTm9ybWFsaXplIEdlb0pTT04gZ2VvbWV0cmllcy9mZWF0dXJlcyBpbnRvIEdlb0pTT04gZmVhdHVyZXMuXHJcbmV4cG9ydCBmdW5jdGlvbiBhc0ZlYXR1cmUoZ2VvanNvbikge1xyXG5cdGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyB8fCBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcclxuXHRcdHJldHVybiBnZW9qc29uO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdHByb3BlcnRpZXM6IHt9LFxyXG5cdFx0Z2VvbWV0cnk6IGdlb2pzb25cclxuXHR9O1xyXG59XHJcblxyXG52YXIgUG9pbnRUb0dlb0pTT04gPSB7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdQb2ludCcsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBsYXRMbmdUb0Nvb3Jkcyh0aGlzLmdldExhdExuZygpLCBwcmVjaXNpb24pXHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBAbmFtZXNwYWNlIE1hcmtlclxyXG4vLyBAc2VjdGlvbiBPdGhlciBtZXRob2RzXHJcbi8vIEBtZXRob2QgdG9HZW9KU09OKHByZWNpc2lvbj86IE51bWJlcnxmYWxzZSk6IE9iamVjdFxyXG4vLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuLy8gUmV0dXJucyBhIFtgR2VvSlNPTmBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dlb0pTT04pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXJrZXIgKGFzIGEgR2VvSlNPTiBgUG9pbnRgIEZlYXR1cmUpLlxyXG5NYXJrZXIuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcblxyXG4vLyBAbmFtZXNwYWNlIENpcmNsZU1hcmtlclxyXG4vLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuLy8gQ29vcmRpbmF0ZXMgdmFsdWVzIGFyZSByb3VuZGVkIHdpdGggW2Bmb3JtYXROdW1gXSgjdXRpbC1mb3JtYXRudW0pIGZ1bmN0aW9uIHdpdGggZ2l2ZW4gYHByZWNpc2lvbmAuXHJcbi8vIFJldHVybnMgYSBbYEdlb0pTT05gXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HZW9KU09OKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY2lyY2xlIG1hcmtlciAoYXMgYSBHZW9KU09OIGBQb2ludGAgRmVhdHVyZSkuXHJcbkNpcmNsZS5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuQ2lyY2xlTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgUG9seWxpbmVcclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbi8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlsaW5lIChhcyBhIEdlb0pTT04gYExpbmVTdHJpbmdgIG9yIGBNdWx0aUxpbmVTdHJpbmdgIEZlYXR1cmUpLlxyXG5Qb2x5bGluZS5pbmNsdWRlKHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uIChwcmVjaXNpb24pIHtcclxuXHRcdHZhciBtdWx0aSA9ICFMaW5lVXRpbC5pc0ZsYXQodGhpcy5fbGF0bG5ncyk7XHJcblxyXG5cdFx0dmFyIGNvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcyh0aGlzLl9sYXRsbmdzLCBtdWx0aSA/IDEgOiAwLCBmYWxzZSwgcHJlY2lzaW9uKTtcclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnTGluZVN0cmluZycsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG4vLyBAbmFtZXNwYWNlIFBvbHlnb25cclxuLy8gQG1ldGhvZCB0b0dlb0pTT04ocHJlY2lzaW9uPzogTnVtYmVyfGZhbHNlKTogT2JqZWN0XHJcbi8vIENvb3JkaW5hdGVzIHZhbHVlcyBhcmUgcm91bmRlZCB3aXRoIFtgZm9ybWF0TnVtYF0oI3V0aWwtZm9ybWF0bnVtKSBmdW5jdGlvbiB3aXRoIGdpdmVuIGBwcmVjaXNpb25gLlxyXG4vLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBvbHlnb24gKGFzIGEgR2VvSlNPTiBgUG9seWdvbmAgb3IgYE11bHRpUG9seWdvbmAgRmVhdHVyZSkuXHJcblBvbHlnb24uaW5jbHVkZSh7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgaG9sZXMgPSAhTGluZVV0aWwuaXNGbGF0KHRoaXMuX2xhdGxuZ3MpLFxyXG5cdFx0ICAgIG11bHRpID0gaG9sZXMgJiYgIUxpbmVVdGlsLmlzRmxhdCh0aGlzLl9sYXRsbmdzWzBdKTtcclxuXHJcblx0XHR2YXIgY29vcmRzID0gbGF0TG5nc1RvQ29vcmRzKHRoaXMuX2xhdGxuZ3MsIG11bHRpID8gMiA6IGhvbGVzID8gMSA6IDAsIHRydWUsIHByZWNpc2lvbik7XHJcblxyXG5cdFx0aWYgKCFob2xlcykge1xyXG5cdFx0XHRjb29yZHMgPSBbY29vcmRzXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6IChtdWx0aSA/ICdNdWx0aScgOiAnJykgKyAnUG9seWdvbicsXHJcblx0XHRcdGNvb3JkaW5hdGVzOiBjb29yZHNcclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBMYXllckdyb3VwXHJcbkxheWVyR3JvdXAuaW5jbHVkZSh7XHJcblx0dG9NdWx0aVBvaW50OiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblx0XHR2YXIgY29vcmRzID0gW107XHJcblxyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdGNvb3Jkcy5wdXNoKGxheWVyLnRvR2VvSlNPTihwcmVjaXNpb24pLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBnZXRGZWF0dXJlKHRoaXMsIHtcclxuXHRcdFx0dHlwZTogJ011bHRpUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHRvR2VvSlNPTihwcmVjaXNpb24/OiBOdW1iZXJ8ZmFsc2UpOiBPYmplY3RcclxuXHQvLyBDb29yZGluYXRlcyB2YWx1ZXMgYXJlIHJvdW5kZWQgd2l0aCBbYGZvcm1hdE51bWBdKCN1dGlsLWZvcm1hdG51bSkgZnVuY3Rpb24gd2l0aCBnaXZlbiBgcHJlY2lzaW9uYC5cclxuXHQvLyBSZXR1cm5zIGEgW2BHZW9KU09OYF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2VvSlNPTikgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxheWVyIGdyb3VwIChhcyBhIEdlb0pTT04gYEZlYXR1cmVDb2xsZWN0aW9uYCwgYEdlb21ldHJ5Q29sbGVjdGlvbmAsIG9yIGBNdWx0aVBvaW50YCkuXHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XHJcblxyXG5cdFx0dmFyIHR5cGUgPSB0aGlzLmZlYXR1cmUgJiYgdGhpcy5mZWF0dXJlLmdlb21ldHJ5ICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeS50eXBlO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudG9NdWx0aVBvaW50KHByZWNpc2lvbik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gdHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicsXHJcblx0XHQgICAganNvbnMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0aWYgKGxheWVyLnRvR2VvSlNPTikge1xyXG5cdFx0XHRcdHZhciBqc29uID0gbGF5ZXIudG9HZW9KU09OKHByZWNpc2lvbik7XHJcblx0XHRcdFx0aWYgKGlzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XHJcblx0XHRcdFx0XHRqc29ucy5wdXNoKGpzb24uZ2VvbWV0cnkpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgZmVhdHVyZSA9IGFzRmVhdHVyZShqc29uKTtcclxuXHRcdFx0XHRcdC8vIFNxdWFzaCBuZXN0ZWQgZmVhdHVyZSBjb2xsZWN0aW9uc1xyXG5cdFx0XHRcdFx0aWYgKGZlYXR1cmUudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xyXG5cdFx0XHRcdFx0XHRqc29ucy5wdXNoLmFwcGx5KGpzb25zLCBmZWF0dXJlLmZlYXR1cmVzKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGpzb25zLnB1c2goZmVhdHVyZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuXHRcdFx0cmV0dXJuIGdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHRcdGdlb21ldHJpZXM6IGpzb25zLFxyXG5cdFx0XHRcdHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcblx0XHRcdGZlYXR1cmVzOiBqc29uc1xyXG5cdFx0fTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBHZW9KU09OXHJcbi8vIEBmYWN0b3J5IEwuZ2VvSlNPTihnZW9qc29uPzogT2JqZWN0LCBvcHRpb25zPzogR2VvSlNPTiBvcHRpb25zKVxyXG4vLyBDcmVhdGVzIGEgR2VvSlNPTiBsYXllci4gT3B0aW9uYWxseSBhY2NlcHRzIGFuIG9iamVjdCBpblxyXG4vLyBbR2VvSlNPTiBmb3JtYXRdKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3OTQ2KSB0byBkaXNwbGF5IG9uIHRoZSBtYXBcclxuLy8gKHlvdSBjYW4gYWx0ZXJuYXRpdmVseSBhZGQgaXQgbGF0ZXIgd2l0aCBgYWRkRGF0YWAgbWV0aG9kKSBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdC5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlb0pTT04oZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgR2VvSlNPTihnZW9qc29uLCBvcHRpb25zKTtcclxufVxyXG5cclxuLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eS5cclxuZXhwb3J0IHZhciBnZW9Kc29uID0gZ2VvSlNPTjtcclxuIiwiaW1wb3J0IHtMYXllcn0gZnJvbSAnLi9MYXllcic7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuaW1wb3J0IHt0b0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XHJcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi9nZW9tZXRyeS9Cb3VuZHMnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBJbWFnZU92ZXJsYXlcclxuICogQGFrYSBMLkltYWdlT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW50ZXJhY3RpdmUgbGF5ZXJcclxuICpcclxuICogVXNlZCB0byBsb2FkIGFuZCBkaXNwbGF5IGEgc2luZ2xlIGltYWdlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogdmFyIGltYWdlVXJsID0gJ2h0dHBzOi8vbWFwcy5saWIudXRleGFzLmVkdS9tYXBzL2hpc3RvcmljYWwvbmV3YXJrX25qXzE5MjIuanBnJyxcclxuICogXHRpbWFnZUJvdW5kcyA9IFtbNDAuNzEyMjE2LCAtNzQuMjI2NTVdLCBbNDAuNzczOTQxLCAtNzQuMTI1NDRdXTtcclxuICogTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmwsIGltYWdlQm91bmRzKS5hZGRUbyhtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIEltYWdlT3ZlcmxheSA9IExheWVyLmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBJbWFnZU92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMS4wXHJcblx0XHQvLyBUaGUgb3BhY2l0eSBvZiB0aGUgaW1hZ2Ugb3ZlcmxheS5cclxuXHRcdG9wYWNpdHk6IDEsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhbHQ6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBUZXh0IGZvciB0aGUgYGFsdGAgYXR0cmlidXRlIG9mIHRoZSBpbWFnZSAodXNlZnVsIGZvciBhY2Nlc3NpYmlsaXR5KS5cclxuXHRcdGFsdDogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBpbnRlcmFjdGl2ZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIHRoZSBpbWFnZSBvdmVybGF5IHdpbGwgZW1pdCBbbW91c2UgZXZlbnRzXSgjaW50ZXJhY3RpdmUtbGF5ZXIpIHdoZW4gY2xpY2tlZCBvciBob3ZlcmVkLlxyXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY3Jvc3NPcmlnaW46IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBpbWFnZS5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCB0aGUgaW1hZ2Ugd2lsbCBoYXZlIGl0cyBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyBpbWFnZSBwaXhlbCBkYXRhLlxyXG5cdFx0Ly8gUmVmZXIgdG8gW0NPUlMgU2V0dGluZ3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzKSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuXHRcdGNyb3NzT3JpZ2luOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGVycm9yT3ZlcmxheVVybDogU3RyaW5nID0gJydcclxuXHRcdC8vIFVSTCB0byB0aGUgb3ZlcmxheSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSBvdmVybGF5IHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcblx0XHRlcnJvck92ZXJsYXlVcmw6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gekluZGV4OiBOdW1iZXIgPSAxXHJcblx0XHQvLyBUaGUgZXhwbGljaXQgW3pJbmRleF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQ1NTL0NTU19Qb3NpdGlvbmluZy9VbmRlcnN0YW5kaW5nX3pfaW5kZXgpIG9mIHRoZSBvdmVybGF5IGxheWVyLlxyXG5cdFx0ekluZGV4OiAxLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIGltYWdlLiBFbXB0eSBieSBkZWZhdWx0LlxyXG5cdFx0Y2xhc3NOYW1lOiAnJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykgeyAvLyAoU3RyaW5nLCBMYXRMbmdCb3VuZHMsIE9iamVjdClcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHRcdHRoaXMuX2JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJbWFnZSgpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcclxuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9pbWFnZSwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpO1xyXG5cdFx0dGhpcy5fcmVzZXQoKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5faW1hZ2UpO1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIG92ZXJsYXkuXHJcblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcclxuXHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuXHJcblx0XHRpZiAodGhpcy5faW1hZ2UpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZU9wdHMpIHtcclxuXHRcdGlmIChzdHlsZU9wdHMub3BhY2l0eSkge1xyXG5cdFx0XHR0aGlzLnNldE9wYWNpdHkoc3R5bGVPcHRzLm9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBicmluZ1RvRnJvbnQoKTogdGhpc1xyXG5cdC8vIEJyaW5ncyB0aGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgb3ZlcmxheXMuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9Gcm9udCh0aGlzLl9pbWFnZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGJyaW5nVG9CYWNrKCk6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIG92ZXJsYXlzLlxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdERvbVV0aWwudG9CYWNrKHRoaXMuX2ltYWdlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0VXJsKHVybDogU3RyaW5nKTogdGhpc1xyXG5cdC8vIENoYW5nZXMgdGhlIFVSTCBvZiB0aGUgaW1hZ2UuXHJcblx0c2V0VXJsOiBmdW5jdGlvbiAodXJsKSB7XHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IHVybDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGJvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xyXG5cdC8vIFVwZGF0ZSB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR0aGlzLl9ib3VuZHMgPSB0b0xhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fcmVzZXQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0em9vbTogdGhpcy5fcmVzZXQsXHJcblx0XHRcdHZpZXdyZXNldDogdGhpcy5fcmVzZXRcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xyXG5cdFx0XHRldmVudHMuem9vbWFuaW0gPSB0aGlzLl9hbmltYXRlWm9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHZhbHVlOiBOdW1iZXIpOiB0aGlzXHJcblx0Ly8gQ2hhbmdlcyB0aGUgW3pJbmRleF0oI2ltYWdlb3ZlcmxheS16aW5kZXgpIG9mIHRoZSBpbWFnZSBvdmVybGF5LlxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0XHR0aGlzLm9wdGlvbnMuekluZGV4ID0gdmFsdWU7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kc1xyXG5cdC8vIEdldCB0aGUgYm91bmRzIHRoYXQgdGhpcyBJbWFnZU92ZXJsYXkgY292ZXJzXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBIVE1MRWxlbWVudFxyXG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgSFRNTEltYWdlRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IVE1MSW1hZ2VFbGVtZW50KVxyXG5cdC8vIHVzZWQgYnkgdGhpcyBvdmVybGF5LlxyXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9pbWFnZTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdJTUcnO1xyXG5cdFx0dmFyIGltZyA9IHRoaXMuX2ltYWdlID0gd2FzRWxlbWVudFN1cHBsaWVkID8gdGhpcy5fdXJsIDogRG9tVXRpbC5jcmVhdGUoJ2ltZycpO1xyXG5cclxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoaW1nLCAnbGVhZmxldC1pbWFnZS1sYXllcicpO1xyXG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBEb21VdGlsLmFkZENsYXNzKGltZywgJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpOyB9XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBEb21VdGlsLmFkZENsYXNzKGltZywgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7IH1cclxuXHJcblx0XHRpbWcub25zZWxlY3RzdGFydCA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdGltZy5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcclxuXHJcblx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gdGhlIEltYWdlT3ZlcmxheSBsYXllciBoYXMgbG9hZGVkIGl0cyBpbWFnZVxyXG5cdFx0aW1nLm9ubG9hZCA9IFV0aWwuYmluZCh0aGlzLmZpcmUsIHRoaXMsICdsb2FkJyk7XHJcblx0XHRpbWcub25lcnJvciA9IFV0aWwuYmluZCh0aGlzLl9vdmVybGF5T25FcnJvciwgdGhpcywgJ2Vycm9yJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcblx0XHRcdGltZy5jcm9zc09yaWdpbiA9IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuekluZGV4KSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuXHRcdFx0dGhpcy5fdXJsID0gaW1nLnNyYztcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGltZy5zcmMgPSB0aGlzLl91cmw7XHJcblx0XHRpbWcuYWx0ID0gdGhpcy5vcHRpb25zLmFsdDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKGUuem9vbSksXHJcblx0XHQgICAgb2Zmc2V0ID0gdGhpcy5fbWFwLl9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzKHRoaXMuX2JvdW5kcywgZS56b29tLCBlLmNlbnRlcikubWluO1xyXG5cclxuXHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2ltYWdlLCBvZmZzZXQsIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHRfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlLFxyXG5cdFx0ICAgIGJvdW5kcyA9IG5ldyBCb3VuZHMoXHJcblx0XHQgICAgICAgIHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fYm91bmRzLmdldE5vcnRoV2VzdCgpKSxcclxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCkpKSxcclxuXHRcdCAgICBzaXplID0gYm91bmRzLmdldFNpemUoKTtcclxuXHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGltYWdlLCBib3VuZHMubWluKTtcclxuXHJcblx0XHRpbWFnZS5zdHlsZS53aWR0aCAgPSBzaXplLnggKyAncHgnO1xyXG5cdFx0aW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2ltYWdlLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2ltYWdlICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X292ZXJsYXlPbkVycm9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBAZXZlbnQgZXJyb3I6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBJbWFnZU92ZXJsYXkgbGF5ZXIgZmFpbHMgdG8gbG9hZCBpdHMgaW1hZ2VcclxuXHRcdHRoaXMuZmlyZSgnZXJyb3InKTtcclxuXHJcblx0XHR2YXIgZXJyb3JVcmwgPSB0aGlzLm9wdGlvbnMuZXJyb3JPdmVybGF5VXJsO1xyXG5cdFx0aWYgKGVycm9yVXJsICYmIHRoaXMuX3VybCAhPT0gZXJyb3JVcmwpIHtcclxuXHRcdFx0dGhpcy5fdXJsID0gZXJyb3JVcmw7XHJcblx0XHRcdHRoaXMuX2ltYWdlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0Q2VudGVyKCk6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgSW1hZ2VPdmVybGF5LlxyXG5cdGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kcy5nZXRDZW50ZXIoKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQGZhY3RvcnkgTC5pbWFnZU92ZXJsYXkoaW1hZ2VVcmw6IFN0cmluZywgYm91bmRzOiBMYXRMbmdCb3VuZHMsIG9wdGlvbnM/OiBJbWFnZU92ZXJsYXkgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGFuIGltYWdlIG92ZXJsYXkgb2JqZWN0IGdpdmVuIHRoZSBVUkwgb2YgdGhlIGltYWdlIGFuZCB0aGVcclxuLy8gZ2VvZ3JhcGhpY2FsIGJvdW5kcyBpdCBpcyB0aWVkIHRvLlxyXG5leHBvcnQgdmFyIGltYWdlT3ZlcmxheSA9IGZ1bmN0aW9uICh1cmwsIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgSW1hZ2VPdmVybGF5KHVybCwgYm91bmRzLCBvcHRpb25zKTtcclxufTtcclxuIiwiaW1wb3J0IHtJbWFnZU92ZXJsYXl9IGZyb20gJy4vSW1hZ2VPdmVybGF5JztcclxuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi9kb20vRG9tVXRpbCc7XHJcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBWaWRlb092ZXJsYXlcclxuICogQGFrYSBMLlZpZGVvT3ZlcmxheVxyXG4gKiBAaW5oZXJpdHMgSW1hZ2VPdmVybGF5XHJcbiAqXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSBhIHZpZGVvIHBsYXllciBvdmVyIHNwZWNpZmljIGJvdW5kcyBvZiB0aGUgbWFwLiBFeHRlbmRzIGBJbWFnZU92ZXJsYXlgLlxyXG4gKlxyXG4gKiBBIHZpZGVvIG92ZXJsYXkgdXNlcyB0aGUgW2A8dmlkZW8+YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRNTC9FbGVtZW50L3ZpZGVvKVxyXG4gKiBIVE1MNSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgdmlkZW9VcmwgPSAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS9iaXRlcy8wMDE4OC9wYXRyaWNpYV9uYXNhLndlYm0nLFxyXG4gKiBcdHZpZGVvQm91bmRzID0gW1sgMzIsIC0xMzBdLCBbIDEzLCAtMTAwXV07XHJcbiAqIEwudmlkZW9PdmVybGF5KHZpZGVvVXJsLCB2aWRlb0JvdW5kcyApLmFkZFRvKG1hcCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgVmlkZW9PdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XHJcblxyXG5cdC8vIEBzZWN0aW9uXHJcblx0Ly8gQGFrYSBWaWRlb092ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gYXV0b3BsYXk6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSB2aWRlbyBzdGFydHMgcGxheWluZyBhdXRvbWF0aWNhbGx5IHdoZW4gbG9hZGVkLlxyXG5cdFx0Ly8gT24gc29tZSBicm93c2VycyBhdXRvcGxheSB3aWxsIG9ubHkgd29yayB3aXRoIGBtdXRlZDogdHJ1ZWBcclxuXHRcdGF1dG9wbGF5OiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gbG9vcDogQm9vbGVhbiA9IHRydWVcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgbG9vcCBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgd2hlbiBwbGF5ZWQuXHJcblx0XHRsb29wOiB0cnVlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2VlcEFzcGVjdFJhdGlvOiBCb29sZWFuID0gdHJ1ZVxyXG5cdFx0Ly8gV2hldGhlciB0aGUgdmlkZW8gd2lsbCBzYXZlIGFzcGVjdCByYXRpbyBhZnRlciB0aGUgcHJvamVjdGlvbi5cclxuXHRcdC8vIFJlbGV2YW50IGZvciBzdXBwb3J0ZWQgYnJvd3NlcnMuIFNlZSBbYnJvd3NlciBjb21wYXRpYmlsaXR5XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvb2JqZWN0LWZpdClcclxuXHRcdGtlZXBBc3BlY3RSYXRpbzogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG11dGVkOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHZpZGVvIHN0YXJ0cyBvbiBtdXRlIHdoZW4gbG9hZGVkLlxyXG5cdFx0bXV0ZWQ6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcGxheXNJbmxpbmU6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBNb2JpbGUgYnJvd3NlcnMgd2lsbCBwbGF5IHRoZSB2aWRlbyByaWdodCB3aGVyZSBpdCBpcyBpbnN0ZWFkIG9mIG9wZW4gaXQgdXAgaW4gZnVsbHNjcmVlbiBtb2RlLlxyXG5cdFx0cGxheXNJbmxpbmU6IHRydWVcclxuXHR9LFxyXG5cclxuXHRfaW5pdEltYWdlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgd2FzRWxlbWVudFN1cHBsaWVkID0gdGhpcy5fdXJsLnRhZ05hbWUgPT09ICdWSURFTyc7XHJcblx0XHR2YXIgdmlkID0gdGhpcy5faW1hZ2UgPSB3YXNFbGVtZW50U3VwcGxpZWQgPyB0aGlzLl91cmwgOiBEb21VdGlsLmNyZWF0ZSgndmlkZW8nKTtcclxuXHJcblx0XHREb21VdGlsLmFkZENsYXNzKHZpZCwgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHsgRG9tVXRpbC5hZGRDbGFzcyh2aWQsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTsgfVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHsgRG9tVXRpbC5hZGRDbGFzcyh2aWQsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpOyB9XHJcblxyXG5cdFx0dmlkLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XHJcblx0XHR2aWQub25tb3VzZW1vdmUgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0Ly8gQGV2ZW50IGxvYWQ6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSB2aWRlbyBoYXMgZmluaXNoZWQgbG9hZGluZyB0aGUgZmlyc3QgZnJhbWVcclxuXHRcdHZpZC5vbmxvYWRlZGRhdGEgPSBVdGlsLmJpbmQodGhpcy5maXJlLCB0aGlzLCAnbG9hZCcpO1xyXG5cclxuXHRcdGlmICh3YXNFbGVtZW50U3VwcGxpZWQpIHtcclxuXHRcdFx0dmFyIHNvdXJjZUVsZW1lbnRzID0gdmlkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzb3VyY2UnKTtcclxuXHRcdFx0dmFyIHNvdXJjZXMgPSBbXTtcclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzb3VyY2VFbGVtZW50cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHNvdXJjZXMucHVzaChzb3VyY2VFbGVtZW50c1tqXS5zcmMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl91cmwgPSAoc291cmNlRWxlbWVudHMubGVuZ3RoID4gMCkgPyBzb3VyY2VzIDogW3ZpZC5zcmNdO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFVdGlsLmlzQXJyYXkodGhpcy5fdXJsKSkgeyB0aGlzLl91cmwgPSBbdGhpcy5fdXJsXTsgfVxyXG5cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmtlZXBBc3BlY3RSYXRpbyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmlkLnN0eWxlLCAnb2JqZWN0Rml0JykpIHtcclxuXHRcdFx0dmlkLnN0eWxlWydvYmplY3RGaXQnXSA9ICdmaWxsJztcclxuXHRcdH1cclxuXHRcdHZpZC5hdXRvcGxheSA9ICEhdGhpcy5vcHRpb25zLmF1dG9wbGF5O1xyXG5cdFx0dmlkLmxvb3AgPSAhIXRoaXMub3B0aW9ucy5sb29wO1xyXG5cdFx0dmlkLm11dGVkID0gISF0aGlzLm9wdGlvbnMubXV0ZWQ7XHJcblx0XHR2aWQucGxheXNJbmxpbmUgPSAhIXRoaXMub3B0aW9ucy5wbGF5c0lubGluZTtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdXJsLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBzb3VyY2UgPSBEb21VdGlsLmNyZWF0ZSgnc291cmNlJyk7XHJcblx0XHRcdHNvdXJjZS5zcmMgPSB0aGlzLl91cmxbaV07XHJcblx0XHRcdHZpZC5hcHBlbmRDaGlsZChzb3VyY2UpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRFbGVtZW50KCk6IEhUTUxWaWRlb0VsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBbYEhUTUxWaWRlb0VsZW1lbnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSFRNTFZpZGVvRWxlbWVudClcclxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC52aWRlb092ZXJsYXkodmlkZW86IFN0cmluZ3xBcnJheXxIVE1MVmlkZW9FbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFZpZGVvT3ZlcmxheSBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYW4gaW1hZ2Ugb3ZlcmxheSBvYmplY3QgZ2l2ZW4gdGhlIFVSTCBvZiB0aGUgdmlkZW8gKG9yIGFycmF5IG9mIFVSTHMsIG9yIGV2ZW4gYSB2aWRlbyBlbGVtZW50KSBhbmQgdGhlXHJcbi8vIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2aWRlb092ZXJsYXkodmlkZW8sIGJvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVmlkZW9PdmVybGF5KHZpZGVvLCBib3VuZHMsIG9wdGlvbnMpO1xyXG59XHJcbiIsImltcG9ydCB7SW1hZ2VPdmVybGF5fSBmcm9tICcuL0ltYWdlT3ZlcmxheSc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEBjbGFzcyBTVkdPdmVybGF5XG4gKiBAYWthIEwuU1ZHT3ZlcmxheVxuICogQGluaGVyaXRzIEltYWdlT3ZlcmxheVxuICpcbiAqIFVzZWQgdG8gbG9hZCwgZGlzcGxheSBhbmQgcHJvdmlkZSBET00gYWNjZXNzIHRvIGFuIFNWRyBmaWxlIG92ZXIgc3BlY2lmaWMgYm91bmRzIG9mIHRoZSBtYXAuIEV4dGVuZHMgYEltYWdlT3ZlcmxheWAuXG4gKlxuICogQW4gU1ZHIG92ZXJsYXkgdXNlcyB0aGUgW2A8c3ZnPmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL1NWRy9FbGVtZW50L3N2ZykgZWxlbWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzXG4gKiB2YXIgc3ZnRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xuICogc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKTtcbiAqIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgXCIwIDAgMjAwIDIwMFwiKTtcbiAqIHN2Z0VsZW1lbnQuaW5uZXJIVE1MID0gJzxyZWN0IHdpZHRoPVwiMjAwXCIgaGVpZ2h0PVwiMjAwXCIvPjxyZWN0IHg9XCI3NVwiIHk9XCIyM1wiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHN0eWxlPVwiZmlsbDpyZWRcIi8+PHJlY3QgeD1cIjc1XCIgeT1cIjEyM1wiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiIHN0eWxlPVwiZmlsbDojMDAxM2ZmXCIvPic7XG4gKiB2YXIgc3ZnRWxlbWVudEJvdW5kcyA9IFsgWyAzMiwgLTEzMCBdLCBbIDEzLCAtMTAwIF0gXTtcbiAqIEwuc3ZnT3ZlcmxheShzdmdFbGVtZW50LCBzdmdFbGVtZW50Qm91bmRzKS5hZGRUbyhtYXApO1xuICogYGBgXG4gKi9cblxuZXhwb3J0IHZhciBTVkdPdmVybGF5ID0gSW1hZ2VPdmVybGF5LmV4dGVuZCh7XG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZWwgPSB0aGlzLl9pbWFnZSA9IHRoaXMuX3VybDtcblxuXHRcdERvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LWltYWdlLWxheWVyJyk7XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkgeyBEb21VdGlsLmFkZENsYXNzKGVsLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7IH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSkgeyBEb21VdGlsLmFkZENsYXNzKGVsLCB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTsgfVxuXG5cdFx0ZWwub25zZWxlY3RzdGFydCA9IFV0aWwuZmFsc2VGbjtcblx0XHRlbC5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcblx0fVxuXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudCgpOiBTVkdFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIFtgU1ZHRWxlbWVudGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9TVkdFbGVtZW50KVxuXHQvLyB1c2VkIGJ5IHRoaXMgb3ZlcmxheS5cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwuc3ZnT3ZlcmxheShzdmc6IFN0cmluZ3xTVkdFbGVtZW50LCBib3VuZHM6IExhdExuZ0JvdW5kcywgb3B0aW9ucz86IFNWR092ZXJsYXkgb3B0aW9ucylcbi8vIEluc3RhbnRpYXRlcyBhbiBpbWFnZSBvdmVybGF5IG9iamVjdCBnaXZlbiBhbiBTVkcgZWxlbWVudCBhbmQgdGhlIGdlb2dyYXBoaWNhbCBib3VuZHMgaXQgaXMgdGllZCB0by5cbi8vIEEgdmlld0JveCBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgb24gdGhlIFNWRyBlbGVtZW50IHRvIHpvb20gaW4gYW5kIG91dCBwcm9wZXJseS5cblxuZXhwb3J0IGZ1bmN0aW9uIHN2Z092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFNWR092ZXJsYXkoZWwsIGJvdW5kcywgb3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCB7dG9MYXRMbmcsIExhdExuZ30gZnJvbSAnLi4vZ2VvL0xhdExuZyc7XHJcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBEaXZPdmVybGF5XHJcbiAqIEBpbmhlcml0cyBJbnRlcmFjdGl2ZSBsYXllclxyXG4gKiBAYWthIEwuRGl2T3ZlcmxheVxyXG4gKiBCYXNlIG1vZGVsIGZvciBMLlBvcHVwIGFuZCBMLlRvb2x0aXAuIEluaGVyaXQgZnJvbSBpdCBmb3IgY3VzdG9tIG92ZXJsYXlzIGxpa2UgcGx1Z2lucy5cclxuICovXHJcblxyXG4vLyBAbmFtZXNwYWNlIERpdk92ZXJsYXlcclxuZXhwb3J0IHZhciBEaXZPdmVybGF5ID0gTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIERpdk92ZXJsYXkgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gaW50ZXJhY3RpdmU6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgdHJ1ZSwgdGhlIHBvcHVwL3Rvb2x0aXAgd2lsbCBsaXN0ZW4gdG8gdGhlIG1vdXNlIGV2ZW50cy5cclxuXHRcdGludGVyYWN0aXZlOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCAwKVxyXG5cdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgb3ZlcmxheSBwb3NpdGlvbi5cclxuXHRcdG9mZnNldDogWzAsIDBdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSAnJ1xyXG5cdFx0Ly8gQSBjdXN0b20gQ1NTIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBvdmVybGF5LlxyXG5cdFx0Y2xhc3NOYW1lOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHBhbmU6IFN0cmluZyA9IHVuZGVmaW5lZFxyXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgb3ZlcmxheSB3aWxsIGJlIGFkZGVkLlxyXG5cdFx0cGFuZTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9uID0gJydcclxuXHRcdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgb3ZlcmxheSB3aGlsZSBpbml0aWFsaXppbmcuIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBzb3VyY2UgbGF5ZXIgd2lsbCBiZVxyXG5cdFx0Ly8gcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgIHRvIGJlIHVzZWQgaW4gdGhlIG92ZXJsYXkuXHJcblx0XHRjb250ZW50OiAnJ1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRcdGlmIChvcHRpb25zICYmIChvcHRpb25zIGluc3RhbmNlb2YgTGF0TG5nIHx8IFV0aWwuaXNBcnJheShvcHRpb25zKSkpIHtcclxuXHRcdFx0dGhpcy5fbGF0bG5nID0gdG9MYXRMbmcob3B0aW9ucyk7XHJcblx0XHRcdFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBzb3VyY2UpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0XHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNvbnRlbnQpIHtcclxuXHRcdFx0dGhpcy5fY29udGVudCA9IHRoaXMub3B0aW9ucy5jb250ZW50O1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3Blbk9uKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFkZHMgdGhlIG92ZXJsYXkgdG8gdGhlIG1hcC5cclxuXHQvLyBBbHRlcm5hdGl2ZSB0byBgbWFwLm9wZW5Qb3B1cChwb3B1cClgL2Aub3BlblRvb2x0aXAodG9vbHRpcClgLlxyXG5cdG9wZW5PbjogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwID0gYXJndW1lbnRzLmxlbmd0aCA/IG1hcCA6IHRoaXMuX3NvdXJjZS5fbWFwOyAvLyBleHBlcmltZW50YWwsIG5vdCB0aGUgcGFydCBvZiBwdWJsaWMgYXBpXHJcblx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSkge1xyXG5cdFx0XHRtYXAuYWRkTGF5ZXIodGhpcyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGNsb3NlKCk6IHRoaXNcclxuXHQvLyBDbG9zZXMgdGhlIG92ZXJsYXkuXHJcblx0Ly8gQWx0ZXJuYXRpdmUgdG8gYG1hcC5jbG9zZVBvcHVwKHBvcHVwKWAvYC5jbG9zZVRvb2x0aXAodG9vbHRpcClgXHJcblx0Ly8gYW5kIGBsYXllci5jbG9zZVBvcHVwKClgL2AuY2xvc2VUb29sdGlwKClgLlxyXG5cdGNsb3NlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9nZ2xlKGxheWVyPzogTGF5ZXIpOiB0aGlzXHJcblx0Ly8gT3BlbnMgb3IgY2xvc2VzIHRoZSBvdmVybGF5IGJvdW5kIHRvIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cclxuXHQvLyBBcmd1bWVudCBtYXkgYmUgb21pdHRlZCBvbmx5IGZvciBvdmVybGF5IGJvdW5kIHRvIGxheWVyLlxyXG5cdC8vIEFsdGVybmF0aXZlIHRvIGBsYXllci50b2dnbGVQb3B1cCgpYC9gLnRvZ2dsZVRvb2x0aXAoKWAuXHJcblx0dG9nZ2xlOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5jbG9zZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2UgPSBsYXllcjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsYXllciA9IHRoaXMuX3NvdXJjZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9wcmVwYXJlT3BlbigpO1xyXG5cclxuXHRcdFx0Ly8gb3BlbiB0aGUgb3ZlcmxheSBvbiB0aGUgbWFwXHJcblx0XHRcdHRoaXMub3Blbk9uKGxheWVyLl9tYXApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX3pvb21BbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xyXG5cclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHRoaXMuX2luaXRMYXlvdXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3JlbW92ZVRpbWVvdXQpO1xyXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0aWYgKG1hcC5fZmFkZUFuaW1hdGVkKSB7XHJcblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYnJpbmdUb0Zyb250KCk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtaW50ZXJhY3RpdmUnKTtcclxuXHRcdFx0dGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRpZiAobWFwLl9mYWRlQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgMCk7XHJcblx0XHRcdHRoaXMuX3JlbW92ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KFV0aWwuYmluZChEb21VdGlsLnJlbW92ZSwgdW5kZWZpbmVkLCB0aGlzLl9jb250YWluZXIpLCAyMDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmludGVyYWN0aXZlKSB7XHJcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xyXG5cdFx0XHR0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcblx0Ly8gQG1ldGhvZCBnZXRMYXRMbmc6IExhdExuZ1xyXG5cdC8vIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBwb2ludCBvZiB0aGUgb3ZlcmxheS5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRMYXRMbmcobGF0bG5nOiBMYXRMbmcpOiB0aGlzXHJcblx0Ly8gU2V0cyB0aGUgZ2VvZ3JhcGhpY2FsIHBvaW50IHdoZXJlIHRoZSBvdmVybGF5IHdpbGwgb3Blbi5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IHRvTGF0TG5nKGxhdGxuZyk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblx0XHRcdHRoaXMuX2FkanVzdFBhbigpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRDb250ZW50OiBTdHJpbmd8SFRNTEVsZW1lbnRcclxuXHQvLyBSZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSBvdmVybGF5LlxyXG5cdGdldENvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0Q29udGVudChodG1sQ29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fEZ1bmN0aW9uKTogdGhpc1xyXG5cdC8vIFNldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgb3ZlcmxheS4gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHNvdXJjZSBsYXllciB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uXHJcblx0Ly8gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgIHRvIGJlIHVzZWQgaW4gdGhlIG92ZXJsYXkuXHJcblx0c2V0Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgZ2V0RWxlbWVudDogU3RyaW5nfEhUTUxFbGVtZW50XHJcblx0Ly8gUmV0dXJucyB0aGUgSFRNTCBjb250YWluZXIgb2YgdGhlIG92ZXJsYXkuXHJcblx0Z2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIHVwZGF0ZTogbnVsbFxyXG5cdC8vIFVwZGF0ZXMgdGhlIG92ZXJsYXkgY29udGVudCwgbGF5b3V0IGFuZCBwb3NpdGlvbi4gVXNlZnVsIGZvciB1cGRhdGluZyB0aGUgb3ZlcmxheSBhZnRlciBzb21ldGhpbmcgaW5zaWRlIGNoYW5nZWQsIGUuZy4gaW1hZ2UgbG9hZGVkLlxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHJcblx0XHR0aGlzLl91cGRhdGVDb250ZW50KCk7XHJcblx0XHR0aGlzLl91cGRhdGVMYXlvdXQoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcclxuXHJcblx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBldmVudHMgPSB7XHJcblx0XHRcdHpvb206IHRoaXMuX3VwZGF0ZVBvc2l0aW9uLFxyXG5cdFx0XHR2aWV3cmVzZXQ6IHRoaXMuX3VwZGF0ZVBvc2l0aW9uXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fYW5pbWF0ZVpvb207XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZXZlbnRzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgaXNPcGVuOiBCb29sZWFuXHJcblx0Ly8gUmV0dXJucyBgdHJ1ZWAgd2hlbiB0aGUgb3ZlcmxheSBpcyB2aXNpYmxlIG9uIHRoZSBtYXAuXHJcblx0aXNPcGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISF0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLmhhc0xheWVyKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0Zyb250OiB0aGlzXHJcblx0Ly8gQnJpbmdzIHRoaXMgb3ZlcmxheSBpbiBmcm9udCBvZiBvdGhlciBvdmVybGF5cyAoaW4gdGhlIHNhbWUgbWFwIHBhbmUpLlxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHREb21VdGlsLnRvRnJvbnQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcclxuXHQvLyBCcmluZ3MgdGhpcyBvdmVybGF5IHRvIHRoZSBiYWNrIG9mIG90aGVyIG92ZXJsYXlzIChpbiB0aGUgc2FtZSBtYXAgcGFuZSkuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0RG9tVXRpbC50b0JhY2sodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIHByZXBhcmUgYm91bmQgb3ZlcmxheSB0byBvcGVuOiB1cGRhdGUgbGF0bG5nIHBvcyAvIGNvbnRlbnQgc291cmNlIChmb3IgRmVhdHVyZUdyb3VwKVxyXG5cdF9wcmVwYXJlT3BlbjogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dmFyIHNvdXJjZSA9IHRoaXMuX3NvdXJjZTtcclxuXHRcdGlmICghc291cmNlLl9tYXApIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0aWYgKHNvdXJjZSBpbnN0YW5jZW9mIEZlYXR1cmVHcm91cCkge1xyXG5cdFx0XHRzb3VyY2UgPSBudWxsO1xyXG5cdFx0XHR2YXIgbGF5ZXJzID0gdGhpcy5fc291cmNlLl9sYXllcnM7XHJcblx0XHRcdGZvciAodmFyIGlkIGluIGxheWVycykge1xyXG5cdFx0XHRcdGlmIChsYXllcnNbaWRdLl9tYXApIHtcclxuXHRcdFx0XHRcdHNvdXJjZSA9IGxheWVyc1tpZF07XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFzb3VyY2UpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIFVuYWJsZSB0byBnZXQgc291cmNlIGxheWVyLlxyXG5cclxuXHRcdFx0Ly8gc2V0IG92ZXJsYXkgc291cmNlIHRvIHRoaXMgbGF5ZXJcclxuXHRcdFx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghbGF0bG5nKSB7XHJcblx0XHRcdGlmIChzb3VyY2UuZ2V0Q2VudGVyKSB7XHJcblx0XHRcdFx0bGF0bG5nID0gc291cmNlLmdldENlbnRlcigpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHNvdXJjZS5nZXRMYXRMbmcpIHtcclxuXHRcdFx0XHRsYXRsbmcgPSBzb3VyY2UuZ2V0TGF0TG5nKCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoc291cmNlLmdldEJvdW5kcykge1xyXG5cdFx0XHRcdGxhdGxuZyA9IHNvdXJjZS5nZXRCb3VuZHMoKS5nZXRDZW50ZXIoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgc291cmNlIGxheWVyIExhdExuZy4nKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5zZXRMYXRMbmcobGF0bG5nKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdC8vIHVwZGF0ZSB0aGUgb3ZlcmxheSAoY29udGVudCwgbGF5b3V0LCBldGMuLi4pXHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbm9kZSA9IHRoaXMuX2NvbnRlbnROb2RlO1xyXG5cdFx0dmFyIGNvbnRlbnQgPSAodHlwZW9mIHRoaXMuX2NvbnRlbnQgPT09ICdmdW5jdGlvbicpID8gdGhpcy5fY29udGVudCh0aGlzLl9zb3VyY2UgfHwgdGhpcykgOiB0aGlzLl9jb250ZW50O1xyXG5cclxuXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0bm9kZS5pbm5lckhUTUwgPSBjb250ZW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0d2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcblx0XHRcdFx0bm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBEaXZPdmVybGF5XHJcblx0XHQvLyBAc2VjdGlvbiBEaXZPdmVybGF5IGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IGNvbnRlbnR1cGRhdGU6IEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIHRoZSBjb250ZW50IG9mIHRoZSBvdmVybGF5IGlzIHVwZGF0ZWRcclxuXHRcdHRoaXMuZmlyZSgnY29udGVudHVwZGF0ZScpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5vZmZzZXQpLFxyXG5cdFx0ICAgIGFuY2hvciA9IHRoaXMuX2dldEFuY2hvcigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcclxuXHRcdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcy5hZGQoYW5jaG9yKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvZmZzZXQgPSBvZmZzZXQuYWRkKHBvcykuYWRkKGFuY2hvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGJvdHRvbSA9IHRoaXMuX2NvbnRhaW5lckJvdHRvbSA9IC1vZmZzZXQueSxcclxuXHRcdCAgICBsZWZ0ID0gdGhpcy5fY29udGFpbmVyTGVmdCA9IC1NYXRoLnJvdW5kKHRoaXMuX2NvbnRhaW5lcldpZHRoIC8gMikgKyBvZmZzZXQueDtcclxuXHJcblx0XHQvLyBib3R0b20gcG9zaXRpb24gdGhlIG92ZXJsYXkgaW4gY2FzZSB0aGUgaGVpZ2h0IG9mIHRoZSBvdmVybGF5IGNoYW5nZXMgKGltYWdlcyBsb2FkaW5nIGV0YylcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5ib3R0b20gPSBib3R0b20gKyAncHgnO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gWzAsIDBdO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuTWFwLmluY2x1ZGUoe1xyXG5cdF9pbml0T3ZlcmxheTogZnVuY3Rpb24gKE92ZXJsYXlDbGFzcywgY29udGVudCwgbGF0bG5nLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgb3ZlcmxheSA9IGNvbnRlbnQ7XHJcblx0XHRpZiAoIShvdmVybGF5IGluc3RhbmNlb2YgT3ZlcmxheUNsYXNzKSkge1xyXG5cdFx0XHRvdmVybGF5ID0gbmV3IE92ZXJsYXlDbGFzcyhvcHRpb25zKS5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxhdGxuZykge1xyXG5cdFx0XHRvdmVybGF5LnNldExhdExuZyhsYXRsbmcpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG92ZXJsYXk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG5MYXllci5pbmNsdWRlKHtcclxuXHRfaW5pdE92ZXJsYXk6IGZ1bmN0aW9uIChPdmVybGF5Q2xhc3MsIG9sZCwgY29udGVudCwgb3B0aW9ucykge1xyXG5cdFx0dmFyIG92ZXJsYXkgPSBjb250ZW50O1xyXG5cdFx0aWYgKG92ZXJsYXkgaW5zdGFuY2VvZiBPdmVybGF5Q2xhc3MpIHtcclxuXHRcdFx0VXRpbC5zZXRPcHRpb25zKG92ZXJsYXksIG9wdGlvbnMpO1xyXG5cdFx0XHRvdmVybGF5Ll9zb3VyY2UgPSB0aGlzO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b3ZlcmxheSA9IChvbGQgJiYgIW9wdGlvbnMpID8gb2xkIDogbmV3IE92ZXJsYXlDbGFzcyhvcHRpb25zLCB0aGlzKTtcclxuXHRcdFx0b3ZlcmxheS5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG92ZXJsYXk7XHJcblx0fVxyXG59KTtcclxuIiwiaW1wb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xyXG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi9kb20vRG9tRXZlbnQnO1xyXG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uL2RvbS9Eb21VdGlsJztcclxuaW1wb3J0IHtQb2ludCwgdG9Qb2ludH0gZnJvbSAnLi4vZ2VvbWV0cnkvUG9pbnQnO1xyXG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XHJcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xyXG5pbXBvcnQge1BhdGh9IGZyb20gJy4vdmVjdG9yL1BhdGgnO1xyXG5pbXBvcnQge0ZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xyXG5cclxuLypcclxuICogQGNsYXNzIFBvcHVwXHJcbiAqIEBpbmhlcml0cyBEaXZPdmVybGF5XHJcbiAqIEBha2EgTC5Qb3B1cFxyXG4gKiBVc2VkIHRvIG9wZW4gcG9wdXBzIGluIGNlcnRhaW4gcGxhY2VzIG9mIHRoZSBtYXAuIFVzZSBbTWFwLm9wZW5Qb3B1cF0oI21hcC1vcGVucG9wdXApIHRvXHJcbiAqIG9wZW4gcG9wdXBzIHdoaWxlIG1ha2luZyBzdXJlIHRoYXQgb25seSBvbmUgcG9wdXAgaXMgb3BlbiBhdCBvbmUgdGltZVxyXG4gKiAocmVjb21tZW5kZWQgZm9yIHVzYWJpbGl0eSksIG9yIHVzZSBbTWFwLmFkZExheWVyXSgjbWFwLWFkZGxheWVyKSB0byBvcGVuIGFzIG1hbnkgYXMgeW91IHdhbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIElmIHlvdSB3YW50IHRvIGp1c3QgYmluZCBhIHBvcHVwIHRvIG1hcmtlciBjbGljayBhbmQgdGhlbiBvcGVuIGl0LCBpdCdzIHJlYWxseSBlYXN5OlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXJrZXIuYmluZFBvcHVwKHBvcHVwQ29udGVudCkub3BlblBvcHVwKCk7XHJcbiAqIGBgYFxyXG4gKiBQYXRoIG92ZXJsYXlzIGxpa2UgcG9seWxpbmVzIGFsc28gaGF2ZSBhIGBiaW5kUG9wdXBgIG1ldGhvZC5cclxuICpcclxuICogQSBwb3B1cCBjYW4gYmUgYWxzbyBzdGFuZGFsb25lOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiB2YXIgcG9wdXAgPSBMLnBvcHVwKClcclxuICogXHQuc2V0TGF0TG5nKGxhdGxuZylcclxuICogXHQuc2V0Q29udGVudCgnPHA+SGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgcG9wdXAuPC9wPicpXHJcbiAqIFx0Lm9wZW5PbihtYXApO1xyXG4gKiBgYGBcclxuICogb3JcclxuICogYGBganNcclxuICogdmFyIHBvcHVwID0gTC5wb3B1cChsYXRsbmcsIHtjb250ZW50OiAnPHA+SGVsbG8gd29ybGQhPGJyIC8+VGhpcyBpcyBhIG5pY2UgcG9wdXAuPC9wPicpXHJcbiAqIFx0Lm9wZW5PbihtYXApO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG5leHBvcnQgdmFyIFBvcHVwID0gRGl2T3ZlcmxheS5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgUG9wdXAgb3B0aW9uc1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3BvcHVwUGFuZSdcclxuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIHBvcHVwIHdpbGwgYmUgYWRkZWQuXHJcblx0XHRwYW5lOiAncG9wdXBQYW5lJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCA3KVxyXG5cdFx0Ly8gVGhlIG9mZnNldCBvZiB0aGUgcG9wdXAgcG9zaXRpb24uXHJcblx0XHRvZmZzZXQ6IFswLCA3XSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heFdpZHRoOiBOdW1iZXIgPSAzMDBcclxuXHRcdC8vIE1heCB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuXHRcdG1heFdpZHRoOiAzMDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtaW5XaWR0aDogTnVtYmVyID0gNTBcclxuXHRcdC8vIE1pbiB3aWR0aCBvZiB0aGUgcG9wdXAsIGluIHBpeGVscy5cclxuXHRcdG1pbldpZHRoOiA1MCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIG1heEhlaWdodDogTnVtYmVyID0gbnVsbFxyXG5cdFx0Ly8gSWYgc2V0LCBjcmVhdGVzIGEgc2Nyb2xsYWJsZSBjb250YWluZXIgb2YgdGhlIGdpdmVuIGhlaWdodFxyXG5cdFx0Ly8gaW5zaWRlIGEgcG9wdXAgaWYgaXRzIGNvbnRlbnQgZXhjZWVkcyBpdC5cclxuXHRcdC8vIFRoZSBzY3JvbGxhYmxlIGNvbnRhaW5lciBjYW4gYmUgc3R5bGVkIHVzaW5nIHRoZVxyXG5cdFx0Ly8gYGxlYWZsZXQtcG9wdXAtc2Nyb2xsZWRgIENTUyBjbGFzcyBzZWxlY3Rvci5cclxuXHRcdG1heEhlaWdodDogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGF1dG9QYW46IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIGRvIHBhbm5pbmcgYW5pbWF0aW9uXHJcblx0XHQvLyB0byBmaXQgdGhlIG9wZW5lZCBwb3B1cC5cclxuXHRcdGF1dG9QYW46IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IFBvaW50ID0gbnVsbFxyXG5cdFx0Ly8gVGhlIG1hcmdpbiBiZXR3ZWVuIHRoZSBwb3B1cCBhbmQgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgbWFwXHJcblx0XHQvLyB2aWV3IGFmdGVyIGF1dG9wYW5uaW5nIHdhcyBwZXJmb3JtZWQuXHJcblx0XHRhdXRvUGFuUGFkZGluZ1RvcExlZnQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZ0JvdHRvbVJpZ2h0OiBQb2ludCA9IG51bGxcclxuXHRcdC8vIFRoZSBtYXJnaW4gYmV0d2VlbiB0aGUgcG9wdXAgYW5kIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBtYXBcclxuXHRcdC8vIHZpZXcgYWZ0ZXIgYXV0b3Bhbm5pbmcgd2FzIHBlcmZvcm1lZC5cclxuXHRcdGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IG51bGwsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvUGFuUGFkZGluZzogUG9pbnQgPSBQb2ludCg1LCA1KVxyXG5cdFx0Ly8gRXF1aXZhbGVudCBvZiBzZXR0aW5nIGJvdGggdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBhdXRvcGFuIHBhZGRpbmcgdG8gdGhlIHNhbWUgdmFsdWUuXHJcblx0XHRhdXRvUGFuUGFkZGluZzogWzUsIDVdLFxyXG5cclxuXHRcdC8vIEBvcHRpb24ga2VlcEluVmlldzogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBTZXQgaXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRvIHByZXZlbnQgdXNlcnMgZnJvbSBwYW5uaW5nIHRoZSBwb3B1cFxyXG5cdFx0Ly8gb2ZmIG9mIHRoZSBzY3JlZW4gd2hpbGUgaXQgaXMgb3Blbi5cclxuXHRcdGtlZXBJblZpZXc6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gY2xvc2VCdXR0b246IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBDb250cm9scyB0aGUgcHJlc2VuY2Ugb2YgYSBjbG9zZSBidXR0b24gaW4gdGhlIHBvcHVwLlxyXG5cdFx0Y2xvc2VCdXR0b246IHRydWUsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBhdXRvQ2xvc2U6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG5cdFx0Ly8gdGhlIHBvcHVwIGNsb3Npbmcgd2hlbiBhbm90aGVyIHBvcHVwIGlzIG9wZW5lZC5cclxuXHRcdGF1dG9DbG9zZTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlT25Fc2NhcGVLZXk6IEJvb2xlYW4gPSB0cnVlXHJcblx0XHQvLyBTZXQgaXQgdG8gYGZhbHNlYCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZlxyXG5cdFx0Ly8gdGhlIEVTQyBrZXkgZm9yIGNsb3Npbmcgb2YgdGhlIHBvcHVwLlxyXG5cdFx0Y2xvc2VPbkVzY2FwZUtleTogdHJ1ZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsb3NlT25DbGljazogQm9vbGVhbiA9ICpcclxuXHRcdC8vIFNldCBpdCBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiB0aGUgcG9wdXAgY2xvc2luZyB3aGVuIHVzZXIgY2xpY2tzXHJcblx0XHQvLyBvbiB0aGUgbWFwLiBEZWZhdWx0cyB0byB0aGUgbWFwJ3MgW2BjbG9zZVBvcHVwT25DbGlja2BdKCNtYXAtY2xvc2Vwb3B1cG9uY2xpY2spIG9wdGlvbi5cclxuXHJcblx0XHQvLyBAb3B0aW9uIGNsYXNzTmFtZTogU3RyaW5nID0gJydcclxuXHRcdC8vIEEgY3VzdG9tIENTUyBjbGFzcyBuYW1lIHRvIGFzc2lnbiB0byB0aGUgcG9wdXAuXHJcblx0XHRjbGFzc05hbWU6ICcnXHJcblx0fSxcclxuXHJcblx0Ly8gQG5hbWVzcGFjZSBQb3B1cFxyXG5cdC8vIEBtZXRob2Qgb3Blbk9uKG1hcDogTWFwKTogdGhpc1xyXG5cdC8vIEFsdGVybmF0aXZlIHRvIGBtYXAub3BlblBvcHVwKHBvcHVwKWAuXHJcblx0Ly8gQWRkcyB0aGUgcG9wdXAgdG8gdGhlIG1hcCBhbmQgY2xvc2VzIHRoZSBwcmV2aW91cyBvbmUuXHJcblx0b3Blbk9uOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAgPSBhcmd1bWVudHMubGVuZ3RoID8gbWFwIDogdGhpcy5fc291cmNlLl9tYXA7IC8vIGV4cGVyaW1lbnRhbCwgbm90IHRoZSBwYXJ0IG9mIHB1YmxpYyBhcGlcclxuXHJcblx0XHRpZiAoIW1hcC5oYXNMYXllcih0aGlzKSAmJiBtYXAuX3BvcHVwICYmIG1hcC5fcG9wdXAub3B0aW9ucy5hdXRvQ2xvc2UpIHtcclxuXHRcdFx0bWFwLnJlbW92ZUxheWVyKG1hcC5fcG9wdXApO1xyXG5cdFx0fVxyXG5cdFx0bWFwLl9wb3B1cCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIERpdk92ZXJsYXkucHJvdG90eXBlLm9wZW5Pbi5jYWxsKHRoaXMsIG1hcCk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgcG9wdXBvcGVuOiBQb3B1cEV2ZW50XHJcblx0XHQvLyBGaXJlZCB3aGVuIGEgcG9wdXAgaXMgb3BlbmVkIGluIHRoZSBtYXBcclxuXHRcdG1hcC5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cG9wZW46IFBvcHVwRXZlbnRcclxuXHRcdFx0Ly8gRmlyZWQgd2hlbiBhIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaXMgb3BlbmVkXHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9LCB0cnVlKTtcclxuXHRcdFx0Ly8gRm9yIG5vbi1wYXRoIGxheWVycywgd2UgdG9nZ2xlIHRoZSBwb3B1cCB3aGVuIGNsaWNraW5nXHJcblx0XHRcdC8vIGFnYWluIHRoZSBsYXllciwgc28gcHJldmVudCB0aGUgbWFwIHRvIHJlb3BlbiBpdC5cclxuXHRcdFx0aWYgKCEodGhpcy5fc291cmNlIGluc3RhbmNlb2YgUGF0aCkpIHtcclxuXHRcdFx0XHR0aGlzLl9zb3VyY2Uub24oJ3ByZWNsaWNrJywgRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHREaXZPdmVybGF5LnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XHJcblxyXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcclxuXHRcdC8vIEBzZWN0aW9uIFBvcHVwIGV2ZW50c1xyXG5cdFx0Ly8gQGV2ZW50IHBvcHVwY2xvc2U6IFBvcHVwRXZlbnRcclxuXHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBpbiB0aGUgbWFwIGlzIGNsb3NlZFxyXG5cdFx0bWFwLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdC8vIEBuYW1lc3BhY2UgTGF5ZXJcclxuXHRcdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHRcdC8vIEBldmVudCBwb3B1cGNsb3NlOiBQb3B1cEV2ZW50XHJcblx0XHRcdC8vIEZpcmVkIHdoZW4gYSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZFxyXG5cdFx0XHR0aGlzLl9zb3VyY2UuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30sIHRydWUpO1xyXG5cdFx0XHRpZiAoISh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG5cdFx0XHRcdHRoaXMuX3NvdXJjZS5vZmYoJ3ByZWNsaWNrJywgRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IERpdk92ZXJsYXkucHJvdG90eXBlLmdldEV2ZW50cy5jYWxsKHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICE9PSB1bmRlZmluZWQgPyB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIDogdGhpcy5fbWFwLm9wdGlvbnMuY2xvc2VQb3B1cE9uQ2xpY2spIHtcclxuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5jbG9zZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmtlZXBJblZpZXcpIHtcclxuXHRcdFx0ZXZlbnRzLm1vdmVlbmQgPSB0aGlzLl9hZGp1c3RQYW47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHByZWZpeCA9ICdsZWFmbGV0LXBvcHVwJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JyxcclxuXHRcdFx0cHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICtcclxuXHRcdFx0JyBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHJcblx0XHR2YXIgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXIgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50LXdyYXBwZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy1jb250ZW50Jywgd3JhcHBlcik7XHJcblxyXG5cdFx0RG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oY29udGFpbmVyKTtcclxuXHRcdERvbUV2ZW50LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbih0aGlzLl9jb250ZW50Tm9kZSk7XHJcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdjb250ZXh0bWVudScsIERvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XHJcblxyXG5cdFx0dGhpcy5fdGlwQ29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctdGlwLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XHJcblx0XHR0aGlzLl90aXAgPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy10aXAnLCB0aGlzLl90aXBDb250YWluZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b24pIHtcclxuXHRcdFx0dmFyIGNsb3NlQnV0dG9uID0gdGhpcy5fY2xvc2VCdXR0b24gPSBEb21VdGlsLmNyZWF0ZSgnYScsIHByZWZpeCArICctY2xvc2UtYnV0dG9uJywgY29udGFpbmVyKTtcclxuXHRcdFx0Y2xvc2VCdXR0b24uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2J1dHRvbicpOyAvLyBvdmVycmlkZXMgdGhlIGltcGxpY2l0IHJvbGU9bGluayBvZiA8YT4gZWxlbWVudHMgIzczOTlcclxuXHRcdFx0Y2xvc2VCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgJ0Nsb3NlIHBvcHVwJyk7XHJcblx0XHRcdGNsb3NlQnV0dG9uLmhyZWYgPSAnI2Nsb3NlJztcclxuXHRcdFx0Y2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiYjMjE1Ozwvc3Bhbj4nO1xyXG5cclxuXHRcdFx0RG9tRXZlbnQub24oY2xvc2VCdXR0b24sICdjbGljaycsIGZ1bmN0aW9uIChldikge1xyXG5cdFx0XHRcdERvbUV2ZW50LnByZXZlbnREZWZhdWx0KGV2KTtcclxuXHRcdFx0XHR0aGlzLmNsb3NlKCk7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250ZW50Tm9kZSxcclxuXHRcdCAgICBzdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcclxuXHJcblx0XHRzdHlsZS53aWR0aCA9ICcnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xyXG5cclxuXHRcdHZhciB3aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuXHRcdHdpZHRoID0gTWF0aC5taW4od2lkdGgsIHRoaXMub3B0aW9ucy5tYXhXaWR0aCk7XHJcblx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCB0aGlzLm9wdGlvbnMubWluV2lkdGgpO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gKHdpZHRoICsgMSkgKyAncHgnO1xyXG5cdFx0c3R5bGUud2hpdGVTcGFjZSA9ICcnO1xyXG5cclxuXHRcdHN0eWxlLmhlaWdodCA9ICcnO1xyXG5cclxuXHRcdHZhciBoZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0LFxyXG5cdFx0ICAgIG1heEhlaWdodCA9IHRoaXMub3B0aW9ucy5tYXhIZWlnaHQsXHJcblx0XHQgICAgc2Nyb2xsZWRDbGFzcyA9ICdsZWFmbGV0LXBvcHVwLXNjcm9sbGVkJztcclxuXHJcblx0XHRpZiAobWF4SGVpZ2h0ICYmIGhlaWdodCA+IG1heEhlaWdodCkge1xyXG5cdFx0XHRzdHlsZS5oZWlnaHQgPSBtYXhIZWlnaHQgKyAncHgnO1xyXG5cdFx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgZS56b29tLCBlLmNlbnRlciksXHJcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XHJcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zLmFkZChhbmNob3IpKTtcclxuXHR9LFxyXG5cclxuXHRfYWRqdXN0UGFuOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5hdXRvUGFuKSB7IHJldHVybjsgfVxyXG5cdFx0aWYgKHRoaXMuX21hcC5fcGFuQW5pbSkgeyB0aGlzLl9tYXAuX3BhbkFuaW0uc3RvcCgpOyB9XHJcblxyXG5cdFx0Ly8gV2UgY2FuIGVuZGxlc3NseSByZWN1cnNlIGlmIGtlZXBJblZpZXcgaXMgc2V0IGFuZCB0aGUgdmlldyByZXNldHMuXHJcblx0XHQvLyBMZXQncyBndWFyZCBhZ2FpbnN0IHRoYXQgYnkgZXhpdGluZyBlYXJseSBpZiB3ZSdyZSByZXNwb25kaW5nIHRvIG91ciBvd24gYXV0b3Bhbi5cclxuXHRcdGlmICh0aGlzLl9hdXRvcGFubmluZykge1xyXG5cdFx0XHR0aGlzLl9hdXRvcGFubmluZyA9IGZhbHNlO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBtYXJnaW5Cb3R0b20gPSBwYXJzZUludChEb21VdGlsLmdldFN0eWxlKHRoaXMuX2NvbnRhaW5lciwgJ21hcmdpbkJvdHRvbScpLCAxMCkgfHwgMCxcclxuXHRcdCAgICBjb250YWluZXJIZWlnaHQgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0ICsgbWFyZ2luQm90dG9tLFxyXG5cdFx0ICAgIGNvbnRhaW5lcldpZHRoID0gdGhpcy5fY29udGFpbmVyV2lkdGgsXHJcblx0XHQgICAgbGF5ZXJQb3MgPSBuZXcgUG9pbnQodGhpcy5fY29udGFpbmVyTGVmdCwgLWNvbnRhaW5lckhlaWdodCAtIHRoaXMuX2NvbnRhaW5lckJvdHRvbSk7XHJcblxyXG5cdFx0bGF5ZXJQb3MuX2FkZChEb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lcikpO1xyXG5cclxuXHRcdHZhciBjb250YWluZXJQb3MgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQobGF5ZXJQb3MpLFxyXG5cdFx0ICAgIHBhZGRpbmcgPSB0b1BvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ1RMID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdUb3BMZWZ0IHx8IHBhZGRpbmcpLFxyXG5cdFx0ICAgIHBhZGRpbmdCUiA9IHRvUG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgc2l6ZSA9IG1hcC5nZXRTaXplKCksXHJcblx0XHQgICAgZHggPSAwLFxyXG5cdFx0ICAgIGR5ID0gMDtcclxuXHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCArIHBhZGRpbmdCUi54ID4gc2l6ZS54KSB7IC8vIHJpZ2h0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggKyBjb250YWluZXJXaWR0aCAtIHNpemUueCArIHBhZGRpbmdCUi54O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy54IC0gZHggLSBwYWRkaW5nVEwueCA8IDApIHsgLy8gbGVmdFxyXG5cdFx0XHRkeCA9IGNvbnRhaW5lclBvcy54IC0gcGFkZGluZ1RMLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgKyBjb250YWluZXJIZWlnaHQgKyBwYWRkaW5nQlIueSA+IHNpemUueSkgeyAvLyBib3R0b21cclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCAtIHNpemUueSArIHBhZGRpbmdCUi55O1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbnRhaW5lclBvcy55IC0gZHkgLSBwYWRkaW5nVEwueSA8IDApIHsgLy8gdG9wXHJcblx0XHRcdGR5ID0gY29udGFpbmVyUG9zLnkgLSBwYWRkaW5nVEwueTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAbmFtZXNwYWNlIE1hcFxyXG5cdFx0Ly8gQHNlY3Rpb24gUG9wdXAgZXZlbnRzXHJcblx0XHQvLyBAZXZlbnQgYXV0b3BhbnN0YXJ0OiBFdmVudFxyXG5cdFx0Ly8gRmlyZWQgd2hlbiB0aGUgbWFwIHN0YXJ0cyBhdXRvcGFubmluZyB3aGVuIG9wZW5pbmcgYSBwb3B1cC5cclxuXHRcdGlmIChkeCB8fCBkeSkge1xyXG5cdFx0XHQvLyBUcmFjayB0aGF0IHdlJ3JlIGF1dG9wYW5uaW5nLCBhcyB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmUtcmFuIG9uIG1vdmVlbmRcclxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5rZWVwSW5WaWV3KSB7XHJcblx0XHRcdFx0dGhpcy5fYXV0b3Bhbm5pbmcgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtYXBcclxuXHRcdFx0ICAgIC5maXJlKCdhdXRvcGFuc3RhcnQnKVxyXG5cdFx0XHQgICAgLnBhbkJ5KFtkeCwgZHldKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZ2V0QW5jaG9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBXaGVyZSBzaG91bGQgd2UgYW5jaG9yIHRoZSBwb3B1cCBvbiB0aGUgc291cmNlIGxheWVyP1xyXG5cdFx0cmV0dXJuIHRvUG9pbnQodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5fZ2V0UG9wdXBBbmNob3IgPyB0aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCkgOiBbMCwgMF0pO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuLy8gQG5hbWVzcGFjZSBQb3B1cFxyXG4vLyBAZmFjdG9yeSBMLnBvcHVwKG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcclxuLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSBwb3B1cCB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoZSBMYXllciB0byB3aGljaCBpdCByZWZlcnMuXHJcbi8vIEBhbHRlcm5hdGl2ZVxyXG4vLyBAZmFjdG9yeSBMLnBvcHVwKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogUG9wdXAgb3B0aW9ucylcclxuLy8gSW5zdGFudGlhdGVzIGEgYFBvcHVwYCBvYmplY3QgZ2l2ZW4gYGxhdGxuZ2Agd2hlcmUgdGhlIHBvcHVwIHdpbGwgb3BlbiBhbmQgYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24uXHJcbmV4cG9ydCB2YXIgcG9wdXAgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XHJcblx0cmV0dXJuIG5ldyBQb3B1cChvcHRpb25zLCBzb3VyY2UpO1xyXG59O1xyXG5cclxuXHJcbi8qIEBuYW1lc3BhY2UgTWFwXHJcbiAqIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcclxuICogQG9wdGlvbiBjbG9zZVBvcHVwT25DbGljazogQm9vbGVhbiA9IHRydWVcclxuICogU2V0IGl0IHRvIGBmYWxzZWAgaWYgeW91IGRvbid0IHdhbnQgcG9wdXBzIHRvIGNsb3NlIHdoZW4gdXNlciBjbGlja3MgdGhlIG1hcC5cclxuICovXHJcbk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGNsb3NlUG9wdXBPbkNsaWNrOiB0cnVlXHJcbn0pO1xyXG5cclxuXHJcbi8vIEBuYW1lc3BhY2UgTWFwXHJcbi8vIEBzZWN0aW9uIE1ldGhvZHMgZm9yIExheWVycyBhbmQgQ29udHJvbHNcclxuTWFwLmluY2x1ZGUoe1xyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKHBvcHVwOiBQb3B1cCk6IHRoaXNcclxuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHBvcHVwIHdoaWxlIGNsb3NpbmcgdGhlIHByZXZpb3VzbHkgb3BlbmVkICh0byBtYWtlIHN1cmUgb25seSBvbmUgaXMgb3BlbmVkIGF0IG9uZSB0aW1lIGZvciB1c2FiaWxpdHkpLlxyXG5cdC8vIEBhbHRlcm5hdGl2ZVxyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBQb3B1cCBvcHRpb25zKTogdGhpc1xyXG5cdC8vIENyZWF0ZXMgYSBwb3B1cCB3aXRoIHRoZSBzcGVjaWZpZWQgY29udGVudCBhbmQgb3B0aW9ucyBhbmQgb3BlbnMgaXQgaW4gdGhlIGdpdmVuIHBvaW50IG9uIGEgbWFwLlxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKHBvcHVwLCBsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX2luaXRPdmVybGF5KFBvcHVwLCBwb3B1cCwgbGF0bG5nLCBvcHRpb25zKVxyXG5cdFx0ICAub3Blbk9uKHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgY2xvc2VQb3B1cChwb3B1cD86IFBvcHVwKTogdGhpc1xyXG5cdC8vIENsb3NlcyB0aGUgcG9wdXAgcHJldmlvdXNseSBvcGVuZWQgd2l0aCBbb3BlblBvcHVwXSgjbWFwLW9wZW5wb3B1cCkgKG9yIHRoZSBnaXZlbiBvbmUpLlxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkge1xyXG5cdFx0cG9wdXAgPSBhcmd1bWVudHMubGVuZ3RoID8gcG9wdXAgOiB0aGlzLl9wb3B1cDtcclxuXHRcdGlmIChwb3B1cCkge1xyXG5cdFx0XHRwb3B1cC5jbG9zZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcbi8qXHJcbiAqIEBuYW1lc3BhY2UgTGF5ZXJcclxuICogQHNlY3Rpb24gUG9wdXAgbWV0aG9kcyBleGFtcGxlXHJcbiAqXHJcbiAqIEFsbCBsYXllcnMgc2hhcmUgYSBzZXQgb2YgbWV0aG9kcyBjb252ZW5pZW50IGZvciBiaW5kaW5nIHBvcHVwcyB0byBpdC5cclxuICpcclxuICogYGBganNcclxuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRQb3B1cCgnSGkgVGhlcmUhJykuYWRkVG8obWFwKTtcclxuICogbGF5ZXIub3BlblBvcHVwKCk7XHJcbiAqIGxheWVyLmNsb3NlUG9wdXAoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIFBvcHVwcyB3aWxsIGFsc28gYmUgYXV0b21hdGljYWxseSBvcGVuZWQgd2hlbiB0aGUgbGF5ZXIgaXMgY2xpY2tlZCBvbiBhbmQgY2xvc2VkIHdoZW4gdGhlIGxheWVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwIG9yIGFub3RoZXIgcG9wdXAgaXMgb3BlbmVkLlxyXG4gKi9cclxuXHJcbi8vIEBzZWN0aW9uIFBvcHVwIG1ldGhvZHNcclxuTGF5ZXIuaW5jbHVkZSh7XHJcblxyXG5cdC8vIEBtZXRob2QgYmluZFBvcHVwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxQb3B1cCwgb3B0aW9ucz86IFBvcHVwIG9wdGlvbnMpOiB0aGlzXHJcblx0Ly8gQmluZHMgYSBwb3B1cCB0byB0aGUgbGF5ZXIgd2l0aCB0aGUgcGFzc2VkIGBjb250ZW50YCBhbmQgc2V0cyB1cCB0aGVcclxuXHQvLyBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLiBJZiBhIGBGdW5jdGlvbmAgaXMgcGFzc2VkIGl0IHdpbGwgcmVjZWl2ZVxyXG5cdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxyXG5cdGJpbmRQb3B1cDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMuX3BvcHVwID0gdGhpcy5faW5pdE92ZXJsYXkoUG9wdXAsIHRoaXMuX3BvcHVwLCBjb250ZW50LCBvcHRpb25zKTtcclxuXHRcdGlmICghdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkKSB7XHJcblx0XHRcdHRoaXMub24oe1xyXG5cdFx0XHRcdGNsaWNrOiB0aGlzLl9vcGVuUG9wdXAsXHJcblx0XHRcdFx0a2V5cHJlc3M6IHRoaXMuX29uS2V5UHJlc3MsXHJcblx0XHRcdFx0cmVtb3ZlOiB0aGlzLmNsb3NlUG9wdXAsXHJcblx0XHRcdFx0bW92ZTogdGhpcy5fbW92ZVBvcHVwXHJcblx0XHRcdH0pO1xyXG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdW5iaW5kUG9wdXAoKTogdGhpc1xyXG5cdC8vIFJlbW92ZXMgdGhlIHBvcHVwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFBvcHVwYC5cclxuXHR1bmJpbmRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMub2ZmKHtcclxuXHRcdFx0XHRjbGljazogdGhpcy5fb3BlblBvcHVwLFxyXG5cdFx0XHRcdGtleXByZXNzOiB0aGlzLl9vbktleVByZXNzLFxyXG5cdFx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVBvcHVwLFxyXG5cdFx0XHRcdG1vdmU6IHRoaXMuX21vdmVQb3B1cFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gbnVsbDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgb3BlblBvcHVwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcclxuXHQvLyBPcGVucyB0aGUgYm91bmQgcG9wdXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCBwb3B1cCBhbmNob3IgaWYgbm8gYGxhdGxuZ2AgaXMgcGFzc2VkLlxyXG5cdG9wZW5Qb3B1cDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApKSB7XHJcblx0XHRcdFx0dGhpcy5fcG9wdXAuX3NvdXJjZSA9IHRoaXM7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMuX3BvcHVwLl9wcmVwYXJlT3BlbihsYXRsbmcgfHwgdGhpcy5fbGF0bG5nKSkge1xyXG5cdFx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIG9uIHRoZSBtYXBcclxuXHRcdFx0XHR0aGlzLl9wb3B1cC5vcGVuT24odGhpcy5fbWFwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjbG9zZVBvcHVwKCk6IHRoaXNcclxuXHQvLyBDbG9zZXMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cclxuXHRjbG9zZVBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuY2xvc2UoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2QgdG9nZ2xlUG9wdXAoKTogdGhpc1xyXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXHJcblx0dG9nZ2xlUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC50b2dnbGUodGhpcyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBAbWV0aG9kIGlzUG9wdXBPcGVuKCk6IGJvb2xlYW5cclxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcG9wdXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cclxuXHRpc1BvcHVwT3BlbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICh0aGlzLl9wb3B1cCA/IHRoaXMuX3BvcHVwLmlzT3BlbigpIDogZmFsc2UpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UG9wdXBDb250ZW50KGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxQb3B1cCk6IHRoaXNcclxuXHQvLyBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBwb3B1cCBib3VuZCB0byB0aGlzIGxheWVyLlxyXG5cdHNldFBvcHVwQ29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBnZXRQb3B1cCgpOiBQb3B1cFxyXG5cdC8vIFJldHVybnMgdGhlIHBvcHVwIGJvdW5kIHRvIHRoaXMgbGF5ZXIuXHJcblx0Z2V0UG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9wb3B1cDtcclxuXHR9LFxyXG5cclxuXHRfb3BlblBvcHVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9wb3B1cCB8fCAhdGhpcy5fbWFwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdC8vIHByZXZlbnQgbWFwIGNsaWNrXHJcblx0XHREb21FdmVudC5zdG9wKGUpO1xyXG5cclxuXHRcdHZhciB0YXJnZXQgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwLl9zb3VyY2UgPT09IHRhcmdldCAmJiAhKHRhcmdldCBpbnN0YW5jZW9mIFBhdGgpKSB7XHJcblx0XHRcdC8vIHRyZWF0IGl0IGxpa2UgYSBtYXJrZXIgYW5kIGZpZ3VyZSBvdXRcclxuXHRcdFx0Ly8gaWYgd2Ugc2hvdWxkIHRvZ2dsZSBpdCBvcGVuL2Nsb3NlZFxyXG5cdFx0XHRpZiAodGhpcy5fbWFwLmhhc0xheWVyKHRoaXMuX3BvcHVwKSkge1xyXG5cdFx0XHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMub3BlblBvcHVwKGUubGF0bG5nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHR0aGlzLl9wb3B1cC5fc291cmNlID0gdGFyZ2V0O1xyXG5cdFx0dGhpcy5vcGVuUG9wdXAoZS5sYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9wb3B1cC5zZXRMYXRMbmcoZS5sYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdF9vbktleVByZXNzOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKGUub3JpZ2luYWxFdmVudC5rZXlDb2RlID09PSAxMykge1xyXG5cdFx0XHR0aGlzLl9vcGVuUG9wdXAoZSk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuIiwiaW1wb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xuaW1wb3J0IHt0b1BvaW50fSBmcm9tICcuLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge01hcH0gZnJvbSAnLi4vbWFwL01hcCc7XG5pbXBvcnQge0xheWVyfSBmcm9tICcuL0xheWVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vY29yZS9VdGlsJztcbmltcG9ydCB7RmVhdHVyZUdyb3VwfSBmcm9tICcuL0ZlYXR1cmVHcm91cCc7XG5cbi8qXG4gKiBAY2xhc3MgVG9vbHRpcFxuICogQGluaGVyaXRzIERpdk92ZXJsYXlcbiAqIEBha2EgTC5Ub29sdGlwXG4gKiBVc2VkIHRvIGRpc3BsYXkgc21hbGwgdGV4dHMgb24gdG9wIG9mIG1hcCBsYXllcnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIElmIHlvdSB3YW50IHRvIGp1c3QgYmluZCBhIHRvb2x0aXAgdG8gbWFya2VyOlxuICpcbiAqIGBgYGpzXG4gKiBtYXJrZXIuYmluZFRvb2x0aXAoXCJteSB0b29sdGlwIHRleHRcIikub3BlblRvb2x0aXAoKTtcbiAqIGBgYFxuICogUGF0aCBvdmVybGF5cyBsaWtlIHBvbHlsaW5lcyBhbHNvIGhhdmUgYSBgYmluZFRvb2x0aXBgIG1ldGhvZC5cbiAqXG4gKiBBIHRvb2x0aXAgY2FuIGJlIGFsc28gc3RhbmRhbG9uZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHRvb2x0aXAgPSBMLnRvb2x0aXAoKVxuICogXHQuc2V0TGF0TG5nKGxhdGxuZylcbiAqIFx0LnNldENvbnRlbnQoJ0hlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHRvb2x0aXAuJylcbiAqIFx0LmFkZFRvKG1hcCk7XG4gKiBgYGBcbiAqIG9yXG4gKiBgYGBqc1xuICogdmFyIHRvb2x0aXAgPSBMLnRvb2x0aXAobGF0bG5nLCB7Y29udGVudDogJ0hlbGxvIHdvcmxkITxiciAvPlRoaXMgaXMgYSBuaWNlIHRvb2x0aXAuJ30pXG4gKiBcdC5hZGRUbyhtYXApO1xuICogYGBgXG4gKlxuICpcbiAqIE5vdGUgYWJvdXQgdG9vbHRpcCBvZmZzZXQuIExlYWZsZXQgdGFrZXMgdHdvIG9wdGlvbnMgaW4gY29uc2lkZXJhdGlvblxuICogZm9yIGNvbXB1dGluZyB0b29sdGlwIG9mZnNldHRpbmc6XG4gKiAtIHRoZSBgb2Zmc2V0YCBUb29sdGlwIG9wdGlvbjogaXQgZGVmYXVsdHMgdG8gWzAsIDBdLCBhbmQgaXQncyBzcGVjaWZpYyB0byBvbmUgdG9vbHRpcC5cbiAqICAgQWRkIGEgcG9zaXRpdmUgeCBvZmZzZXQgdG8gbW92ZSB0aGUgdG9vbHRpcCB0byB0aGUgcmlnaHQsIGFuZCBhIHBvc2l0aXZlIHkgb2Zmc2V0IHRvXG4gKiAgIG1vdmUgaXQgdG8gdGhlIGJvdHRvbS4gTmVnYXRpdmVzIHdpbGwgbW92ZSB0byB0aGUgbGVmdCBhbmQgdG9wLlxuICogLSB0aGUgYHRvb2x0aXBBbmNob3JgIEljb24gb3B0aW9uOiB0aGlzIHdpbGwgb25seSBiZSBjb25zaWRlcmVkIGZvciBNYXJrZXIuIFlvdVxuICogICBzaG91bGQgYWRhcHQgdGhpcyB2YWx1ZSBpZiB5b3UgdXNlIGEgY3VzdG9tIGljb24uXG4gKi9cblxuXG4vLyBAbmFtZXNwYWNlIFRvb2x0aXBcbmV4cG9ydCB2YXIgVG9vbHRpcCA9IERpdk92ZXJsYXkuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIFRvb2x0aXAgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiBwYW5lOiBTdHJpbmcgPSAndG9vbHRpcFBhbmUnXG5cdFx0Ly8gYE1hcCBwYW5lYCB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIGJlIGFkZGVkLlxuXHRcdHBhbmU6ICd0b29sdGlwUGFuZScsXG5cblx0XHQvLyBAb3B0aW9uIG9mZnNldDogUG9pbnQgPSBQb2ludCgwLCAwKVxuXHRcdC8vIE9wdGlvbmFsIG9mZnNldCBvZiB0aGUgdG9vbHRpcCBwb3NpdGlvbi5cblx0XHRvZmZzZXQ6IFswLCAwXSxcblxuXHRcdC8vIEBvcHRpb24gZGlyZWN0aW9uOiBTdHJpbmcgPSAnYXV0bydcblx0XHQvLyBEaXJlY3Rpb24gd2hlcmUgdG8gb3BlbiB0aGUgdG9vbHRpcC4gUG9zc2libGUgdmFsdWVzIGFyZTogYHJpZ2h0YCwgYGxlZnRgLFxuXHRcdC8vIGB0b3BgLCBgYm90dG9tYCwgYGNlbnRlcmAsIGBhdXRvYC5cblx0XHQvLyBgYXV0b2Agd2lsbCBkeW5hbWljYWxseSBzd2l0Y2ggYmV0d2VlbiBgcmlnaHRgIGFuZCBgbGVmdGAgYWNjb3JkaW5nIHRvIHRoZSB0b29sdGlwXG5cdFx0Ly8gcG9zaXRpb24gb24gdGhlIG1hcC5cblx0XHRkaXJlY3Rpb246ICdhdXRvJyxcblxuXHRcdC8vIEBvcHRpb24gcGVybWFuZW50OiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIHRvIG9wZW4gdGhlIHRvb2x0aXAgcGVybWFuZW50bHkgb3Igb25seSBvbiBtb3VzZW92ZXIuXG5cdFx0cGVybWFuZW50OiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gc3RpY2t5OiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBJZiB0cnVlLCB0aGUgdG9vbHRpcCB3aWxsIGZvbGxvdyB0aGUgbW91c2UgaW5zdGVhZCBvZiBiZWluZyBmaXhlZCBhdCB0aGUgZmVhdHVyZSBjZW50ZXIuXG5cdFx0c3RpY2t5OiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gb3BhY2l0eTogTnVtYmVyID0gMC45XG5cdFx0Ly8gVG9vbHRpcCBjb250YWluZXIgb3BhY2l0eS5cblx0XHRvcGFjaXR5OiAwLjlcblx0fSxcblxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuXHRcdERpdk92ZXJsYXkucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcblx0XHR0aGlzLnNldE9wYWNpdHkodGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG5cdFx0Ly8gRmlyZWQgd2hlbiBhIHRvb2x0aXAgaXMgb3BlbmVkIGluIHRoZSBtYXAuXG5cdFx0bWFwLmZpcmUoJ3Rvb2x0aXBvcGVuJywge3Rvb2x0aXA6IHRoaXN9KTtcblxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcblx0XHRcdHRoaXMuYWRkRXZlbnRQYXJlbnQodGhpcy5fc291cmNlKTtcblxuXHRcdFx0Ly8gQG5hbWVzcGFjZSBMYXllclxuXHRcdFx0Ly8gQHNlY3Rpb24gVG9vbHRpcCBldmVudHNcblx0XHRcdC8vIEBldmVudCB0b29sdGlwb3BlbjogVG9vbHRpcEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIG9wZW5lZC5cblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwb3BlbicsIHt0b29sdGlwOiB0aGlzfSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0RGl2T3ZlcmxheS5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuXG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXBcblx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdC8vIEBldmVudCB0b29sdGlwY2xvc2U6IFRvb2x0aXBFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0b29sdGlwIGluIHRoZSBtYXAgaXMgY2xvc2VkLlxuXHRcdG1hcC5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30pO1xuXG5cdFx0aWYgKHRoaXMuX3NvdXJjZSkge1xuXHRcdFx0dGhpcy5yZW1vdmVFdmVudFBhcmVudCh0aGlzLl9zb3VyY2UpO1xuXG5cdFx0XHQvLyBAbmFtZXNwYWNlIExheWVyXG5cdFx0XHQvLyBAc2VjdGlvbiBUb29sdGlwIGV2ZW50c1xuXHRcdFx0Ly8gQGV2ZW50IHRvb2x0aXBjbG9zZTogVG9vbHRpcEV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGlzIGNsb3NlZC5cblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCd0b29sdGlwY2xvc2UnLCB7dG9vbHRpcDogdGhpc30sIHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0gRGl2T3ZlcmxheS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5wZXJtYW5lbnQpIHtcblx0XHRcdGV2ZW50cy5wcmVjbGljayA9IHRoaXMuY2xvc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC10b29sdGlwJyxcblx0XHQgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgJyAnICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgJycpICsgJyBsZWFmbGV0LXpvb20tJyArICh0aGlzLl96b29tQW5pbWF0ZWQgPyAnYW5pbWF0ZWQnIDogJ2hpZGUnKTtcblxuXHRcdHRoaXMuX2NvbnRlbnROb2RlID0gdGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSk7XG5cblx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3Rvb2x0aXAnKTtcblx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdpZCcsICdsZWFmbGV0LXRvb2x0aXAtJyArIFV0aWwuc3RhbXAodGhpcykpO1xuXHR9LFxuXG5cdF91cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9hZGp1c3RQYW46IGZ1bmN0aW9uICgpIHt9LFxuXG5cdF9zZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvcykge1xuXHRcdHZhciBzdWJYLCBzdWJZLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgY2VudGVyUG9pbnQgPSBtYXAubGF0TG5nVG9Db250YWluZXJQb2ludChtYXAuZ2V0Q2VudGVyKCkpLFxuXHRcdCAgICB0b29sdGlwUG9pbnQgPSBtYXAubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQocG9zKSxcblx0XHQgICAgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbixcblx0XHQgICAgdG9vbHRpcFdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoLFxuXHRcdCAgICB0b29sdGlwSGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodCxcblx0XHQgICAgb2Zmc2V0ID0gdG9Qb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KSxcblx0XHQgICAgYW5jaG9yID0gdGhpcy5fZ2V0QW5jaG9yKCk7XG5cblx0XHRpZiAoZGlyZWN0aW9uID09PSAndG9wJykge1xuXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aCAvIDI7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodDtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdHN1YlggPSB0b29sdGlwV2lkdGggLyAyO1xuXHRcdFx0c3ViWSA9IDA7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoIC8gMjtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcblx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0c3ViWCA9IDA7XG5cdFx0XHRzdWJZID0gdG9vbHRpcEhlaWdodCAvIDI7XG5cdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuXHRcdFx0c3ViWCA9IHRvb2x0aXBXaWR0aDtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcblx0XHR9IGVsc2UgaWYgKHRvb2x0aXBQb2ludC54IDwgY2VudGVyUG9pbnQueCkge1xuXHRcdFx0ZGlyZWN0aW9uID0gJ3JpZ2h0Jztcblx0XHRcdHN1YlggPSAwO1xuXHRcdFx0c3ViWSA9IHRvb2x0aXBIZWlnaHQgLyAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXJlY3Rpb24gPSAnbGVmdCc7XG5cdFx0XHRzdWJYID0gdG9vbHRpcFdpZHRoICsgKG9mZnNldC54ICsgYW5jaG9yLngpICogMjtcblx0XHRcdHN1YlkgPSB0b29sdGlwSGVpZ2h0IC8gMjtcblx0XHR9XG5cblx0XHRwb3MgPSBwb3Muc3VidHJhY3QodG9Qb2ludChzdWJYLCBzdWJZLCB0cnVlKSkuYWRkKG9mZnNldCkuYWRkKGFuY2hvcik7XG5cblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1yaWdodCcpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC10b29sdGlwLWxlZnQnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC10b3AnKTtcblx0XHREb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC1ib3R0b20nKTtcblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdG9vbHRpcC0nICsgZGlyZWN0aW9uKTtcblx0XHREb21VdGlsLnNldFBvc2l0aW9uKGNvbnRhaW5lciwgcG9zKTtcblx0fSxcblxuXHRfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xuXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdH0sXG5cblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCBvcGFjaXR5KTtcblx0XHR9XG5cdH0sXG5cblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIGUuem9vbSwgZS5jZW50ZXIpO1xuXHRcdHRoaXMuX3NldFBvc2l0aW9uKHBvcyk7XG5cdH0sXG5cblx0X2dldEFuY2hvcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFdoZXJlIHNob3VsZCB3ZSBhbmNob3IgdGhlIHRvb2x0aXAgb24gdGhlIHNvdXJjZSBsYXllcj9cblx0XHRyZXR1cm4gdG9Qb2ludCh0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yICYmICF0aGlzLm9wdGlvbnMuc3RpY2t5ID8gdGhpcy5fc291cmNlLl9nZXRUb29sdGlwQW5jaG9yKCkgOiBbMCwgMF0pO1xuXHR9XG5cbn0pO1xuXG4vLyBAbmFtZXNwYWNlIFRvb2x0aXBcbi8vIEBmYWN0b3J5IEwudG9vbHRpcChvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zLCBzb3VyY2U/OiBMYXllcilcbi8vIEluc3RhbnRpYXRlcyBhIGBUb29sdGlwYCBvYmplY3QgZ2l2ZW4gYW4gb3B0aW9uYWwgYG9wdGlvbnNgIG9iamVjdCB0aGF0IGRlc2NyaWJlcyBpdHMgYXBwZWFyYW5jZSBhbmQgbG9jYXRpb24gYW5kIGFuIG9wdGlvbmFsIGBzb3VyY2VgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gdGFnIHRoZSB0b29sdGlwIHdpdGggYSByZWZlcmVuY2UgdG8gdGhlIExheWVyIHRvIHdoaWNoIGl0IHJlZmVycy5cbi8vIEBhbHRlcm5hdGl2ZVxuLy8gQGZhY3RvcnkgTC50b29sdGlwKGxhdGxuZzogTGF0TG5nLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKVxuLy8gSW5zdGFudGlhdGVzIGEgYFRvb2x0aXBgIG9iamVjdCBnaXZlbiBgbGF0bG5nYCB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIG9wZW4gYW5kIGFuIG9wdGlvbmFsIGBvcHRpb25zYCBvYmplY3QgdGhhdCBkZXNjcmliZXMgaXRzIGFwcGVhcmFuY2UgYW5kIGxvY2F0aW9uLlxuZXhwb3J0IHZhciB0b29sdGlwID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuXHRyZXR1cm4gbmV3IFRvb2x0aXAob3B0aW9ucywgc291cmNlKTtcbn07XG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBNZXRob2RzIGZvciBMYXllcnMgYW5kIENvbnRyb2xzXG5NYXAuaW5jbHVkZSh7XG5cblx0Ly8gQG1ldGhvZCBvcGVuVG9vbHRpcCh0b29sdGlwOiBUb29sdGlwKTogdGhpc1xuXHQvLyBPcGVucyB0aGUgc3BlY2lmaWVkIHRvb2x0aXAuXG5cdC8vIEBhbHRlcm5hdGl2ZVxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudCwgbGF0bG5nOiBMYXRMbmcsIG9wdGlvbnM/OiBUb29sdGlwIG9wdGlvbnMpOiB0aGlzXG5cdC8vIENyZWF0ZXMgYSB0b29sdGlwIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZW50IGFuZCBvcHRpb25zIGFuZCBvcGVuIGl0LlxuXHRvcGVuVG9vbHRpcDogZnVuY3Rpb24gKHRvb2x0aXAsIGxhdGxuZywgb3B0aW9ucykge1xuXHRcdHRoaXMuX2luaXRPdmVybGF5KFRvb2x0aXAsIHRvb2x0aXAsIGxhdGxuZywgb3B0aW9ucylcblx0XHQgIC5vcGVuT24odGhpcyk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGNsb3NlVG9vbHRpcCh0b29sdGlwOiBUb29sdGlwKTogdGhpc1xuXHQvLyBDbG9zZXMgdGhlIHRvb2x0aXAgZ2l2ZW4gYXMgcGFyYW1ldGVyLlxuXHRjbG9zZVRvb2x0aXA6IGZ1bmN0aW9uICh0b29sdGlwKSB7XG5cdFx0dG9vbHRpcC5jbG9zZSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cbn0pO1xuXG4vKlxuICogQG5hbWVzcGFjZSBMYXllclxuICogQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzIGV4YW1wbGVcbiAqXG4gKiBBbGwgbGF5ZXJzIHNoYXJlIGEgc2V0IG9mIG1ldGhvZHMgY29udmVuaWVudCBmb3IgYmluZGluZyB0b29sdGlwcyB0byBpdC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxheWVyID0gTC5Qb2x5Z29uKGxhdGxuZ3MpLmJpbmRUb29sdGlwKCdIaSBUaGVyZSEnKS5hZGRUbyhtYXApO1xuICogbGF5ZXIub3BlblRvb2x0aXAoKTtcbiAqIGxheWVyLmNsb3NlVG9vbHRpcCgpO1xuICogYGBgXG4gKi9cblxuLy8gQHNlY3Rpb24gVG9vbHRpcCBtZXRob2RzXG5MYXllci5pbmNsdWRlKHtcblxuXHQvLyBAbWV0aG9kIGJpbmRUb29sdGlwKGNvbnRlbnQ6IFN0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbnxUb29sdGlwLCBvcHRpb25zPzogVG9vbHRpcCBvcHRpb25zKTogdGhpc1xuXHQvLyBCaW5kcyBhIHRvb2x0aXAgdG8gdGhlIGxheWVyIHdpdGggdGhlIHBhc3NlZCBgY29udGVudGAgYW5kIHNldHMgdXAgdGhlXG5cdC8vIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuIElmIGEgYEZ1bmN0aW9uYCBpcyBwYXNzZWQgaXQgd2lsbCByZWNlaXZlXG5cdC8vIHRoZSBsYXllciBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHNob3VsZCByZXR1cm4gYSBgU3RyaW5nYCBvciBgSFRNTEVsZW1lbnRgLlxuXHRiaW5kVG9vbHRpcDogZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcblxuXHRcdGlmICh0aGlzLl90b29sdGlwICYmIHRoaXMuaXNUb29sdGlwT3BlbigpKSB7XG5cdFx0XHR0aGlzLnVuYmluZFRvb2x0aXAoKTtcblx0XHR9XG5cblx0XHR0aGlzLl90b29sdGlwID0gdGhpcy5faW5pdE92ZXJsYXkoVG9vbHRpcCwgdGhpcy5fdG9vbHRpcCwgY29udGVudCwgb3B0aW9ucyk7XG5cdFx0dGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnMoKTtcblxuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50ICYmIHRoaXMuX21hcCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIodGhpcykpIHtcblx0XHRcdHRoaXMub3BlblRvb2x0aXAoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIHVuYmluZFRvb2x0aXAoKTogdGhpc1xuXHQvLyBSZW1vdmVzIHRoZSB0b29sdGlwIHByZXZpb3VzbHkgYm91bmQgd2l0aCBgYmluZFRvb2x0aXBgLlxuXHR1bmJpbmRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKHRydWUpO1xuXHRcdFx0dGhpcy5jbG9zZVRvb2x0aXAoKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfaW5pdFRvb2x0aXBJbnRlcmFjdGlvbnM6IGZ1bmN0aW9uIChyZW1vdmUpIHtcblx0XHRpZiAoIXJlbW92ZSAmJiB0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZCkgeyByZXR1cm47IH1cblx0XHR2YXIgb25PZmYgPSByZW1vdmUgPyAnb2ZmJyA6ICdvbicsXG5cdFx0ICAgIGV2ZW50cyA9IHtcblx0XHRcdHJlbW92ZTogdGhpcy5jbG9zZVRvb2x0aXAsXG5cdFx0XHRtb3ZlOiB0aGlzLl9tb3ZlVG9vbHRpcFxuXHRcdCAgICB9O1xuXHRcdGlmICghdGhpcy5fdG9vbHRpcC5vcHRpb25zLnBlcm1hbmVudCkge1xuXHRcdFx0ZXZlbnRzLm1vdXNlb3ZlciA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdFx0ZXZlbnRzLm1vdXNlb3V0ID0gdGhpcy5jbG9zZVRvb2x0aXA7XG5cdFx0XHRldmVudHMuY2xpY2sgPSB0aGlzLl9vcGVuVG9vbHRpcDtcblx0XHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdFx0dGhpcy5fYWRkRm9jdXNMaXN0ZW5lcnMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV2ZW50cy5hZGQgPSB0aGlzLl9hZGRGb2N1c0xpc3RlbmVycztcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXZlbnRzLmFkZCA9IHRoaXMuX29wZW5Ub29sdGlwO1xuXHRcdH1cblx0XHRpZiAodGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSkge1xuXHRcdFx0ZXZlbnRzLm1vdXNlbW92ZSA9IHRoaXMuX21vdmVUb29sdGlwO1xuXHRcdH1cblx0XHR0aGlzW29uT2ZmXShldmVudHMpO1xuXHRcdHRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkID0gIXJlbW92ZTtcblx0fSxcblxuXHQvLyBAbWV0aG9kIG9wZW5Ub29sdGlwKGxhdGxuZz86IExhdExuZyk6IHRoaXNcblx0Ly8gT3BlbnMgdGhlIGJvdW5kIHRvb2x0aXAgYXQgdGhlIHNwZWNpZmllZCBgbGF0bG5nYCBvciBhdCB0aGUgZGVmYXVsdCB0b29sdGlwIGFuY2hvciBpZiBubyBgbGF0bG5nYCBpcyBwYXNzZWQuXG5cdG9wZW5Ub29sdGlwOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBGZWF0dXJlR3JvdXApKSB7XG5cdFx0XHRcdHRoaXMuX3Rvb2x0aXAuX3NvdXJjZSA9IHRoaXM7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fdG9vbHRpcC5fcHJlcGFyZU9wZW4obGF0bG5nKSkge1xuXHRcdFx0XHQvLyBvcGVuIHRoZSB0b29sdGlwIG9uIHRoZSBtYXBcblx0XHRcdFx0dGhpcy5fdG9vbHRpcC5vcGVuT24odGhpcy5fbWFwKTtcblxuXHRcdFx0XHRpZiAodGhpcy5nZXRFbGVtZW50KSB7XG5cdFx0XHRcdFx0dGhpcy5fc2V0QXJpYURlc2NyaWJlZEJ5T25MYXllcih0aGlzKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmVhY2hMYXllcikge1xuXHRcdFx0XHRcdHRoaXMuZWFjaExheWVyKHRoaXMuX3NldEFyaWFEZXNjcmliZWRCeU9uTGF5ZXIsIHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgY2xvc2VUb29sdGlwKCk6IHRoaXNcblx0Ly8gQ2xvc2VzIHRoZSB0b29sdGlwIGJvdW5kIHRvIHRoaXMgbGF5ZXIgaWYgaXQgaXMgb3Blbi5cblx0Y2xvc2VUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHJldHVybiB0aGlzLl90b29sdGlwLmNsb3NlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEBtZXRob2QgdG9nZ2xlVG9vbHRpcCgpOiB0aGlzXG5cdC8vIE9wZW5zIG9yIGNsb3NlcyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cblx0dG9nZ2xlVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90b29sdGlwKSB7XG5cdFx0XHR0aGlzLl90b29sdGlwLnRvZ2dsZSh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBpc1Rvb2x0aXBPcGVuKCk6IGJvb2xlYW5cblx0Ly8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllciBpcyBjdXJyZW50bHkgb3Blbi5cblx0aXNUb29sdGlwT3BlbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90b29sdGlwLmlzT3BlbigpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0VG9vbHRpcENvbnRlbnQoY29udGVudDogU3RyaW5nfEhUTUxFbGVtZW50fFRvb2x0aXApOiB0aGlzXG5cdC8vIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAgYm91bmQgdG8gdGhpcyBsYXllci5cblx0c2V0VG9vbHRpcENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG5cdFx0aWYgKHRoaXMuX3Rvb2x0aXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudChjb250ZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRUb29sdGlwKCk6IFRvb2x0aXBcblx0Ly8gUmV0dXJucyB0aGUgdG9vbHRpcCBib3VuZCB0byB0aGlzIGxheWVyLlxuXHRnZXRUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Rvb2x0aXA7XG5cdH0sXG5cblx0X2FkZEZvY3VzTGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuZ2V0RWxlbWVudCkge1xuXHRcdFx0dGhpcy5fYWRkRm9jdXNMaXN0ZW5lcnNPbkxheWVyKHRoaXMpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5lYWNoTGF5ZXIpIHtcblx0XHRcdHRoaXMuZWFjaExheWVyKHRoaXMuX2FkZEZvY3VzTGlzdGVuZXJzT25MYXllciwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9hZGRGb2N1c0xpc3RlbmVyc09uTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBlbCA9IHR5cGVvZiBsYXllci5nZXRFbGVtZW50ID09PSAnZnVuY3Rpb24nICYmIGxheWVyLmdldEVsZW1lbnQoKTtcblx0XHRpZiAoZWwpIHtcblx0XHRcdERvbUV2ZW50Lm9uKGVsLCAnZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuX3Rvb2x0aXAuX3NvdXJjZSA9IGxheWVyO1xuXHRcdFx0XHR0aGlzLm9wZW5Ub29sdGlwKCk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHRcdERvbUV2ZW50Lm9uKGVsLCAnYmx1cicsIHRoaXMuY2xvc2VUb29sdGlwLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldEFyaWFEZXNjcmliZWRCeU9uTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBlbCA9IHR5cGVvZiBsYXllci5nZXRFbGVtZW50ID09PSAnZnVuY3Rpb24nICYmIGxheWVyLmdldEVsZW1lbnQoKTtcblx0XHRpZiAoZWwpIHtcblx0XHRcdGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsIHRoaXMuX3Rvb2x0aXAuX2NvbnRhaW5lci5pZCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0X29wZW5Ub29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghdGhpcy5fdG9vbHRpcCB8fCAhdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIG1hcCBpcyBtb3ZpbmcsIHdlIHdpbGwgc2hvdyB0aGUgdG9vbHRpcCBhZnRlciBpdCdzIGRvbmUuXG5cdFx0aWYgKHRoaXMuX21hcC5kcmFnZ2luZyAmJiB0aGlzLl9tYXAuZHJhZ2dpbmcubW92aW5nKCkgJiYgIXRoaXMuX29wZW5PbmNlRmxhZykge1xuXHRcdFx0dGhpcy5fb3Blbk9uY2VGbGFnID0gdHJ1ZTtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdHRoaXMuX21hcC5vbmNlKCdtb3ZlZW5kJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGF0Ll9vcGVuT25jZUZsYWcgPSBmYWxzZTtcblx0XHRcdFx0dGhhdC5fb3BlblRvb2x0aXAoZSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl90b29sdGlwLl9zb3VyY2UgPSBlLmxheWVyIHx8IGUudGFyZ2V0O1xuXG5cdFx0dGhpcy5vcGVuVG9vbHRpcCh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ID8gZS5sYXRsbmcgOiB1bmRlZmluZWQpO1xuXHR9LFxuXG5cdF9tb3ZlVG9vbHRpcDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF0bG5nID0gZS5sYXRsbmcsIGNvbnRhaW5lclBvaW50LCBsYXllclBvaW50O1xuXHRcdGlmICh0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5ICYmIGUub3JpZ2luYWxFdmVudCkge1xuXHRcdFx0Y29udGFpbmVyUG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZS5vcmlnaW5hbEV2ZW50KTtcblx0XHRcdGxheWVyUG9pbnQgPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoY29udGFpbmVyUG9pbnQpO1xuXHRcdFx0bGF0bG5nID0gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcblx0XHR9XG5cdFx0dGhpcy5fdG9vbHRpcC5zZXRMYXRMbmcobGF0bG5nKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge0ljb259IGZyb20gJy4vSWNvbic7XG5pbXBvcnQge3RvUG9pbnQgYXMgcG9pbnR9IGZyb20gJy4uLy4uL2dlb21ldHJ5L1BvaW50JztcbmltcG9ydCB7ZW1wdHl9IGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcblxuLypcbiAqIEBjbGFzcyBEaXZJY29uXG4gKiBAYWthIEwuRGl2SWNvblxuICogQGluaGVyaXRzIEljb25cbiAqXG4gKiBSZXByZXNlbnRzIGEgbGlnaHR3ZWlnaHQgaWNvbiBmb3IgbWFya2VycyB0aGF0IHVzZXMgYSBzaW1wbGUgYDxkaXY+YFxuICogZWxlbWVudCBpbnN0ZWFkIG9mIGFuIGltYWdlLiBJbmhlcml0cyBmcm9tIGBJY29uYCBidXQgaWdub3JlcyB0aGUgYGljb25VcmxgIGFuZCBzaGFkb3cgb3B0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciBteUljb24gPSBMLmRpdkljb24oe2NsYXNzTmFtZTogJ215LWRpdi1pY29uJ30pO1xuICogLy8geW91IGNhbiBzZXQgLm15LWRpdi1pY29uIHN0eWxlcyBpbiBDU1NcbiAqXG4gKiBMLm1hcmtlcihbNTAuNTA1LCAzMC41N10sIHtpY29uOiBteUljb259KS5hZGRUbyhtYXApO1xuICogYGBgXG4gKlxuICogQnkgZGVmYXVsdCwgaXQgaGFzIGEgJ2xlYWZsZXQtZGl2LWljb24nIENTUyBjbGFzcyBhbmQgaXMgc3R5bGVkIGFzIGEgbGl0dGxlIHdoaXRlIHNxdWFyZSB3aXRoIGEgc2hhZG93LlxuICovXG5cbmV4cG9ydCB2YXIgRGl2SWNvbiA9IEljb24uZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdC8vIEBzZWN0aW9uXG5cdFx0Ly8gQGFrYSBEaXZJY29uIG9wdGlvbnNcblx0XHRpY29uU2l6ZTogWzEyLCAxMl0sIC8vIGFsc28gY2FuIGJlIHNldCB0aHJvdWdoIENTU1xuXG5cdFx0Ly8gaWNvbkFuY2hvcjogKFBvaW50KSxcblx0XHQvLyBwb3B1cEFuY2hvcjogKFBvaW50KSxcblxuXHRcdC8vIEBvcHRpb24gaHRtbDogU3RyaW5nfEhUTUxFbGVtZW50ID0gJydcblx0XHQvLyBDdXN0b20gSFRNTCBjb2RlIHRvIHB1dCBpbnNpZGUgdGhlIGRpdiBlbGVtZW50LCBlbXB0eSBieSBkZWZhdWx0LiBBbHRlcm5hdGl2ZWx5LFxuXHRcdC8vIGFuIGluc3RhbmNlIG9mIGBIVE1MRWxlbWVudGAuXG5cdFx0aHRtbDogZmFsc2UsXG5cblx0XHQvLyBAb3B0aW9uIGJnUG9zOiBQb2ludCA9IFswLCAwXVxuXHRcdC8vIE9wdGlvbmFsIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBiYWNrZ3JvdW5kLCBpbiBwaXhlbHNcblx0XHRiZ1BvczogbnVsbCxcblxuXHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24nXG5cdH0sXG5cblx0Y3JlYXRlSWNvbjogZnVuY3Rpb24gKG9sZEljb24pIHtcblx0XHR2YXIgZGl2ID0gKG9sZEljb24gJiYgb2xkSWNvbi50YWdOYW1lID09PSAnRElWJykgPyBvbGRJY29uIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRpZiAob3B0aW9ucy5odG1sIGluc3RhbmNlb2YgRWxlbWVudCkge1xuXHRcdFx0ZW1wdHkoZGl2KTtcblx0XHRcdGRpdi5hcHBlbmRDaGlsZChvcHRpb25zLmh0bWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXYuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sICE9PSBmYWxzZSA/IG9wdGlvbnMuaHRtbCA6ICcnO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmJnUG9zKSB7XG5cdFx0XHR2YXIgYmdQb3MgPSBwb2ludChvcHRpb25zLmJnUG9zKTtcblx0XHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAoLWJnUG9zLngpICsgJ3B4ICcgKyAoLWJnUG9zLnkpICsgJ3B4Jztcblx0XHR9XG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJyk7XG5cblx0XHRyZXR1cm4gZGl2O1xuXHR9LFxuXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59KTtcblxuLy8gQGZhY3RvcnkgTC5kaXZJY29uKG9wdGlvbnM6IERpdkljb24gb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBgRGl2SWNvbmAgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBkaXZJY29uKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBEaXZJY29uKG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHtJY29ufSBmcm9tICcuL0ljb24nO1xuZXhwb3J0IHtpY29ufSBmcm9tICcuL0ljb24nO1xuaW1wb3J0IHtJY29uRGVmYXVsdH0gZnJvbSAnLi9JY29uLkRlZmF1bHQnO1xuSWNvbi5EZWZhdWx0ID0gSWNvbkRlZmF1bHQ7XG5leHBvcnQge0ljb259O1xuXG5leHBvcnQge0Rpdkljb24sIGRpdkljb259IGZyb20gJy4vRGl2SWNvbic7XG5leHBvcnQge01hcmtlciwgbWFya2VyfSBmcm9tICcuL01hcmtlcic7XG4iLCJpbXBvcnQge0xheWVyfSBmcm9tICcuLi9MYXllcic7XG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQge1BvaW50fSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Qb2ludCc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcbmltcG9ydCB7TGF0TG5nQm91bmRzLCB0b0xhdExuZ0JvdW5kcyBhcyBsYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuXG4vKlxuICogQGNsYXNzIEdyaWRMYXllclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuR3JpZExheWVyXG4gKlxuICogR2VuZXJpYyBjbGFzcyBmb3IgaGFuZGxpbmcgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMuIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCB0aWxlIGxheWVycyBhbmQgcmVwbGFjZXMgYFRpbGVMYXllci5DYW52YXNgLlxuICogR3JpZExheWVyIGNhbiBiZSBleHRlbmRlZCB0byBjcmVhdGUgYSB0aWxlZCBncmlkIG9mIEhUTUwgZWxlbWVudHMgbGlrZSBgPGNhbnZhcz5gLCBgPGltZz5gIG9yIGA8ZGl2PmAuIEdyaWRMYXllciB3aWxsIGhhbmRsZSBjcmVhdGluZyBhbmQgYW5pbWF0aW5nIHRoZXNlIERPTSBlbGVtZW50cyBmb3IgeW91LlxuICpcbiAqXG4gKiBAc2VjdGlvbiBTeW5jaHJvbm91cyB1c2FnZVxuICogQGV4YW1wbGVcbiAqXG4gKiBUbyBjcmVhdGUgYSBjdXN0b20gbGF5ZXIsIGV4dGVuZCBHcmlkTGF5ZXIgYW5kIGltcGxlbWVudCB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLCB3aGljaCB3aWxsIGJlIHBhc3NlZCBhIGBQb2ludGAgb2JqZWN0IHdpdGggdGhlIGB4YCwgYHlgLCBhbmQgYHpgICh6b29tIGxldmVsKSBjb29yZGluYXRlcyB0byBkcmF3IHlvdXIgdGlsZS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMpe1xuICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICpcbiAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gKlxuICogICAgICAgICAvLyBnZXQgYSBjYW52YXMgY29udGV4dCBhbmQgZHJhdyBzb21ldGhpbmcgb24gaXQgdXNpbmcgY29vcmRzLngsIGNvb3Jkcy55IGFuZCBjb29yZHMuelxuICogICAgICAgICB2YXIgY3R4ID0gdGlsZS5nZXRDb250ZXh0KCcyZCcpO1xuICpcbiAqICAgICAgICAgLy8gcmV0dXJuIHRoZSB0aWxlIHNvIGl0IGNhbiBiZSByZW5kZXJlZCBvbiBzY3JlZW5cbiAqICAgICAgICAgcmV0dXJuIHRpbGU7XG4gKiAgICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAc2VjdGlvbiBBc3luY2hyb25vdXMgdXNhZ2VcbiAqIEBleGFtcGxlXG4gKlxuICogVGlsZSBjcmVhdGlvbiBjYW4gYWxzbyBiZSBhc3luY2hyb25vdXMsIHRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYSB0aGlyZC1wYXJ0eSBkcmF3aW5nIGxpYnJhcnkuIE9uY2UgdGhlIHRpbGUgaXMgZmluaXNoZWQgZHJhd2luZyBpdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBgZG9uZSgpYCBjYWxsYmFjay5cbiAqXG4gKiBgYGBqc1xuICogdmFyIENhbnZhc0xheWVyID0gTC5HcmlkTGF5ZXIuZXh0ZW5kKHtcbiAqICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbihjb29yZHMsIGRvbmUpe1xuICogICAgICAgICB2YXIgZXJyb3I7XG4gKlxuICogICAgICAgICAvLyBjcmVhdGUgYSA8Y2FudmFzPiBlbGVtZW50IGZvciBkcmF3aW5nXG4gKiAgICAgICAgIHZhciB0aWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnY2FudmFzJywgJ2xlYWZsZXQtdGlsZScpO1xuICpcbiAqICAgICAgICAgLy8gc2V0dXAgdGlsZSB3aWR0aCBhbmQgaGVpZ2h0IGFjY29yZGluZyB0byB0aGUgb3B0aW9uc1xuICogICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemUoKTtcbiAqICAgICAgICAgdGlsZS53aWR0aCA9IHNpemUueDtcbiAqICAgICAgICAgdGlsZS5oZWlnaHQgPSBzaXplLnk7XG4gKlxuICogICAgICAgICAvLyBkcmF3IHNvbWV0aGluZyBhc3luY2hyb25vdXNseSBhbmQgcGFzcyB0aGUgdGlsZSB0byB0aGUgZG9uZSgpIGNhbGxiYWNrXG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBkb25lKGVycm9yLCB0aWxlKTtcbiAqICAgICAgICAgfSwgMTAwMCk7XG4gKlxuICogICAgICAgICByZXR1cm4gdGlsZTtcbiAqICAgICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBzZWN0aW9uXG4gKi9cblxuXG5leHBvcnQgdmFyIEdyaWRMYXllciA9IExheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBHcmlkTGF5ZXIgb3B0aW9uc1xuXHRvcHRpb25zOiB7XG5cdFx0Ly8gQG9wdGlvbiB0aWxlU2l6ZTogTnVtYmVyfFBvaW50ID0gMjU2XG5cdFx0Ly8gV2lkdGggYW5kIGhlaWdodCBvZiB0aWxlcyBpbiB0aGUgZ3JpZC4gVXNlIGEgbnVtYmVyIGlmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGVxdWFsLCBvciBgTC5wb2ludCh3aWR0aCwgaGVpZ2h0KWAgb3RoZXJ3aXNlLlxuXHRcdHRpbGVTaXplOiAyNTYsXG5cblx0XHQvLyBAb3B0aW9uIG9wYWNpdHk6IE51bWJlciA9IDEuMFxuXHRcdC8vIE9wYWNpdHkgb2YgdGhlIHRpbGVzLiBDYW4gYmUgdXNlZCBpbiB0aGUgYGNyZWF0ZVRpbGUoKWAgZnVuY3Rpb24uXG5cdFx0b3BhY2l0eTogMSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlbklkbGU6IEJvb2xlYW4gPSAoZGVwZW5kcylcblx0XHQvLyBMb2FkIG5ldyB0aWxlcyBvbmx5IHdoZW4gcGFubmluZyBlbmRzLlxuXHRcdC8vIGB0cnVlYCBieSBkZWZhdWx0IG9uIG1vYmlsZSBicm93c2VycywgaW4gb3JkZXIgdG8gYXZvaWQgdG9vIG1hbnkgcmVxdWVzdHMgYW5kIGtlZXAgc21vb3RoIG5hdmlnYXRpb24uXG5cdFx0Ly8gYGZhbHNlYCBvdGhlcndpc2UgaW4gb3JkZXIgdG8gZGlzcGxheSBuZXcgdGlsZXMgX2R1cmluZ18gcGFubmluZywgc2luY2UgaXQgaXMgZWFzeSB0byBwYW4gb3V0c2lkZSB0aGVcblx0XHQvLyBbYGtlZXBCdWZmZXJgXSgjZ3JpZGxheWVyLWtlZXBidWZmZXIpIG9wdGlvbiBpbiBkZXNrdG9wIGJyb3dzZXJzLlxuXHRcdHVwZGF0ZVdoZW5JZGxlOiBCcm93c2VyLm1vYmlsZSxcblxuXHRcdC8vIEBvcHRpb24gdXBkYXRlV2hlblpvb21pbmc6IEJvb2xlYW4gPSB0cnVlXG5cdFx0Ly8gQnkgZGVmYXVsdCwgYSBzbW9vdGggem9vbSBhbmltYXRpb24gKGR1cmluZyBhIFt0b3VjaCB6b29tXSgjbWFwLXRvdWNoem9vbSkgb3IgYSBbYGZseVRvKClgXSgjbWFwLWZseXRvKSkgd2lsbCB1cGRhdGUgZ3JpZCBsYXllcnMgZXZlcnkgaW50ZWdlciB6b29tIGxldmVsLiBTZXR0aW5nIHRoaXMgb3B0aW9uIHRvIGBmYWxzZWAgd2lsbCB1cGRhdGUgdGhlIGdyaWQgbGF5ZXIgb25seSB3aGVuIHRoZSBzbW9vdGggYW5pbWF0aW9uIGVuZHMuXG5cdFx0dXBkYXRlV2hlblpvb21pbmc6IHRydWUsXG5cblx0XHQvLyBAb3B0aW9uIHVwZGF0ZUludGVydmFsOiBOdW1iZXIgPSAyMDBcblx0XHQvLyBUaWxlcyB3aWxsIG5vdCB1cGRhdGUgbW9yZSB0aGFuIG9uY2UgZXZlcnkgYHVwZGF0ZUludGVydmFsYCBtaWxsaXNlY29uZHMgd2hlbiBwYW5uaW5nLlxuXHRcdHVwZGF0ZUludGVydmFsOiAyMDAsXG5cblx0XHQvLyBAb3B0aW9uIHpJbmRleDogTnVtYmVyID0gMVxuXHRcdC8vIFRoZSBleHBsaWNpdCB6SW5kZXggb2YgdGhlIHRpbGUgbGF5ZXIuXG5cdFx0ekluZGV4OiAxLFxuXG5cdFx0Ly8gQG9wdGlvbiBib3VuZHM6IExhdExuZ0JvdW5kcyA9IHVuZGVmaW5lZFxuXHRcdC8vIElmIHNldCwgdGlsZXMgd2lsbCBvbmx5IGJlIGxvYWRlZCBpbnNpZGUgdGhlIHNldCBgTGF0TG5nQm91bmRzYC5cblx0XHRib3VuZHM6IG51bGwsXG5cblx0XHQvLyBAb3B0aW9uIG1pblpvb206IE51bWJlciA9IDBcblx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cblx0XHRtaW5ab29tOiAwLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVwIHRvIHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZSBkaXNwbGF5ZWQgKGluY2x1c2l2ZSkuXG5cdFx0bWF4Wm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBtYXhOYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBNYXhpbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG5cdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBoaWdoZXIgdGhhbiBgbWF4TmF0aXZlWm9vbWAgd2lsbCBiZSBsb2FkZWRcblx0XHQvLyBmcm9tIGBtYXhOYXRpdmVab29tYCBsZXZlbCBhbmQgYXV0by1zY2FsZWQuXG5cdFx0bWF4TmF0aXZlWm9vbTogdW5kZWZpbmVkLFxuXG5cdFx0Ly8gQG9wdGlvbiBtaW5OYXRpdmVab29tOiBOdW1iZXIgPSB1bmRlZmluZWRcblx0XHQvLyBNaW5pbXVtIHpvb20gbnVtYmVyIHRoZSB0aWxlIHNvdXJjZSBoYXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzcGVjaWZpZWQsXG5cdFx0Ly8gdGhlIHRpbGVzIG9uIGFsbCB6b29tIGxldmVscyBsb3dlciB0aGFuIGBtaW5OYXRpdmVab29tYCB3aWxsIGJlIGxvYWRlZFxuXHRcdC8vIGZyb20gYG1pbk5hdGl2ZVpvb21gIGxldmVsIGFuZCBhdXRvLXNjYWxlZC5cblx0XHRtaW5OYXRpdmVab29tOiB1bmRlZmluZWQsXG5cblx0XHQvLyBAb3B0aW9uIG5vV3JhcDogQm9vbGVhbiA9IGZhbHNlXG5cdFx0Ly8gV2hldGhlciB0aGUgbGF5ZXIgaXMgd3JhcHBlZCBhcm91bmQgdGhlIGFudGltZXJpZGlhbi4gSWYgYHRydWVgLCB0aGVcblx0XHQvLyBHcmlkTGF5ZXIgd2lsbCBvbmx5IGJlIGRpc3BsYXllZCBvbmNlIGF0IGxvdyB6b29tIGxldmVscy4gSGFzIG5vXG5cdFx0Ly8gZWZmZWN0IHdoZW4gdGhlIFttYXAgQ1JTXSgjbWFwLWNycykgZG9lc24ndCB3cmFwIGFyb3VuZC4gQ2FuIGJlIHVzZWRcblx0XHQvLyBpbiBjb21iaW5hdGlvbiB3aXRoIFtgYm91bmRzYF0oI2dyaWRsYXllci1ib3VuZHMpIHRvIHByZXZlbnQgcmVxdWVzdGluZ1xuXHRcdC8vIHRpbGVzIG91dHNpZGUgdGhlIENSUyBsaW1pdHMuXG5cdFx0bm9XcmFwOiBmYWxzZSxcblxuXHRcdC8vIEBvcHRpb24gcGFuZTogU3RyaW5nID0gJ3RpbGVQYW5lJ1xuXHRcdC8vIGBNYXAgcGFuZWAgd2hlcmUgdGhlIGdyaWQgbGF5ZXIgd2lsbCBiZSBhZGRlZC5cblx0XHRwYW5lOiAndGlsZVBhbmUnLFxuXG5cdFx0Ly8gQG9wdGlvbiBjbGFzc05hbWU6IFN0cmluZyA9ICcnXG5cdFx0Ly8gQSBjdXN0b20gY2xhc3MgbmFtZSB0byBhc3NpZ24gdG8gdGhlIHRpbGUgbGF5ZXIuIEVtcHR5IGJ5IGRlZmF1bHQuXG5cdFx0Y2xhc3NOYW1lOiAnJyxcblxuXHRcdC8vIEBvcHRpb24ga2VlcEJ1ZmZlcjogTnVtYmVyID0gMlxuXHRcdC8vIFdoZW4gcGFubmluZyB0aGUgbWFwLCBrZWVwIHRoaXMgbWFueSByb3dzIGFuZCBjb2x1bW5zIG9mIHRpbGVzIGJlZm9yZSB1bmxvYWRpbmcgdGhlbS5cblx0XHRrZWVwQnVmZmVyOiAyXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRVdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7XG5cblx0XHR0aGlzLl9sZXZlbHMgPSB7fTtcblx0XHR0aGlzLl90aWxlcyA9IHt9O1xuXG5cdFx0dGhpcy5fcmVzZXRWaWV3KCk7IC8vIGltcGxpY2l0IF91cGRhdGUoKSBjYWxsXG5cdH0sXG5cblx0YmVmb3JlQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0bWFwLl9hZGRab29tTGltaXQodGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0bWFwLl9yZW1vdmVab29tTGltaXQodGhpcyk7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gbnVsbDtcblx0XHR0aGlzLl90aWxlWm9vbSA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHQvLyBAbWV0aG9kIGJyaW5nVG9Gcm9udDogdGhpc1xuXHQvLyBCcmluZ3MgdGhlIHRpbGUgbGF5ZXIgdG8gdGhlIHRvcCBvZiBhbGwgdGlsZSBsYXllcnMuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdERvbVV0aWwudG9Gcm9udCh0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0dGhpcy5fc2V0QXV0b1pJbmRleChNYXRoLm1heCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgYnJpbmdUb0JhY2s6IHRoaXNcblx0Ly8gQnJpbmdzIHRoZSB0aWxlIGxheWVyIHRvIHRoZSBib3R0b20gb2YgYWxsIHRpbGUgbGF5ZXJzLlxuXHRicmluZ1RvQmFjazogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdERvbVV0aWwudG9CYWNrKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHR0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly8gQG1ldGhvZCBnZXRDb250YWluZXI6IEhUTUxFbGVtZW50XG5cdC8vIFJldHVybnMgdGhlIEhUTUwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSB0aWxlcyBmb3IgdGhpcyBsYXllci5cblx0Z2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcblx0fSxcblxuXHQvLyBAbWV0aG9kIHNldE9wYWNpdHkob3BhY2l0eTogTnVtYmVyKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBbb3BhY2l0eV0oI2dyaWRsYXllci1vcGFjaXR5KSBvZiB0aGUgZ3JpZCBsYXllci5cblx0c2V0T3BhY2l0eTogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XG5cdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0WkluZGV4KHpJbmRleDogTnVtYmVyKTogdGhpc1xuXHQvLyBDaGFuZ2VzIHRoZSBbekluZGV4XSgjZ3JpZGxheWVyLXppbmRleCkgb2YgdGhlIGdyaWQgbGF5ZXIuXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xuXHRcdHRoaXMub3B0aW9ucy56SW5kZXggPSB6SW5kZXg7XG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvLyBAbWV0aG9kIGlzTG9hZGluZzogQm9vbGVhblxuXHQvLyBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgdGlsZSBpbiB0aGUgZ3JpZCBsYXllciBoYXMgbm90IGZpbmlzaGVkIGxvYWRpbmcuXG5cdGlzTG9hZGluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9sb2FkaW5nO1xuXHR9LFxuXG5cdC8vIEBtZXRob2QgcmVkcmF3OiB0aGlzXG5cdC8vIENhdXNlcyB0aGUgbGF5ZXIgdG8gY2xlYXIgYWxsIHRoZSB0aWxlcyBhbmQgcmVxdWVzdCB0aGVtIGFnYWluLlxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVBbGxUaWxlcygpO1xuXHRcdFx0dmFyIHRpbGVab29tID0gdGhpcy5fY2xhbXBab29tKHRoaXMuX21hcC5nZXRab29tKCkpO1xuXHRcdFx0aWYgKHRpbGVab29tICE9PSB0aGlzLl90aWxlWm9vbSkge1xuXHRcdFx0XHR0aGlzLl90aWxlWm9vbSA9IHRpbGVab29tO1xuXHRcdFx0XHR0aGlzLl91cGRhdGVMZXZlbHMoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3ByZXJlc2V0OiB0aGlzLl9pbnZhbGlkYXRlQWxsLFxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHR6b29tOiB0aGlzLl9yZXNldFZpZXcsXG5cdFx0XHRtb3ZlZW5kOiB0aGlzLl9vbk1vdmVFbmRcblx0XHR9O1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUpIHtcblx0XHRcdC8vIHVwZGF0ZSB0aWxlcyBvbiBtb3ZlLCBidXQgbm90IG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciBnaXZlbiBpbnRlcnZhbFxuXHRcdFx0aWYgKCF0aGlzLl9vbk1vdmUpIHtcblx0XHRcdFx0dGhpcy5fb25Nb3ZlID0gVXRpbC50aHJvdHRsZSh0aGlzLl9vbk1vdmVFbmQsIHRoaXMub3B0aW9ucy51cGRhdGVJbnRlcnZhbCwgdGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdGV2ZW50cy5tb3ZlID0gdGhpcy5fb25Nb3ZlO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl96b29tQW5pbWF0ZWQpIHtcblx0XHRcdGV2ZW50cy56b29tYW5pbSA9IHRoaXMuX2FuaW1hdGVab29tO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudHM7XG5cdH0sXG5cblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcblx0Ly8gTGF5ZXJzIGV4dGVuZGluZyBgR3JpZExheWVyYCBzaGFsbCByZWltcGxlbWVudCB0aGUgZm9sbG93aW5nIG1ldGhvZC5cblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxuXHQvLyBDYWxsZWQgb25seSBpbnRlcm5hbGx5LCBtdXN0IGJlIG92ZXJyaWRkZW4gYnkgY2xhc3NlcyBleHRlbmRpbmcgYEdyaWRMYXllcmAuXG5cdC8vIFJldHVybnMgdGhlIGBIVE1MRWxlbWVudGAgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gYGNvb3Jkc2AuIElmIHRoZSBgZG9uZWAgY2FsbGJhY2tcblx0Ly8gaXMgc3BlY2lmaWVkLCBpdCBtdXN0IGJlIGNhbGxlZCB3aGVuIHRoZSB0aWxlIGhhcyBmaW5pc2hlZCBsb2FkaW5nIGFuZCBkcmF3aW5nLlxuXHRjcmVhdGVUaWxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHR9LFxuXG5cdC8vIEBzZWN0aW9uXG5cdC8vIEBtZXRob2QgZ2V0VGlsZVNpemU6IFBvaW50XG5cdC8vIE5vcm1hbGl6ZXMgdGhlIFt0aWxlU2l6ZSBvcHRpb25dKCNncmlkbGF5ZXItdGlsZXNpemUpIGludG8gYSBwb2ludC4gVXNlZCBieSB0aGUgYGNyZWF0ZVRpbGUoKWAgbWV0aG9kLlxuXHRnZXRUaWxlU2l6ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzID0gdGhpcy5vcHRpb25zLnRpbGVTaXplO1xuXHRcdHJldHVybiBzIGluc3RhbmNlb2YgUG9pbnQgPyBzIDogbmV3IFBvaW50KHMsIHMpO1xuXHR9LFxuXG5cdF91cGRhdGVaSW5kZXg6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyICYmIHRoaXMub3B0aW9ucy56SW5kZXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9jb250YWluZXIuc3R5bGUuekluZGV4ID0gdGhpcy5vcHRpb25zLnpJbmRleDtcblx0XHR9XG5cdH0sXG5cblx0X3NldEF1dG9aSW5kZXg6IGZ1bmN0aW9uIChjb21wYXJlKSB7XG5cdFx0Ly8gZ28gdGhyb3VnaCBhbGwgb3RoZXIgbGF5ZXJzIG9mIHRoZSBzYW1lIHBhbmUsIHNldCB6SW5kZXggdG8gbWF4ICsgMSAoZnJvbnQpIG9yIG1pbiAtIDEgKGJhY2spXG5cblx0XHR2YXIgbGF5ZXJzID0gdGhpcy5nZXRQYW5lKCkuY2hpbGRyZW4sXG5cdFx0ICAgIGVkZ2VaSW5kZXggPSAtY29tcGFyZSgtSW5maW5pdHksIEluZmluaXR5KTsgLy8gLUluZmluaXR5IGZvciBtYXgsIEluZmluaXR5IGZvciBtaW5cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXllcnMubGVuZ3RoLCB6SW5kZXg7IGkgPCBsZW47IGkrKykge1xuXG5cdFx0XHR6SW5kZXggPSBsYXllcnNbaV0uc3R5bGUuekluZGV4O1xuXG5cdFx0XHRpZiAobGF5ZXJzW2ldICE9PSB0aGlzLl9jb250YWluZXIgJiYgekluZGV4KSB7XG5cdFx0XHRcdGVkZ2VaSW5kZXggPSBjb21wYXJlKGVkZ2VaSW5kZXgsICt6SW5kZXgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0Zpbml0ZShlZGdlWkluZGV4KSkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IGVkZ2VaSW5kZXggKyBjb21wYXJlKC0xLCAxKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxuXG5cdFx0Ly8gSUUgZG9lc24ndCBpbmhlcml0IGZpbHRlciBvcGFjaXR5IHByb3Blcmx5LCBzbyB3ZSdyZSBmb3JjZWQgdG8gc2V0IGl0IG9uIHRpbGVzXG5cdFx0aWYgKEJyb3dzZXIuaWVsdDkpIHsgcmV0dXJuOyB9XG5cblx0XHREb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cblx0XHR2YXIgbm93ID0gK25ldyBEYXRlKCksXG5cdFx0ICAgIG5leHRGcmFtZSA9IGZhbHNlLFxuXHRcdCAgICB3aWxsUHJ1bmUgPSBmYWxzZTtcblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKCF0aWxlLmN1cnJlbnQgfHwgIXRpbGUubG9hZGVkKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdHZhciBmYWRlID0gTWF0aC5taW4oMSwgKG5vdyAtIHRpbGUubG9hZGVkKSAvIDIwMCk7XG5cblx0XHRcdERvbVV0aWwuc2V0T3BhY2l0eSh0aWxlLmVsLCBmYWRlKTtcblx0XHRcdGlmIChmYWRlIDwgMSkge1xuXHRcdFx0XHRuZXh0RnJhbWUgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRpbGUuYWN0aXZlKSB7XG5cdFx0XHRcdFx0d2lsbFBydW5lID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9vbk9wYXF1ZVRpbGUodGlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh3aWxsUHJ1bmUgJiYgIXRoaXMuX25vUHJ1bmUpIHsgdGhpcy5fcHJ1bmVUaWxlcygpOyB9XG5cblx0XHRpZiAobmV4dEZyYW1lKSB7XG5cdFx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9mYWRlRnJhbWUpO1xuXHRcdFx0dGhpcy5fZmFkZUZyYW1lID0gVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZU9wYWNpdHksIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfb25PcGFxdWVUaWxlOiBVdGlsLmZhbHNlRm4sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fY29udGFpbmVyID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWxheWVyICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5IDwgMSkge1xuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZ2V0UGFuZSgpLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cdH0sXG5cblx0X3VwZGF0ZUxldmVsczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHpvb20gPSB0aGlzLl90aWxlWm9vbSxcblx0XHQgICAgbWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5tYXhab29tO1xuXG5cdFx0aWYgKHpvb20gPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cblx0XHRmb3IgKHZhciB6IGluIHRoaXMuX2xldmVscykge1xuXHRcdFx0eiA9IE51bWJlcih6KTtcblx0XHRcdGlmICh0aGlzLl9sZXZlbHNbel0uZWwuY2hpbGRyZW4ubGVuZ3RoIHx8IHogPT09IHpvb20pIHtcblx0XHRcdFx0dGhpcy5fbGV2ZWxzW3pdLmVsLnN0eWxlLnpJbmRleCA9IG1heFpvb20gLSBNYXRoLmFicyh6b29tIC0geik7XG5cdFx0XHRcdHRoaXMuX29uVXBkYXRlTGV2ZWwoeik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0XHR0aGlzLl9yZW1vdmVUaWxlc0F0Wm9vbSh6KTtcblx0XHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbCh6KTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbem9vbV0sXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdGlmICghbGV2ZWwpIHtcblx0XHRcdGxldmVsID0gdGhpcy5fbGV2ZWxzW3pvb21dID0ge307XG5cblx0XHRcdGxldmVsLmVsID0gRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXRpbGUtY29udGFpbmVyIGxlYWZsZXQtem9vbS1hbmltYXRlZCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHRsZXZlbC5lbC5zdHlsZS56SW5kZXggPSBtYXhab29tO1xuXG5cdFx0XHRsZXZlbC5vcmlnaW4gPSBtYXAucHJvamVjdChtYXAudW5wcm9qZWN0KG1hcC5nZXRQaXhlbE9yaWdpbigpKSwgem9vbSkucm91bmQoKTtcblx0XHRcdGxldmVsLnpvb20gPSB6b29tO1xuXG5cdFx0XHR0aGlzLl9zZXRab29tVHJhbnNmb3JtKGxldmVsLCBtYXAuZ2V0Q2VudGVyKCksIG1hcC5nZXRab29tKCkpO1xuXG5cdFx0XHQvLyBmb3JjZSB0aGUgYnJvd3NlciB0byBjb25zaWRlciB0aGUgbmV3bHkgYWRkZWQgZWxlbWVudCBmb3IgdHJhbnNpdGlvblxuXHRcdFx0VXRpbC5mYWxzZUZuKGxldmVsLmVsLm9mZnNldFdpZHRoKTtcblxuXHRcdFx0dGhpcy5fb25DcmVhdGVMZXZlbChsZXZlbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGV2ZWwgPSBsZXZlbDtcblxuXHRcdHJldHVybiBsZXZlbDtcblx0fSxcblxuXHRfb25VcGRhdGVMZXZlbDogVXRpbC5mYWxzZUZuLFxuXG5cdF9vblJlbW92ZUxldmVsOiBVdGlsLmZhbHNlRm4sXG5cblx0X29uQ3JlYXRlTGV2ZWw6IFV0aWwuZmFsc2VGbixcblxuXHRfcHJ1bmVUaWxlczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGtleSwgdGlsZTtcblxuXHRcdHZhciB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0XHRpZiAoem9vbSA+IHRoaXMub3B0aW9ucy5tYXhab29tIHx8XG5cdFx0XHR6b29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcblx0XHRcdHRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0dGlsZS5yZXRhaW4gPSB0aWxlLmN1cnJlbnQ7XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gdGhpcy5fdGlsZXMpIHtcblx0XHRcdHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXHRcdFx0aWYgKHRpbGUuY3VycmVudCAmJiAhdGlsZS5hY3RpdmUpIHtcblx0XHRcdFx0dmFyIGNvb3JkcyA9IHRpbGUuY29vcmRzO1xuXHRcdFx0XHRpZiAoIXRoaXMuX3JldGFpblBhcmVudChjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMueiAtIDUpKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oY29vcmRzLngsIGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLnogKyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ucmV0YWluKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVRpbGVzQXRab29tOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0aWYgKHRoaXMuX3RpbGVzW2tleV0uY29vcmRzLnogIT09IHpvb20pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZW1vdmVUaWxlKGtleSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmVBbGxUaWxlczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dGhpcy5fcmVtb3ZlVGlsZShrZXkpO1xuXHRcdH1cblx0fSxcblxuXHRfaW52YWxpZGF0ZUFsbDogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIHogaW4gdGhpcy5fbGV2ZWxzKSB7XG5cdFx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9sZXZlbHNbel0uZWwpO1xuXHRcdFx0dGhpcy5fb25SZW1vdmVMZXZlbChOdW1iZXIoeikpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2xldmVsc1t6XTtcblx0XHR9XG5cdFx0dGhpcy5fcmVtb3ZlQWxsVGlsZXMoKTtcblxuXHRcdHRoaXMuX3RpbGVab29tID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdF9yZXRhaW5QYXJlbnQ6IGZ1bmN0aW9uICh4LCB5LCB6LCBtaW5ab29tKSB7XG5cdFx0dmFyIHgyID0gTWF0aC5mbG9vcih4IC8gMiksXG5cdFx0ICAgIHkyID0gTWF0aC5mbG9vcih5IC8gMiksXG5cdFx0ICAgIHoyID0geiAtIDEsXG5cdFx0ICAgIGNvb3JkczIgPSBuZXcgUG9pbnQoK3gyLCAreTIpO1xuXHRcdGNvb3JkczIueiA9ICt6MjtcblxuXHRcdHZhciBrZXkgPSB0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzMiksXG5cdFx0ICAgIHRpbGUgPSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0aWYgKHRpbGUgJiYgdGlsZS5hY3RpdmUpIHtcblx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fSBlbHNlIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG5cdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKHoyID4gbWluWm9vbSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JldGFpblBhcmVudCh4MiwgeTIsIHoyLCBtaW5ab29tKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X3JldGFpbkNoaWxkcmVuOiBmdW5jdGlvbiAoeCwgeSwgeiwgbWF4Wm9vbSkge1xuXG5cdFx0Zm9yICh2YXIgaSA9IDIgKiB4OyBpIDwgMiAqIHggKyAyOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAyICogeTsgaiA8IDIgKiB5ICsgMjsgaisrKSB7XG5cblx0XHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBQb2ludChpLCBqKTtcblx0XHRcdFx0Y29vcmRzLnogPSB6ICsgMTtcblxuXHRcdFx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3JkcyksXG5cdFx0XHRcdCAgICB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblxuXHRcdFx0XHRpZiAodGlsZSAmJiB0aWxlLmFjdGl2ZSkge1xuXHRcdFx0XHRcdHRpbGUucmV0YWluID0gdHJ1ZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKHRpbGUgJiYgdGlsZS5sb2FkZWQpIHtcblx0XHRcdFx0XHR0aWxlLnJldGFpbiA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoeiArIDEgPCBtYXhab29tKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV0YWluQ2hpbGRyZW4oaSwgaiwgeiArIDEsIG1heFpvb20pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldFZpZXc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGFuaW1hdGluZyA9IGUgJiYgKGUucGluY2ggfHwgZS5mbHlUbyk7XG5cdFx0dGhpcy5fc2V0Vmlldyh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCksIGFuaW1hdGluZywgYW5pbWF0aW5nKTtcblx0fSxcblxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fc2V0VmlldyhlLmNlbnRlciwgZS56b29tLCB0cnVlLCBlLm5vVXBkYXRlKTtcblx0fSxcblxuXHRfY2xhbXBab29tOiBmdW5jdGlvbiAoem9vbSkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5taW5OYXRpdmVab29tICYmIHpvb20gPCBvcHRpb25zLm1pbk5hdGl2ZVpvb20pIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1pbk5hdGl2ZVpvb207XG5cdFx0fVxuXG5cdFx0aWYgKHVuZGVmaW5lZCAhPT0gb3B0aW9ucy5tYXhOYXRpdmVab29tICYmIG9wdGlvbnMubWF4TmF0aXZlWm9vbSA8IHpvb20pIHtcblx0XHRcdHJldHVybiBvcHRpb25zLm1heE5hdGl2ZVpvb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHpvb207XG5cdH0sXG5cblx0X3NldFZpZXc6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIG5vUHJ1bmUsIG5vVXBkYXRlKSB7XG5cdFx0dmFyIHRpbGVab29tID0gTWF0aC5yb3VuZCh6b29tKTtcblx0XHRpZiAoKHRoaXMub3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSkgfHxcblx0XHQgICAgKHRoaXMub3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgJiYgdGlsZVpvb20gPCB0aGlzLm9wdGlvbnMubWluWm9vbSkpIHtcblx0XHRcdHRpbGVab29tID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aWxlWm9vbSA9IHRoaXMuX2NsYW1wWm9vbSh0aWxlWm9vbSk7XG5cdFx0fVxuXG5cdFx0dmFyIHRpbGVab29tQ2hhbmdlZCA9IHRoaXMub3B0aW9ucy51cGRhdGVXaGVuWm9vbWluZyAmJiAodGlsZVpvb20gIT09IHRoaXMuX3RpbGVab29tKTtcblxuXHRcdGlmICghbm9VcGRhdGUgfHwgdGlsZVpvb21DaGFuZ2VkKSB7XG5cblx0XHRcdHRoaXMuX3RpbGVab29tID0gdGlsZVpvb207XG5cblx0XHRcdGlmICh0aGlzLl9hYm9ydExvYWRpbmcpIHtcblx0XHRcdFx0dGhpcy5fYWJvcnRMb2FkaW5nKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3VwZGF0ZUxldmVscygpO1xuXHRcdFx0dGhpcy5fcmVzZXRHcmlkKCk7XG5cblx0XHRcdGlmICh0aWxlWm9vbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZShjZW50ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIW5vUHJ1bmUpIHtcblx0XHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGbGFnIHRvIHByZXZlbnQgX3VwZGF0ZU9wYWNpdHkgZnJvbSBwcnVuaW5nIHRpbGVzIGR1cmluZ1xuXHRcdFx0Ly8gYSB6b29tIGFuaW0gb3IgYSBwaW5jaCBnZXN0dXJlXG5cdFx0XHR0aGlzLl9ub1BydW5lID0gISFub1BydW5lO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm1zKGNlbnRlciwgem9vbSk7XG5cdH0sXG5cblx0X3NldFpvb21UcmFuc2Zvcm1zOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sZXZlbHMpIHtcblx0XHRcdHRoaXMuX3NldFpvb21UcmFuc2Zvcm0odGhpcy5fbGV2ZWxzW2ldLCBjZW50ZXIsIHpvb20pO1xuXHRcdH1cblx0fSxcblxuXHRfc2V0Wm9vbVRyYW5zZm9ybTogZnVuY3Rpb24gKGxldmVsLCBjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIGxldmVsLnpvb20pLFxuXHRcdCAgICB0cmFuc2xhdGUgPSBsZXZlbC5vcmlnaW4ubXVsdGlwbHlCeShzY2FsZSlcblx0XHQgICAgICAgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpLnJvdW5kKCk7XG5cblx0XHRpZiAoQnJvd3Nlci5hbnkzZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRUcmFuc2Zvcm0obGV2ZWwuZWwsIHRyYW5zbGF0ZSwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKGxldmVsLmVsLCB0cmFuc2xhdGUpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVzZXRHcmlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgY3JzID0gbWFwLm9wdGlvbnMuY3JzLFxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuX3RpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLFxuXHRcdCAgICB0aWxlWm9vbSA9IHRoaXMuX3RpbGVab29tO1xuXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKHRoaXMuX3RpbGVab29tKTtcblx0XHRpZiAoYm91bmRzKSB7XG5cdFx0XHR0aGlzLl9nbG9iYWxUaWxlUmFuZ2UgPSB0aGlzLl9weEJvdW5kc1RvVGlsZVJhbmdlKGJvdW5kcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fd3JhcFggPSBjcnMud3JhcExuZyAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFswLCBjcnMud3JhcExuZ1swXV0sIHRpbGVab29tKS54IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoWzAsIGNycy53cmFwTG5nWzFdXSwgdGlsZVpvb20pLnggLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdFx0dGhpcy5fd3JhcFkgPSBjcnMud3JhcExhdCAmJiAhdGhpcy5vcHRpb25zLm5vV3JhcCAmJiBbXG5cdFx0XHRNYXRoLmZsb29yKG1hcC5wcm9qZWN0KFtjcnMud3JhcExhdFswXSwgMF0sIHRpbGVab29tKS55IC8gdGlsZVNpemUueCksXG5cdFx0XHRNYXRoLmNlaWwobWFwLnByb2plY3QoW2Nycy53cmFwTGF0WzFdLCAwXSwgdGlsZVpvb20pLnkgLyB0aWxlU2l6ZS55KVxuXHRcdF07XG5cdH0sXG5cblx0X29uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwIHx8IHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdF9nZXRUaWxlZFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoY2VudGVyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgbWFwWm9vbSA9IG1hcC5fYW5pbWF0aW5nWm9vbSA/IE1hdGgubWF4KG1hcC5fYW5pbWF0ZVRvWm9vbSwgbWFwLmdldFpvb20oKSkgOiBtYXAuZ2V0Wm9vbSgpLFxuXHRcdCAgICBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUobWFwWm9vbSwgdGhpcy5fdGlsZVpvb20pLFxuXHRcdCAgICBwaXhlbENlbnRlciA9IG1hcC5wcm9qZWN0KGNlbnRlciwgdGhpcy5fdGlsZVpvb20pLmZsb29yKCksXG5cdFx0ICAgIGhhbGZTaXplID0gbWFwLmdldFNpemUoKS5kaXZpZGVCeShzY2FsZSAqIDIpO1xuXG5cdFx0cmV0dXJuIG5ldyBCb3VuZHMocGl4ZWxDZW50ZXIuc3VidHJhY3QoaGFsZlNpemUpLCBwaXhlbENlbnRlci5hZGQoaGFsZlNpemUpKTtcblx0fSxcblxuXHQvLyBQcml2YXRlIG1ldGhvZCB0byBsb2FkIHRpbGVzIGluIHRoZSBncmlkJ3MgYWN0aXZlIHpvb20gbGV2ZWwgYWNjb3JkaW5nIHRvIG1hcCBib3VuZHNcblx0X3VwZGF0ZTogZnVuY3Rpb24gKGNlbnRlcikge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdFx0aWYgKCFtYXApIHsgcmV0dXJuOyB9XG5cdFx0dmFyIHpvb20gPSB0aGlzLl9jbGFtcFpvb20obWFwLmdldFpvb20oKSk7XG5cblx0XHRpZiAoY2VudGVyID09PSB1bmRlZmluZWQpIHsgY2VudGVyID0gbWFwLmdldENlbnRlcigpOyB9XG5cdFx0aWYgKHRoaXMuX3RpbGVab29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XHQvLyBpZiBvdXQgb2YgbWluem9vbS9tYXh6b29tXG5cblx0XHR2YXIgcGl4ZWxCb3VuZHMgPSB0aGlzLl9nZXRUaWxlZFBpeGVsQm91bmRzKGNlbnRlciksXG5cdFx0ICAgIHRpbGVSYW5nZSA9IHRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UocGl4ZWxCb3VuZHMpLFxuXHRcdCAgICB0aWxlQ2VudGVyID0gdGlsZVJhbmdlLmdldENlbnRlcigpLFxuXHRcdCAgICBxdWV1ZSA9IFtdLFxuXHRcdCAgICBtYXJnaW4gPSB0aGlzLm9wdGlvbnMua2VlcEJ1ZmZlcixcblx0XHQgICAgbm9QcnVuZVJhbmdlID0gbmV3IEJvdW5kcyh0aWxlUmFuZ2UuZ2V0Qm90dG9tTGVmdCgpLnN1YnRyYWN0KFttYXJnaW4sIC1tYXJnaW5dKSxcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWxlUmFuZ2UuZ2V0VG9wUmlnaHQoKS5hZGQoW21hcmdpbiwgLW1hcmdpbl0pKTtcblxuXHRcdC8vIFNhbml0eSBjaGVjazogcGFuaWMgaWYgdGhlIHRpbGUgcmFuZ2UgY29udGFpbnMgSW5maW5pdHkgc29tZXdoZXJlLlxuXHRcdGlmICghKGlzRmluaXRlKHRpbGVSYW5nZS5taW4ueCkgJiZcblx0XHQgICAgICBpc0Zpbml0ZSh0aWxlUmFuZ2UubWluLnkpICYmXG5cdFx0ICAgICAgaXNGaW5pdGUodGlsZVJhbmdlLm1heC54KSAmJlxuXHRcdCAgICAgIGlzRmluaXRlKHRpbGVSYW5nZS5tYXgueSkpKSB7IHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGxvYWQgYW4gaW5maW5pdGUgbnVtYmVyIG9mIHRpbGVzJyk7IH1cblxuXHRcdGZvciAodmFyIGtleSBpbiB0aGlzLl90aWxlcykge1xuXHRcdFx0dmFyIGMgPSB0aGlzLl90aWxlc1trZXldLmNvb3Jkcztcblx0XHRcdGlmIChjLnogIT09IHRoaXMuX3RpbGVab29tIHx8ICFub1BydW5lUmFuZ2UuY29udGFpbnMobmV3IFBvaW50KGMueCwgYy55KSkpIHtcblx0XHRcdFx0dGhpcy5fdGlsZXNba2V5XS5jdXJyZW50ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gX3VwZGF0ZSBqdXN0IGxvYWRzIG1vcmUgdGlsZXMuIElmIHRoZSB0aWxlIHpvb20gbGV2ZWwgZGlmZmVycyB0b28gbXVjaFxuXHRcdC8vIGZyb20gdGhlIG1hcCdzLCBsZXQgX3NldFZpZXcgcmVzZXQgbGV2ZWxzIGFuZCBwcnVuZSBvbGQgdGlsZXMuXG5cdFx0aWYgKE1hdGguYWJzKHpvb20gLSB0aGlzLl90aWxlWm9vbSkgPiAxKSB7IHRoaXMuX3NldFZpZXcoY2VudGVyLCB6b29tKTsgcmV0dXJuOyB9XG5cblx0XHQvLyBjcmVhdGUgYSBxdWV1ZSBvZiBjb29yZGluYXRlcyB0byBsb2FkIHRpbGVzIGZyb21cblx0XHRmb3IgKHZhciBqID0gdGlsZVJhbmdlLm1pbi55OyBqIDw9IHRpbGVSYW5nZS5tYXgueTsgaisrKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gdGlsZVJhbmdlLm1pbi54OyBpIDw9IHRpbGVSYW5nZS5tYXgueDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjb29yZHMgPSBuZXcgUG9pbnQoaSwgaik7XG5cdFx0XHRcdGNvb3Jkcy56ID0gdGhpcy5fdGlsZVpvb207XG5cblx0XHRcdFx0aWYgKCF0aGlzLl9pc1ZhbGlkVGlsZShjb29yZHMpKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdFx0dmFyIHRpbGUgPSB0aGlzLl90aWxlc1t0aGlzLl90aWxlQ29vcmRzVG9LZXkoY29vcmRzKV07XG5cdFx0XHRcdGlmICh0aWxlKSB7XG5cdFx0XHRcdFx0dGlsZS5jdXJyZW50ID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKGNvb3Jkcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzb3J0IHRpbGUgcXVldWUgdG8gbG9hZCB0aWxlcyBpbiBvcmRlciBvZiB0aGVpciBkaXN0YW5jZSB0byBjZW50ZXJcblx0XHRxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYS5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpIC0gYi5kaXN0YW5jZVRvKHRpbGVDZW50ZXIpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0Ly8gaWYgaXQncyB0aGUgZmlyc3QgYmF0Y2ggb2YgdGlsZXMgdG8gbG9hZFxuXHRcdFx0aWYgKCF0aGlzLl9sb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuX2xvYWRpbmcgPSB0cnVlO1xuXHRcdFx0XHQvLyBAZXZlbnQgbG9hZGluZzogRXZlbnRcblx0XHRcdFx0Ly8gRmlyZWQgd2hlbiB0aGUgZ3JpZCBsYXllciBzdGFydHMgbG9hZGluZyB0aWxlcy5cblx0XHRcdFx0dGhpcy5maXJlKCdsb2FkaW5nJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNyZWF0ZSBET00gZnJhZ21lbnQgdG8gYXBwZW5kIHRpbGVzIGluIG9uZSBiYXRjaFxuXHRcdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fYWRkVGlsZShxdWV1ZVtpXSwgZnJhZ21lbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9sZXZlbC5lbC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pc1ZhbGlkVGlsZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBjcnMgPSB0aGlzLl9tYXAub3B0aW9ucy5jcnM7XG5cblx0XHRpZiAoIWNycy5pbmZpbml0ZSkge1xuXHRcdFx0Ly8gZG9uJ3QgbG9hZCB0aWxlIGlmIGl0J3Mgb3V0IG9mIGJvdW5kcyBhbmQgbm90IHdyYXBwZWRcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9nbG9iYWxUaWxlUmFuZ2U7XG5cdFx0XHRpZiAoKCFjcnMud3JhcExuZyAmJiAoY29vcmRzLnggPCBib3VuZHMubWluLnggfHwgY29vcmRzLnggPiBib3VuZHMubWF4LngpKSB8fFxuXHRcdFx0ICAgICghY3JzLndyYXBMYXQgJiYgKGNvb3Jkcy55IDwgYm91bmRzLm1pbi55IHx8IGNvb3Jkcy55ID4gYm91bmRzLm1heC55KSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYm91bmRzKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHQvLyBkb24ndCBsb2FkIHRpbGUgaWYgaXQgZG9lc24ndCBpbnRlcnNlY3QgdGhlIGJvdW5kcyBpbiBvcHRpb25zXG5cdFx0dmFyIHRpbGVCb3VuZHMgPSB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHMoY29vcmRzKTtcblx0XHRyZXR1cm4gbGF0TG5nQm91bmRzKHRoaXMub3B0aW9ucy5ib3VuZHMpLm92ZXJsYXBzKHRpbGVCb3VuZHMpO1xuXHR9LFxuXG5cdF9rZXlUb0JvdW5kczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHJldHVybiB0aGlzLl90aWxlQ29vcmRzVG9Cb3VuZHModGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSkpO1xuXHR9LFxuXG5cdF90aWxlQ29vcmRzVG9Od1NlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCksXG5cdFx0ICAgIG53UG9pbnQgPSBjb29yZHMuc2NhbGVCeSh0aWxlU2l6ZSksXG5cdFx0ICAgIHNlUG9pbnQgPSBud1BvaW50LmFkZCh0aWxlU2l6ZSksXG5cdFx0ICAgIG53ID0gbWFwLnVucHJvamVjdChud1BvaW50LCBjb29yZHMueiksXG5cdFx0ICAgIHNlID0gbWFwLnVucHJvamVjdChzZVBvaW50LCBjb29yZHMueik7XG5cdFx0cmV0dXJuIFtudywgc2VdO1xuXHR9LFxuXG5cdC8vIGNvbnZlcnRzIHRpbGUgY29vcmRpbmF0ZXMgdG8gaXRzIGdlb2dyYXBoaWNhbCBib3VuZHNcblx0X3RpbGVDb29yZHNUb0JvdW5kczogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHZhciBicCA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcblx0XHQgICAgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhicFswXSwgYnBbMV0pO1xuXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMubm9XcmFwKSB7XG5cdFx0XHRib3VuZHMgPSB0aGlzLl9tYXAud3JhcExhdExuZ0JvdW5kcyhib3VuZHMpO1xuXHRcdH1cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXHQvLyBjb252ZXJ0cyB0aWxlIGNvb3JkaW5hdGVzIHRvIGtleSBmb3IgdGhlIHRpbGUgY2FjaGVcblx0X3RpbGVDb29yZHNUb0tleTogZnVuY3Rpb24gKGNvb3Jkcykge1xuXHRcdHJldHVybiBjb29yZHMueCArICc6JyArIGNvb3Jkcy55ICsgJzonICsgY29vcmRzLno7XG5cdH0sXG5cblx0Ly8gY29udmVydHMgdGlsZSBjYWNoZSBrZXkgdG8gY29vcmRpbmF0ZXNcblx0X2tleVRvVGlsZUNvb3JkczogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciBrID0ga2V5LnNwbGl0KCc6JyksXG5cdFx0ICAgIGNvb3JkcyA9IG5ldyBQb2ludCgra1swXSwgK2tbMV0pO1xuXHRcdGNvb3Jkcy56ID0gK2tbMl07XG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fSxcblxuXHRfcmVtb3ZlVGlsZTogZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHREb21VdGlsLnJlbW92ZSh0aWxlLmVsKTtcblxuXHRcdGRlbGV0ZSB0aGlzLl90aWxlc1trZXldO1xuXG5cdFx0Ly8gQGV2ZW50IHRpbGV1bmxvYWQ6IFRpbGVFdmVudFxuXHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIGlzIHJlbW92ZWQgKGUuZy4gd2hlbiBhIHRpbGUgZ29lcyBvZmYgdGhlIHNjcmVlbikuXG5cdFx0dGhpcy5maXJlKCd0aWxldW5sb2FkJywge1xuXHRcdFx0dGlsZTogdGlsZS5lbCxcblx0XHRcdGNvb3JkczogdGhpcy5fa2V5VG9UaWxlQ29vcmRzKGtleSlcblx0XHR9KTtcblx0fSxcblxuXHRfaW5pdFRpbGU6IGZ1bmN0aW9uICh0aWxlKSB7XG5cdFx0RG9tVXRpbC5hZGRDbGFzcyh0aWxlLCAnbGVhZmxldC10aWxlJyk7XG5cblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XG5cdFx0dGlsZS5zdHlsZS53aWR0aCA9IHRpbGVTaXplLnggKyAncHgnO1xuXHRcdHRpbGUuc3R5bGUuaGVpZ2h0ID0gdGlsZVNpemUueSArICdweCc7XG5cblx0XHR0aWxlLm9uc2VsZWN0c3RhcnQgPSBVdGlsLmZhbHNlRm47XG5cdFx0dGlsZS5vbm1vdXNlbW92ZSA9IFV0aWwuZmFsc2VGbjtcblxuXHRcdC8vIHVwZGF0ZSBvcGFjaXR5IG9uIHRpbGVzIGluIElFNy04IGJlY2F1c2Ugb2YgZmlsdGVyIGluaGVyaXRhbmNlIHByb2JsZW1zXG5cdFx0aWYgKEJyb3dzZXIuaWVsdDkgJiYgdGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XG5cdFx0XHREb21VdGlsLnNldE9wYWNpdHkodGlsZSwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkVGlsZTogZnVuY3Rpb24gKGNvb3JkcywgY29udGFpbmVyKSB7XG5cdFx0dmFyIHRpbGVQb3MgPSB0aGlzLl9nZXRUaWxlUG9zKGNvb3JkcyksXG5cdFx0ICAgIGtleSA9IHRoaXMuX3RpbGVDb29yZHNUb0tleShjb29yZHMpO1xuXG5cdFx0dmFyIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGUodGhpcy5fd3JhcENvb3Jkcyhjb29yZHMpLCBVdGlsLmJpbmQodGhpcy5fdGlsZVJlYWR5LCB0aGlzLCBjb29yZHMpKTtcblxuXHRcdHRoaXMuX2luaXRUaWxlKHRpbGUpO1xuXG5cdFx0Ly8gaWYgY3JlYXRlVGlsZSBpcyBkZWZpbmVkIHdpdGggYSBzZWNvbmQgYXJndW1lbnQgKFwiZG9uZVwiIGNhbGxiYWNrKSxcblx0XHQvLyB3ZSBrbm93IHRoYXQgdGlsZSBpcyBhc3luYyBhbmQgd2lsbCBiZSByZWFkeSBsYXRlcjsgb3RoZXJ3aXNlXG5cdFx0aWYgKHRoaXMuY3JlYXRlVGlsZS5sZW5ndGggPCAyKSB7XG5cdFx0XHQvLyBtYXJrIHRpbGUgYXMgcmVhZHksIGJ1dCBkZWxheSBvbmUgZnJhbWUgZm9yIG9wYWNpdHkgYW5pbWF0aW9uIHRvIGhhcHBlblxuXHRcdFx0VXRpbC5yZXF1ZXN0QW5pbUZyYW1lKFV0aWwuYmluZCh0aGlzLl90aWxlUmVhZHksIHRoaXMsIGNvb3JkcywgbnVsbCwgdGlsZSkpO1xuXHRcdH1cblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24odGlsZSwgdGlsZVBvcyk7XG5cblx0XHQvLyBzYXZlIHRpbGUgaW4gY2FjaGVcblx0XHR0aGlzLl90aWxlc1trZXldID0ge1xuXHRcdFx0ZWw6IHRpbGUsXG5cdFx0XHRjb29yZHM6IGNvb3Jkcyxcblx0XHRcdGN1cnJlbnQ6IHRydWVcblx0XHR9O1xuXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRpbGUpO1xuXHRcdC8vIEBldmVudCB0aWxlbG9hZHN0YXJ0OiBUaWxlRXZlbnRcblx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBpcyByZXF1ZXN0ZWQgYW5kIHN0YXJ0cyBsb2FkaW5nLlxuXHRcdHRoaXMuZmlyZSgndGlsZWxvYWRzdGFydCcsIHtcblx0XHRcdHRpbGU6IHRpbGUsXG5cdFx0XHRjb29yZHM6IGNvb3Jkc1xuXHRcdH0pO1xuXHR9LFxuXG5cdF90aWxlUmVhZHk6IGZ1bmN0aW9uIChjb29yZHMsIGVyciwgdGlsZSkge1xuXHRcdGlmIChlcnIpIHtcblx0XHRcdC8vIEBldmVudCB0aWxlZXJyb3I6IFRpbGVFcnJvckV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIGxvYWRpbmcgYSB0aWxlLlxuXHRcdFx0dGhpcy5maXJlKCd0aWxlZXJyb3InLCB7XG5cdFx0XHRcdGVycm9yOiBlcnIsXG5cdFx0XHRcdHRpbGU6IHRpbGUsXG5cdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIga2V5ID0gdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KGNvb3Jkcyk7XG5cblx0XHR0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcblx0XHRpZiAoIXRpbGUpIHsgcmV0dXJuOyB9XG5cblx0XHR0aWxlLmxvYWRlZCA9ICtuZXcgRGF0ZSgpO1xuXHRcdGlmICh0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0RG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUuZWwsIDApO1xuXHRcdFx0VXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fZmFkZUZyYW1lKTtcblx0XHRcdHRoaXMuX2ZhZGVGcmFtZSA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl91cGRhdGVPcGFjaXR5LCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGlsZS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0dGhpcy5fcHJ1bmVUaWxlcygpO1xuXHRcdH1cblxuXHRcdGlmICghZXJyKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHRpbGUuZWwsICdsZWFmbGV0LXRpbGUtbG9hZGVkJyk7XG5cblx0XHRcdC8vIEBldmVudCB0aWxlbG9hZDogVGlsZUV2ZW50XG5cdFx0XHQvLyBGaXJlZCB3aGVuIGEgdGlsZSBsb2Fkcy5cblx0XHRcdHRoaXMuZmlyZSgndGlsZWxvYWQnLCB7XG5cdFx0XHRcdHRpbGU6IHRpbGUuZWwsXG5cdFx0XHRcdGNvb3JkczogY29vcmRzXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbm9UaWxlc1RvTG9hZCgpKSB7XG5cdFx0XHR0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG5cdFx0XHQvLyBAZXZlbnQgbG9hZDogRXZlbnRcblx0XHRcdC8vIEZpcmVkIHdoZW4gdGhlIGdyaWQgbGF5ZXIgbG9hZGVkIGFsbCB2aXNpYmxlIHRpbGVzLlxuXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XG5cblx0XHRcdGlmIChCcm93c2VyLmllbHQ5IHx8ICF0aGlzLl9tYXAuX2ZhZGVBbmltYXRlZCkge1xuXHRcdFx0XHRVdGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5fcHJ1bmVUaWxlcywgdGhpcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBXYWl0IGEgYml0IG1vcmUgdGhhbiAwLjIgc2VjcyAodGhlIGR1cmF0aW9uIG9mIHRoZSB0aWxlIGZhZGUtaW4pXG5cdFx0XHRcdC8vIHRvIHRyaWdnZXIgYSBwcnVuaW5nLlxuXHRcdFx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9wcnVuZVRpbGVzLCB0aGlzKSwgMjUwKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2dldFRpbGVQb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRyZXR1cm4gY29vcmRzLnNjYWxlQnkodGhpcy5nZXRUaWxlU2l6ZSgpKS5zdWJ0cmFjdCh0aGlzLl9sZXZlbC5vcmlnaW4pO1xuXHR9LFxuXG5cdF93cmFwQ29vcmRzOiBmdW5jdGlvbiAoY29vcmRzKSB7XG5cdFx0dmFyIG5ld0Nvb3JkcyA9IG5ldyBQb2ludChcblx0XHRcdHRoaXMuX3dyYXBYID8gVXRpbC53cmFwTnVtKGNvb3Jkcy54LCB0aGlzLl93cmFwWCkgOiBjb29yZHMueCxcblx0XHRcdHRoaXMuX3dyYXBZID8gVXRpbC53cmFwTnVtKGNvb3Jkcy55LCB0aGlzLl93cmFwWSkgOiBjb29yZHMueSk7XG5cdFx0bmV3Q29vcmRzLnogPSBjb29yZHMuejtcblx0XHRyZXR1cm4gbmV3Q29vcmRzO1xuXHR9LFxuXG5cdF9weEJvdW5kc1RvVGlsZVJhbmdlOiBmdW5jdGlvbiAoYm91bmRzKSB7XG5cdFx0dmFyIHRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpO1xuXHRcdHJldHVybiBuZXcgQm91bmRzKFxuXHRcdFx0Ym91bmRzLm1pbi51bnNjYWxlQnkodGlsZVNpemUpLmZsb29yKCksXG5cdFx0XHRib3VuZHMubWF4LnVuc2NhbGVCeSh0aWxlU2l6ZSkuY2VpbCgpLnN1YnRyYWN0KFsxLCAxXSkpO1xuXHR9LFxuXG5cdF9ub1RpbGVzVG9Mb2FkOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3RpbGVzW2tleV0ubG9hZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuZ3JpZExheWVyKG9wdGlvbnM/OiBHcmlkTGF5ZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgR3JpZExheWVyIHdpdGggdGhlIHN1cHBsaWVkIG9wdGlvbnMuXG5leHBvcnQgZnVuY3Rpb24gZ3JpZExheWVyKG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBHcmlkTGF5ZXIob3B0aW9ucyk7XG59XG4iLCJpbXBvcnQge0dyaWRMYXllcn0gZnJvbSAnLi9HcmlkTGF5ZXInO1xyXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XHJcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XHJcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xyXG5cclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBUaWxlTGF5ZXJcclxuICogQGluaGVyaXRzIEdyaWRMYXllclxyXG4gKiBAYWthIEwuVGlsZUxheWVyXHJcbiAqIFVzZWQgdG8gbG9hZCBhbmQgZGlzcGxheSB0aWxlIGxheWVycyBvbiB0aGUgbWFwLiBOb3RlIHRoYXQgbW9zdCB0aWxlIHNlcnZlcnMgcmVxdWlyZSBhdHRyaWJ1dGlvbiwgd2hpY2ggeW91IGNhbiBzZXQgdW5kZXIgYExheWVyYC4gRXh0ZW5kcyBgR3JpZExheWVyYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogYGBganNcclxuICogTC50aWxlTGF5ZXIoJ2h0dHBzOi8vdGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmc/e2Zvb30nLCB7Zm9vOiAnYmFyJywgYXR0cmlidXRpb246ICcmY29weTsgPGEgaHJlZj1cImh0dHBzOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL2NvcHlyaWdodFwiPk9wZW5TdHJlZXRNYXA8L2E+IGNvbnRyaWJ1dG9ycyd9KS5hZGRUbyhtYXApO1xuICogYGBgXHJcbiAqXHJcbiAqIEBzZWN0aW9uIFVSTCB0ZW1wbGF0ZVxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBBIHN0cmluZyBvZiB0aGUgZm9sbG93aW5nIGZvcm06XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiAnaHR0cHM6Ly97c30uc29tZWRvbWFpbi5jb20vYmxhYmxhL3t6fS97eH0ve3l9e3J9LnBuZydcclxuICogYGBgXHJcbiAqXHJcbiAqIGB7c31gIG1lYW5zIG9uZSBvZiB0aGUgYXZhaWxhYmxlIHN1YmRvbWFpbnMgKHVzZWQgc2VxdWVudGlhbGx5IHRvIGhlbHAgd2l0aCBicm93c2VyIHBhcmFsbGVsIHJlcXVlc3RzIHBlciBkb21haW4gbGltaXRhdGlvbjsgc3ViZG9tYWluIHZhbHVlcyBhcmUgc3BlY2lmaWVkIGluIG9wdGlvbnM7IGBhYCwgYGJgIG9yIGBjYCBieSBkZWZhdWx0LCBjYW4gYmUgb21pdHRlZCksIGB7en1gIOKAlCB6b29tIGxldmVsLCBge3h9YCBhbmQgYHt5fWAg4oCUIHRpbGUgY29vcmRpbmF0ZXMuIGB7cn1gIGNhbiBiZSB1c2VkIHRvIGFkZCBcIiZjb21tYXQ7MnhcIiB0byB0aGUgVVJMIHRvIGxvYWQgcmV0aW5hIHRpbGVzLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHVzZSBjdXN0b20ga2V5cyBpbiB0aGUgdGVtcGxhdGUsIHdoaWNoIHdpbGwgYmUgW2V2YWx1YXRlZF0oI3V0aWwtdGVtcGxhdGUpIGZyb20gVGlsZUxheWVyIG9wdGlvbnMsIGxpa2UgdGhpczpcclxuICpcclxuICogYGBgXHJcbiAqIEwudGlsZUxheWVyKCdodHRwczovL3tzfS5zb21lZG9tYWluLmNvbS97Zm9vfS97en0ve3h9L3t5fS5wbmcnLCB7Zm9vOiAnYmFyJ30pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5cclxuZXhwb3J0IHZhciBUaWxlTGF5ZXIgPSBHcmlkTGF5ZXIuZXh0ZW5kKHtcclxuXHJcblx0Ly8gQHNlY3Rpb25cclxuXHQvLyBAYWthIFRpbGVMYXllciBvcHRpb25zXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBtaW5ab29tOiBOdW1iZXIgPSAwXHJcblx0XHQvLyBUaGUgbWluaW11bSB6b29tIGxldmVsIGRvd24gdG8gd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlIGRpc3BsYXllZCAoaW5jbHVzaXZlKS5cclxuXHRcdG1pblpvb206IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBtYXhab29tOiBOdW1iZXIgPSAxOFxyXG5cdFx0Ly8gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1cCB0byB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmUgZGlzcGxheWVkIChpbmNsdXNpdmUpLlxyXG5cdFx0bWF4Wm9vbTogMTgsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdWJkb21haW5zOiBTdHJpbmd8U3RyaW5nW10gPSAnYWJjJ1xyXG5cdFx0Ly8gU3ViZG9tYWlucyBvZiB0aGUgdGlsZSBzZXJ2aWNlLiBDYW4gYmUgcGFzc2VkIGluIHRoZSBmb3JtIG9mIG9uZSBzdHJpbmcgKHdoZXJlIGVhY2ggbGV0dGVyIGlzIGEgc3ViZG9tYWluIG5hbWUpIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcblx0XHRzdWJkb21haW5zOiAnYWJjJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGVycm9yVGlsZVVybDogU3RyaW5nID0gJydcclxuXHRcdC8vIFVSTCB0byB0aGUgdGlsZSBpbWFnZSB0byBzaG93IGluIHBsYWNlIG9mIHRoZSB0aWxlIHRoYXQgZmFpbGVkIHRvIGxvYWQuXHJcblx0XHRlcnJvclRpbGVVcmw6ICcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbU9mZnNldDogTnVtYmVyID0gMFxyXG5cdFx0Ly8gVGhlIHpvb20gbnVtYmVyIHVzZWQgaW4gdGlsZSBVUkxzIHdpbGwgYmUgb2Zmc2V0IHdpdGggdGhpcyB2YWx1ZS5cclxuXHRcdHpvb21PZmZzZXQ6IDAsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiB0bXM6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCBpbnZlcnNlcyBZIGF4aXMgbnVtYmVyaW5nIGZvciB0aWxlcyAodHVybiB0aGlzIG9uIGZvciBbVE1TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UaWxlX01hcF9TZXJ2aWNlKSBzZXJ2aWNlcykuXHJcblx0XHR0bXM6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gem9vbVJldmVyc2U6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgc2V0IHRvIHRydWUsIHRoZSB6b29tIG51bWJlciB1c2VkIGluIHRpbGUgVVJMcyB3aWxsIGJlIHJldmVyc2VkIChgbWF4Wm9vbSAtIHpvb21gIGluc3RlYWQgb2YgYHpvb21gKVxyXG5cdFx0em9vbVJldmVyc2U6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gZGV0ZWN0UmV0aW5hOiBCb29sZWFuID0gZmFsc2VcclxuXHRcdC8vIElmIGB0cnVlYCBhbmQgdXNlciBpcyBvbiBhIHJldGluYSBkaXNwbGF5LCBpdCB3aWxsIHJlcXVlc3QgZm91ciB0aWxlcyBvZiBoYWxmIHRoZSBzcGVjaWZpZWQgc2l6ZSBhbmQgYSBiaWdnZXIgem9vbSBsZXZlbCBpbiBwbGFjZSBvZiBvbmUgdG8gdXRpbGl6ZSB0aGUgaGlnaCByZXNvbHV0aW9uLlxyXG5cdFx0ZGV0ZWN0UmV0aW5hOiBmYWxzZSxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGNyb3NzT3JpZ2luOiBCb29sZWFufFN0cmluZyA9IGZhbHNlXHJcblx0XHQvLyBXaGV0aGVyIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgd2lsbCBiZSBhZGRlZCB0byB0aGUgdGlsZXMuXHJcblx0XHQvLyBJZiBhIFN0cmluZyBpcyBwcm92aWRlZCwgYWxsIHRpbGVzIHdpbGwgaGF2ZSB0aGVpciBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgc2V0IHRvIHRoZSBTdHJpbmcgcHJvdmlkZWQuIFRoaXMgaXMgbmVlZGVkIGlmIHlvdSB3YW50IHRvIGFjY2VzcyB0aWxlIHBpeGVsIGRhdGEuXHJcblx0XHQvLyBSZWZlciB0byBbQ09SUyBTZXR0aW5nc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXMpIGZvciB2YWxpZCBTdHJpbmcgdmFsdWVzLlxyXG5cdFx0Y3Jvc3NPcmlnaW46IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gcmVmZXJyZXJQb2xpY3k6IEJvb2xlYW58U3RyaW5nID0gZmFsc2VcclxuXHRcdC8vIFdoZXRoZXIgdGhlIHJlZmVycmVyUG9saWN5IGF0dHJpYnV0ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0aWxlcy5cclxuXHRcdC8vIElmIGEgU3RyaW5nIGlzIHByb3ZpZGVkLCBhbGwgdGlsZXMgd2lsbCBoYXZlIHRoZWlyIHJlZmVycmVyUG9saWN5IGF0dHJpYnV0ZSBzZXQgdG8gdGhlIFN0cmluZyBwcm92aWRlZC5cclxuXHRcdC8vIFRoaXMgbWF5IGJlIG5lZWRlZCBpZiB5b3VyIG1hcCdzIHJlbmRlcmluZyBjb250ZXh0IGhhcyBhIHN0cmljdCBkZWZhdWx0IGJ1dCB5b3VyIHRpbGUgcHJvdmlkZXIgZXhwZWN0cyBhIHZhbGlkIHJlZmVycmVyXHJcblx0XHQvLyAoZS5nLiB0byB2YWxpZGF0ZSBhbiBBUEkgdG9rZW4pLlxyXG5cdFx0Ly8gUmVmZXIgdG8gW0hUTUxJbWFnZUVsZW1lbnQucmVmZXJyZXJQb2xpY3ldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MSW1hZ2VFbGVtZW50L3JlZmVycmVyUG9saWN5KSBmb3IgdmFsaWQgU3RyaW5nIHZhbHVlcy5cclxuXHRcdHJlZmVycmVyUG9saWN5OiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0b3B0aW9ucyA9IFV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHQvLyBkZXRlY3RpbmcgcmV0aW5hIGRpc3BsYXlzLCBhZGp1c3RpbmcgdGlsZVNpemUgYW5kIHpvb20gbGV2ZWxzXHJcblx0XHRpZiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgQnJvd3Nlci5yZXRpbmEgJiYgb3B0aW9ucy5tYXhab29tID4gMCkge1xyXG5cclxuXHRcdFx0b3B0aW9ucy50aWxlU2l6ZSA9IE1hdGguZmxvb3Iob3B0aW9ucy50aWxlU2l6ZSAvIDIpO1xyXG5cclxuXHRcdFx0aWYgKCFvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcblx0XHRcdFx0b3B0aW9ucy56b29tT2Zmc2V0Kys7XHJcblx0XHRcdFx0b3B0aW9ucy5tYXhab29tID0gTWF0aC5tYXgob3B0aW9ucy5taW5ab29tLCBvcHRpb25zLm1heFpvb20gLSAxKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvcHRpb25zLnpvb21PZmZzZXQtLTtcclxuXHRcdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIG9wdGlvbnMubWluWm9vbSArIDEpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1heCgwLCBvcHRpb25zLm1pblpvb20pO1xyXG5cdFx0fSBlbHNlIGlmICghb3B0aW9ucy56b29tUmV2ZXJzZSkge1xyXG5cdFx0XHQvLyBtYWtlIHN1cmUgbWF4Wm9vbSBpcyBndGUgbWluWm9vbVxyXG5cdFx0XHRvcHRpb25zLm1heFpvb20gPSBNYXRoLm1heChvcHRpb25zLm1pblpvb20sIG9wdGlvbnMubWF4Wm9vbSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBtYWtlIHN1cmUgbWluWm9vbSBpcyBsdGUgbWF4Wm9vbVxyXG5cdFx0XHRvcHRpb25zLm1pblpvb20gPSBNYXRoLm1pbihvcHRpb25zLm1heFpvb20sIG9wdGlvbnMubWluWm9vbSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zLnN1YmRvbWFpbnMgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdG9wdGlvbnMuc3ViZG9tYWlucyA9IG9wdGlvbnMuc3ViZG9tYWlucy5zcGxpdCgnJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vbigndGlsZXVubG9hZCcsIHRoaXMuX29uVGlsZVJlbW92ZSk7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBzZXRVcmwodXJsOiBTdHJpbmcsIG5vUmVkcmF3PzogQm9vbGVhbik6IHRoaXNcclxuXHQvLyBVcGRhdGVzIHRoZSBsYXllcidzIFVSTCB0ZW1wbGF0ZSBhbmQgcmVkcmF3cyBpdCAodW5sZXNzIGBub1JlZHJhd2AgaXMgc2V0IHRvIGB0cnVlYCkuXHJcblx0Ly8gSWYgdGhlIFVSTCBkb2VzIG5vdCBjaGFuZ2UsIHRoZSBsYXllciB3aWxsIG5vdCBiZSByZWRyYXduIHVubGVzc1xyXG5cdC8vIHRoZSBub1JlZHJhdyBwYXJhbWV0ZXIgaXMgc2V0IHRvIGZhbHNlLlxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCwgbm9SZWRyYXcpIHtcclxuXHRcdGlmICh0aGlzLl91cmwgPT09IHVybCAmJiBub1JlZHJhdyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdG5vUmVkcmF3ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gQG1ldGhvZCBjcmVhdGVUaWxlKGNvb3JkczogT2JqZWN0LCBkb25lPzogRnVuY3Rpb24pOiBIVE1MRWxlbWVudFxyXG5cdC8vIENhbGxlZCBvbmx5IGludGVybmFsbHksIG92ZXJyaWRlcyBHcmlkTGF5ZXIncyBbYGNyZWF0ZVRpbGUoKWBdKCNncmlkbGF5ZXItY3JlYXRldGlsZSlcclxuXHQvLyB0byByZXR1cm4gYW4gYDxpbWc+YCBIVE1MIGVsZW1lbnQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgaW1hZ2UgVVJMIGdpdmVuIGBjb29yZHNgLiBUaGUgYGRvbmVgXHJcblx0Ly8gY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRpbGUgaGFzIGJlZW4gbG9hZGVkLlxyXG5cdGNyZWF0ZVRpbGU6IGZ1bmN0aW9uIChjb29yZHMsIGRvbmUpIHtcclxuXHRcdHZhciB0aWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblxyXG5cdFx0RG9tRXZlbnQub24odGlsZSwgJ2xvYWQnLCBVdGlsLmJpbmQodGhpcy5fdGlsZU9uTG9hZCwgdGhpcywgZG9uZSwgdGlsZSkpO1xyXG5cdFx0RG9tRXZlbnQub24odGlsZSwgJ2Vycm9yJywgVXRpbC5iaW5kKHRoaXMuX3RpbGVPbkVycm9yLCB0aGlzLCBkb25lLCB0aWxlKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiB8fCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICcnKSB7XHJcblx0XHRcdHRpbGUuY3Jvc3NPcmlnaW4gPSB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09IHRydWUgPyAnJyA6IHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmb3IgdGhpcyBuZXcgb3B0aW9uIHdlIGZvbGxvdyB0aGUgZG9jdW1lbnRlZCBiZWhhdmlvclxyXG5cdFx0Ly8gbW9yZSBjbG9zZWx5IGJ5IG9ubHkgc2V0dGluZyB0aGUgcHJvcGVydHkgd2hlbiBzdHJpbmdcclxuXHRcdGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnJlZmVycmVyUG9saWN5ID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHR0aWxlLnJlZmVycmVyUG9saWN5ID0gdGhpcy5vcHRpb25zLnJlZmVycmVyUG9saWN5O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRoZSBhbHQgYXR0cmlidXRlIGlzIHNldCB0byB0aGUgZW1wdHkgc3RyaW5nLFxyXG5cdFx0Ly8gYWxsb3dpbmcgc2NyZWVuIHJlYWRlcnMgdG8gaWdub3JlIHRoZSBkZWNvcmF0aXZlIGltYWdlIHRpbGVzLlxyXG5cdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1dBSS90dXRvcmlhbHMvaW1hZ2VzL2RlY29yYXRpdmUvXHJcblx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbC1hcmlhLyNlbC1pbWctZW1wdHktYWx0XHJcblx0XHR0aWxlLmFsdCA9ICcnO1xyXG5cclxuXHRcdHRpbGUuc3JjID0gdGhpcy5nZXRUaWxlVXJsKGNvb3Jkcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRpbGU7XHJcblx0fSxcclxuXHJcblx0Ly8gQHNlY3Rpb24gRXh0ZW5zaW9uIG1ldGhvZHNcclxuXHQvLyBAdW5pbmhlcml0YWJsZVxyXG5cdC8vIExheWVycyBleHRlbmRpbmcgYFRpbGVMYXllcmAgbWlnaHQgcmVpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBtZXRob2QuXHJcblx0Ly8gQG1ldGhvZCBnZXRUaWxlVXJsKGNvb3JkczogT2JqZWN0KTogU3RyaW5nXHJcblx0Ly8gQ2FsbGVkIG9ubHkgaW50ZXJuYWxseSwgcmV0dXJucyB0aGUgVVJMIGZvciBhIHRpbGUgZ2l2ZW4gaXRzIGNvb3JkaW5hdGVzLlxyXG5cdC8vIENsYXNzZXMgZXh0ZW5kaW5nIGBUaWxlTGF5ZXJgIGNhbiBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIHRvIHByb3ZpZGUgY3VzdG9tIHRpbGUgVVJMIG5hbWluZyBzY2hlbWVzLlxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRyOiBCcm93c2VyLnJldGluYSA/ICdAMngnIDogJycsXHJcblx0XHRcdHM6IHRoaXMuX2dldFN1YmRvbWFpbihjb29yZHMpLFxyXG5cdFx0XHR4OiBjb29yZHMueCxcclxuXHRcdFx0eTogY29vcmRzLnksXHJcblx0XHRcdHo6IHRoaXMuX2dldFpvb21Gb3JVcmwoKVxyXG5cdFx0fTtcclxuXHRcdGlmICh0aGlzLl9tYXAgJiYgIXRoaXMuX21hcC5vcHRpb25zLmNycy5pbmZpbml0ZSkge1xyXG5cdFx0XHR2YXIgaW52ZXJ0ZWRZID0gdGhpcy5fZ2xvYmFsVGlsZVJhbmdlLm1heC55IC0gY29vcmRzLnk7XHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMudG1zKSB7XHJcblx0XHRcdFx0ZGF0YVsneSddID0gaW52ZXJ0ZWRZO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRhdGFbJy15J10gPSBpbnZlcnRlZFk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFV0aWwudGVtcGxhdGUodGhpcy5fdXJsLCBVdGlsLmV4dGVuZChkYXRhLCB0aGlzLm9wdGlvbnMpKTtcclxuXHR9LFxyXG5cclxuXHRfdGlsZU9uTG9hZDogZnVuY3Rpb24gKGRvbmUsIHRpbGUpIHtcclxuXHRcdC8vIEZvciBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8zMzMyXHJcblx0XHRpZiAoQnJvd3Nlci5pZWx0OSkge1xyXG5cdFx0XHRzZXRUaW1lb3V0KFV0aWwuYmluZChkb25lLCB0aGlzLCBudWxsLCB0aWxlKSwgMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkb25lKG51bGwsIHRpbGUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF90aWxlT25FcnJvcjogZnVuY3Rpb24gKGRvbmUsIHRpbGUsIGUpIHtcclxuXHRcdHZhciBlcnJvclVybCA9IHRoaXMub3B0aW9ucy5lcnJvclRpbGVVcmw7XHJcblx0XHRpZiAoZXJyb3JVcmwgJiYgdGlsZS5nZXRBdHRyaWJ1dGUoJ3NyYycpICE9PSBlcnJvclVybCkge1xyXG5cdFx0XHR0aWxlLnNyYyA9IGVycm9yVXJsO1xyXG5cdFx0fVxyXG5cdFx0ZG9uZShlLCB0aWxlKTtcclxuXHR9LFxyXG5cclxuXHRfb25UaWxlUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0ZS50aWxlLm9ubG9hZCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0X2dldFpvb21Gb3JVcmw6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciB6b29tID0gdGhpcy5fdGlsZVpvb20sXHJcblx0XHRtYXhab29tID0gdGhpcy5vcHRpb25zLm1heFpvb20sXHJcblx0XHR6b29tUmV2ZXJzZSA9IHRoaXMub3B0aW9ucy56b29tUmV2ZXJzZSxcclxuXHRcdHpvb21PZmZzZXQgPSB0aGlzLm9wdGlvbnMuem9vbU9mZnNldDtcclxuXHJcblx0XHRpZiAoem9vbVJldmVyc2UpIHtcclxuXHRcdFx0em9vbSA9IG1heFpvb20gLSB6b29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB6b29tICsgem9vbU9mZnNldDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0U3ViZG9tYWluOiBmdW5jdGlvbiAodGlsZVBvaW50KSB7XHJcblx0XHR2YXIgaW5kZXggPSBNYXRoLmFicyh0aWxlUG9pbnQueCArIHRpbGVQb2ludC55KSAlIHRoaXMub3B0aW9ucy5zdWJkb21haW5zLmxlbmd0aDtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc3ViZG9tYWluc1tpbmRleF07XHJcblx0fSxcclxuXHJcblx0Ly8gc3RvcHMgbG9hZGluZyBhbGwgdGlsZXMgaW4gdGhlIGJhY2tncm91bmQgbGF5ZXJcclxuXHRfYWJvcnRMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaSwgdGlsZTtcclxuXHRcdGZvciAoaSBpbiB0aGlzLl90aWxlcykge1xyXG5cdFx0XHRpZiAodGhpcy5fdGlsZXNbaV0uY29vcmRzLnogIT09IHRoaXMuX3RpbGVab29tKSB7XHJcblx0XHRcdFx0dGlsZSA9IHRoaXMuX3RpbGVzW2ldLmVsO1xyXG5cclxuXHRcdFx0XHR0aWxlLm9ubG9hZCA9IFV0aWwuZmFsc2VGbjtcclxuXHRcdFx0XHR0aWxlLm9uZXJyb3IgPSBVdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0XHRcdGlmICghdGlsZS5jb21wbGV0ZSkge1xyXG5cdFx0XHRcdFx0dGlsZS5zcmMgPSBVdGlsLmVtcHR5SW1hZ2VVcmw7XHJcblx0XHRcdFx0XHR2YXIgY29vcmRzID0gdGhpcy5fdGlsZXNbaV0uY29vcmRzO1xyXG5cdFx0XHRcdFx0RG9tVXRpbC5yZW1vdmUodGlsZSk7XHJcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fdGlsZXNbaV07XHJcblx0XHRcdFx0XHQvLyBAZXZlbnQgdGlsZWFib3J0OiBUaWxlRXZlbnRcclxuXHRcdFx0XHRcdC8vIEZpcmVkIHdoZW4gYSB0aWxlIHdhcyBsb2FkaW5nIGJ1dCBpcyBub3cgbm90IHdhbnRlZC5cclxuXHRcdFx0XHRcdHRoaXMuZmlyZSgndGlsZWFib3J0Jywge1xyXG5cdFx0XHRcdFx0XHR0aWxlOiB0aWxlLFxyXG5cdFx0XHRcdFx0XHRjb29yZHM6IGNvb3Jkc1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZVRpbGU6IGZ1bmN0aW9uIChrZXkpIHtcclxuXHRcdHZhciB0aWxlID0gdGhpcy5fdGlsZXNba2V5XTtcclxuXHRcdGlmICghdGlsZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBDYW5jZWxzIGFueSBwZW5kaW5nIGh0dHAgcmVxdWVzdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aWxlXHJcblx0XHR0aWxlLmVsLnNldEF0dHJpYnV0ZSgnc3JjJywgVXRpbC5lbXB0eUltYWdlVXJsKTtcclxuXHJcblx0XHRyZXR1cm4gR3JpZExheWVyLnByb3RvdHlwZS5fcmVtb3ZlVGlsZS5jYWxsKHRoaXMsIGtleSk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVSZWFkeTogZnVuY3Rpb24gKGNvb3JkcywgZXJyLCB0aWxlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCB8fCAodGlsZSAmJiB0aWxlLmdldEF0dHJpYnV0ZSgnc3JjJykgPT09IFV0aWwuZW1wdHlJbWFnZVVybCkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBHcmlkTGF5ZXIucHJvdG90eXBlLl90aWxlUmVhZHkuY2FsbCh0aGlzLCBjb29yZHMsIGVyciwgdGlsZSk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vLyBAZmFjdG9yeSBMLnRpbGVsYXllcih1cmxUZW1wbGF0ZTogU3RyaW5nLCBvcHRpb25zPzogVGlsZUxheWVyIG9wdGlvbnMpXHJcbi8vIEluc3RhbnRpYXRlcyBhIHRpbGUgbGF5ZXIgb2JqZWN0IGdpdmVuIGEgYFVSTCB0ZW1wbGF0ZWAgYW5kIG9wdGlvbmFsbHkgYW4gb3B0aW9ucyBvYmplY3QuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGlsZUxheWVyKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgVGlsZUxheWVyKHVybCwgb3B0aW9ucyk7XHJcbn1cclxuIiwiaW1wb3J0IHtUaWxlTGF5ZXJ9IGZyb20gJy4vVGlsZUxheWVyJztcclxuaW1wb3J0IHtleHRlbmQsIHNldE9wdGlvbnMsIGdldFBhcmFtU3RyaW5nfSBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xyXG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xyXG5pbXBvcnQge0VQU0c0MzI2fSBmcm9tICcuLi8uLi9nZW8vY3JzL0NSUy5FUFNHNDMyNic7XHJcbmltcG9ydCB7dG9Cb3VuZHN9IGZyb20gJy4uLy4uL2dlb21ldHJ5L0JvdW5kcyc7XHJcblxyXG4vKlxyXG4gKiBAY2xhc3MgVGlsZUxheWVyLldNU1xyXG4gKiBAaW5oZXJpdHMgVGlsZUxheWVyXHJcbiAqIEBha2EgTC5UaWxlTGF5ZXIuV01TXHJcbiAqIFVzZWQgdG8gZGlzcGxheSBbV01TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWFwX1NlcnZpY2UpIHNlcnZpY2VzIGFzIHRpbGUgbGF5ZXJzIG9uIHRoZSBtYXAuIEV4dGVuZHMgYFRpbGVMYXllcmAuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIHZhciBuZXhyYWQgPSBMLnRpbGVMYXllci53bXMoXCJodHRwOi8vbWVzb25ldC5hZ3Jvbi5pYXN0YXRlLmVkdS9jZ2ktYmluL3dtcy9uZXhyYWQvbjByLmNnaVwiLCB7XHJcbiAqIFx0bGF5ZXJzOiAnbmV4cmFkLW4wci05MDA5MTMnLFxyXG4gKiBcdGZvcm1hdDogJ2ltYWdlL3BuZycsXHJcbiAqIFx0dHJhbnNwYXJlbnQ6IHRydWUsXHJcbiAqIFx0YXR0cmlidXRpb246IFwiV2VhdGhlciBkYXRhIMKpIDIwMTIgSUVNIE5leHJhZFwiXHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICovXHJcblxyXG5leHBvcnQgdmFyIFRpbGVMYXllcldNUyA9IFRpbGVMYXllci5leHRlbmQoe1xyXG5cclxuXHQvLyBAc2VjdGlvblxyXG5cdC8vIEBha2EgVGlsZUxheWVyLldNUyBvcHRpb25zXHJcblx0Ly8gSWYgYW55IGN1c3RvbSBvcHRpb25zIG5vdCBkb2N1bWVudGVkIGhlcmUgYXJlIHVzZWQsIHRoZXkgd2lsbCBiZSBzZW50IHRvIHRoZVxyXG5cdC8vIFdNUyBzZXJ2ZXIgYXMgZXh0cmEgcGFyYW1ldGVycyBpbiBlYWNoIHJlcXVlc3QgVVJMLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yXHJcblx0Ly8gW25vbi1zdGFuZGFyZCB2ZW5kb3IgV01TIHBhcmFtZXRlcnNdKGh0dHBzOi8vZG9jcy5nZW9zZXJ2ZXIub3JnL3N0YWJsZS9lbi91c2VyL3NlcnZpY2VzL3dtcy92ZW5kb3IuaHRtbCkuXHJcblx0ZGVmYXVsdFdtc1BhcmFtczoge1xyXG5cdFx0c2VydmljZTogJ1dNUycsXHJcblx0XHRyZXF1ZXN0OiAnR2V0TWFwJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGxheWVyczogU3RyaW5nID0gJydcclxuXHRcdC8vICoqKHJlcXVpcmVkKSoqIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFdNUyBsYXllcnMgdG8gc2hvdy5cclxuXHRcdGxheWVyczogJycsXHJcblxyXG5cdFx0Ly8gQG9wdGlvbiBzdHlsZXM6IFN0cmluZyA9ICcnXHJcblx0XHQvLyBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBXTVMgc3R5bGVzLlxyXG5cdFx0c3R5bGVzOiAnJyxcclxuXHJcblx0XHQvLyBAb3B0aW9uIGZvcm1hdDogU3RyaW5nID0gJ2ltYWdlL2pwZWcnXHJcblx0XHQvLyBXTVMgaW1hZ2UgZm9ybWF0ICh1c2UgYCdpbWFnZS9wbmcnYCBmb3IgbGF5ZXJzIHdpdGggdHJhbnNwYXJlbmN5KS5cclxuXHRcdGZvcm1hdDogJ2ltYWdlL2pwZWcnLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdHJhbnNwYXJlbnQ6IEJvb2xlYW4gPSBmYWxzZVxyXG5cdFx0Ly8gSWYgYHRydWVgLCB0aGUgV01TIHNlcnZpY2Ugd2lsbCByZXR1cm4gaW1hZ2VzIHdpdGggdHJhbnNwYXJlbmN5LlxyXG5cdFx0dHJhbnNwYXJlbnQ6IGZhbHNlLFxyXG5cclxuXHRcdC8vIEBvcHRpb24gdmVyc2lvbjogU3RyaW5nID0gJzEuMS4xJ1xyXG5cdFx0Ly8gVmVyc2lvbiBvZiB0aGUgV01TIHNlcnZpY2UgdG8gdXNlXHJcblx0XHR2ZXJzaW9uOiAnMS4xLjEnXHJcblx0fSxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gQG9wdGlvbiBjcnM6IENSUyA9IG51bGxcclxuXHRcdC8vIENvb3JkaW5hdGUgUmVmZXJlbmNlIFN5c3RlbSB0byB1c2UgZm9yIHRoZSBXTVMgcmVxdWVzdHMsIGRlZmF1bHRzIHRvXHJcblx0XHQvLyBtYXAgQ1JTLiBEb24ndCBjaGFuZ2UgdGhpcyBpZiB5b3UncmUgbm90IHN1cmUgd2hhdCBpdCBtZWFucy5cclxuXHRcdGNyczogbnVsbCxcclxuXHJcblx0XHQvLyBAb3B0aW9uIHVwcGVyY2FzZTogQm9vbGVhbiA9IGZhbHNlXHJcblx0XHQvLyBJZiBgdHJ1ZWAsIFdNUyByZXF1ZXN0IHBhcmFtZXRlciBrZXlzIHdpbGwgYmUgdXBwZXJjYXNlLlxyXG5cdFx0dXBwZXJjYXNlOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcblx0XHR0aGlzLl91cmwgPSB1cmw7XHJcblxyXG5cdFx0dmFyIHdtc1BhcmFtcyA9IGV4dGVuZCh7fSwgdGhpcy5kZWZhdWx0V21zUGFyYW1zKTtcclxuXHJcblx0XHQvLyBhbGwga2V5cyB0aGF0IGFyZSBub3QgVGlsZUxheWVyIG9wdGlvbnMgZ28gdG8gV01TIHBhcmFtc1xyXG5cdFx0Zm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XHJcblx0XHRcdGlmICghKGkgaW4gdGhpcy5vcHRpb25zKSkge1xyXG5cdFx0XHRcdHdtc1BhcmFtc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgcmVhbFJldGluYSA9IG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEJyb3dzZXIucmV0aW5hID8gMiA6IDE7XHJcblx0XHR2YXIgdGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCk7XHJcblx0XHR3bXNQYXJhbXMud2lkdGggPSB0aWxlU2l6ZS54ICogcmVhbFJldGluYTtcclxuXHRcdHdtc1BhcmFtcy5oZWlnaHQgPSB0aWxlU2l6ZS55ICogcmVhbFJldGluYTtcclxuXHJcblx0XHR0aGlzLndtc1BhcmFtcyA9IHdtc1BhcmFtcztcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cclxuXHRcdHRoaXMuX2NycyA9IHRoaXMub3B0aW9ucy5jcnMgfHwgbWFwLm9wdGlvbnMuY3JzO1xyXG5cdFx0dGhpcy5fd21zVmVyc2lvbiA9IHBhcnNlRmxvYXQodGhpcy53bXNQYXJhbXMudmVyc2lvbik7XHJcblxyXG5cdFx0dmFyIHByb2plY3Rpb25LZXkgPSB0aGlzLl93bXNWZXJzaW9uID49IDEuMyA/ICdjcnMnIDogJ3Nycyc7XHJcblx0XHR0aGlzLndtc1BhcmFtc1twcm9qZWN0aW9uS2V5XSA9IHRoaXMuX2Nycy5jb2RlO1xyXG5cclxuXHRcdFRpbGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xyXG5cdH0sXHJcblxyXG5cdGdldFRpbGVVcmw6IGZ1bmN0aW9uIChjb29yZHMpIHtcclxuXHJcblx0XHR2YXIgdGlsZUJvdW5kcyA9IHRoaXMuX3RpbGVDb29yZHNUb053U2UoY29vcmRzKSxcclxuXHRcdCAgICBjcnMgPSB0aGlzLl9jcnMsXHJcblx0XHQgICAgYm91bmRzID0gdG9Cb3VuZHMoY3JzLnByb2plY3QodGlsZUJvdW5kc1swXSksIGNycy5wcm9qZWN0KHRpbGVCb3VuZHNbMV0pKSxcclxuXHRcdCAgICBtaW4gPSBib3VuZHMubWluLFxyXG5cdFx0ICAgIG1heCA9IGJvdW5kcy5tYXgsXHJcblx0XHQgICAgYmJveCA9ICh0aGlzLl93bXNWZXJzaW9uID49IDEuMyAmJiB0aGlzLl9jcnMgPT09IEVQU0c0MzI2ID9cclxuXHRcdCAgICBbbWluLnksIG1pbi54LCBtYXgueSwgbWF4LnhdIDpcclxuXHRcdCAgICBbbWluLngsIG1pbi55LCBtYXgueCwgbWF4LnldKS5qb2luKCcsJyksXHJcblx0XHQgICAgdXJsID0gVGlsZUxheWVyLnByb3RvdHlwZS5nZXRUaWxlVXJsLmNhbGwodGhpcywgY29vcmRzKTtcclxuXHRcdHJldHVybiB1cmwgK1xyXG5cdFx0XHRnZXRQYXJhbVN0cmluZyh0aGlzLndtc1BhcmFtcywgdXJsLCB0aGlzLm9wdGlvbnMudXBwZXJjYXNlKSArXHJcblx0XHRcdCh0aGlzLm9wdGlvbnMudXBwZXJjYXNlID8gJyZCQk9YPScgOiAnJmJib3g9JykgKyBiYm94O1xyXG5cdH0sXHJcblxyXG5cdC8vIEBtZXRob2Qgc2V0UGFyYW1zKHBhcmFtczogT2JqZWN0LCBub1JlZHJhdz86IEJvb2xlYW4pOiB0aGlzXHJcblx0Ly8gTWVyZ2VzIGFuIG9iamVjdCB3aXRoIHRoZSBuZXcgcGFyYW1ldGVycyBhbmQgcmUtcmVxdWVzdHMgdGlsZXMgb24gdGhlIGN1cnJlbnQgc2NyZWVuICh1bmxlc3MgYG5vUmVkcmF3YCB3YXMgc2V0IHRvIHRydWUpLlxyXG5cdHNldFBhcmFtczogZnVuY3Rpb24gKHBhcmFtcywgbm9SZWRyYXcpIHtcclxuXHJcblx0XHRleHRlbmQodGhpcy53bXNQYXJhbXMsIHBhcmFtcyk7XHJcblxyXG5cdFx0aWYgKCFub1JlZHJhdykge1xyXG5cdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gQGZhY3RvcnkgTC50aWxlTGF5ZXIud21zKGJhc2VVcmw6IFN0cmluZywgb3B0aW9uczogVGlsZUxheWVyLldNUyBvcHRpb25zKVxyXG4vLyBJbnN0YW50aWF0ZXMgYSBXTVMgdGlsZSBsYXllciBvYmplY3QgZ2l2ZW4gYSBiYXNlIFVSTCBvZiB0aGUgV01TIHNlcnZpY2UgYW5kIGEgV01TIHBhcmFtZXRlcnMvb3B0aW9ucyBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiB0aWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBUaWxlTGF5ZXJXTVModXJsLCBvcHRpb25zKTtcclxufVxyXG4iLCJleHBvcnQge0dyaWRMYXllciwgZ3JpZExheWVyfSBmcm9tICcuL0dyaWRMYXllcic7XG5pbXBvcnQge1RpbGVMYXllciwgdGlsZUxheWVyfSBmcm9tICcuL1RpbGVMYXllcic7XG5pbXBvcnQge1RpbGVMYXllcldNUywgdGlsZUxheWVyV01TfSBmcm9tICcuL1RpbGVMYXllci5XTVMnO1xuVGlsZUxheWVyLldNUyA9IFRpbGVMYXllcldNUztcbnRpbGVMYXllci53bXMgPSB0aWxlTGF5ZXJXTVM7XG5leHBvcnQge1RpbGVMYXllciwgdGlsZUxheWVyfTtcbiIsImltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL0xheWVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcbmltcG9ydCB7Qm91bmRzfSBmcm9tICcuLi8uLi9nZW9tZXRyeS9Cb3VuZHMnO1xuXG5cblxuLypcbiAqIEBjbGFzcyBSZW5kZXJlclxuICogQGluaGVyaXRzIExheWVyXG4gKiBAYWthIEwuUmVuZGVyZXJcbiAqXG4gKiBCYXNlIGNsYXNzIGZvciB2ZWN0b3IgcmVuZGVyZXIgaW1wbGVtZW50YXRpb25zIChgU1ZHYCwgYENhbnZhc2ApLiBIYW5kbGVzIHRoZVxuICogRE9NIGNvbnRhaW5lciBvZiB0aGUgcmVuZGVyZXIsIGl0cyBib3VuZHMsIGFuZCBpdHMgem9vbSBhbmltYXRpb24uXG4gKlxuICogQSBgUmVuZGVyZXJgIHdvcmtzIGFzIGFuIGltcGxpY2l0IGxheWVyIGdyb3VwIGZvciBhbGwgYFBhdGhgcyAtIHRoZSByZW5kZXJlclxuICogaXRzZWxmIGNhbiBiZSBhZGRlZCBvciByZW1vdmVkIHRvIHRoZSBtYXAuIEFsbCBwYXRocyB1c2UgYSByZW5kZXJlciwgd2hpY2ggY2FuXG4gKiBiZSBpbXBsaWNpdCAodGhlIG1hcCB3aWxsIGRlY2lkZSB0aGUgdHlwZSBvZiByZW5kZXJlciBhbmQgdXNlIGl0IGF1dG9tYXRpY2FsbHkpXG4gKiBvciBleHBsaWNpdCAodXNpbmcgdGhlIFtgcmVuZGVyZXJgXSgjcGF0aC1yZW5kZXJlcikgb3B0aW9uIG9mIHRoZSBwYXRoKS5cbiAqXG4gKiBEbyBub3QgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHksIHVzZSBgU1ZHYCBhbmQgYENhbnZhc2AgaW5zdGVhZC5cbiAqXG4gKiBAZXZlbnQgdXBkYXRlOiBFdmVudFxuICogRmlyZWQgd2hlbiB0aGUgcmVuZGVyZXIgdXBkYXRlcyBpdHMgYm91bmRzLCBjZW50ZXIgYW5kIHpvb20sIGZvciBleGFtcGxlIHdoZW5cbiAqIGl0cyBtYXAgaGFzIG1vdmVkXG4gKi9cblxuZXhwb3J0IHZhciBSZW5kZXJlciA9IExheWVyLmV4dGVuZCh7XG5cblx0Ly8gQHNlY3Rpb25cblx0Ly8gQGFrYSBSZW5kZXJlciBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHBhZGRpbmc6IE51bWJlciA9IDAuMVxuXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpcCBhcmVhIGFyb3VuZCB0aGUgbWFwIHZpZXcgKHJlbGF0aXZlIHRvIGl0cyBzaXplKVxuXHRcdC8vIGUuZy4gMC4xIHdvdWxkIGJlIDEwJSBvZiBtYXAgdmlldyBpbiBlYWNoIGRpcmVjdGlvblxuXHRcdHBhZGRpbmc6IDAuMVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0VXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdFV0aWwuc3RhbXAodGhpcyk7XG5cdFx0dGhpcy5fbGF5ZXJzID0gdGhpcy5fbGF5ZXJzIHx8IHt9O1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdHRoaXMuX2luaXRDb250YWluZXIoKTsgLy8gZGVmaW5lZCBieSByZW5kZXJlciBpbXBsZW1lbnRhdGlvbnNcblxuXHRcdFx0Ly8gYWx3YXlzIGtlZXAgdHJhbnNmb3JtLW9yaWdpbiBhcyAwIDBcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0XHR0aGlzLm9uKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVQYXRocywgdGhpcyk7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLm9mZigndXBkYXRlJywgdGhpcy5fdXBkYXRlUGF0aHMsIHRoaXMpO1xuXHRcdHRoaXMuX2Rlc3Ryb3lDb250YWluZXIoKTtcblx0fSxcblxuXHRnZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZXZlbnRzID0ge1xuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl9yZXNldCxcblx0XHRcdHpvb206IHRoaXMuX29uWm9vbSxcblx0XHRcdG1vdmVlbmQ6IHRoaXMuX3VwZGF0ZSxcblx0XHRcdHpvb21lbmQ6IHRoaXMuX29uWm9vbUVuZFxuXHRcdH07XG5cdFx0aWYgKHRoaXMuX3pvb21BbmltYXRlZCkge1xuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fb25BbmltWm9vbTtcblx0XHR9XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25BbmltWm9vbTogZnVuY3Rpb24gKGV2KSB7XG5cdFx0dGhpcy5fdXBkYXRlVHJhbnNmb3JtKGV2LmNlbnRlciwgZXYuem9vbSk7XG5cdH0sXG5cblx0X29uWm9vbTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9tYXAuZ2V0Q2VudGVyKCksIHRoaXMuX21hcC5nZXRab29tKCkpO1xuXHR9LFxuXG5cdF91cGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20pIHtcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9tYXAuZ2V0Wm9vbVNjYWxlKHpvb20sIHRoaXMuX3pvb20pLFxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuX21hcC5nZXRTaXplKCkubXVsdGlwbHlCeSgwLjUgKyB0aGlzLm9wdGlvbnMucGFkZGluZyksXG5cdFx0ICAgIGN1cnJlbnRDZW50ZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2NlbnRlciwgem9vbSksXG5cblx0XHQgICAgdG9wTGVmdE9mZnNldCA9IHZpZXdIYWxmLm11bHRpcGx5QnkoLXNjYWxlKS5hZGQoY3VycmVudENlbnRlclBvaW50KVxuXHRcdFx0XHQgIC5zdWJ0cmFjdCh0aGlzLl9tYXAuX2dldE5ld1BpeGVsT3JpZ2luKGNlbnRlciwgem9vbSkpO1xuXG5cdFx0aWYgKEJyb3dzZXIuYW55M2QpIHtcblx0XHRcdERvbVV0aWwuc2V0VHJhbnNmb3JtKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCwgc2NhbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHREb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgdG9wTGVmdE9mZnNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHRcdHRoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20pO1xuXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9yZXNldCgpO1xuXHRcdH1cblx0fSxcblxuXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG5cdFx0XHR0aGlzLl9sYXllcnNbaWRdLl9wcm9qZWN0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVQYXRoczogZnVuY3Rpb24gKCkge1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0dGhpcy5fbGF5ZXJzW2lkXS5fdXBkYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBVcGRhdGUgcGl4ZWwgYm91bmRzIG9mIHJlbmRlcmVyIGNvbnRhaW5lciAoZm9yIHBvc2l0aW9uaW5nL3NpemluZy9jbGlwcGluZyBsYXRlcilcblx0XHQvLyBTdWJjbGFzc2VzIGFyZSByZXNwb25zaWJsZSBvZiBmaXJpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxuXHRcdHZhciBwID0gdGhpcy5vcHRpb25zLnBhZGRpbmcsXG5cdFx0ICAgIHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtaW4gPSB0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoc2l6ZS5tdWx0aXBseUJ5KC1wKSkucm91bmQoKTtcblxuXHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHMobWluLCBtaW4uYWRkKHNpemUubXVsdGlwbHlCeSgxICsgcCAqIDIpKS5yb3VuZCgpKTtcblxuXHRcdHRoaXMuX2NlbnRlciA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcblx0XHR0aGlzLl96b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0fVxufSk7XG4iLCJpbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCBCcm93c2VyIGZyb20gJy4uLy4uL2NvcmUvQnJvd3Nlcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEBjbGFzcyBDYW52YXNcbiAqIEBpbmhlcml0cyBSZW5kZXJlclxuICogQGFrYSBMLkNhbnZhc1xuICpcbiAqIEFsbG93cyB2ZWN0b3IgbGF5ZXJzIHRvIGJlIGRpc3BsYXllZCB3aXRoIFtgPGNhbnZhcz5gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQ2FudmFzX0FQSSkuXG4gKiBJbmhlcml0cyBgUmVuZGVyZXJgLlxuICpcbiAqIER1ZSB0byBbdGVjaG5pY2FsIGxpbWl0YXRpb25zXShodHRwczovL2Nhbml1c2UuY29tL2NhbnZhcyksIENhbnZhcyBpcyBub3RcbiAqIGF2YWlsYWJsZSBpbiBhbGwgd2ViIGJyb3dzZXJzLCBub3RhYmx5IElFOCwgYW5kIG92ZXJsYXBwaW5nIGdlb21ldHJpZXMgbWlnaHRcbiAqIG5vdCBkaXNwbGF5IHByb3Blcmx5IGluIHNvbWUgZWRnZSBjYXNlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZSBDYW52YXMgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICogXHRyZW5kZXJlcjogTC5jYW52YXMoKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2UgYSBDYW52YXMgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAqIHZhciBteVJlbmRlcmVyID0gTC5jYW52YXMoeyBwYWRkaW5nOiAwLjUgfSk7XG4gKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgQ2FudmFzID0gUmVuZGVyZXIuZXh0ZW5kKHtcblxuXHQvLyBAc2VjdGlvblxuXHQvLyBAYWthIENhbnZhcyBvcHRpb25zXG5cdG9wdGlvbnM6IHtcblx0XHQvLyBAb3B0aW9uIHRvbGVyYW5jZTogTnVtYmVyID0gMFxuXHRcdC8vIEhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpY2sgdG9sZXJhbmNlIGFyb3VuZCBhIHBhdGgvb2JqZWN0IG9uIHRoZSBtYXAuXG5cdFx0dG9sZXJhbmNlOiAwXG5cdH0sXG5cblx0Z2V0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGV2ZW50cyA9IFJlbmRlcmVyLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtcblx0XHRldmVudHMudmlld3ByZXJlc2V0ID0gdGhpcy5fb25WaWV3UHJlUmVzZXQ7XG5cdFx0cmV0dXJuIGV2ZW50cztcblx0fSxcblxuXHRfb25WaWV3UHJlUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBTZXQgYSBmbGFnIHNvIHRoYXQgYSB2aWV3cHJlcmVzZXQrbW92ZWVuZCt2aWV3cmVzZXQgb25seSB1cGRhdGVzJnJlZHJhd3Mgb25jZVxuXHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSB0cnVlO1xuXHR9LFxuXG5cdG9uQWRkOiBmdW5jdGlvbiAoKSB7XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcyk7XG5cblx0XHQvLyBSZWRyYXcgdmVjdG9ycyBzaW5jZSBjYW52YXMgaXMgY2xlYXJlZCB1cG9uIHJlbW92YWwsXG5cdFx0Ly8gaW4gY2FzZSBvZiByZW1vdmluZyB0aGUgcmVuZGVyZXIgaXRzZWxmIGZyb20gdGhlIG1hcC5cblx0XHR0aGlzLl9kcmF3KCk7XG5cdH0sXG5cblx0X2luaXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub24oY29udGFpbmVyLCAnY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgY29udGV4dG1lbnUnLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihjb250YWluZXIsICdtb3VzZW91dCcsIHRoaXMuX2hhbmRsZU1vdXNlT3V0LCB0aGlzKTtcblx0XHRjb250YWluZXJbJ19sZWFmbGV0X2Rpc2FibGVfZXZlbnRzJ10gPSB0cnVlO1xuXG5cdFx0dGhpcy5fY3R4ID0gY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XG5cdH0sXG5cblx0X2Rlc3Ryb3lDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZWRyYXdSZXF1ZXN0KTtcblx0XHRkZWxldGUgdGhpcy5fY3R4O1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcblx0fSxcblxuXHRfdXBkYXRlUGF0aHM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocykgeyByZXR1cm47IH1cblxuXHRcdHZhciBsYXllcjtcblx0XHR0aGlzLl9yZWRyYXdCb3VuZHMgPSBudWxsO1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX2xheWVycykge1xuXHRcdFx0bGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuXHRcdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdH1cblx0XHR0aGlzLl9yZWRyYXcoKTtcblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcC5fYW5pbWF0aW5nWm9vbSAmJiB0aGlzLl9ib3VuZHMpIHsgcmV0dXJuOyB9XG5cblx0XHRSZW5kZXJlci5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG5cdFx0dmFyIGIgPSB0aGlzLl9ib3VuZHMsXG5cdFx0ICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcixcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBtID0gQnJvd3Nlci5yZXRpbmEgPyAyIDogMTtcblxuXHRcdERvbVV0aWwuc2V0UG9zaXRpb24oY29udGFpbmVyLCBiLm1pbik7XG5cblx0XHQvLyBzZXQgY2FudmFzIHNpemUgKGFsc28gY2xlYXJpbmcgaXQpOyB1c2UgZG91YmxlIHNpemUgb24gcmV0aW5hXG5cdFx0Y29udGFpbmVyLndpZHRoID0gbSAqIHNpemUueDtcblx0XHRjb250YWluZXIuaGVpZ2h0ID0gbSAqIHNpemUueTtcblx0XHRjb250YWluZXIuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuXHRcdGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xuXG5cdFx0aWYgKEJyb3dzZXIucmV0aW5hKSB7XG5cdFx0XHR0aGlzLl9jdHguc2NhbGUoMiwgMik7XG5cdFx0fVxuXG5cdFx0Ly8gdHJhbnNsYXRlIHNvIHdlIHVzZSB0aGUgc2FtZSBwYXRoIGNvb3JkaW5hdGVzIGFmdGVyIGNhbnZhcyBlbGVtZW50IG1vdmVzXG5cdFx0dGhpcy5fY3R4LnRyYW5zbGF0ZSgtYi5taW4ueCwgLWIubWluLnkpO1xuXG5cdFx0Ly8gVGVsbCBwYXRocyB0byByZWRyYXcgdGhlbXNlbHZlc1xuXHRcdHRoaXMuZmlyZSgndXBkYXRlJyk7XG5cdH0sXG5cblx0X3Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl9yZXNldC5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpIHtcblx0XHRcdHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3VwZGF0ZVBhdGhzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildID0gbGF5ZXI7XG5cblx0XHR2YXIgb3JkZXIgPSBsYXllci5fb3JkZXIgPSB7XG5cdFx0XHRsYXllcjogbGF5ZXIsXG5cdFx0XHRwcmV2OiB0aGlzLl9kcmF3TGFzdCxcblx0XHRcdG5leHQ6IG51bGxcblx0XHR9O1xuXHRcdGlmICh0aGlzLl9kcmF3TGFzdCkgeyB0aGlzLl9kcmF3TGFzdC5uZXh0ID0gb3JkZXI7IH1cblx0XHR0aGlzLl9kcmF3TGFzdCA9IG9yZGVyO1xuXHRcdHRoaXMuX2RyYXdGaXJzdCA9IHRoaXMuX2RyYXdGaXJzdCB8fCB0aGlzLl9kcmF3TGFzdDtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RyYXdMYXN0ID0gcHJldjtcblx0XHR9XG5cdFx0aWYgKHByZXYpIHtcblx0XHRcdHByZXYubmV4dCA9IG5leHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RyYXdGaXJzdCA9IG5leHQ7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIGxheWVyLl9vcmRlcjtcblxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbVXRpbC5zdGFtcChsYXllcildO1xuXG5cdFx0dGhpcy5fcmVxdWVzdFJlZHJhdyhsYXllcik7XG5cdH0sXG5cblx0X3VwZGF0ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdC8vIFJlZHJhdyB0aGUgdW5pb24gb2YgdGhlIGxheWVyJ3Mgb2xkIHBpeGVsXG5cdFx0Ly8gYm91bmRzIGFuZCB0aGUgbmV3IHBpeGVsIGJvdW5kcy5cblx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuXHRcdGxheWVyLl9wcm9qZWN0KCk7XG5cdFx0bGF5ZXIuX3VwZGF0ZSgpO1xuXHRcdC8vIFRoZSByZWRyYXcgd2lsbCBleHRlbmQgdGhlIHJlZHJhdyBib3VuZHNcblx0XHQvLyB3aXRoIHRoZSBuZXcgcGl4ZWwgYm91bmRzLlxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF91cGRhdGVTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fdXBkYXRlRGFzaEFycmF5KGxheWVyKTtcblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fSxcblxuXHRfdXBkYXRlRGFzaEFycmF5OiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAodHlwZW9mIGxheWVyLm9wdGlvbnMuZGFzaEFycmF5ID09PSAnc3RyaW5nJykge1xuXHRcdFx0dmFyIHBhcnRzID0gbGF5ZXIub3B0aW9ucy5kYXNoQXJyYXkuc3BsaXQoL1ssIF0rLyksXG5cdFx0XHQgICAgZGFzaEFycmF5ID0gW10sXG5cdFx0XHQgICAgZGFzaFZhbHVlLFxuXHRcdFx0ICAgIGk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGFzaFZhbHVlID0gTnVtYmVyKHBhcnRzW2ldKTtcblx0XHRcdFx0Ly8gSWdub3JlIGRhc2ggYXJyYXkgY29udGFpbmluZyBpbnZhbGlkIGxlbmd0aHNcblx0XHRcdFx0aWYgKGlzTmFOKGRhc2hWYWx1ZSkpIHsgcmV0dXJuOyB9XG5cdFx0XHRcdGRhc2hBcnJheS5wdXNoKGRhc2hWYWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgPSBkYXNoQXJyYXk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxheWVyLm9wdGlvbnMuX2Rhc2hBcnJheSA9IGxheWVyLm9wdGlvbnMuZGFzaEFycmF5O1xuXHRcdH1cblx0fSxcblxuXHRfcmVxdWVzdFJlZHJhdzogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHMobGF5ZXIpO1xuXHRcdHRoaXMuX3JlZHJhd1JlcXVlc3QgPSB0aGlzLl9yZWRyYXdSZXF1ZXN0IHx8IFV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9yZWRyYXcsIHRoaXMpO1xuXHR9LFxuXG5cdF9leHRlbmRSZWRyYXdCb3VuZHM6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmIChsYXllci5fcHhCb3VuZHMpIHtcblx0XHRcdHZhciBwYWRkaW5nID0gKGxheWVyLm9wdGlvbnMud2VpZ2h0IHx8IDApICsgMTtcblx0XHRcdHRoaXMuX3JlZHJhd0JvdW5kcyA9IHRoaXMuX3JlZHJhd0JvdW5kcyB8fCBuZXcgQm91bmRzKCk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5taW4uc3VidHJhY3QoW3BhZGRpbmcsIHBhZGRpbmddKSk7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKGxheWVyLl9weEJvdW5kcy5tYXguYWRkKFtwYWRkaW5nLCBwYWRkaW5nXSkpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVkcmF3OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVkcmF3UmVxdWVzdCA9IG51bGw7XG5cblx0XHRpZiAodGhpcy5fcmVkcmF3Qm91bmRzKSB7XG5cdFx0XHR0aGlzLl9yZWRyYXdCb3VuZHMubWluLl9mbG9vcigpO1xuXHRcdFx0dGhpcy5fcmVkcmF3Qm91bmRzLm1heC5fY2VpbCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NsZWFyKCk7IC8vIGNsZWFyIGxheWVycyBpbiByZWRyYXcgYm91bmRzXG5cdFx0dGhpcy5fZHJhdygpOyAvLyBkcmF3IGxheWVyc1xuXG5cdFx0dGhpcy5fcmVkcmF3Qm91bmRzID0gbnVsbDtcblx0fSxcblxuXHRfY2xlYXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdGlmIChib3VuZHMpIHtcblx0XHRcdHZhciBzaXplID0gYm91bmRzLmdldFNpemUoKTtcblx0XHRcdHRoaXMuX2N0eC5jbGVhclJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY3R4LnNhdmUoKTtcblx0XHRcdHRoaXMuX2N0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0XHR0aGlzLl9jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NvbnRhaW5lci53aWR0aCwgdGhpcy5fY29udGFpbmVyLmhlaWdodCk7XG5cdFx0XHR0aGlzLl9jdHgucmVzdG9yZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBsYXllciwgYm91bmRzID0gdGhpcy5fcmVkcmF3Qm91bmRzO1xuXHRcdHRoaXMuX2N0eC5zYXZlKCk7XG5cdFx0aWYgKGJvdW5kcykge1xuXHRcdFx0dmFyIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXHRcdFx0dGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0dGhpcy5fY3R4LnJlY3QoYm91bmRzLm1pbi54LCBib3VuZHMubWluLnksIHNpemUueCwgc2l6ZS55KTtcblx0XHRcdHRoaXMuX2N0eC5jbGlwKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhd2luZyA9IHRydWU7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmICghYm91bmRzIHx8IChsYXllci5fcHhCb3VuZHMgJiYgbGF5ZXIuX3B4Qm91bmRzLmludGVyc2VjdHMoYm91bmRzKSkpIHtcblx0XHRcdFx0bGF5ZXIuX3VwZGF0ZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9kcmF3aW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLl9jdHgucmVzdG9yZSgpOyAgLy8gUmVzdG9yZSBzdGF0ZSBiZWZvcmUgY2xpcHBpbmcuXG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cdFx0aWYgKCF0aGlzLl9kcmF3aW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGksIGosIGxlbjIsIHAsXG5cdFx0ICAgIHBhcnRzID0gbGF5ZXIuX3BhcnRzLFxuXHRcdCAgICBsZW4gPSBwYXJ0cy5sZW5ndGgsXG5cdFx0ICAgIGN0eCA9IHRoaXMuX2N0eDtcblxuXHRcdGlmICghbGVuKSB7IHJldHVybjsgfVxuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydHNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG5cdFx0XHRcdHAgPSBwYXJ0c1tpXVtqXTtcblx0XHRcdFx0Y3R4W2ogPyAnbGluZVRvJyA6ICdtb3ZlVG8nXShwLngsIHAueSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9maWxsU3Ryb2tlKGN0eCwgbGF5ZXIpO1xuXG5cdFx0Ly8gVE9ETyBvcHRpbWl6YXRpb246IDEgZmlsbC9zdHJva2UgZm9yIGFsbCBmZWF0dXJlcyB3aXRoIGVxdWFsIHN0eWxlIGluc3RlYWQgb2YgMSBmb3IgZWFjaCBmZWF0dXJlXG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cblx0XHRpZiAoIXRoaXMuX2RyYXdpbmcgfHwgbGF5ZXIuX2VtcHR5KCkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgcCA9IGxheWVyLl9wb2ludCxcblx0XHQgICAgY3R4ID0gdGhpcy5fY3R4LFxuXHRcdCAgICByID0gTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzKSwgMSksXG5cdFx0ICAgIHMgPSAoTWF0aC5tYXgoTWF0aC5yb3VuZChsYXllci5fcmFkaXVzWSksIDEpIHx8IHIpIC8gcjtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4LnNjYWxlKDEsIHMpO1xuXHRcdH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHguYXJjKHAueCwgcC55IC8gcywgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcblxuXHRcdGlmIChzICE9PSAxKSB7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2ZpbGxTdHJva2UoY3R4LCBsYXllcik7XG5cdH0sXG5cblx0X2ZpbGxTdHJva2U6IGZ1bmN0aW9uIChjdHgsIGxheWVyKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBsYXllci5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5maWxsT3BhY2l0eTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xuXHRcdFx0Y3R4LmZpbGwob3B0aW9ucy5maWxsUnVsZSB8fCAnZXZlbm9kZCcpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSAmJiBvcHRpb25zLndlaWdodCAhPT0gMCkge1xuXHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0XHRjdHguc2V0TGluZURhc2gobGF5ZXIub3B0aW9ucyAmJiBsYXllci5vcHRpb25zLl9kYXNoQXJyYXkgfHwgW10pO1xuXHRcdFx0fVxuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3B0aW9ucy5vcGFjaXR5O1xuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMud2VpZ2h0O1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5jb2xvcjtcblx0XHRcdGN0eC5saW5lQ2FwID0gb3B0aW9ucy5saW5lQ2FwO1xuXHRcdFx0Y3R4LmxpbmVKb2luID0gb3B0aW9ucy5saW5lSm9pbjtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ2FudmFzIG9idmlvdXNseSBkb2Vzbid0IGhhdmUgbW91c2UgZXZlbnRzIGZvciBpbmRpdmlkdWFsIGRyYXduIG9iamVjdHMsXG5cdC8vIHNvIHdlIGVtdWxhdGUgdGhhdCBieSBjYWxjdWxhdGluZyB3aGF0J3MgdW5kZXIgdGhlIG1vdXNlIG9uIG1vdXNlbW92ZS9jbGljayBtYW51YWxseVxuXG5cdF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUpLCBsYXllciwgY2xpY2tlZExheWVyO1xuXG5cdFx0Zm9yICh2YXIgb3JkZXIgPSB0aGlzLl9kcmF3Rmlyc3Q7IG9yZGVyOyBvcmRlciA9IG9yZGVyLm5leHQpIHtcblx0XHRcdGxheWVyID0gb3JkZXIubGF5ZXI7XG5cdFx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBsYXllci5fY29udGFpbnNQb2ludChwb2ludCkpIHtcblx0XHRcdFx0aWYgKCEoZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSA9PT0gJ3ByZWNsaWNrJykgfHwgIXRoaXMuX21hcC5fZHJhZ2dhYmxlTW92ZWQobGF5ZXIpKSB7XG5cdFx0XHRcdFx0Y2xpY2tlZExheWVyID0gbGF5ZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fZmlyZUV2ZW50KGNsaWNrZWRMYXllciA/IFtjbGlja2VkTGF5ZXJdIDogZmFsc2UsIGUpO1xuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuZHJhZ2dpbmcubW92aW5nKCkgfHwgdGhpcy5fbWFwLl9hbmltYXRpbmdab29tKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSk7XG5cdFx0dGhpcy5faGFuZGxlTW91c2VIb3ZlcihlLCBwb2ludCk7XG5cdH0sXG5cblxuXHRfaGFuZGxlTW91c2VPdXQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5faG92ZXJlZExheWVyO1xuXHRcdGlmIChsYXllcikge1xuXHRcdFx0Ly8gaWYgd2UncmUgbGVhdmluZyB0aGUgbGF5ZXIsIGZpcmUgbW91c2VvdXRcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpO1xuXHRcdFx0dGhpcy5fZmlyZUV2ZW50KFtsYXllcl0sIGUsICdtb3VzZW91dCcpO1xuXHRcdFx0dGhpcy5faG92ZXJlZExheWVyID0gbnVsbDtcblx0XHRcdHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZU1vdXNlSG92ZXI6IGZ1bmN0aW9uIChlLCBwb2ludCkge1xuXHRcdGlmICh0aGlzLl9tb3VzZUhvdmVyVGhyb3R0bGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGxheWVyLCBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG5cblx0XHRmb3IgKHZhciBvcmRlciA9IHRoaXMuX2RyYXdGaXJzdDsgb3JkZXI7IG9yZGVyID0gb3JkZXIubmV4dCkge1xuXHRcdFx0bGF5ZXIgPSBvcmRlci5sYXllcjtcblx0XHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlICYmIGxheWVyLl9jb250YWluc1BvaW50KHBvaW50KSkge1xuXHRcdFx0XHRjYW5kaWRhdGVIb3ZlcmVkTGF5ZXIgPSBsYXllcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoY2FuZGlkYXRlSG92ZXJlZExheWVyICE9PSB0aGlzLl9ob3ZlcmVkTGF5ZXIpIHtcblx0XHRcdHRoaXMuX2hhbmRsZU1vdXNlT3V0KGUpO1xuXG5cdFx0XHRpZiAoY2FuZGlkYXRlSG92ZXJlZExheWVyKSB7XG5cdFx0XHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1pbnRlcmFjdGl2ZScpOyAvLyBjaGFuZ2UgY3Vyc29yXG5cdFx0XHRcdHRoaXMuX2ZpcmVFdmVudChbY2FuZGlkYXRlSG92ZXJlZExheWVyXSwgZSwgJ21vdXNlb3ZlcicpO1xuXHRcdFx0XHR0aGlzLl9ob3ZlcmVkTGF5ZXIgPSBjYW5kaWRhdGVIb3ZlcmVkTGF5ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlyZUV2ZW50KHRoaXMuX2hvdmVyZWRMYXllciA/IFt0aGlzLl9ob3ZlcmVkTGF5ZXJdIDogZmFsc2UsIGUpO1xuXG5cdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IHRydWU7XG5cdFx0c2V0VGltZW91dChVdGlsLmJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZCA9IGZhbHNlO1xuXHRcdH0sIHRoaXMpLCAzMik7XG5cdH0sXG5cblx0X2ZpcmVFdmVudDogZnVuY3Rpb24gKGxheWVycywgZSwgdHlwZSkge1xuXHRcdHRoaXMuX21hcC5fZmlyZURPTUV2ZW50KGUsIHR5cGUgfHwgZS50eXBlLCBsYXllcnMpO1xuXHR9LFxuXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBvcmRlciA9IGxheWVyLl9vcmRlcjtcblxuXHRcdGlmICghb3JkZXIpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgbmV4dCA9IG9yZGVyLm5leHQ7XG5cdFx0dmFyIHByZXYgPSBvcmRlci5wcmV2O1xuXG5cdFx0aWYgKG5leHQpIHtcblx0XHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEFscmVhZHkgbGFzdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2UgaWYgKG5leHQpIHtcblx0XHRcdC8vIFVwZGF0ZSBmaXJzdCBlbnRyeSB1bmxlc3MgdGhpcyBpcyB0aGVcblx0XHRcdC8vIHNpbmdsZSBlbnRyeVxuXHRcdFx0dGhpcy5fZHJhd0ZpcnN0ID0gbmV4dDtcblx0XHR9XG5cblx0XHRvcmRlci5wcmV2ID0gdGhpcy5fZHJhd0xhc3Q7XG5cdFx0dGhpcy5fZHJhd0xhc3QubmV4dCA9IG9yZGVyO1xuXG5cdFx0b3JkZXIubmV4dCA9IG51bGw7XG5cdFx0dGhpcy5fZHJhd0xhc3QgPSBvcmRlcjtcblxuXHRcdHRoaXMuX3JlcXVlc3RSZWRyYXcobGF5ZXIpO1xuXHR9LFxuXG5cdF9icmluZ1RvQmFjazogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIG9yZGVyID0gbGF5ZXIuX29yZGVyO1xuXG5cdFx0aWYgKCFvcmRlcikgeyByZXR1cm47IH1cblxuXHRcdHZhciBuZXh0ID0gb3JkZXIubmV4dDtcblx0XHR2YXIgcHJldiA9IG9yZGVyLnByZXY7XG5cblx0XHRpZiAocHJldikge1xuXHRcdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQWxyZWFkeSBmaXJzdFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAobmV4dCkge1xuXHRcdFx0bmV4dC5wcmV2ID0gcHJldjtcblx0XHR9IGVsc2UgaWYgKHByZXYpIHtcblx0XHRcdC8vIFVwZGF0ZSBsYXN0IGVudHJ5IHVubGVzcyB0aGlzIGlzIHRoZVxuXHRcdFx0Ly8gc2luZ2xlIGVudHJ5XG5cdFx0XHR0aGlzLl9kcmF3TGFzdCA9IHByZXY7XG5cdFx0fVxuXG5cdFx0b3JkZXIucHJldiA9IG51bGw7XG5cblx0XHRvcmRlci5uZXh0ID0gdGhpcy5fZHJhd0ZpcnN0O1xuXHRcdHRoaXMuX2RyYXdGaXJzdC5wcmV2ID0gb3JkZXI7XG5cdFx0dGhpcy5fZHJhd0ZpcnN0ID0gb3JkZXI7XG5cblx0XHR0aGlzLl9yZXF1ZXN0UmVkcmF3KGxheWVyKTtcblx0fVxufSk7XG5cbi8vIEBmYWN0b3J5IEwuY2FudmFzKG9wdGlvbnM/OiBSZW5kZXJlciBvcHRpb25zKVxuLy8gQ3JlYXRlcyBhIENhbnZhcyByZW5kZXJlciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGNhbnZhcyhvcHRpb25zKSB7XG5cdHJldHVybiBCcm93c2VyLmNhbnZhcyA/IG5ldyBDYW52YXMob3B0aW9ucykgOiBudWxsO1xufVxuIiwiaW1wb3J0ICogYXMgRG9tVXRpbCBmcm9tICcuLi8uLi9kb20vRG9tVXRpbCc7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcblxuLypcbiAqIFRoYW5rcyB0byBEbWl0cnkgQmFyYW5vdnNreSBhbmQgaGlzIFJhcGhhZWwgbGlicmFyeSBmb3IgaW5zcGlyYXRpb24hXG4gKi9cblxuXG5leHBvcnQgdmFyIHZtbENyZWF0ZSA9IChmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0ZG9jdW1lbnQubmFtZXNwYWNlcy5hZGQoJ2x2bWwnLCAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8bHZtbDonICsgbmFtZSArICcgY2xhc3M9XCJsdm1sXCI+Jyk7XG5cdFx0fTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIERvIG5vdCByZXR1cm4gZm4gZnJvbSBjYXRjaCBibG9jayBzbyBgZWAgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvcHVsbC83Mjc5XG5cdH1cblx0cmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzwnICsgbmFtZSArICcgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFwiIGNsYXNzPVwibHZtbFwiPicpO1xuXHR9O1xufSkoKTtcblxuXG4vKlxuICogQGNsYXNzIFNWR1xuICpcbiAqXG4gKiBWTUwgd2FzIGRlcHJlY2F0ZWQgaW4gMjAxMiwgd2hpY2ggbWVhbnMgVk1MIGZ1bmN0aW9uYWxpdHkgZXhpc3RzIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gKiB3aXRoIG9sZCB2ZXJzaW9ucyBvZiBJbnRlcm5ldCBFeHBsb3Jlci5cbiAqL1xuXG4vLyBtaXhpbiB0byByZWRlZmluZSBzb21lIFNWRyBtZXRob2RzIHRvIGhhbmRsZSBWTUwgc3ludGF4IHdoaWNoIGlzIHNpbWlsYXIgYnV0IHdpdGggc29tZSBkaWZmZXJlbmNlc1xuZXhwb3J0IHZhciB2bWxNaXhpbiA9IHtcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IERvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC12bWwtY29udGFpbmVyJyk7XG5cdH0sXG5cblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XG5cdFx0UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblx0XHR0aGlzLmZpcmUoJ3VwZGF0ZScpO1xuXHR9LFxuXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXIgPSB2bWxDcmVhdGUoJ3NoYXBlJyk7XG5cblx0XHREb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdm1sLXNoYXBlICcgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCAnJykpO1xuXG5cdFx0Y29udGFpbmVyLmNvb3Jkc2l6ZSA9ICcxIDEnO1xuXG5cdFx0bGF5ZXIuX3BhdGggPSB2bWxDcmVhdGUoJ3BhdGgnKTtcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQobGF5ZXIuX3BhdGgpO1xuXG5cdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuXHRcdHRoaXMuX2xheWVyc1tVdGlsLnN0YW1wKGxheWVyKV0gPSBsYXllcjtcblx0fSxcblxuXHRfYWRkUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGxheWVyLl9jb250YWluZXI7XG5cdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5pbnRlcmFjdGl2ZSkge1xuXHRcdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZVBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXHRcdERvbVV0aWwucmVtb3ZlKGNvbnRhaW5lcik7XG5cdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQoY29udGFpbmVyKTtcblx0XHRkZWxldGUgdGhpcy5fbGF5ZXJzW1V0aWwuc3RhbXAobGF5ZXIpXTtcblx0fSxcblxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBzdHJva2UgPSBsYXllci5fc3Ryb2tlLFxuXHRcdCAgICBmaWxsID0gbGF5ZXIuX2ZpbGwsXG5cdFx0ICAgIG9wdGlvbnMgPSBsYXllci5vcHRpb25zLFxuXHRcdCAgICBjb250YWluZXIgPSBsYXllci5fY29udGFpbmVyO1xuXG5cdFx0Y29udGFpbmVyLnN0cm9rZWQgPSAhIW9wdGlvbnMuc3Ryb2tlO1xuXHRcdGNvbnRhaW5lci5maWxsZWQgPSAhIW9wdGlvbnMuZmlsbDtcblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuXHRcdFx0aWYgKCFzdHJva2UpIHtcblx0XHRcdFx0c3Ryb2tlID0gbGF5ZXIuX3N0cm9rZSA9IHZtbENyZWF0ZSgnc3Ryb2tlJyk7XG5cdFx0XHR9XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoc3Ryb2tlKTtcblx0XHRcdHN0cm9rZS53ZWlnaHQgPSBvcHRpb25zLndlaWdodCArICdweCc7XG5cdFx0XHRzdHJva2UuY29sb3IgPSBvcHRpb25zLmNvbG9yO1xuXHRcdFx0c3Ryb2tlLm9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XG5cblx0XHRcdGlmIChvcHRpb25zLmRhc2hBcnJheSkge1xuXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gVXRpbC5pc0FycmF5KG9wdGlvbnMuZGFzaEFycmF5KSA/XG5cdFx0XHRcdCAgICBvcHRpb25zLmRhc2hBcnJheS5qb2luKCcgJykgOlxuXHRcdFx0XHQgICAgb3B0aW9ucy5kYXNoQXJyYXkucmVwbGFjZSgvKCAqLCAqKS9nLCAnICcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9ICcnO1xuXHRcdFx0fVxuXHRcdFx0c3Ryb2tlLmVuZGNhcCA9IG9wdGlvbnMubGluZUNhcC5yZXBsYWNlKCdidXR0JywgJ2ZsYXQnKTtcblx0XHRcdHN0cm9rZS5qb2luc3R5bGUgPSBvcHRpb25zLmxpbmVKb2luO1xuXG5cdFx0fSBlbHNlIGlmIChzdHJva2UpIHtcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChzdHJva2UpO1xuXHRcdFx0bGF5ZXIuX3N0cm9rZSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0aWYgKCFmaWxsKSB7XG5cdFx0XHRcdGZpbGwgPSBsYXllci5fZmlsbCA9IHZtbENyZWF0ZSgnZmlsbCcpO1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGZpbGwpO1xuXHRcdFx0ZmlsbC5jb2xvciA9IG9wdGlvbnMuZmlsbENvbG9yIHx8IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRmaWxsLm9wYWNpdHkgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xuXG5cdFx0fSBlbHNlIGlmIChmaWxsKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoZmlsbCk7XG5cdFx0XHRsYXllci5fZmlsbCA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwID0gbGF5ZXIuX3BvaW50LnJvdW5kKCksXG5cdFx0ICAgIHIgPSBNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLFxuXHRcdCAgICByMiA9IE1hdGgucm91bmQobGF5ZXIuX3JhZGl1c1kgfHwgcik7XG5cblx0XHR0aGlzLl9zZXRQYXRoKGxheWVyLCBsYXllci5fZW1wdHkoKSA/ICdNMCAwJyA6XG5cdFx0XHQnQUwgJyArIHAueCArICcsJyArIHAueSArICcgJyArIHIgKyAnLCcgKyByMiArICcgMCwnICsgKDY1NTM1ICogMzYwKSk7XG5cdH0sXG5cblx0X3NldFBhdGg6IGZ1bmN0aW9uIChsYXllciwgcGF0aCkge1xuXHRcdGxheWVyLl9wYXRoLnYgPSBwYXRoO1xuXHR9LFxuXG5cdF9icmluZ1RvRnJvbnQ6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9Gcm9udChsYXllci5fY29udGFpbmVyKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9CYWNrKGxheWVyLl9jb250YWluZXIpO1xuXHR9XG59O1xuIiwiaW1wb3J0IHtSZW5kZXJlcn0gZnJvbSAnLi9SZW5kZXJlcic7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQgQnJvd3NlciBmcm9tICcuLi8uLi9jb3JlL0Jyb3dzZXInO1xuaW1wb3J0IHtzdGFtcH0gZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCB7c3ZnQ3JlYXRlLCBwb2ludHNUb1BhdGh9IGZyb20gJy4vU1ZHLlV0aWwnO1xuZXhwb3J0IHtwb2ludHNUb1BhdGh9O1xuaW1wb3J0IHt2bWxNaXhpbiwgdm1sQ3JlYXRlfSBmcm9tICcuL1NWRy5WTUwnO1xuXG5leHBvcnQgdmFyIGNyZWF0ZSA9IEJyb3dzZXIudm1sID8gdm1sQ3JlYXRlIDogc3ZnQ3JlYXRlO1xuXG4vKlxuICogQGNsYXNzIFNWR1xuICogQGluaGVyaXRzIFJlbmRlcmVyXG4gKiBAYWthIEwuU1ZHXG4gKlxuICogQWxsb3dzIHZlY3RvciBsYXllcnMgdG8gYmUgZGlzcGxheWVkIHdpdGggW1NWR10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvU1ZHKS5cbiAqIEluaGVyaXRzIGBSZW5kZXJlcmAuXG4gKlxuICogRHVlIHRvIFt0ZWNobmljYWwgbGltaXRhdGlvbnNdKGh0dHBzOi8vY2FuaXVzZS5jb20vc3ZnKSwgU1ZHIGlzIG5vdFxuICogYXZhaWxhYmxlIGluIGFsbCB3ZWIgYnJvd3NlcnMsIG5vdGFibHkgQW5kcm9pZCAyLnggYW5kIDMueC5cbiAqXG4gKiBBbHRob3VnaCBTVkcgaXMgbm90IGF2YWlsYWJsZSBvbiBJRTcgYW5kIElFOCwgdGhlc2UgYnJvd3NlcnMgc3VwcG9ydFxuICogW1ZNTF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX01hcmt1cF9MYW5ndWFnZSlcbiAqIChhIG5vdyBkZXByZWNhdGVkIHRlY2hub2xvZ3kpLCBhbmQgdGhlIFNWRyByZW5kZXJlciB3aWxsIGZhbGwgYmFjayB0byBWTUwgaW5cbiAqIHRoaXMgY2FzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZSBTVkcgYnkgZGVmYXVsdCBmb3IgYWxsIHBhdGhzIGluIHRoZSBtYXA6XG4gKlxuICogYGBganNcbiAqIHZhciBtYXAgPSBMLm1hcCgnbWFwJywge1xuICogXHRyZW5kZXJlcjogTC5zdmcoKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBVc2UgYSBTVkcgcmVuZGVyZXIgd2l0aCBleHRyYSBwYWRkaW5nIGZvciBzcGVjaWZpYyB2ZWN0b3IgZ2VvbWV0cmllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIG1hcCA9IEwubWFwKCdtYXAnKTtcbiAqIHZhciBteVJlbmRlcmVyID0gTC5zdmcoeyBwYWRkaW5nOiAwLjUgfSk7XG4gKiB2YXIgbGluZSA9IEwucG9seWxpbmUoIGNvb3JkaW5hdGVzLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIHZhciBjaXJjbGUgPSBMLmNpcmNsZSggY2VudGVyLCB7IHJlbmRlcmVyOiBteVJlbmRlcmVyIH0gKTtcbiAqIGBgYFxuICovXG5cbmV4cG9ydCB2YXIgU1ZHID0gUmVuZGVyZXIuZXh0ZW5kKHtcblxuXHRfaW5pdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNyZWF0ZSgnc3ZnJyk7XG5cblx0XHQvLyBtYWtlcyBpdCBwb3NzaWJsZSB0byBjbGljayB0aHJvdWdoIHN2ZyByb290OyB3ZSdsbCByZXNldCBpdCBiYWNrIGluIGluZGl2aWR1YWwgcGF0aHNcblx0XHR0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XG5cblx0XHR0aGlzLl9yb290R3JvdXAgPSBjcmVhdGUoJ2cnKTtcblx0XHR0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcm9vdEdyb3VwKTtcblx0fSxcblxuXHRfZGVzdHJveUNvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwucmVtb3ZlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0RG9tRXZlbnQub2ZmKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lcjtcblx0XHRkZWxldGUgdGhpcy5fcm9vdEdyb3VwO1xuXHRcdGRlbGV0ZSB0aGlzLl9zdmdTaXplO1xuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwLl9hbmltYXRpbmdab29tICYmIHRoaXMuX2JvdW5kcykgeyByZXR1cm47IH1cblxuXHRcdFJlbmRlcmVyLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cblx0XHR2YXIgYiA9IHRoaXMuX2JvdW5kcyxcblx0XHQgICAgc2l6ZSA9IGIuZ2V0U2l6ZSgpLFxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG5cblx0XHQvLyBzZXQgc2l6ZSBvZiBzdmctY29udGFpbmVyIGlmIGNoYW5nZWRcblx0XHRpZiAoIXRoaXMuX3N2Z1NpemUgfHwgIXRoaXMuX3N2Z1NpemUuZXF1YWxzKHNpemUpKSB7XG5cdFx0XHR0aGlzLl9zdmdTaXplID0gc2l6ZTtcblx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc2l6ZS54KTtcblx0XHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUueSk7XG5cdFx0fVxuXG5cdFx0Ly8gbW92ZW1lbnQ6IHVwZGF0ZSBjb250YWluZXIgdmlld0JveCBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY2hhbmdlIGNvb3JkaW5hdGVzIG9mIGluZGl2aWR1YWwgbGF5ZXJzXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbihjb250YWluZXIsIGIubWluKTtcblx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgW2IubWluLngsIGIubWluLnksIHNpemUueCwgc2l6ZS55XS5qb2luKCcgJykpO1xuXG5cdFx0dGhpcy5maXJlKCd1cGRhdGUnKTtcblx0fSxcblxuXHQvLyBtZXRob2RzIGJlbG93IGFyZSBjYWxsZWQgYnkgdmVjdG9yIGxheWVycyBpbXBsZW1lbnRhdGlvbnNcblxuXHRfaW5pdFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdHZhciBwYXRoID0gbGF5ZXIuX3BhdGggPSBjcmVhdGUoJ3BhdGgnKTtcblxuXHRcdC8vIEBuYW1lc3BhY2UgUGF0aFxuXHRcdC8vIEBvcHRpb24gY2xhc3NOYW1lOiBTdHJpbmcgPSBudWxsXG5cdFx0Ly8gQ3VzdG9tIGNsYXNzIG5hbWUgc2V0IG9uIGFuIGVsZW1lbnQuIE9ubHkgZm9yIFNWRyByZW5kZXJlci5cblx0XHRpZiAobGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpIHtcblx0XHRcdERvbVV0aWwuYWRkQ2xhc3MocGF0aCwgbGF5ZXIub3B0aW9ucy5jbGFzc05hbWUpO1xuXHRcdH1cblxuXHRcdGlmIChsYXllci5vcHRpb25zLmludGVyYWN0aXZlKSB7XG5cdFx0XHREb21VdGlsLmFkZENsYXNzKHBhdGgsICdsZWFmbGV0LWludGVyYWN0aXZlJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlU3R5bGUobGF5ZXIpO1xuXHRcdHRoaXMuX2xheWVyc1tzdGFtcChsYXllcildID0gbGF5ZXI7XG5cdH0sXG5cblx0X2FkZFBhdGg6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdGlmICghdGhpcy5fcm9vdEdyb3VwKSB7IHRoaXMuX2luaXRDb250YWluZXIoKTsgfVxuXHRcdHRoaXMuX3Jvb3RHcm91cC5hcHBlbmRDaGlsZChsYXllci5fcGF0aCk7XG5cdFx0bGF5ZXIuYWRkSW50ZXJhY3RpdmVUYXJnZXQobGF5ZXIuX3BhdGgpO1xuXHR9LFxuXG5cdF9yZW1vdmVQYXRoOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHREb21VdGlsLnJlbW92ZShsYXllci5fcGF0aCk7XG5cdFx0bGF5ZXIucmVtb3ZlSW50ZXJhY3RpdmVUYXJnZXQobGF5ZXIuX3BhdGgpO1xuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbc3RhbXAobGF5ZXIpXTtcblx0fSxcblxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0bGF5ZXIuX3Byb2plY3QoKTtcblx0XHRsYXllci5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgcGF0aCA9IGxheWVyLl9wYXRoLFxuXHRcdCAgICBvcHRpb25zID0gbGF5ZXIub3B0aW9ucztcblxuXHRcdGlmICghcGF0aCkgeyByZXR1cm47IH1cblxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIG9wdGlvbnMuY29sb3IpO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1vcGFjaXR5Jywgb3B0aW9ucy5vcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBvcHRpb25zLndlaWdodCk7XG5cdFx0XHRwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCBvcHRpb25zLmxpbmVDYXApO1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsIG9wdGlvbnMubGluZUpvaW4pO1xuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoQXJyYXkpIHtcblx0XHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBvcHRpb25zLmRhc2hBcnJheSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0aW9ucy5kYXNoT2Zmc2V0KSB7XG5cdFx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIG9wdGlvbnMuZGFzaE9mZnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdub25lJyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xuXHRcdFx0cGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yKTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCBvcHRpb25zLmZpbGxPcGFjaXR5KTtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLXJ1bGUnLCBvcHRpb25zLmZpbGxSdWxlIHx8ICdldmVub2RkJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcblx0XHR9XG5cdH0sXG5cblx0X3VwZGF0ZVBvbHk6IGZ1bmN0aW9uIChsYXllciwgY2xvc2VkKSB7XG5cdFx0dGhpcy5fc2V0UGF0aChsYXllciwgcG9pbnRzVG9QYXRoKGxheWVyLl9wYXJ0cywgY2xvc2VkKSk7XG5cdH0sXG5cblx0X3VwZGF0ZUNpcmNsZTogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIHAgPSBsYXllci5fcG9pbnQsXG5cdFx0ICAgIHIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXMpLCAxKSxcblx0XHQgICAgcjIgPSBNYXRoLm1heChNYXRoLnJvdW5kKGxheWVyLl9yYWRpdXNZKSwgMSkgfHwgcixcblx0XHQgICAgYXJjID0gJ2EnICsgciArICcsJyArIHIyICsgJyAwIDEsMCAnO1xuXG5cdFx0Ly8gZHJhd2luZyBhIGNpcmNsZSB3aXRoIHR3byBoYWxmLWFyY3Ncblx0XHR2YXIgZCA9IGxheWVyLl9lbXB0eSgpID8gJ00wIDAnIDpcblx0XHRcdCdNJyArIChwLnggLSByKSArICcsJyArIHAueSArXG5cdFx0XHRhcmMgKyAociAqIDIpICsgJywwICcgK1xuXHRcdFx0YXJjICsgKC1yICogMikgKyAnLDAgJztcblxuXHRcdHRoaXMuX3NldFBhdGgobGF5ZXIsIGQpO1xuXHR9LFxuXG5cdF9zZXRQYXRoOiBmdW5jdGlvbiAobGF5ZXIsIHBhdGgpIHtcblx0XHRsYXllci5fcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCBwYXRoKTtcblx0fSxcblxuXHQvLyBTVkcgZG9lcyBub3QgaGF2ZSB0aGUgY29uY2VwdCBvZiB6SW5kZXggc28gd2UgcmVzb3J0IHRvIGNoYW5naW5nIHRoZSBET00gb3JkZXIgb2YgZWxlbWVudHNcblx0X2JyaW5nVG9Gcm9udDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0RG9tVXRpbC50b0Zyb250KGxheWVyLl9wYXRoKTtcblx0fSxcblxuXHRfYnJpbmdUb0JhY2s6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdERvbVV0aWwudG9CYWNrKGxheWVyLl9wYXRoKTtcblx0fVxufSk7XG5cbmlmIChCcm93c2VyLnZtbCkge1xuXHRTVkcuaW5jbHVkZSh2bWxNaXhpbik7XG59XG5cbi8vIEBuYW1lc3BhY2UgU1ZHXG4vLyBAZmFjdG9yeSBMLnN2ZyhvcHRpb25zPzogUmVuZGVyZXIgb3B0aW9ucylcbi8vIENyZWF0ZXMgYSBTVkcgcmVuZGVyZXIgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiBzdmcob3B0aW9ucykge1xuXHRyZXR1cm4gQnJvd3Nlci5zdmcgfHwgQnJvd3Nlci52bWwgPyBuZXcgU1ZHKG9wdGlvbnMpIDogbnVsbDtcbn1cbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi8uLi9tYXAvTWFwJztcbmltcG9ydCB7Y2FudmFzfSBmcm9tICcuL0NhbnZhcyc7XG5pbXBvcnQge3N2Z30gZnJvbSAnLi9TVkcnO1xuXG5NYXAuaW5jbHVkZSh7XG5cdC8vIEBuYW1lc3BhY2UgTWFwOyBAbWV0aG9kIGdldFJlbmRlcmVyKGxheWVyOiBQYXRoKTogUmVuZGVyZXJcblx0Ly8gUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgYFJlbmRlcmVyYCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlbmRlciB0aGUgZ2l2ZW5cblx0Ly8gYFBhdGhgLiBJdCB3aWxsIGVuc3VyZSB0aGF0IHRoZSBgcmVuZGVyZXJgIG9wdGlvbnMgb2YgdGhlIG1hcCBhbmQgcGF0aHNcblx0Ly8gYXJlIHJlc3BlY3RlZCwgYW5kIHRoYXQgdGhlIHJlbmRlcmVycyBkbyBleGlzdCBvbiB0aGUgbWFwLlxuXHRnZXRSZW5kZXJlcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0Ly8gQG5hbWVzcGFjZSBQYXRoOyBAb3B0aW9uIHJlbmRlcmVyOiBSZW5kZXJlclxuXHRcdC8vIFVzZSB0aGlzIHNwZWNpZmljIGluc3RhbmNlIG9mIGBSZW5kZXJlcmAgZm9yIHRoaXMgcGF0aC4gVGFrZXNcblx0XHQvLyBwcmVjZWRlbmNlIG92ZXIgdGhlIG1hcCdzIFtkZWZhdWx0IHJlbmRlcmVyXSgjbWFwLXJlbmRlcmVyKS5cblx0XHR2YXIgcmVuZGVyZXIgPSBsYXllci5vcHRpb25zLnJlbmRlcmVyIHx8IHRoaXMuX2dldFBhbmVSZW5kZXJlcihsYXllci5vcHRpb25zLnBhbmUpIHx8IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCB0aGlzLl9yZW5kZXJlcjtcblxuXHRcdGlmICghcmVuZGVyZXIpIHtcblx0XHRcdHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXIgPSB0aGlzLl9jcmVhdGVSZW5kZXJlcigpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5oYXNMYXllcihyZW5kZXJlcikpIHtcblx0XHRcdHRoaXMuYWRkTGF5ZXIocmVuZGVyZXIpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVuZGVyZXI7XG5cdH0sXG5cblx0X2dldFBhbmVSZW5kZXJlcjogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAobmFtZSA9PT0gJ292ZXJsYXlQYW5lJyB8fCBuYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgcmVuZGVyZXIgPSB0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdO1xuXHRcdGlmIChyZW5kZXJlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZW5kZXJlciA9IHRoaXMuX2NyZWF0ZVJlbmRlcmVyKHtwYW5lOiBuYW1lfSk7XG5cdFx0XHR0aGlzLl9wYW5lUmVuZGVyZXJzW25hbWVdID0gcmVuZGVyZXI7XG5cdFx0fVxuXHRcdHJldHVybiByZW5kZXJlcjtcblx0fSxcblxuXHRfY3JlYXRlUmVuZGVyZXI6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0Ly8gQG5hbWVzcGFjZSBNYXA7IEBvcHRpb24gcHJlZmVyQ2FudmFzOiBCb29sZWFuID0gZmFsc2Vcblx0XHQvLyBXaGV0aGVyIGBQYXRoYHMgc2hvdWxkIGJlIHJlbmRlcmVkIG9uIGEgYENhbnZhc2AgcmVuZGVyZXIuXG5cdFx0Ly8gQnkgZGVmYXVsdCwgYWxsIGBQYXRoYHMgYXJlIHJlbmRlcmVkIGluIGEgYFNWR2AgcmVuZGVyZXIuXG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMucHJlZmVyQ2FudmFzICYmIGNhbnZhcyhvcHRpb25zKSkgfHwgc3ZnKG9wdGlvbnMpO1xuXHR9XG59KTtcbiIsImltcG9ydCB7UG9seWdvbn0gZnJvbSAnLi9Qb2x5Z29uJztcbmltcG9ydCB7dG9MYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuXG4vKlxuICogTC5SZWN0YW5nbGUgZXh0ZW5kcyBQb2x5Z29uIGFuZCBjcmVhdGVzIGEgcmVjdGFuZ2xlIHdoZW4gcGFzc2VkIGEgTGF0TG5nQm91bmRzIG9iamVjdC5cbiAqL1xuXG4vKlxuICogQGNsYXNzIFJlY3RhbmdsZVxuICogQGFrYSBMLlJlY3RhbmdsZVxuICogQGluaGVyaXRzIFBvbHlnb25cbiAqXG4gKiBBIGNsYXNzIGZvciBkcmF3aW5nIHJlY3RhbmdsZSBvdmVybGF5cyBvbiBhIG1hcC4gRXh0ZW5kcyBgUG9seWdvbmAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVmaW5lIHJlY3RhbmdsZSBnZW9ncmFwaGljYWwgYm91bmRzXG4gKiB2YXIgYm91bmRzID0gW1s1NC41NTkzMjIsIC01Ljc2NzgyMl0sIFs1Ni4xMjEwNjA0LCAtMy4wMjEyNDBdXTtcbiAqXG4gKiAvLyBjcmVhdGUgYW4gb3JhbmdlIHJlY3RhbmdsZVxuICogTC5yZWN0YW5nbGUoYm91bmRzLCB7Y29sb3I6IFwiI2ZmNzgwMFwiLCB3ZWlnaHQ6IDF9KS5hZGRUbyhtYXApO1xuICpcbiAqIC8vIHpvb20gdGhlIG1hcCB0byB0aGUgcmVjdGFuZ2xlIGJvdW5kc1xuICogbWFwLmZpdEJvdW5kcyhib3VuZHMpO1xuICogYGBgXG4gKlxuICovXG5cblxuZXhwb3J0IHZhciBSZWN0YW5nbGUgPSBQb2x5Z29uLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMsIG9wdGlvbnMpIHtcblx0XHRQb2x5Z29uLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgdGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcyksIG9wdGlvbnMpO1xuXHR9LFxuXG5cdC8vIEBtZXRob2Qgc2V0Qm91bmRzKGxhdExuZ0JvdW5kczogTGF0TG5nQm91bmRzKTogdGhpc1xuXHQvLyBSZWRyYXdzIHRoZSByZWN0YW5nbGUgd2l0aCB0aGUgcGFzc2VkIGJvdW5kcy5cblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0TGF0TG5ncyh0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSk7XG5cdH0sXG5cblx0X2JvdW5kc1RvTGF0TG5nczogZnVuY3Rpb24gKGxhdExuZ0JvdW5kcykge1xuXHRcdGxhdExuZ0JvdW5kcyA9IHRvTGF0TG5nQm91bmRzKGxhdExuZ0JvdW5kcyk7XG5cdFx0cmV0dXJuIFtcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aFdlc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aEVhc3QoKSxcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXRTb3V0aEVhc3QoKVxuXHRcdF07XG5cdH1cbn0pO1xuXG5cbi8vIEBmYWN0b3J5IEwucmVjdGFuZ2xlKGxhdExuZ0JvdW5kczogTGF0TG5nQm91bmRzLCBvcHRpb25zPzogUG9seWxpbmUgb3B0aW9ucylcbmV4cG9ydCBmdW5jdGlvbiByZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgUmVjdGFuZ2xlKGxhdExuZ0JvdW5kcywgb3B0aW9ucyk7XG59XG4iLCJleHBvcnQge1JlbmRlcmVyfSBmcm9tICcuL1JlbmRlcmVyJztcbmV4cG9ydCB7Q2FudmFzLCBjYW52YXN9IGZyb20gJy4vQ2FudmFzJztcbmltcG9ydCB7U1ZHLCBjcmVhdGUsIHBvaW50c1RvUGF0aCwgc3ZnfSBmcm9tICcuL1NWRyc7XG5TVkcuY3JlYXRlID0gY3JlYXRlO1xuU1ZHLnBvaW50c1RvUGF0aCA9IHBvaW50c1RvUGF0aDtcbmV4cG9ydCB7U1ZHLCBzdmd9O1xuaW1wb3J0ICcuL1JlbmRlcmVyLmdldFJlbmRlcmVyJztcdC8vIFRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrLCBidXQgbmVlZGVkIGJlY2F1c2UgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG5cbmV4cG9ydCB7UGF0aH0gZnJvbSAnLi9QYXRoJztcbmV4cG9ydCB7Q2lyY2xlTWFya2VyLCBjaXJjbGVNYXJrZXJ9IGZyb20gJy4vQ2lyY2xlTWFya2VyJztcbmV4cG9ydCB7Q2lyY2xlLCBjaXJjbGV9IGZyb20gJy4vQ2lyY2xlJztcbmV4cG9ydCB7UG9seWxpbmUsIHBvbHlsaW5lfSBmcm9tICcuL1BvbHlsaW5lJztcbmV4cG9ydCB7UG9seWdvbiwgcG9seWdvbn0gZnJvbSAnLi9Qb2x5Z29uJztcbmV4cG9ydCB7UmVjdGFuZ2xlLCByZWN0YW5nbGV9IGZyb20gJy4vUmVjdGFuZ2xlJztcbiIsImV4cG9ydCB7TGF5ZXJ9IGZyb20gJy4vTGF5ZXInO1xuZXhwb3J0IHtMYXllckdyb3VwLCBsYXllckdyb3VwfSBmcm9tICcuL0xheWVyR3JvdXAnO1xuZXhwb3J0IHtGZWF0dXJlR3JvdXAsIGZlYXR1cmVHcm91cH0gZnJvbSAnLi9GZWF0dXJlR3JvdXAnO1xuaW1wb3J0IHtHZW9KU09OLCBnZW9KU09OLCBnZW9Kc29uLCBnZW9tZXRyeVRvTGF5ZXIsIGNvb3Jkc1RvTGF0TG5nLCBjb29yZHNUb0xhdExuZ3MsIGxhdExuZ1RvQ29vcmRzLCBsYXRMbmdzVG9Db29yZHMsIGdldEZlYXR1cmUsIGFzRmVhdHVyZX0gZnJvbSAnLi9HZW9KU09OJztcbkdlb0pTT04uZ2VvbWV0cnlUb0xheWVyID0gZ2VvbWV0cnlUb0xheWVyO1xuR2VvSlNPTi5jb29yZHNUb0xhdExuZyA9IGNvb3Jkc1RvTGF0TG5nO1xuR2VvSlNPTi5jb29yZHNUb0xhdExuZ3MgPSBjb29yZHNUb0xhdExuZ3M7XG5HZW9KU09OLmxhdExuZ1RvQ29vcmRzID0gbGF0TG5nVG9Db29yZHM7XG5HZW9KU09OLmxhdExuZ3NUb0Nvb3JkcyA9IGxhdExuZ3NUb0Nvb3Jkcztcbkdlb0pTT04uZ2V0RmVhdHVyZSA9IGdldEZlYXR1cmU7XG5HZW9KU09OLmFzRmVhdHVyZSA9IGFzRmVhdHVyZTtcbmV4cG9ydCB7R2VvSlNPTiwgZ2VvSlNPTiwgZ2VvSnNvbn07XG5cbmV4cG9ydCB7SW1hZ2VPdmVybGF5LCBpbWFnZU92ZXJsYXl9IGZyb20gJy4vSW1hZ2VPdmVybGF5JztcbmV4cG9ydCB7VmlkZW9PdmVybGF5LCB2aWRlb092ZXJsYXl9IGZyb20gJy4vVmlkZW9PdmVybGF5JztcbmV4cG9ydCB7U1ZHT3ZlcmxheSwgc3ZnT3ZlcmxheX0gZnJvbSAnLi9TVkdPdmVybGF5JztcblxuZXhwb3J0IHtEaXZPdmVybGF5fSBmcm9tICcuL0Rpdk92ZXJsYXknO1xuZXhwb3J0IHtQb3B1cCwgcG9wdXB9IGZyb20gJy4vUG9wdXAnO1xuZXhwb3J0IHtUb29sdGlwLCB0b29sdGlwfSBmcm9tICcuL1Rvb2x0aXAnO1xuXG5leHBvcnQgKiBmcm9tICcuL21hcmtlci9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL3RpbGUvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi92ZWN0b3IvaW5kZXgnO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBVdGlsIGZyb20gJy4uLy4uL2NvcmUvVXRpbCc7XG5pbXBvcnQgKiBhcyBEb21VdGlsIGZyb20gJy4uLy4uL2RvbS9Eb21VdGlsJztcbmltcG9ydCAqIGFzIERvbUV2ZW50IGZyb20gJy4uLy4uL2RvbS9Eb21FdmVudCc7XG5pbXBvcnQge0xhdExuZ0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvL0xhdExuZ0JvdW5kcyc7XG5pbXBvcnQge0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEwuSGFuZGxlci5Cb3hab29tIGlzIHVzZWQgdG8gYWRkIHNoaWZ0LWRyYWcgem9vbSBpbnRlcmFjdGlvbiB0byB0aGUgbWFwXG4gKiAoem9vbSB0byBhIHNlbGVjdGVkIGJvdW5kaW5nIGJveCksIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gYm94Wm9vbTogQm9vbGVhbiA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgdG8gYSByZWN0YW5ndWxhciBhcmVhIHNwZWNpZmllZCBieVxuXHQvLyBkcmFnZ2luZyB0aGUgbW91c2Ugd2hpbGUgcHJlc3NpbmcgdGhlIHNoaWZ0IGtleS5cblx0Ym94Wm9vbTogdHJ1ZVxufSk7XG5cbmV4cG9ydCB2YXIgQm94Wm9vbSA9IEhhbmRsZXIuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl9jb250YWluZXIgPSBtYXAuX2NvbnRhaW5lcjtcblx0XHR0aGlzLl9wYW5lID0gbWFwLl9wYW5lcy5vdmVybGF5UGFuZTtcblx0XHR0aGlzLl9yZXNldFN0YXRlVGltZW91dCA9IDA7XG5cdFx0bWFwLm9uKCd1bmxvYWQnLCB0aGlzLl9kZXN0cm95LCB0aGlzKTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX2NvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XG5cdH0sXG5cblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbW92ZWQ7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHREb21VdGlsLnJlbW92ZSh0aGlzLl9wYW5lKTtcblx0XHRkZWxldGUgdGhpcy5fcGFuZTtcblx0fSxcblxuXHRfcmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHR9LFxuXG5cdF9jbGVhckRlZmVycmVkUmVzZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZXNldFN0YXRlVGltZW91dCAhPT0gMCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0KTtcblx0XHRcdHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0ID0gMDtcblx0XHR9XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICghZS5zaGlmdEtleSB8fCAoKGUud2hpY2ggIT09IDEpICYmIChlLmJ1dHRvbiAhPT0gMSkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdFx0Ly8gQ2xlYXIgdGhlIGRlZmVycmVkIHJlc2V0U3RhdGUgaWYgaXQgaGFzbid0IGV4ZWN1dGVkIHlldCwgb3RoZXJ3aXNlIGl0XG5cdFx0Ly8gd2lsbCBpbnRlcnJ1cHQgdGhlIGludGVyYWN0aW9uIGFuZCBvcnBoYW4gYSBib3ggZWxlbWVudCBpbiB0aGUgY29udGFpbmVyLlxuXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZSgpO1xuXG5cdFx0RG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuXHRcdERvbVV0aWwuZGlzYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0dGhpcy5fc3RhcnRQb2ludCA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcblxuXHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCB7XG5cdFx0XHRjb250ZXh0bWVudTogRG9tRXZlbnQuc3RvcCxcblx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG5cdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG5cdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLl9ib3ggPSBEb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtem9vbS1ib3gnLCB0aGlzLl9jb250YWluZXIpO1xuXHRcdFx0RG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNyb3NzaGFpcicpO1xuXG5cdFx0XHR0aGlzLl9tYXAuZmlyZSgnYm94em9vbXN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcG9pbnQgPSB0aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IEJvdW5kcyh0aGlzLl9wb2ludCwgdGhpcy5fc3RhcnRQb2ludCksXG5cdFx0ICAgIHNpemUgPSBib3VuZHMuZ2V0U2l6ZSgpO1xuXG5cdFx0RG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9ib3gsIGJvdW5kcy5taW4pO1xuXG5cdFx0dGhpcy5fYm94LnN0eWxlLndpZHRoICA9IHNpemUueCArICdweCc7XG5cdFx0dGhpcy5fYm94LnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XG5cdH0sXG5cblx0X2ZpbmlzaDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tb3ZlZCkge1xuXHRcdFx0RG9tVXRpbC5yZW1vdmUodGhpcy5fYm94KTtcblx0XHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jcm9zc2hhaXInKTtcblx0XHR9XG5cblx0XHREb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcblx0XHREb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xuXG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCB7XG5cdFx0XHRjb250ZXh0bWVudTogRG9tRXZlbnQuc3RvcCxcblx0XHRcdG1vdXNlbW92ZTogdGhpcy5fb25Nb3VzZU1vdmUsXG5cdFx0XHRtb3VzZXVwOiB0aGlzLl9vbk1vdXNlVXAsXG5cdFx0XHRrZXlkb3duOiB0aGlzLl9vbktleURvd25cblx0XHR9LCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICgoZS53aGljaCAhPT0gMSkgJiYgKGUuYnV0dG9uICE9PSAxKSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2ZpbmlzaCgpO1xuXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkgeyByZXR1cm47IH1cblx0XHQvLyBQb3N0cG9uZSB0byBuZXh0IEpTIHRpY2sgc28gaW50ZXJuYWwgY2xpY2sgZXZlbnQgaGFuZGxpbmdcblx0XHQvLyBzdGlsbCBzZWUgaXQgYXMgXCJtb3ZlZFwiLlxuXHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG5cdFx0dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9yZXNldFN0YXRlLCB0aGlzKSwgMCk7XG5cblx0XHR2YXIgYm91bmRzID0gbmV3IExhdExuZ0JvdW5kcyhcblx0XHQgICAgICAgIHRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX3N0YXJ0UG9pbnQpLFxuXHRcdCAgICAgICAgdGhpcy5fbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQpKTtcblxuXHRcdHRoaXMuX21hcFxuXHRcdFx0LmZpdEJvdW5kcyhib3VuZHMpXG5cdFx0XHQuZmlyZSgnYm94em9vbWVuZCcsIHtib3hab29tQm91bmRzOiBib3VuZHN9KTtcblx0fSxcblxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG5cdFx0XHR0aGlzLl9maW5pc2goKTtcblx0XHRcdHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCk7XG5cdFx0XHR0aGlzLl9yZXNldFN0YXRlKCk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBwcm9wZXJ0eSBib3hab29tOiBIYW5kbGVyXG4vLyBCb3ggKHNoaWZ0LWRyYWcgd2l0aCBtb3VzZSkgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2JveFpvb20nLCBCb3hab29tKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuXG4vKlxuICogTC5IYW5kbGVyLkRvdWJsZUNsaWNrWm9vbSBpcyB1c2VkIHRvIGhhbmRsZSBkb3VibGUtY2xpY2sgem9vbSBvbiB0aGUgbWFwLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcblxuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBvcHRpb24gZG91YmxlQ2xpY2tab29tOiBCb29sZWFufFN0cmluZyA9IHRydWVcblx0Ly8gV2hldGhlciB0aGUgbWFwIGNhbiBiZSB6b29tZWQgaW4gYnkgZG91YmxlIGNsaWNraW5nIG9uIGl0IGFuZFxuXHQvLyB6b29tZWQgb3V0IGJ5IGRvdWJsZSBjbGlja2luZyB3aGlsZSBob2xkaW5nIHNoaWZ0LiBJZiBwYXNzZWRcblx0Ly8gYCdjZW50ZXInYCwgZG91YmxlLWNsaWNrIHpvb20gd2lsbCB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlXG5cdC8vICB2aWV3IHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgdGhlIG1vdXNlIHdhcy5cblx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXG59KTtcblxuZXhwb3J0IHZhciBEb3VibGVDbGlja1pvb20gPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcblx0fSxcblxuXHRfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvbGRab29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgZGVsdGEgPSBtYXAub3B0aW9ucy56b29tRGVsdGEsXG5cdFx0ICAgIHpvb20gPSBlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyBvbGRab29tIC0gZGVsdGEgOiBvbGRab29tICsgZGVsdGE7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0bWFwLnNldFpvb20oem9vbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKGUuY29udGFpbmVyUG9pbnQsIHpvb20pO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vL1xuLy8gTWFwIHByb3BlcnRpZXMgaW5jbHVkZSBpbnRlcmFjdGlvbiBoYW5kbGVycyB0aGF0IGFsbG93IHlvdSB0byBjb250cm9sXG4vLyBpbnRlcmFjdGlvbiBiZWhhdmlvciBpbiBydW50aW1lLCBlbmFibGluZyBvciBkaXNhYmxpbmcgY2VydGFpbiBmZWF0dXJlcyBzdWNoXG4vLyBhcyBkcmFnZ2luZyBvciB0b3VjaCB6b29tIChzZWUgYEhhbmRsZXJgIG1ldGhvZHMpLiBGb3IgZXhhbXBsZTpcbi8vXG4vLyBgYGBqc1xuLy8gbWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCk7XG4vLyBgYGBcbi8vXG4vLyBAcHJvcGVydHkgZG91YmxlQ2xpY2tab29tOiBIYW5kbGVyXG4vLyBEb3VibGUgY2xpY2sgem9vbSBoYW5kbGVyLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RvdWJsZUNsaWNrWm9vbScsIERvdWJsZUNsaWNrWm9vbSk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCB7RHJhZ2dhYmxlfSBmcm9tICcuLi8uLi9kb20vRHJhZ2dhYmxlJztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IHt0b0xhdExuZ0JvdW5kcyBhcyBsYXRMbmdCb3VuZHN9IGZyb20gJy4uLy4uL2dlby9MYXRMbmdCb3VuZHMnO1xuaW1wb3J0IHt0b0JvdW5kc30gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvQm91bmRzJztcblxuLypcbiAqIEwuSGFuZGxlci5NYXBEcmFnIGlzIHVzZWQgdG8gbWFrZSB0aGUgbWFwIGRyYWdnYWJsZSAod2l0aCBwYW5uaW5nIGluZXJ0aWEpLCBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gKi9cblxuLy8gQG5hbWVzcGFjZSBNYXBcbi8vIEBzZWN0aW9uIEludGVyYWN0aW9uIE9wdGlvbnNcbk1hcC5tZXJnZU9wdGlvbnMoe1xuXHQvLyBAb3B0aW9uIGRyYWdnaW5nOiBCb29sZWFuID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgaXMgZHJhZ2dhYmxlIHdpdGggbW91c2UvdG91Y2ggb3Igbm90LlxuXHRkcmFnZ2luZzogdHJ1ZSxcblxuXHQvLyBAc2VjdGlvbiBQYW5uaW5nIEluZXJ0aWEgT3B0aW9uc1xuXHQvLyBAb3B0aW9uIGluZXJ0aWE6IEJvb2xlYW4gPSAqXG5cdC8vIElmIGVuYWJsZWQsIHBhbm5pbmcgb2YgdGhlIG1hcCB3aWxsIGhhdmUgYW4gaW5lcnRpYSBlZmZlY3Qgd2hlcmVcblx0Ly8gdGhlIG1hcCBidWlsZHMgbW9tZW50dW0gd2hpbGUgZHJhZ2dpbmcgYW5kIGNvbnRpbnVlcyBtb3ZpbmcgaW5cblx0Ly8gdGhlIHNhbWUgZGlyZWN0aW9uIGZvciBzb21lIHRpbWUuIEZlZWxzIGVzcGVjaWFsbHkgbmljZSBvbiB0b3VjaFxuXHQvLyBkZXZpY2VzLiBFbmFibGVkIGJ5IGRlZmF1bHQuXG5cdGluZXJ0aWE6IHRydWUsXG5cblx0Ly8gQG9wdGlvbiBpbmVydGlhRGVjZWxlcmF0aW9uOiBOdW1iZXIgPSAzMDAwXG5cdC8vIFRoZSByYXRlIHdpdGggd2hpY2ggdGhlIGluZXJ0aWFsIG1vdmVtZW50IHNsb3dzIGRvd24sIGluIHBpeGVscy9zZWNvbmTCsi5cblx0aW5lcnRpYURlY2VsZXJhdGlvbjogMzQwMCwgLy8gcHgvc14yXG5cblx0Ly8gQG9wdGlvbiBpbmVydGlhTWF4U3BlZWQ6IE51bWJlciA9IEluZmluaXR5XG5cdC8vIE1heCBzcGVlZCBvZiB0aGUgaW5lcnRpYWwgbW92ZW1lbnQsIGluIHBpeGVscy9zZWNvbmQuXG5cdGluZXJ0aWFNYXhTcGVlZDogSW5maW5pdHksIC8vIHB4L3NcblxuXHQvLyBAb3B0aW9uIGVhc2VMaW5lYXJpdHk6IE51bWJlciA9IDAuMlxuXHRlYXNlTGluZWFyaXR5OiAwLjIsXG5cblx0Ly8gVE9ETyByZWZhY3RvciwgbW92ZSB0byBDUlNcblx0Ly8gQG9wdGlvbiB3b3JsZENvcHlKdW1wOiBCb29sZWFuID0gZmFsc2Vcblx0Ly8gV2l0aCB0aGlzIG9wdGlvbiBlbmFibGVkLCB0aGUgbWFwIHRyYWNrcyB3aGVuIHlvdSBwYW4gdG8gYW5vdGhlciBcImNvcHlcIlxuXHQvLyBvZiB0aGUgd29ybGQgYW5kIHNlYW1sZXNzbHkganVtcHMgdG8gdGhlIG9yaWdpbmFsIG9uZSBzbyB0aGF0IGFsbCBvdmVybGF5c1xuXHQvLyBsaWtlIG1hcmtlcnMgYW5kIHZlY3RvciBsYXllcnMgYXJlIHN0aWxsIHZpc2libGUuXG5cdHdvcmxkQ29weUp1bXA6IGZhbHNlLFxuXG5cdC8vIEBvcHRpb24gbWF4Qm91bmRzVmlzY29zaXR5OiBOdW1iZXIgPSAwLjBcblx0Ly8gSWYgYG1heEJvdW5kc2AgaXMgc2V0LCB0aGlzIG9wdGlvbiB3aWxsIGNvbnRyb2wgaG93IHNvbGlkIHRoZSBib3VuZHNcblx0Ly8gYXJlIHdoZW4gZHJhZ2dpbmcgdGhlIG1hcCBhcm91bmQuIFRoZSBkZWZhdWx0IHZhbHVlIG9mIGAwLjBgIGFsbG93cyB0aGVcblx0Ly8gdXNlciB0byBkcmFnIG91dHNpZGUgdGhlIGJvdW5kcyBhdCBub3JtYWwgc3BlZWQsIGhpZ2hlciB2YWx1ZXMgd2lsbFxuXHQvLyBzbG93IGRvd24gbWFwIGRyYWdnaW5nIG91dHNpZGUgYm91bmRzLCBhbmQgYDEuMGAgbWFrZXMgdGhlIGJvdW5kcyBmdWxseVxuXHQvLyBzb2xpZCwgcHJldmVudGluZyB0aGUgdXNlciBmcm9tIGRyYWdnaW5nIG91dHNpZGUgdGhlIGJvdW5kcy5cblx0bWF4Qm91bmRzVmlzY29zaXR5OiAwLjBcbn0pO1xuXG5leHBvcnQgdmFyIERyYWcgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9kcmFnZ2FibGUpIHtcblx0XHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUobWFwLl9tYXBQYW5lLCBtYXAuX2NvbnRhaW5lcik7XG5cblx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbih7XG5cdFx0XHRcdGRyYWdzdGFydDogdGhpcy5fb25EcmFnU3RhcnQsXG5cdFx0XHRcdGRyYWc6IHRoaXMuX29uRHJhZyxcblx0XHRcdFx0ZHJhZ2VuZDogdGhpcy5fb25EcmFnRW5kXG5cdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnTGltaXQsIHRoaXMpO1xuXHRcdFx0aWYgKG1hcC5vcHRpb25zLndvcmxkQ29weUp1bXApIHtcblx0XHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKCdwcmVkcmFnJywgdGhpcy5fb25QcmVEcmFnV3JhcCwgdGhpcyk7XG5cdFx0XHRcdG1hcC5vbignem9vbWVuZCcsIHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cblx0XHRcdFx0bWFwLndoZW5SZWFkeSh0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHREb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbGVhZmxldC1ncmFiIGxlYWZsZXQtdG91Y2gtZHJhZycpO1xuXHRcdHRoaXMuX2RyYWdnYWJsZS5lbmFibGUoKTtcblx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcblx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZ3JhYicpO1xuXHRcdERvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLWRyYWcnKTtcblx0XHR0aGlzLl9kcmFnZ2FibGUuZGlzYWJsZSgpO1xuXHR9LFxuXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSAmJiB0aGlzLl9kcmFnZ2FibGUuX21vdmVkO1xuXHR9LFxuXG5cdG1vdmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3Zpbmc7XG5cdH0sXG5cblx0X29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdG1hcC5fc3RvcCgpO1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHMgJiYgdGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzVmlzY29zaXR5KSB7XG5cdFx0XHR2YXIgYm91bmRzID0gbGF0TG5nQm91bmRzKHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cblx0XHRcdHRoaXMuX29mZnNldExpbWl0ID0gdG9Cb3VuZHMoXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXROb3J0aFdlc3QoKSkubXVsdGlwbHlCeSgtMSksXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KGJvdW5kcy5nZXRTb3V0aEVhc3QoKSkubXVsdGlwbHlCeSgtMSlcblx0XHRcdFx0XHQuYWRkKHRoaXMuX21hcC5nZXRTaXplKCkpKTtcblxuXHRcdFx0dGhpcy5fdmlzY29zaXR5ID0gTWF0aC5taW4oMS4wLCBNYXRoLm1heCgwLjAsIHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kc1Zpc2Nvc2l0eSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9vZmZzZXRMaW1pdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0bWFwXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XG5cblx0XHRpZiAobWFwLm9wdGlvbnMuaW5lcnRpYSkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb25zID0gW107XG5cdFx0XHR0aGlzLl90aW1lcyA9IFtdO1xuXHRcdH1cblx0fSxcblxuXHRfb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhKSB7XG5cdFx0XHR2YXIgdGltZSA9IHRoaXMuX2xhc3RUaW1lID0gK25ldyBEYXRlKCksXG5cdFx0XHQgICAgcG9zID0gdGhpcy5fbGFzdFBvcyA9IHRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zIHx8IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zO1xuXG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xuXHRcdFx0dGhpcy5fdGltZXMucHVzaCh0aW1lKTtcblxuXHRcdFx0dGhpcy5fcHJ1bmVQb3NpdGlvbnModGltZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbWFwXG5cdFx0ICAgIC5maXJlKCdtb3ZlJywgZSlcblx0XHQgICAgLmZpcmUoJ2RyYWcnLCBlKTtcblx0fSxcblxuXHRfcHJ1bmVQb3NpdGlvbnM6IGZ1bmN0aW9uICh0aW1lKSB7XG5cdFx0d2hpbGUgKHRoaXMuX3Bvc2l0aW9ucy5sZW5ndGggPiAxICYmIHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDUwKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMuc2hpZnQoKTtcblx0XHRcdHRoaXMuX3RpbWVzLnNoaWZ0KCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vblpvb21FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcHhDZW50ZXIgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxuXHRcdCAgICBweFdvcmxkQ2VudGVyID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbMCwgMF0pO1xuXG5cdFx0dGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0ID0gcHhXb3JsZENlbnRlci5zdWJ0cmFjdChweENlbnRlcikueDtcblx0XHR0aGlzLl93b3JsZFdpZHRoID0gdGhpcy5fbWFwLmdldFBpeGVsV29ybGRCb3VuZHMoKS5nZXRTaXplKCkueDtcblx0fSxcblxuXHRfdmlzY291c0xpbWl0OiBmdW5jdGlvbiAodmFsdWUsIHRocmVzaG9sZCkge1xuXHRcdHJldHVybiB2YWx1ZSAtICh2YWx1ZSAtIHRocmVzaG9sZCkgKiB0aGlzLl92aXNjb3NpdHk7XG5cdH0sXG5cblx0X29uUHJlRHJhZ0xpbWl0OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl92aXNjb3NpdHkgfHwgIXRoaXMuX29mZnNldExpbWl0KSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnN1YnRyYWN0KHRoaXMuX2RyYWdnYWJsZS5fc3RhcnRQb3MpO1xuXG5cdFx0dmFyIGxpbWl0ID0gdGhpcy5fb2Zmc2V0TGltaXQ7XG5cdFx0aWYgKG9mZnNldC54IDwgbGltaXQubWluLngpIHsgb2Zmc2V0LnggPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LngsIGxpbWl0Lm1pbi54KTsgfVxuXHRcdGlmIChvZmZzZXQueSA8IGxpbWl0Lm1pbi55KSB7IG9mZnNldC55ID0gdGhpcy5fdmlzY291c0xpbWl0KG9mZnNldC55LCBsaW1pdC5taW4ueSk7IH1cblx0XHRpZiAob2Zmc2V0LnggPiBsaW1pdC5tYXgueCkgeyBvZmZzZXQueCA9IHRoaXMuX3Zpc2NvdXNMaW1pdChvZmZzZXQueCwgbGltaXQubWF4LngpOyB9XG5cdFx0aWYgKG9mZnNldC55ID4gbGltaXQubWF4LnkpIHsgb2Zmc2V0LnkgPSB0aGlzLl92aXNjb3VzTGltaXQob2Zmc2V0LnksIGxpbWl0Lm1heC55KTsgfVxuXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MgPSB0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLmFkZChvZmZzZXQpO1xuXHR9LFxuXG5cdF9vblByZURyYWdXcmFwOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVE9ETyByZWZhY3RvciB0byBiZSBhYmxlIHRvIGFkanVzdCBtYXAgcGFuZSBwb3NpdGlvbiBhZnRlciB6b29tXG5cdFx0dmFyIHdvcmxkV2lkdGggPSB0aGlzLl93b3JsZFdpZHRoLFxuXHRcdCAgICBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKHdvcmxkV2lkdGggLyAyKSxcblx0XHQgICAgZHggPSB0aGlzLl9pbml0aWFsV29ybGRPZmZzZXQsXG5cdFx0ICAgIHggPSB0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54LFxuXHRcdCAgICBuZXdYMSA9ICh4IC0gaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCArIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYMiA9ICh4ICsgaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCAtIGhhbGZXaWR0aCAtIGR4LFxuXHRcdCAgICBuZXdYID0gTWF0aC5hYnMobmV3WDEgKyBkeCkgPCBNYXRoLmFicyhuZXdYMiArIGR4KSA/IG5ld1gxIDogbmV3WDI7XG5cblx0XHR0aGlzLl9kcmFnZ2FibGUuX2Fic1BvcyA9IHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLmNsb25lKCk7XG5cdFx0dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCA9IG5ld1g7XG5cdH0sXG5cblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICBvcHRpb25zID0gbWFwLm9wdGlvbnMsXG5cblx0XHQgICAgbm9JbmVydGlhID0gIW9wdGlvbnMuaW5lcnRpYSB8fCBlLm5vSW5lcnRpYSB8fCB0aGlzLl90aW1lcy5sZW5ndGggPCAyO1xuXG5cdFx0bWFwLmZpcmUoJ2RyYWdlbmQnLCBlKTtcblxuXHRcdGlmIChub0luZXJ0aWEpIHtcblx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcHJ1bmVQb3NpdGlvbnMoK25ldyBEYXRlKCkpO1xuXG5cdFx0XHR2YXIgZGlyZWN0aW9uID0gdGhpcy5fbGFzdFBvcy5zdWJ0cmFjdCh0aGlzLl9wb3NpdGlvbnNbMF0pLFxuXHRcdFx0ICAgIGR1cmF0aW9uID0gKHRoaXMuX2xhc3RUaW1lIC0gdGhpcy5fdGltZXNbMF0pIC8gMTAwMCxcblx0XHRcdCAgICBlYXNlID0gb3B0aW9ucy5lYXNlTGluZWFyaXR5LFxuXG5cdFx0XHQgICAgc3BlZWRWZWN0b3IgPSBkaXJlY3Rpb24ubXVsdGlwbHlCeShlYXNlIC8gZHVyYXRpb24pLFxuXHRcdFx0ICAgIHNwZWVkID0gc3BlZWRWZWN0b3IuZGlzdGFuY2VUbyhbMCwgMF0pLFxuXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkID0gTWF0aC5taW4ob3B0aW9ucy5pbmVydGlhTWF4U3BlZWQsIHNwZWVkKSxcblx0XHRcdCAgICBsaW1pdGVkU3BlZWRWZWN0b3IgPSBzcGVlZFZlY3Rvci5tdWx0aXBseUJ5KGxpbWl0ZWRTcGVlZCAvIHNwZWVkKSxcblxuXHRcdFx0ICAgIGRlY2VsZXJhdGlvbkR1cmF0aW9uID0gbGltaXRlZFNwZWVkIC8gKG9wdGlvbnMuaW5lcnRpYURlY2VsZXJhdGlvbiAqIGVhc2UpLFxuXHRcdFx0ICAgIG9mZnNldCA9IGxpbWl0ZWRTcGVlZFZlY3Rvci5tdWx0aXBseUJ5KC1kZWNlbGVyYXRpb25EdXJhdGlvbiAvIDIpLnJvdW5kKCk7XG5cblx0XHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7XG5cdFx0XHRcdG1hcC5maXJlKCdtb3ZlZW5kJyk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9mZnNldCA9IG1hcC5fbGltaXRPZmZzZXQob2Zmc2V0LCBtYXAub3B0aW9ucy5tYXhCb3VuZHMpO1xuXG5cdFx0XHRcdFV0aWwucmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bWFwLnBhbkJ5KG9mZnNldCwge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb246IGRlY2VsZXJhdGlvbkR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0ZWFzZUxpbmVhcml0eTogZWFzZSxcblx0XHRcdFx0XHRcdG5vTW92ZVN0YXJ0OiB0cnVlLFxuXHRcdFx0XHRcdFx0YW5pbWF0ZTogdHJ1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IGRyYWdnaW5nOiBIYW5kbGVyXG4vLyBNYXAgZHJhZ2dpbmcgaGFuZGxlciAoYnkgYm90aCBtb3VzZSBhbmQgdG91Y2gpLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2RyYWdnaW5nJywgRHJhZyk7XG4iLCJpbXBvcnQge01hcH0gZnJvbSAnLi4vTWFwJztcbmltcG9ydCB7SGFuZGxlcn0gZnJvbSAnLi4vLi4vY29yZS9IYW5kbGVyJztcbmltcG9ydCB7b24sIG9mZiwgc3RvcH0gZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCB7dG9Qb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuXG5cbi8qXG4gKiBMLk1hcC5LZXlib2FyZCBpcyBoYW5kbGluZyBrZXlib2FyZCBpbnRlcmFjdGlvbiB3aXRoIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gS2V5Ym9hcmQgTmF2aWdhdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQG9wdGlvbiBrZXlib2FyZDogQm9vbGVhbiA9IHRydWVcblx0Ly8gTWFrZXMgdGhlIG1hcCBmb2N1c2FibGUgYW5kIGFsbG93cyB1c2VycyB0byBuYXZpZ2F0ZSB0aGUgbWFwIHdpdGgga2V5Ym9hcmRcblx0Ly8gYXJyb3dzIGFuZCBgK2AvYC1gIGtleXMuXG5cdGtleWJvYXJkOiB0cnVlLFxuXG5cdC8vIEBvcHRpb24ga2V5Ym9hcmRQYW5EZWx0YTogTnVtYmVyID0gODBcblx0Ly8gQW1vdW50IG9mIHBpeGVscyB0byBwYW4gd2hlbiBwcmVzc2luZyBhbiBhcnJvdyBrZXkuXG5cdGtleWJvYXJkUGFuRGVsdGE6IDgwXG59KTtcblxuZXhwb3J0IHZhciBLZXlib2FyZCA9IEhhbmRsZXIuZXh0ZW5kKHtcblxuXHRrZXlDb2Rlczoge1xuXHRcdGxlZnQ6ICAgIFszN10sXG5cdFx0cmlnaHQ6ICAgWzM5XSxcblx0XHRkb3duOiAgICBbNDBdLFxuXHRcdHVwOiAgICAgIFszOF0sXG5cdFx0em9vbUluOiAgWzE4NywgMTA3LCA2MSwgMTcxXSxcblx0XHR6b29tT3V0OiBbMTg5LCAxMDksIDU0LCAxNzNdXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblxuXHRcdHRoaXMuX3NldFBhbkRlbHRhKG1hcC5vcHRpb25zLmtleWJvYXJkUGFuRGVsdGEpO1xuXHRcdHRoaXMuX3NldFpvb21EZWx0YShtYXAub3B0aW9ucy56b29tRGVsdGEpO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX21hcC5fY29udGFpbmVyO1xuXG5cdFx0Ly8gbWFrZSB0aGUgY29udGFpbmVyIGZvY3VzYWJsZSBieSB0YWJiaW5nXG5cdFx0aWYgKGNvbnRhaW5lci50YWJJbmRleCA8PSAwKSB7XG5cdFx0XHRjb250YWluZXIudGFiSW5kZXggPSAnMCc7XG5cdFx0fVxuXG5cdFx0b24oY29udGFpbmVyLCB7XG5cdFx0XHRmb2N1czogdGhpcy5fb25Gb2N1cyxcblx0XHRcdGJsdXI6IHRoaXMuX29uQmx1cixcblx0XHRcdG1vdXNlZG93bjogdGhpcy5fb25Nb3VzZURvd25cblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMuX21hcC5vbih7XG5cdFx0XHRmb2N1czogdGhpcy5fYWRkSG9va3MsXG5cdFx0XHRibHVyOiB0aGlzLl9yZW1vdmVIb29rc1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmVtb3ZlSG9va3MoKTtcblxuXHRcdG9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwge1xuXHRcdFx0Zm9jdXM6IHRoaXMuX29uRm9jdXMsXG5cdFx0XHRibHVyOiB0aGlzLl9vbkJsdXIsXG5cdFx0XHRtb3VzZWRvd246IHRoaXMuX29uTW91c2VEb3duXG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXAub2ZmKHtcblx0XHRcdGZvY3VzOiB0aGlzLl9hZGRIb29rcyxcblx0XHRcdGJsdXI6IHRoaXMuX3JlbW92ZUhvb2tzXG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2ZvY3VzZWQpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgYm9keSA9IGRvY3VtZW50LmJvZHksXG5cdFx0ICAgIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdCAgICB0b3AgPSBib2R5LnNjcm9sbFRvcCB8fCBkb2NFbC5zY3JvbGxUb3AsXG5cdFx0ICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWwuc2Nyb2xsTGVmdDtcblxuXHRcdHRoaXMuX21hcC5fY29udGFpbmVyLmZvY3VzKCk7XG5cblx0XHR3aW5kb3cuc2Nyb2xsVG8obGVmdCwgdG9wKTtcblx0fSxcblxuXHRfb25Gb2N1czogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZvY3VzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX21hcC5maXJlKCdmb2N1cycpO1xuXHR9LFxuXG5cdF9vbkJsdXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2JsdXInKTtcblx0fSxcblxuXHRfc2V0UGFuRGVsdGE6IGZ1bmN0aW9uIChwYW5EZWx0YSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fcGFuS2V5cyA9IHt9LFxuXHRcdCAgICBjb2RlcyA9IHRoaXMua2V5Q29kZXMsXG5cdFx0ICAgIGksIGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmxlZnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMubGVmdFtpXV0gPSBbLTEgKiBwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnJpZ2h0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnJpZ2h0W2ldXSA9IFtwYW5EZWx0YSwgMF07XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmRvd24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuZG93bltpXV0gPSBbMCwgcGFuRGVsdGFdO1xuXHRcdH1cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy51cC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0a2V5c1tjb2Rlcy51cFtpXV0gPSBbMCwgLTEgKiBwYW5EZWx0YV07XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRab29tRGVsdGE6IGZ1bmN0aW9uICh6b29tRGVsdGEpIHtcblx0XHR2YXIga2V5cyA9IHRoaXMuX3pvb21LZXlzID0ge30sXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2Rlcyxcblx0XHQgICAgaSwgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbUluLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRrZXlzW2NvZGVzLnpvb21JbltpXV0gPSB6b29tRGVsdGE7XG5cdFx0fVxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLnpvb21PdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGtleXNbY29kZXMuem9vbU91dFtpXV0gPSAtem9vbURlbHRhO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRvbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9yZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbktleURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIga2V5ID0gZS5rZXlDb2RlLFxuXHRcdCAgICBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIG9mZnNldDtcblxuXHRcdGlmIChrZXkgaW4gdGhpcy5fcGFuS2V5cykge1xuXHRcdFx0aWYgKCFtYXAuX3BhbkFuaW0gfHwgIW1hcC5fcGFuQW5pbS5faW5Qcm9ncmVzcykge1xuXHRcdFx0XHRvZmZzZXQgPSB0aGlzLl9wYW5LZXlzW2tleV07XG5cdFx0XHRcdGlmIChlLnNoaWZ0S2V5KSB7XG5cdFx0XHRcdFx0b2Zmc2V0ID0gdG9Qb2ludChvZmZzZXQpLm11bHRpcGx5QnkoMyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobWFwLm9wdGlvbnMubWF4Qm91bmRzKSB7XG5cdFx0XHRcdFx0b2Zmc2V0ID0gbWFwLl9saW1pdE9mZnNldCh0b1BvaW50KG9mZnNldCksIG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobWFwLm9wdGlvbnMud29ybGRDb3B5SnVtcCkge1xuXHRcdFx0XHRcdHZhciBuZXdMYXRMbmcgPSBtYXAud3JhcExhdExuZyhtYXAudW5wcm9qZWN0KG1hcC5wcm9qZWN0KG1hcC5nZXRDZW50ZXIoKSkuYWRkKG9mZnNldCkpKTtcblx0XHRcdFx0XHRtYXAucGFuVG8obmV3TGF0TG5nKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtYXAucGFuQnkob2Zmc2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoa2V5IGluIHRoaXMuX3pvb21LZXlzKSB7XG5cdFx0XHRtYXAuc2V0Wm9vbShtYXAuZ2V0Wm9vbSgpICsgKGUuc2hpZnRLZXkgPyAzIDogMSkgKiB0aGlzLl96b29tS2V5c1trZXldKTtcblxuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAyNyAmJiBtYXAuX3BvcHVwICYmIG1hcC5fcG9wdXAub3B0aW9ucy5jbG9zZU9uRXNjYXBlS2V5KSB7XG5cdFx0XHRtYXAuY2xvc2VQb3B1cCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzdG9wKGUpO1xuXHR9XG59KTtcblxuLy8gQHNlY3Rpb24gSGFuZGxlcnNcbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkga2V5Ym9hcmQ6IEhhbmRsZXJcbi8vIEtleWJvYXJkIG5hdmlnYXRpb24gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdrZXlib2FyZCcsIEtleWJvYXJkKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcblxuLypcbiAqIEwuSGFuZGxlci5TY3JvbGxXaGVlbFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBlbmFibGUgbW91c2Ugc2Nyb2xsIHdoZWVsIHpvb20gb24gdGhlIG1hcC5cbiAqL1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIE1vdXNlIHdoZWVsIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiBzY3JvbGxXaGVlbFpvb206IEJvb2xlYW58U3RyaW5nID0gdHJ1ZVxuXHQvLyBXaGV0aGVyIHRoZSBtYXAgY2FuIGJlIHpvb21lZCBieSB1c2luZyB0aGUgbW91c2Ugd2hlZWwuIElmIHBhc3NlZCBgJ2NlbnRlcidgLFxuXHQvLyBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBtb3VzZSB3YXMuXG5cdHNjcm9sbFdoZWVsWm9vbTogdHJ1ZSxcblxuXHQvLyBAb3B0aW9uIHdoZWVsRGVib3VuY2VUaW1lOiBOdW1iZXIgPSA0MFxuXHQvLyBMaW1pdHMgdGhlIHJhdGUgYXQgd2hpY2ggYSB3aGVlbCBjYW4gZmlyZSAoaW4gbWlsbGlzZWNvbmRzKS4gQnkgZGVmYXVsdFxuXHQvLyB1c2VyIGNhbid0IHpvb20gdmlhIHdoZWVsIG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIHBlciA0MCBtcy5cblx0d2hlZWxEZWJvdW5jZVRpbWU6IDQwLFxuXG5cdC8vIEBvcHRpb24gd2hlZWxQeFBlclpvb21MZXZlbDogTnVtYmVyID0gNjBcblx0Ly8gSG93IG1hbnkgc2Nyb2xsIHBpeGVscyAoYXMgcmVwb3J0ZWQgYnkgW0wuRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YV0oI2RvbWV2ZW50LWdldHdoZWVsZGVsdGEpKVxuXHQvLyBtZWFuIGEgY2hhbmdlIG9mIG9uZSBmdWxsIHpvb20gbGV2ZWwuIFNtYWxsZXIgdmFsdWVzIHdpbGwgbWFrZSB3aGVlbC16b29taW5nXG5cdC8vIGZhc3RlciAoYW5kIHZpY2UgdmVyc2EpLlxuXHR3aGVlbFB4UGVyWm9vbUxldmVsOiA2MFxufSk7XG5cbmV4cG9ydCB2YXIgU2Nyb2xsV2hlZWxab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnd2hlZWwnLCB0aGlzLl9vbldoZWVsU2Nyb2xsLCB0aGlzKTtcblxuXHRcdHRoaXMuX2RlbHRhID0gMDtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3doZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCwgdGhpcyk7XG5cdH0sXG5cblx0X29uV2hlZWxTY3JvbGw6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGRlbHRhID0gRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YShlKTtcblxuXHRcdHZhciBkZWJvdW5jZSA9IHRoaXMuX21hcC5vcHRpb25zLndoZWVsRGVib3VuY2VUaW1lO1xuXG5cdFx0dGhpcy5fZGVsdGEgKz0gZGVsdGE7XG5cdFx0dGhpcy5fbGFzdE1vdXNlUG9zID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpO1xuXG5cdFx0aWYgKCF0aGlzLl9zdGFydFRpbWUpIHtcblx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXHRcdH1cblxuXHRcdHZhciBsZWZ0ID0gTWF0aC5tYXgoZGVib3VuY2UgLSAoK25ldyBEYXRlKCkgLSB0aGlzLl9zdGFydFRpbWUpLCAwKTtcblxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG5cdFx0dGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KFV0aWwuYmluZCh0aGlzLl9wZXJmb3JtWm9vbSwgdGhpcyksIGxlZnQpO1xuXG5cdFx0RG9tRXZlbnQuc3RvcChlKTtcblx0fSxcblxuXHRfcGVyZm9ybVpvb206IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSxcblx0XHQgICAgc25hcCA9IHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwIHx8IDA7XG5cblx0XHRtYXAuX3N0b3AoKTsgLy8gc3RvcCBwYW5uaW5nIGFuZCBmbHkgYW5pbWF0aW9ucyBpZiBhbnlcblxuXHRcdC8vIG1hcCB0aGUgZGVsdGEgd2l0aCBhIHNpZ21vaWQgZnVuY3Rpb24gdG8gLTQuLjQgcmFuZ2UgbGVhbmluZyBvbiAtMS4uMVxuXHRcdHZhciBkMiA9IHRoaXMuX2RlbHRhIC8gKHRoaXMuX21hcC5vcHRpb25zLndoZWVsUHhQZXJab29tTGV2ZWwgKiA0KSxcblx0XHQgICAgZDMgPSA0ICogTWF0aC5sb2coMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGQyKSkpKSAvIE1hdGguTE4yLFxuXHRcdCAgICBkNCA9IHNuYXAgPyBNYXRoLmNlaWwoZDMgLyBzbmFwKSAqIHNuYXAgOiBkMyxcblx0XHQgICAgZGVsdGEgPSBtYXAuX2xpbWl0Wm9vbSh6b29tICsgKHRoaXMuX2RlbHRhID4gMCA/IGQ0IDogLWQ0KSkgLSB6b29tO1xuXG5cdFx0dGhpcy5fZGVsdGEgPSAwO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cblx0XHRpZiAoIWRlbHRhKSB7IHJldHVybjsgfVxuXG5cdFx0aWYgKG1hcC5vcHRpb25zLnNjcm9sbFdoZWVsWm9vbSA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdG1hcC5zZXRab29tKHpvb20gKyBkZWx0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKHRoaXMuX2xhc3RNb3VzZVBvcywgem9vbSArIGRlbHRhKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHNjcm9sbFdoZWVsWm9vbTogSGFuZGxlclxuLy8gU2Nyb2xsIHdoZWVsIHpvb20gaGFuZGxlci5cbk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdzY3JvbGxXaGVlbFpvb20nLCBTY3JvbGxXaGVlbFpvb20pO1xuIiwiaW1wb3J0IHtNYXB9IGZyb20gJy4uL01hcCc7XG5pbXBvcnQge0hhbmRsZXJ9IGZyb20gJy4uLy4uL2NvcmUvSGFuZGxlcic7XG5pbXBvcnQgKiBhcyBEb21FdmVudCBmcm9tICcuLi8uLi9kb20vRG9tRXZlbnQnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnLi4vLi4vZ2VvbWV0cnkvUG9pbnQnO1xuaW1wb3J0ICogYXMgVXRpbCBmcm9tICcuLi8uLi9jb3JlL1V0aWwnO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcblxuLypcbiAqIEwuTWFwLlRhcEhvbGQgaXMgdXNlZCB0byBzaW11bGF0ZSBgY29udGV4dG1lbnVgIGV2ZW50IG9uIGxvbmcgaG9sZCxcbiAqIHdoaWNoIG90aGVyd2lzZSBpcyBub3QgZmlyZWQgYnkgbW9iaWxlIFNhZmFyaS5cbiAqL1xuXG52YXIgdGFwSG9sZERlbGF5ID0gNjAwO1xuXG4vLyBAbmFtZXNwYWNlIE1hcFxuLy8gQHNlY3Rpb24gSW50ZXJhY3Rpb24gT3B0aW9uc1xuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdC8vIEBzZWN0aW9uIFRvdWNoIGludGVyYWN0aW9uIG9wdGlvbnNcblx0Ly8gQG9wdGlvbiB0YXBIb2xkOiBCb29sZWFuXG5cdC8vIEVuYWJsZXMgc2ltdWxhdGlvbiBvZiBgY29udGV4dG1lbnVgIGV2ZW50LCBkZWZhdWx0IGlzIGB0cnVlYCBmb3IgbW9iaWxlIFNhZmFyaS5cblx0dGFwSG9sZDogQnJvd3Nlci50b3VjaE5hdGl2ZSAmJiBCcm93c2VyLnNhZmFyaSAmJiBCcm93c2VyLm1vYmlsZSxcblxuXHQvLyBAb3B0aW9uIHRhcFRvbGVyYW5jZTogTnVtYmVyID0gMTVcblx0Ly8gVGhlIG1heCBudW1iZXIgb2YgcGl4ZWxzIGEgdXNlciBjYW4gc2hpZnQgaGlzIGZpbmdlciBkdXJpbmcgdG91Y2hcblx0Ly8gZm9yIGl0IHRvIGJlIGNvbnNpZGVyZWQgYSB2YWxpZCB0YXAuXG5cdHRhcFRvbGVyYW5jZTogMTVcbn0pO1xuXG5leHBvcnQgdmFyIFRhcEhvbGQgPSBIYW5kbGVyLmV4dGVuZCh7XG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Eb3duLCB0aGlzKTtcblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xuXHR9LFxuXG5cdF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblx0XHRpZiAoZS50b3VjaGVzLmxlbmd0aCAhPT0gMSkgeyByZXR1cm47IH1cblxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcblx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IG5ldyBQb2ludChmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZKTtcblxuXHRcdHRoaXMuX2hvbGRUaW1lb3V0ID0gc2V0VGltZW91dChVdGlsLmJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fY2FuY2VsKCk7XG5cdFx0XHRpZiAoIXRoaXMuX2lzVGFwVmFsaWQoKSkgeyByZXR1cm47IH1cblxuXHRcdFx0Ly8gcHJldmVudCBzaW11bGF0ZWQgbW91c2UgZXZlbnRzIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby90b3VjaC1ldmVudHMvI21vdXNlLWV2ZW50c1xuXHRcdFx0RG9tRXZlbnQub24oZG9jdW1lbnQsICd0b3VjaGVuZCcsIERvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcblx0XHRcdERvbUV2ZW50Lm9uKGRvY3VtZW50LCAndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCB0aGlzLl9jYW5jZWxDbGlja1ByZXZlbnQpO1xuXHRcdFx0dGhpcy5fc2ltdWxhdGVFdmVudCgnY29udGV4dG1lbnUnLCBmaXJzdCk7XG5cdFx0fSwgdGhpcyksIHRhcEhvbGREZWxheSk7XG5cblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsIGNvbnRleHRtZW51JywgdGhpcy5fY2FuY2VsLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcyk7XG5cdH0sXG5cblx0X2NhbmNlbENsaWNrUHJldmVudDogZnVuY3Rpb24gY2FuY2VsQ2xpY2tQcmV2ZW50KCkge1xuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgY2FuY2VsQ2xpY2tQcmV2ZW50KTtcblx0fSxcblxuXHRfY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCBjb250ZXh0bWVudScsIHRoaXMuX2NhbmNlbCwgdGhpcyk7XG5cdFx0RG9tRXZlbnQub2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlLCB0aGlzKTtcblx0fSxcblxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXTtcblx0XHR0aGlzLl9uZXdQb3MgPSBuZXcgUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XG5cdH0sXG5cblx0X2lzVGFwVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpIDw9IHRoaXMuX21hcC5vcHRpb25zLnRhcFRvbGVyYW5jZTtcblx0fSxcblxuXHRfc2ltdWxhdGVFdmVudDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcblx0XHR2YXIgc2ltdWxhdGVkRXZlbnQgPSBuZXcgTW91c2VFdmVudCh0eXBlLCB7XG5cdFx0XHRidWJibGVzOiB0cnVlLFxuXHRcdFx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0XHRcdHZpZXc6IHdpbmRvdyxcblx0XHRcdC8vIGRldGFpbDogMSxcblx0XHRcdHNjcmVlblg6IGUuc2NyZWVuWCxcblx0XHRcdHNjcmVlblk6IGUuc2NyZWVuWSxcblx0XHRcdGNsaWVudFg6IGUuY2xpZW50WCxcblx0XHRcdGNsaWVudFk6IGUuY2xpZW50WSxcblx0XHRcdC8vIGJ1dHRvbjogMixcblx0XHRcdC8vIGJ1dHRvbnM6IDJcblx0XHR9KTtcblxuXHRcdHNpbXVsYXRlZEV2ZW50Ll9zaW11bGF0ZWQgPSB0cnVlO1xuXG5cdFx0ZS50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XG5cdH1cbn0pO1xuXG4vLyBAc2VjdGlvbiBIYW5kbGVyc1xuLy8gQHByb3BlcnR5IHRhcEhvbGQ6IEhhbmRsZXJcbi8vIExvbmcgdGFwIGhhbmRsZXIgdG8gc2ltdWxhdGUgYGNvbnRleHRtZW51YCBldmVudCAodXNlZnVsIGluIG1vYmlsZSBTYWZhcmkpLlxuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ3RhcEhvbGQnLCBUYXBIb2xkKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuLi9NYXAnO1xuaW1wb3J0IHtIYW5kbGVyfSBmcm9tICcuLi8uLi9jb3JlL0hhbmRsZXInO1xuaW1wb3J0ICogYXMgRG9tRXZlbnQgZnJvbSAnLi4vLi4vZG9tL0RvbUV2ZW50JztcbmltcG9ydCAqIGFzIFV0aWwgZnJvbSAnLi4vLi4vY29yZS9VdGlsJztcbmltcG9ydCAqIGFzIERvbVV0aWwgZnJvbSAnLi4vLi4vZG9tL0RvbVV0aWwnO1xuaW1wb3J0IEJyb3dzZXIgZnJvbSAnLi4vLi4vY29yZS9Ccm93c2VyJztcblxuLypcbiAqIEwuSGFuZGxlci5Ub3VjaFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBhZGQgcGluY2ggem9vbSBvbiBzdXBwb3J0ZWQgbW9iaWxlIGJyb3dzZXJzLlxuICovXG5cbi8vIEBuYW1lc3BhY2UgTWFwXG4vLyBAc2VjdGlvbiBJbnRlcmFjdGlvbiBPcHRpb25zXG5NYXAubWVyZ2VPcHRpb25zKHtcblx0Ly8gQHNlY3Rpb24gVG91Y2ggaW50ZXJhY3Rpb24gb3B0aW9uc1xuXHQvLyBAb3B0aW9uIHRvdWNoWm9vbTogQm9vbGVhbnxTdHJpbmcgPSAqXG5cdC8vIFdoZXRoZXIgdGhlIG1hcCBjYW4gYmUgem9vbWVkIGJ5IHRvdWNoLWRyYWdnaW5nIHdpdGggdHdvIGZpbmdlcnMuIElmXG5cdC8vIHBhc3NlZCBgJ2NlbnRlcidgLCBpdCB3aWxsIHpvb20gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlldyByZWdhcmRsZXNzIG9mXG5cdC8vIHdoZXJlIHRoZSB0b3VjaCBldmVudHMgKGZpbmdlcnMpIHdlcmUuIEVuYWJsZWQgZm9yIHRvdWNoLWNhcGFibGUgd2ViXG5cdC8vIGJyb3dzZXJzLlxuXHR0b3VjaFpvb206IEJyb3dzZXIudG91Y2gsXG5cblx0Ly8gQG9wdGlvbiBib3VuY2VBdFpvb21MaW1pdHM6IEJvb2xlYW4gPSB0cnVlXG5cdC8vIFNldCBpdCB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgbWFwIHRvIHpvb20gYmV5b25kIG1pbi9tYXggem9vbVxuXHQvLyBhbmQgdGhlbiBib3VuY2UgYmFjayB3aGVuIHBpbmNoLXpvb21pbmcuXG5cdGJvdW5jZUF0Wm9vbUxpbWl0czogdHJ1ZVxufSk7XG5cbmV4cG9ydCB2YXIgVG91Y2hab29tID0gSGFuZGxlci5leHRlbmQoe1xuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdERvbVV0aWwuYWRkQ2xhc3ModGhpcy5fbWFwLl9jb250YWluZXIsICdsZWFmbGV0LXRvdWNoLXpvb20nKTtcblx0XHREb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0RG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ2xlYWZsZXQtdG91Y2gtem9vbScpO1xuXHRcdERvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHRoaXMpO1xuXHR9LFxuXG5cdF9vblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IG1hcC5fYW5pbWF0aW5nWm9vbSB8fCB0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSk7XG5cblx0XHR0aGlzLl9jZW50ZXJQb2ludCA9IG1hcC5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO1xuXHRcdHRoaXMuX3N0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodGhpcy5fY2VudGVyUG9pbnQpO1xuXHRcdGlmIChtYXAub3B0aW9ucy50b3VjaFpvb20gIT09ICdjZW50ZXInKSB7XG5cdFx0XHR0aGlzLl9waW5jaFN0YXJ0TGF0TG5nID0gbWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcocDEuYWRkKHAyKS5fZGl2aWRlQnkoMikpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3N0YXJ0RGlzdCA9IHAxLmRpc3RhbmNlVG8ocDIpO1xuXHRcdHRoaXMuX3N0YXJ0Wm9vbSA9IG1hcC5nZXRab29tKCk7XG5cblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3pvb21pbmcgPSB0cnVlO1xuXG5cdFx0bWFwLl9zdG9wKCk7XG5cblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKTtcblx0XHREb21FdmVudC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJywgdGhpcy5fb25Ub3VjaEVuZCwgdGhpcyk7XG5cblx0XHREb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcblx0fSxcblxuXHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCAhdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cblxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXG5cdFx0ICAgIHAxID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1swXSksXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUudG91Y2hlc1sxXSksXG5cdFx0ICAgIHNjYWxlID0gcDEuZGlzdGFuY2VUbyhwMikgLyB0aGlzLl9zdGFydERpc3Q7XG5cblx0XHR0aGlzLl96b29tID0gbWFwLmdldFNjYWxlWm9vbShzY2FsZSwgdGhpcy5fc3RhcnRab29tKTtcblxuXHRcdGlmICghbWFwLm9wdGlvbnMuYm91bmNlQXRab29tTGltaXRzICYmIChcblx0XHRcdCh0aGlzLl96b29tIDwgbWFwLmdldE1pblpvb20oKSAmJiBzY2FsZSA8IDEpIHx8XG5cdFx0XHQodGhpcy5fem9vbSA+IG1hcC5nZXRNYXhab29tKCkgJiYgc2NhbGUgPiAxKSkpIHtcblx0XHRcdHRoaXMuX3pvb20gPSBtYXAuX2xpbWl0Wm9vbSh0aGlzLl96b29tKTtcblx0XHR9XG5cblx0XHRpZiAobWFwLm9wdGlvbnMudG91Y2hab29tID09PSAnY2VudGVyJykge1xuXHRcdFx0dGhpcy5fY2VudGVyID0gdGhpcy5fc3RhcnRMYXRMbmc7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEpIHsgcmV0dXJuOyB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEdldCBkZWx0YSBmcm9tIHBpbmNoIHRvIGNlbnRlciwgc28gY2VudGVyTGF0TG5nIGlzIGRlbHRhIGFwcGxpZWQgdG8gaW5pdGlhbCBwaW5jaExhdExuZ1xuXHRcdFx0dmFyIGRlbHRhID0gcDEuX2FkZChwMikuX2RpdmlkZUJ5KDIpLl9zdWJ0cmFjdCh0aGlzLl9jZW50ZXJQb2ludCk7XG5cdFx0XHRpZiAoc2NhbGUgPT09IDEgJiYgZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSB7IHJldHVybjsgfVxuXHRcdFx0dGhpcy5fY2VudGVyID0gbWFwLnVucHJvamVjdChtYXAucHJvamVjdCh0aGlzLl9waW5jaFN0YXJ0TGF0TG5nLCB0aGlzLl96b29tKS5zdWJ0cmFjdChkZWx0YSksIHRoaXMuX3pvb20pO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fbW92ZWQpIHtcblx0XHRcdG1hcC5fbW92ZVN0YXJ0KHRydWUsIGZhbHNlKTtcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRVdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XG5cblx0XHR2YXIgbW92ZUZuID0gVXRpbC5iaW5kKG1hcC5fbW92ZSwgbWFwLCB0aGlzLl9jZW50ZXIsIHRoaXMuX3pvb20sIHtwaW5jaDogdHJ1ZSwgcm91bmQ6IGZhbHNlfSwgdW5kZWZpbmVkKTtcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IFV0aWwucmVxdWVzdEFuaW1GcmFtZShtb3ZlRm4sIHRoaXMsIHRydWUpO1xuXG5cdFx0RG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XG5cdH0sXG5cblx0X29uVG91Y2hFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX21vdmVkIHx8ICF0aGlzLl96b29taW5nKSB7XG5cdFx0XHR0aGlzLl96b29taW5nID0gZmFsc2U7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xuXHRcdFV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcblxuXHRcdERvbUV2ZW50Lm9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlLCB0aGlzKTtcblx0XHREb21FdmVudC5vZmYoZG9jdW1lbnQsICd0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIHRoaXMuX29uVG91Y2hFbmQsIHRoaXMpO1xuXG5cdFx0Ly8gUGluY2ggdXBkYXRlcyBHcmlkTGF5ZXJzJyBsZXZlbHMgb25seSB3aGVuIHpvb21TbmFwIGlzIG9mZiwgc28gem9vbVNuYXAgYmVjb21lcyBub1VwZGF0ZS5cblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xuXHRcdFx0dGhpcy5fbWFwLl9hbmltYXRlWm9vbSh0aGlzLl9jZW50ZXIsIHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pLCB0cnVlLCB0aGlzLl9tYXAub3B0aW9ucy56b29tU25hcCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX21hcC5fcmVzZXRWaWV3KHRoaXMuX2NlbnRlciwgdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSkpO1xuXHRcdH1cblx0fVxufSk7XG5cbi8vIEBzZWN0aW9uIEhhbmRsZXJzXG4vLyBAcHJvcGVydHkgdG91Y2hab29tOiBIYW5kbGVyXG4vLyBUb3VjaCB6b29tIGhhbmRsZXIuXG5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndG91Y2hab29tJywgVG91Y2hab29tKTtcbiIsImltcG9ydCB7TWFwfSBmcm9tICcuL01hcCc7XG5pbXBvcnQge0JveFpvb219IGZyb20gJy4vaGFuZGxlci9NYXAuQm94Wm9vbSc7XG5NYXAuQm94Wm9vbSA9IEJveFpvb207XG5pbXBvcnQge0RvdWJsZUNsaWNrWm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5Eb3VibGVDbGlja1pvb20nO1xuTWFwLkRvdWJsZUNsaWNrWm9vbSA9IERvdWJsZUNsaWNrWm9vbTtcbmltcG9ydCB7RHJhZ30gZnJvbSAnLi9oYW5kbGVyL01hcC5EcmFnJztcbk1hcC5EcmFnID0gRHJhZztcbmltcG9ydCB7S2V5Ym9hcmR9IGZyb20gJy4vaGFuZGxlci9NYXAuS2V5Ym9hcmQnO1xuTWFwLktleWJvYXJkID0gS2V5Ym9hcmQ7XG5pbXBvcnQge1Njcm9sbFdoZWVsWm9vbX0gZnJvbSAnLi9oYW5kbGVyL01hcC5TY3JvbGxXaGVlbFpvb20nO1xuTWFwLlNjcm9sbFdoZWVsWm9vbSA9IFNjcm9sbFdoZWVsWm9vbTtcbmltcG9ydCB7VGFwSG9sZH0gZnJvbSAnLi9oYW5kbGVyL01hcC5UYXBIb2xkJztcbk1hcC5UYXBIb2xkID0gVGFwSG9sZDtcbmltcG9ydCB7VG91Y2hab29tfSBmcm9tICcuL2hhbmRsZXIvTWFwLlRvdWNoWm9vbSc7XG5NYXAuVG91Y2hab29tID0gVG91Y2hab29tO1xuXG5leHBvcnQge01hcCwgY3JlYXRlTWFwIGFzIG1hcH0gZnJvbSAnLi9NYXAnO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztFQUFBOzs7Ozs7RUFNQTtFQUNBO0VBQ08sU0FBU0EsTUFBTUEsQ0FBQ0MsSUFBSSxFQUFFO0lBQzVCLElBQUlDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7SUFFbEIsS0FBS0YsQ0FBQyxHQUFHLENBQUMsRUFBRUMsR0FBRyxHQUFHRSxTQUFTLENBQUNDLE1BQU0sRUFBRUosQ0FBQyxHQUFHQyxHQUFHLEVBQUVELENBQUMsRUFBRSxFQUFFO01BQ2pERSxHQUFHLEdBQUdDLFNBQVMsQ0FBQ0gsQ0FBQyxDQUFDO01BQ2xCLEtBQUtELENBQUMsSUFBSUcsR0FBRyxFQUFFO1FBQ2RKLElBQUksQ0FBQ0MsQ0FBQyxDQUFDLEdBQUdHLEdBQUcsQ0FBQ0gsQ0FBQyxDQUFDO01BQ25CO0lBQ0E7SUFDQyxPQUFPRCxJQUFJO0VBQ1o7O0VBRUE7RUFDQTtFQUNPLElBQUlPLFFBQU0sR0FBR0MsTUFBTSxDQUFDQyxNQUFNLElBQUssWUFBWTtJQUNqRCxTQUFTQyxDQUFDQSxDQUFBLEVBQUc7SUFDYixPQUFPLFVBQVVDLEtBQUssRUFBRTtNQUN2QkQsQ0FBQyxDQUFDRSxTQUFTLEdBQUdE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