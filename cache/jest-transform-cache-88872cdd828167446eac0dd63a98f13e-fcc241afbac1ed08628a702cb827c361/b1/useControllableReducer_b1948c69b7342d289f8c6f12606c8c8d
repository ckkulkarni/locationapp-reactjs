1bbc51066295a2cbd07420fd70f1359b
"use strict";
'use client';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useControllableReducer = useControllableReducer;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var React = _interopRequireWildcard(require("react"));
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function areEqual(a, b) {
  return a === b;
}
const EMPTY_OBJECT = {};
const NOOP = () => {};

/**
 * Gets the current state augmented with controlled values from the outside.
 * If a state item has a corresponding controlled value, it will be used instead of the internal state.
 */
function getControlledState(internalState, controlledProps) {
  const augmentedState = (0, _extends2.default)({}, internalState);
  Object.keys(controlledProps).forEach(key => {
    if (controlledProps[key] !== undefined) {
      augmentedState[key] = controlledProps[key];
    }
  });
  return augmentedState;
}
/**
 * Defines an effect that compares the next state with the previous state and calls
 * the `onStateChange` callback if the state has changed.
 * The comparison is done based on the `stateComparers` parameter.
 */
function useStateChangeDetection(parameters) {
  const {
    nextState,
    initialState,
    stateComparers,
    onStateChange,
    controlledProps,
    lastActionRef
  } = parameters;
  const internalPreviousStateRef = React.useRef(initialState);
  React.useEffect(() => {
    if (lastActionRef.current === null) {
      // Detect changes only if an action has been dispatched.
      return;
    }
    const previousState = getControlledState(internalPreviousStateRef.current, controlledProps);
    Object.keys(nextState).forEach(key => {
      var _stateComparers$key;
      // go through all state keys and compare them with the previous state
      const stateComparer = (_stateComparers$key = stateComparers[key]) != null ? _stateComparers$key : areEqual;
      const nextStateItem = nextState[key];
      const previousStateItem = previousState[key];
      if (previousStateItem == null && nextStateItem != null || previousStateItem != null && nextStateItem == null || previousStateItem != null && nextStateItem != null && !stateComparer(nextStateItem, previousStateItem)) {
        var _event, _type;
        onStateChange == null ? void 0 : onStateChange((_event = lastActionRef.current.event) != null ? _event : null, key, nextStateItem, (_type = lastActionRef.current.type) != null ? _type : '', nextState);
      }
    });
    internalPreviousStateRef.current = nextState;
    lastActionRef.current = null;
  }, [internalPreviousStateRef, nextState, lastActionRef, onStateChange, stateComparers, controlledProps]);
}

/**
 * The alternative to `React.useReducer` that lets you control the state from the outside.
 *
 * It can be used in an uncontrolled mode, similar to `React.useReducer`, or in a controlled mode, when the state is controlled by the props.
 * It also supports partially controlled state, when some state items are controlled and some are not.
 *
 * The controlled state items are provided via the `controlledProps` parameter.
 * When a reducer action is dispatched, the internal state is updated with the new values.
 * A change event (`onStateChange`) is then triggered (for each changed state item) if the new state is different from the previous state.
 * This event can be used to update the controlled values.
 *
 * The comparison of the previous and next states is done using the `stateComparers` parameter.
 * If a state item has a corresponding comparer, it will be used to determine if the state has changed.
 * This is useful when the state item is an object and you want to compare only a subset of its properties or if it's an array and you want to compare its contents.
 *
 * An additional feature is the `actionContext` parameter. It allows you to add additional properties to every action object,
 * similarly to how React context is implicitly available to every component.
 *
 * @template State - The type of the state calculated by the reducer.
 * @template Action - The type of the actions that can be dispatched.
 * @template ActionContext - The type of the additional properties that will be added to every action object.
 *
 * @ignore - internal hook.
 */
function useControllableReducer(parameters) {
  const lastActionRef = React.useRef(null);
  const {
    reducer,
    initialState,
    controlledProps = EMPTY_OBJECT,
    stateComparers = EMPTY_OBJECT,
    onStateChange = NOOP,
    actionContext
  } = parameters;

  // The reducer that is passed to React.useReducer is wrapped with a function that augments the state with controlled values.
  const reducerWithControlledState = React.useCallback((state, action) => {
    lastActionRef.current = action;
    const controlledState = getControlledState(state, controlledProps);
    const newState = reducer(controlledState, action);
    return newState;
  }, [controlledProps, reducer]);
  const [nextState, dispatch] = React.useReducer(reducerWithControlledState, initialState);

  // The action that is passed to dispatch is augmented with the actionContext.
  const dispatchWithContext = React.useCallback(action => {
    dispatch((0, _extends2.default)({}, action, {
      context: actionContext
    }));
  }, [actionContext]);
  useStateChangeDetection({
    nextState,
    initialState,
    stateComparers: stateComparers != null ? stateComparers : EMPTY_OBJECT,
    onStateChange: onStateChange != null ? onStateChange : NOOP,
    controlledProps,
    lastActionRef
  });
  return [getControlledState(nextState, controlledProps), dispatchWithContext];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidXNlQ29udHJvbGxhYmxlUmVkdWNlciIsIl9leHRlbmRzMiIsIlJlYWN0IiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUiLCJub2RlSW50ZXJvcCIsIldlYWtNYXAiLCJjYWNoZUJhYmVsSW50ZXJvcCIsImNhY2hlTm9kZUludGVyb3AiLCJvYmoiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsImNhY2hlIiwiaGFzIiwiZ2V0IiwibmV3T2JqIiwiaGFzUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZGVzYyIsInNldCIsImFyZUVxdWFsIiwiYSIsImIiLCJFTVBUWV9PQkpFQ1QiLCJOT09QIiwiZ2V0Q29udHJvbGxlZFN0YXRlIiwiaW50ZXJuYWxTdGF0ZSIsImNvbnRyb2xsZWRQcm9wcyIsImF1Z21lbnRlZFN0YXRlIiwia2V5cyIsImZvckVhY2giLCJ1bmRlZmluZWQiLCJ1c2VTdGF0ZUNoYW5nZURldGVjdGlvbiIsInBhcmFtZXRlcnMiLCJuZXh0U3RhdGUiLCJpbml0aWFsU3RhdGUiLCJzdGF0ZUNvbXBhcmVycyIsIm9uU3RhdGVDaGFuZ2UiLCJsYXN0QWN0aW9uUmVmIiwiaW50ZXJuYWxQcmV2aW91c1N0YXRlUmVmIiwidXNlUmVmIiwidXNlRWZmZWN0IiwiY3VycmVudCIsInByZXZpb3VzU3RhdGUiLCJfc3RhdGVDb21wYXJlcnMka2V5Iiwic3RhdGVDb21wYXJlciIsIm5leHRTdGF0ZUl0ZW0iLCJwcmV2aW91c1N0YXRlSXRlbSIsIl9ldmVudCIsIl90eXBlIiwiZXZlbnQiLCJ0eXBlIiwicmVkdWNlciIsImFjdGlvbkNvbnRleHQiLCJyZWR1Y2VyV2l0aENvbnRyb2xsZWRTdGF0ZSIsInVzZUNhbGxiYWNrIiwic3RhdGUiLCJhY3Rpb24iLCJjb250cm9sbGVkU3RhdGUiLCJuZXdTdGF0ZSIsImRpc3BhdGNoIiwidXNlUmVkdWNlciIsImRpc3BhdGNoV2l0aENvbnRleHQiLCJjb250ZXh0Il0sInNvdXJjZXMiOlsidXNlQ29udHJvbGxhYmxlUmVkdWNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbid1c2UgY2xpZW50JztcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy51c2VDb250cm9sbGFibGVSZWR1Y2VyID0gdXNlQ29udHJvbGxhYmxlUmVkdWNlcjtcbnZhciBfZXh0ZW5kczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIikpO1xudmFyIFJlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiAobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuZnVuY3Rpb24gYXJlRXF1YWwoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cbmNvbnN0IEVNUFRZX09CSkVDVCA9IHt9O1xuY29uc3QgTk9PUCA9ICgpID0+IHt9O1xuXG4vKipcbiAqIEdldHMgdGhlIGN1cnJlbnQgc3RhdGUgYXVnbWVudGVkIHdpdGggY29udHJvbGxlZCB2YWx1ZXMgZnJvbSB0aGUgb3V0c2lkZS5cbiAqIElmIGEgc3RhdGUgaXRlbSBoYXMgYSBjb3JyZXNwb25kaW5nIGNvbnRyb2xsZWQgdmFsdWUsIGl0IHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBpbnRlcm5hbCBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29udHJvbGxlZFN0YXRlKGludGVybmFsU3RhdGUsIGNvbnRyb2xsZWRQcm9wcykge1xuICBjb25zdCBhdWdtZW50ZWRTdGF0ZSA9ICgwLCBfZXh0ZW5kczIuZGVmYXVsdCkoe30sIGludGVybmFsU3RhdGUpO1xuICBPYmplY3Qua2V5cyhjb250cm9sbGVkUHJvcHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAoY29udHJvbGxlZFByb3BzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXVnbWVudGVkU3RhdGVba2V5XSA9IGNvbnRyb2xsZWRQcm9wc1trZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhdWdtZW50ZWRTdGF0ZTtcbn1cbi8qKlxuICogRGVmaW5lcyBhbiBlZmZlY3QgdGhhdCBjb21wYXJlcyB0aGUgbmV4dCBzdGF0ZSB3aXRoIHRoZSBwcmV2aW91cyBzdGF0ZSBhbmQgY2FsbHNcbiAqIHRoZSBgb25TdGF0ZUNoYW5nZWAgY2FsbGJhY2sgaWYgdGhlIHN0YXRlIGhhcyBjaGFuZ2VkLlxuICogVGhlIGNvbXBhcmlzb24gaXMgZG9uZSBiYXNlZCBvbiB0aGUgYHN0YXRlQ29tcGFyZXJzYCBwYXJhbWV0ZXIuXG4gKi9cbmZ1bmN0aW9uIHVzZVN0YXRlQ2hhbmdlRGV0ZWN0aW9uKHBhcmFtZXRlcnMpIHtcbiAgY29uc3Qge1xuICAgIG5leHRTdGF0ZSxcbiAgICBpbml0aWFsU3RhdGUsXG4gICAgc3RhdGVDb21wYXJlcnMsXG4gICAgb25TdGF0ZUNoYW5nZSxcbiAgICBjb250cm9sbGVkUHJvcHMsXG4gICAgbGFzdEFjdGlvblJlZlxuICB9ID0gcGFyYW1ldGVycztcbiAgY29uc3QgaW50ZXJuYWxQcmV2aW91c1N0YXRlUmVmID0gUmVhY3QudXNlUmVmKGluaXRpYWxTdGF0ZSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGxhc3RBY3Rpb25SZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gRGV0ZWN0IGNoYW5nZXMgb25seSBpZiBhbiBhY3Rpb24gaGFzIGJlZW4gZGlzcGF0Y2hlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IGdldENvbnRyb2xsZWRTdGF0ZShpbnRlcm5hbFByZXZpb3VzU3RhdGVSZWYuY3VycmVudCwgY29udHJvbGxlZFByb3BzKTtcbiAgICBPYmplY3Qua2V5cyhuZXh0U3RhdGUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHZhciBfc3RhdGVDb21wYXJlcnMka2V5O1xuICAgICAgLy8gZ28gdGhyb3VnaCBhbGwgc3RhdGUga2V5cyBhbmQgY29tcGFyZSB0aGVtIHdpdGggdGhlIHByZXZpb3VzIHN0YXRlXG4gICAgICBjb25zdCBzdGF0ZUNvbXBhcmVyID0gKF9zdGF0ZUNvbXBhcmVycyRrZXkgPSBzdGF0ZUNvbXBhcmVyc1trZXldKSAhPSBudWxsID8gX3N0YXRlQ29tcGFyZXJzJGtleSA6IGFyZUVxdWFsO1xuICAgICAgY29uc3QgbmV4dFN0YXRlSXRlbSA9IG5leHRTdGF0ZVtrZXldO1xuICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZUl0ZW0gPSBwcmV2aW91c1N0YXRlW2tleV07XG4gICAgICBpZiAocHJldmlvdXNTdGF0ZUl0ZW0gPT0gbnVsbCAmJiBuZXh0U3RhdGVJdGVtICE9IG51bGwgfHwgcHJldmlvdXNTdGF0ZUl0ZW0gIT0gbnVsbCAmJiBuZXh0U3RhdGVJdGVtID09IG51bGwgfHwgcHJldmlvdXNTdGF0ZUl0ZW0gIT0gbnVsbCAmJiBuZXh0U3RhdGVJdGVtICE9IG51bGwgJiYgIXN0YXRlQ29tcGFyZXIobmV4dFN0YXRlSXRlbSwgcHJldmlvdXNTdGF0ZUl0ZW0pKSB7XG4gICAgICAgIHZhciBfZXZlbnQsIF90eXBlO1xuICAgICAgICBvblN0YXRlQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiBvblN0YXRlQ2hhbmdlKChfZXZlbnQgPSBsYXN0QWN0aW9uUmVmLmN1cnJlbnQuZXZlbnQpICE9IG51bGwgPyBfZXZlbnQgOiBudWxsLCBrZXksIG5leHRTdGF0ZUl0ZW0sIChfdHlwZSA9IGxhc3RBY3Rpb25SZWYuY3VycmVudC50eXBlKSAhPSBudWxsID8gX3R5cGUgOiAnJywgbmV4dFN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpbnRlcm5hbFByZXZpb3VzU3RhdGVSZWYuY3VycmVudCA9IG5leHRTdGF0ZTtcbiAgICBsYXN0QWN0aW9uUmVmLmN1cnJlbnQgPSBudWxsO1xuICB9LCBbaW50ZXJuYWxQcmV2aW91c1N0YXRlUmVmLCBuZXh0U3RhdGUsIGxhc3RBY3Rpb25SZWYsIG9uU3RhdGVDaGFuZ2UsIHN0YXRlQ29tcGFyZXJzLCBjb250cm9sbGVkUHJvcHNdKTtcbn1cblxuLyoqXG4gKiBUaGUgYWx0ZXJuYXRpdmUgdG8gYFJlYWN0LnVzZVJlZHVjZXJgIHRoYXQgbGV0cyB5b3UgY29udHJvbCB0aGUgc3RhdGUgZnJvbSB0aGUgb3V0c2lkZS5cbiAqXG4gKiBJdCBjYW4gYmUgdXNlZCBpbiBhbiB1bmNvbnRyb2xsZWQgbW9kZSwgc2ltaWxhciB0byBgUmVhY3QudXNlUmVkdWNlcmAsIG9yIGluIGEgY29udHJvbGxlZCBtb2RlLCB3aGVuIHRoZSBzdGF0ZSBpcyBjb250cm9sbGVkIGJ5IHRoZSBwcm9wcy5cbiAqIEl0IGFsc28gc3VwcG9ydHMgcGFydGlhbGx5IGNvbnRyb2xsZWQgc3RhdGUsIHdoZW4gc29tZSBzdGF0ZSBpdGVtcyBhcmUgY29udHJvbGxlZCBhbmQgc29tZSBhcmUgbm90LlxuICpcbiAqIFRoZSBjb250cm9sbGVkIHN0YXRlIGl0ZW1zIGFyZSBwcm92aWRlZCB2aWEgdGhlIGBjb250cm9sbGVkUHJvcHNgIHBhcmFtZXRlci5cbiAqIFdoZW4gYSByZWR1Y2VyIGFjdGlvbiBpcyBkaXNwYXRjaGVkLCB0aGUgaW50ZXJuYWwgc3RhdGUgaXMgdXBkYXRlZCB3aXRoIHRoZSBuZXcgdmFsdWVzLlxuICogQSBjaGFuZ2UgZXZlbnQgKGBvblN0YXRlQ2hhbmdlYCkgaXMgdGhlbiB0cmlnZ2VyZWQgKGZvciBlYWNoIGNoYW5nZWQgc3RhdGUgaXRlbSkgaWYgdGhlIG5ldyBzdGF0ZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgcHJldmlvdXMgc3RhdGUuXG4gKiBUaGlzIGV2ZW50IGNhbiBiZSB1c2VkIHRvIHVwZGF0ZSB0aGUgY29udHJvbGxlZCB2YWx1ZXMuXG4gKlxuICogVGhlIGNvbXBhcmlzb24gb2YgdGhlIHByZXZpb3VzIGFuZCBuZXh0IHN0YXRlcyBpcyBkb25lIHVzaW5nIHRoZSBgc3RhdGVDb21wYXJlcnNgIHBhcmFtZXRlci5cbiAqIElmIGEgc3RhdGUgaXRlbSBoYXMgYSBjb3JyZXNwb25kaW5nIGNvbXBhcmVyLCBpdCB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBzdGF0ZSBoYXMgY2hhbmdlZC5cbiAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gdGhlIHN0YXRlIGl0ZW0gaXMgYW4gb2JqZWN0IGFuZCB5b3Ugd2FudCB0byBjb21wYXJlIG9ubHkgYSBzdWJzZXQgb2YgaXRzIHByb3BlcnRpZXMgb3IgaWYgaXQncyBhbiBhcnJheSBhbmQgeW91IHdhbnQgdG8gY29tcGFyZSBpdHMgY29udGVudHMuXG4gKlxuICogQW4gYWRkaXRpb25hbCBmZWF0dXJlIGlzIHRoZSBgYWN0aW9uQ29udGV4dGAgcGFyYW1ldGVyLiBJdCBhbGxvd3MgeW91IHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gZXZlcnkgYWN0aW9uIG9iamVjdCxcbiAqIHNpbWlsYXJseSB0byBob3cgUmVhY3QgY29udGV4dCBpcyBpbXBsaWNpdGx5IGF2YWlsYWJsZSB0byBldmVyeSBjb21wb25lbnQuXG4gKlxuICogQHRlbXBsYXRlIFN0YXRlIC0gVGhlIHR5cGUgb2YgdGhlIHN0YXRlIGNhbGN1bGF0ZWQgYnkgdGhlIHJlZHVjZXIuXG4gKiBAdGVtcGxhdGUgQWN0aW9uIC0gVGhlIHR5cGUgb2YgdGhlIGFjdGlvbnMgdGhhdCBjYW4gYmUgZGlzcGF0Y2hlZC5cbiAqIEB0ZW1wbGF0ZSBBY3Rpb25Db250ZXh0IC0gVGhlIHR5cGUgb2YgdGhlIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gZXZlcnkgYWN0aW9uIG9iamVjdC5cbiAqXG4gKiBAaWdub3JlIC0gaW50ZXJuYWwgaG9vay5cbiAqL1xuZnVuY3Rpb24gdXNlQ29udHJvbGxhYmxlUmVkdWNlcihwYXJhbWV0ZXJzKSB7XG4gIGNvbnN0IGxhc3RBY3Rpb25SZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHtcbiAgICByZWR1Y2VyLFxuICAgIGluaXRpYWxTdGF0ZSxcbiAgICBjb250cm9sbGVkUHJvcHMgPSBFTVBUWV9PQkpFQ1QsXG4gICAgc3RhdGVDb21wYXJlcnMgPSBFTVBUWV9PQkpFQ1QsXG4gICAgb25TdGF0ZUNoYW5nZSA9IE5PT1AsXG4gICAgYWN0aW9uQ29udGV4dFxuICB9ID0gcGFyYW1ldGVycztcblxuICAvLyBUaGUgcmVkdWNlciB0aGF0IGlzIHBhc3NlZCB0byBSZWFjdC51c2VSZWR1Y2VyIGlzIHdyYXBwZWQgd2l0aCBhIGZ1bmN0aW9uIHRoYXQgYXVnbWVudHMgdGhlIHN0YXRlIHdpdGggY29udHJvbGxlZCB2YWx1ZXMuXG4gIGNvbnN0IHJlZHVjZXJXaXRoQ29udHJvbGxlZFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2soKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICBsYXN0QWN0aW9uUmVmLmN1cnJlbnQgPSBhY3Rpb247XG4gICAgY29uc3QgY29udHJvbGxlZFN0YXRlID0gZ2V0Q29udHJvbGxlZFN0YXRlKHN0YXRlLCBjb250cm9sbGVkUHJvcHMpO1xuICAgIGNvbnN0IG5ld1N0YXRlID0gcmVkdWNlcihjb250cm9sbGVkU3RhdGUsIGFjdGlvbik7XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xuICB9LCBbY29udHJvbGxlZFByb3BzLCByZWR1Y2VyXSk7XG4gIGNvbnN0IFtuZXh0U3RhdGUsIGRpc3BhdGNoXSA9IFJlYWN0LnVzZVJlZHVjZXIocmVkdWNlcldpdGhDb250cm9sbGVkU3RhdGUsIGluaXRpYWxTdGF0ZSk7XG5cbiAgLy8gVGhlIGFjdGlvbiB0aGF0IGlzIHBhc3NlZCB0byBkaXNwYXRjaCBpcyBhdWdtZW50ZWQgd2l0aCB0aGUgYWN0aW9uQ29udGV4dC5cbiAgY29uc3QgZGlzcGF0Y2hXaXRoQ29udGV4dCA9IFJlYWN0LnVzZUNhbGxiYWNrKGFjdGlvbiA9PiB7XG4gICAgZGlzcGF0Y2goKDAsIF9leHRlbmRzMi5kZWZhdWx0KSh7fSwgYWN0aW9uLCB7XG4gICAgICBjb250ZXh0OiBhY3Rpb25Db250ZXh0XG4gICAgfSkpO1xuICB9LCBbYWN0aW9uQ29udGV4dF0pO1xuICB1c2VTdGF0ZUNoYW5nZURldGVjdGlvbih7XG4gICAgbmV4dFN0YXRlLFxuICAgIGluaXRpYWxTdGF0ZSxcbiAgICBzdGF0ZUNvbXBhcmVyczogc3RhdGVDb21wYXJlcnMgIT0gbnVsbCA/IHN0YXRlQ29tcGFyZXJzIDogRU1QVFlfT0JKRUNULFxuICAgIG9uU3RhdGVDaGFuZ2U6IG9uU3RhdGVDaGFuZ2UgIT0gbnVsbCA/IG9uU3RhdGVDaGFuZ2UgOiBOT09QLFxuICAgIGNvbnRyb2xsZWRQcm9wcyxcbiAgICBsYXN0QWN0aW9uUmVmXG4gIH0pO1xuICByZXR1cm4gW2dldENvbnRyb2xsZWRTdGF0ZShuZXh0U3RhdGUsIGNvbnRyb2xsZWRQcm9wcyksIGRpc3BhdGNoV2l0aENvbnRleHRdO1xufSJdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTtBQUNaLFlBQVk7O0FBRVosSUFBSUEsc0JBQXNCLEdBQUdDLE9BQU8sQ0FBQyw4Q0FBOEMsQ0FBQztBQUNwRkMs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